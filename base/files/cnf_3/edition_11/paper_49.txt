Modeling and Inheritance of Behaviour
in Object-Oriented Systems
Stephan Philippi
Institute for Software Technology
University of Koblenz-Landau, Germany
philippi @uni-koblenz.de

Abstract

mantics and thus there are no difficulties with the interpretation of object life cycles modeled with this notation. The
problem with Statecharts in this context is that there is not
a single formally based semantics, but a set of them with
subtle differences [19]. Which one applies for a modeling
language integrating Statecharts is usually not specified.)
In addition to a non-existing formally defined semantics,
most object-oriented languages have in common that the
concept of inheritance is targeted to static aspects only, i.e.,
object life cycles as dynamic properties of types are not considered. In consequence, a dynamic model can be assigned
to a subtype which has no relation to the dynamic model of
its supertype. Therefore, instances of a subclass can behave
completely independent with respect to the behaviour specified for its superclass. From the point of view of objectorientation this violates the idea that objects of a subclass
are implicit instances of its parent superclass and thus have
to be able to be used in this context without any problems.
If for example the sequence of allowed method sequences
for inherited methods is altered in a subtype without consideration of the behaviour specified for the supertype; then
objects of the descendant do not behave as specified for the
parent. Thus, unexpected behaviour (like deadlocks).may
occur if the object is used in the context of its supertype.
Starting from this perspective the next section of this article introduces a set of requirements, which from our point
of view have to apply to approaches for the modeling and
inheritance of object behaviour. Prior to the description of
an own approach to life cycle inheritance in section four,
existing proposals are shortly surveyed with respect to the
introduced requirements in section three. Within the last
section some conclusions are given.as well as a description
of future work.
. .

One of the main benejits of object-orientation is the concept of inheritance which allows f o r the derivation of new
typesklasses from existing ones. Within commonly used
object-oriented languages inheritance is usually directed to
attributes and method signatures, only Considering languages providing nieans for the specijication of object life
cjdes, the concept of inheritance needs to be extended to be
able to cover not only static but also behavioural aspects.
This article introduces a set of requirementsfor the modeling and inheritance of object behaviour: Based on a short
survey of existing work a new approach is introduced, which
is suited to be used with a class of object-oriented PetriNets.

1. Introduction
The benefits of a visually based modeling style with multiple views for complex object-oriented systems are due to
notations like OMT [ 151, UML [ 141 and others widely recognized today. Besides the description of the architecture
of a system with a static view, dynamic models are important parts of such languages. Usually, a dynamic model is
assigned to a type and specifies the behaviour (life cycle) of
objects from classes implementing this type with graphical
notations like Statecharts [6] and Petri-Nets [ 111. In general, dynamic models describe states of objects and conditions for the transition between these states. As there
is no common understanding of what to specify in detail
within dynamic models, their exact interpretation depends
on the semantics of the chosen modeling language. Unfortunately, popular modeling languages like the UML have
no formally defined semantics and thus the meaning of a
given (dynamic) model is left open to individual interpretation. (One might argue with respect to the UML and other
modeling languages that Statecharts have a well defined se-

,

2. Requirements

',

..

'.

,

.

As there is no commonly agreed upon definition ok 'object life cycle', different approaches for the modeling of ob-

342
0-7695-1195-3/01 $10.00 0 2001 IEEE

,

ject behaviour allow for the specification of different types
of behaviour. Therefore, the next subsection states as a prerequisite to the discussion of 111fecycle inheritance a set of
requirements for notations specifying object behaviour. Afterwards, general requirements for approaches to life cycle
inheritance as well as requirements which are derived from
a preexisting modeling language which is to extend with a
concept for behavioural inheritance are described.

use of a visual formalism in itself does certainly not guarantee that the underlying notation is easy to learn and handle.
Nevertheless, we consider the incorporation of a non-textual
formalism as a fundamental prerequisite.

2.2. Inheritance of Object Behaviour
General requirements: The most important requirement for any approach to inheritance in general is theprinciple ofsubstitutability. This principle states that 'An instance
of a subtype can always be used in any context in which an
instance of a supertype is expected' [21]. Signature compatible approaches to inheritance maintain type-safety with
syntactical substitutability in common object-oriented languages. In order to provide semantical substitutability, behavioural .aspects have to be taken into account additionally. A first step into this direction is the definition of a
relation between object life cycles of super- and subtypes.
Such a relation is intended to allow for behavioural compatible modifications, only, thus prohibiting arbitrary life cycle alterations within subtypes. Taking this argument a step
further leads immediately to the requirement that preconditions for method activations inherited from a supertype are
not allowed to be strengthened within a subtype, in order to
avoid violations of the principle of substitutability. The reason for this requirement is that a stronger precondition for
the activation of a method in a subtype is not visible from
the point of view of a supertype. Consequently, a user of
an object of the supertype might be faced with unexpected
behaviour if he satisfies the precondition for the activation
of a method as stated in the life cycle of the supertype, but
in fact transparently works with an instance of a subtype. In
this case the activation of the particular method may not be
allowed due to a strengthened precondition in the subtype
which is not satisfied.
The compathility relation between object life cycles has
to be defined in a formal way to allow for automated checkings. As stated above, a prerequisite to this requirement is a
formally based notation for the modeling of object life cycles.
An approach to life cycle inheritance ideally offers a set
of modification rules for the incremental extension of object
behaviour in a compatible way. Such rules are useful especially in the early steps of learning the principles behind a
particular approach to life cycle inheritance.
Special requirements: In addition to the general requirements there are special requirements, as we are searching for an approach to life cycle inheritance which can be
used with so called OOPr/T-ModeIs [ 121. OOPr/T-Models
are a class of object-oriented Petri-Nets which were developed in order to allow for the formally based, visual
modeling of (concurrent) object-oriented systems. OOPr/TModels support the modeling of systems with static, dy-

2.1. Modeling of Object Behaviour
The behaviour of objects (i.e., their life cycle) is usually
considered as part of their interface (i.e., their type definition). An object life cycle consists of conditions for the transition between (abstract) states. As the invocation of publicly available methods is the c d y way to alter the state of
an object, the conditions for the transitions between different states of an object, in fact, 5,pecify activation conditions
for these methods. From our point of view, at least the following types of activation conditions should be supported
by notations for the modeling of object life cycles:
Synchronization conditions: In order to be usable in
the area of concurrent object-oriented systems, synchronization conditions such as 'methods x and y are
not allowed to be executed concurrently' should be expressible.
Attribute value dependent conditions: The activation
of a method has to be able to depend on the value of
publicly readable attribute:;, e.g., 'method x is only allowed to be activated if the values of attributes a and 0
are equal'. This kind of condition is especially useful
with respect to concurrenl systcms containing active
objects.
History based conditions: The activation of a method
has to be able to depcnd on a given sequence of method
calls, likc 'method x is only allowed to be executed
immediately after a call to method y'.
Furthermore, a notation used to model object life cycles
should be formally based, i.e., syntax and semantics have
to be clearly specified. This requirement prevents individual (mis-)interpretations of models and is a prerequisite for
the definition of a compatibility relation between different
object life cycles.
The last requirement is that a notation/formalism for the
modeling of object life cycles has to be as easy as possible
to learn and handle in order to be of any use for complex
systems modeling. Even if this is a qualitative requirement
which is not subject to objective measurement, it seems to
be generally agreed (indicated by the most popular objectoriented modeling languages) that visual notations are superior with this respect in comparison to textual ones. The

343

namic, and functional views on arbitrary abstraction levels,
ranging from high-level analysis to low-level implementation (i.e., visual programming).
To model static aspects of object-oriented. systems,.
OOPr/T-Models integrate a modestly restricted subset of
UML class diagrams. For each non-abstract method
signature of such a class diagram a single extended
PredicateiTransition-Net [5] describes the intended functionality. The most relevant part of 00PriT-Models for the
course of this article are dynamic views. A dynamic view
is assigned to each class of a system specifying activation
conditions for publicly available methods using (slightly
extended) PlaceiTransition-Nets. In detail, each transition
within such a dynamic view is associated to a publicly available method of the corresponding class. A guard containing an expression over publicly accessible (i.e.', readable)
attributes of the class may be assigned to each transition,
further restricting the activation of methods. Publicly available methods of a class are allowed to be executed if a
corresponding transition within the dynamic view is activated, only. If a method is executed the marking which
activated the respective transition is consumed. After the
execution of the method terminated, the markings on the
outgoing arcs of the transition are produced, if any. Thus,
from a designer's point of view transitions within dynamic
views have no timeless behaviour, as tokens are disappearing while methods are being executed. From a semantical
point of view this is a syntactical abbreviation, i.e., a shortcut for a more complex 'real' Petri-Net structure with additional places representing currently aciivated methods.

order, to be able to allow for the automatic generation of
executable Java code.
Like most object-oriented modeling/programming languages, 00PriT-Models initially supported inheritance for
static aspects, only. As argued above, syntactic compatibility is not sufficient to satisfy the principle of substitutability.
Thus, OOPr/T-Models are to be extended with a formally
based approach for the inheritance of object behaviour. In
conjunction with the described interpretation of dynamic
views of 00Pr/T-Models, this results in the following (nongeneral) requirements for an approach to be suited for their
extension:
With observable and invocable behaviour two kinds of
interpretations for object life cycles can be distinguished
[4]. If a given life cycle specifies the observable object behaviour, every sequence of method activations which might
occur for every object of the given type is part of such
a model. With this interpretation of object behaviour it
is possible that life cycle specifications contain activation
sequences which are not invocable for every instance of
the type, i.e., a guarantee for the invocability of sequences
within such models is not given. Life cycles which specify
invocable object behaviour on the other hand guarantee that
activation sequences being part of such a model are invocable. In [4] it is shown; that different kinds of inheritance
relationships apply for observable and invocable object behaviour. In combination with the fact that dynamic views
of OOPdT-Models specify the invocable behaviour of objects, this observation leads to the conclusion that suitable
approaches for the extension of 00Pr/T-Models have to be
focused on invocable object behaviour.
Another requirement for a n approach to life cycle inheritance to be suited for the extension of OOPr/T-Models is
that the underlying principles have to be transferable to the
visual notation for dynamic views.

3. Existing Approaches
Within the last years a number of approaches to life cycle inheritance were published. Thus, the following brief
review of work in this area with respect to the introduced
requirements is by no means a complete catalogue.
Taking a look at the types of conditions for method
activations supported by notations for the specification of
object behaviour, and approaches to life cycle inheritance
based on them, we find that often not all of the three
introduced types are taken into account. In detail, approaches like [ 13, [3] and [9] do not consider synchronization conditions. The restriction of method activations by,
means of conditions which depend on current attribute values (guards) is not supported by [2],[4], and [ 7 ] . History
based constraints are not part of the work presented in [21].
In addition, approaches like [I], [ 3 ] ,[8], [9], and [17] use

Figure 1. Examples for dynamic views
Figure 1 gives different kinds of conditions for method
activations specified with dynamic models as described
above. In detail, Figure l a specifies an activation sequence,
i.e., method 'y' is only allowed to be activated if method 'x'
was activated before and has already finished its execution.
Figure l b specifies that methods 'x' and 'z' are allowed to
be activated concurrently. Method 'y' can only be activated
if neither 'x' nor 'z' is active and attribute 'a' does not equal
attribute 'b' of a given object.
A restriction on dynamic models is, that the modeling
of non-deterministic object behaviour is not supported in

344

non-visually based (i.e., textual) notations for the modeling
of object behaviour.

4. Inheritance in OOPr/T-Models

With respect to the general requirement that inherited
preconditions are not allowed to be strengthened within
subtypes in order to satisfy the principle of substitutability, we find that approaches like [8] and [ 161 are not sharing
this point of view,

The approach to life cycle inheritance for dynamic views
of 00Pr/T-Models presented in this section is based on protocol inheritance as described in [2]. Main differences are
given by the kind of Petri-Nets which are considered as
valid life cycle descriptions within both proposals. As described in the last section, the definition of object life cycles
in [2] restricts the allowable structure of PlaceRransitionNets for the description of dynamic behaviour in several
ways. In detail, every object life cycle needs to be connected, a single input and output place has to exist, and
the initial marking of such a net consists of a single token,
only. Considering dynamic views of 00PrR-Models, such
restrictions do not apply. Here, arbitrary Place/TransitionNets are used, where each transition is associated to a publicly available method of the corresponding type which may
have an additional guard containing an expression over publicly readable attributes.
Considering the inheritance of object life cycles, we have
to be able to check whether dynamic models assigned to
super- and subtypes are compatible. The compatibility relation which has to be satisfied in case of dynamic views of
OOPr/T-Models is based on protocol inheritance, i.e.: ’Two
object life cycles are compatible if the externally visible behaviour of both is not distinguishable, if calls to additional
methods of the subtype are blocked’. From the point of view
of the specified object life cycles, every instance of any subtype may be used in the context of its supertype (multiple
inheritance is not considered) if the above described condition holds.
The algorithm to check whether two object life cycles
super and sub are compatible in the way described above
consists of the following steps:

Proposals described in [ 101 and [ 181 focus on observable
object behaviour and are thus not suited to extend OOPrRModels with life cycle inheritance.
Taking a closer look at the: Petri-Net based approaches
to life cycle inheritance, we find that [2] contains a detailed
discussion, where four different kinds of inheritance relations for behavioural specifications are described. The two
basic relations introduced are protocol and projection inherifunce. With protocol inheritaxe two life cycles are considered compatible if the external behaviour of both can not be
distinguished if calls to additional methods of the subclass
are blocked. Two life cycles are compatible with respect to
projection inheritance if the external behaviour can not be
distinguished if the effects of calls to additional methods of
the subclass are ignored. The two additional inheritance relations introduced in [2] are different combinations of protocol and projection inheritance. With respect to the extension of 00Pr/T-Models, protocol inheritance is of interest,
only, as it is more closely related to invocable behaviour
as described in [4] than projection inheritance and the two
additional combinations of them.
Comparing the Petri-Net based notations of [2] and [7]
with dynamic views of 00PrK-Models, a similar interpretation of life cycle models is given. In detail, transitions are
labeled with identifiers of methods and a given marking of
the net indicates which methods are allowed to be activated.
In contrast to dynamic views in OOPr/T-Models, guards are
not supported by the considered proposals. Another major
difference is that [2] and [7] restrict the structure of allowable Petri-Nets for the modeling of object life cycles. As
such structural restrictions do not apply for dynamic views
of OOPr/T-Models, and additionally more kinds of method
activation conditions are expressible, the results of [2] and
[7] in terms of formally defined compatibility relations between object life cycles are not immediately transferable to
our visual modeling and programming language.

If a guard associated to a method in the subclass is
more restrictive than in the superclass, terminate with
’false’. To be able to test this condition efficiently,
guards are only allowed to be extended in subclasses
with disjunction clauses.
From super and sub construct dynamic views super’
and sub’, where all guards are removed. Additionally,
all transitions within sub’ have to be removed which
are associated to methods not present in super’.

The result of the brief review in this section is that none
of the considered proposals is suited to be integrated into
OOPr/T-ModeIs without modifications, The reasons for this
observation are that there are many subtle differences with
respect to the underlying notations, their expressive power,
and the chosen interpretation as object life cycles. Out of
this, the next section introduces on the base of existing work
an approach to life cycle inheritance which is suited to extend 00Pr/T-Models.

A dynamic view of an OOPr/T-Model may contain
transitions with neither incoming nor outgoing arcs,
which corresponds to the intuition that the activation
of the associated method is not restricted at all. If super’ contains such a transition which is not part of sub’
then terminate with ’false’.

Remove all transitions from super’ and sub’ with neither incoming nor outgoing arcs which are part of both

345

models.

new-buffer

n

5 . Create reachability graphs RGsnper#and RG,,b/ for
super’ and sub’.

6 . Check if all possible activation sequences of super’ are
part of sub’ by means of RGsuperl and RG,,bt. If so,

insert

terminate with ’true’, else exit with ’false’. This condition is checked using an approach based on branching
bisimulation [ 131.

[count < capacity]

remove

In the following we give an example on the use of this algorithm. The dynamic view of a class ’buffer’ with methods
’insert’ and ’remove’ is given in figure 2. This view specifies that methods ’insert’ and ’remove’ are not allowed to
be activated concurrently to avoid inconsistencies. Furthermore, method ’insert’ is only allowed to be activated if the
value of attribute ’count’ is less than the value of attribute
’capacity’, i.e., ’insert’ may only be activated if the buffer
capacity is not already exceeded. Analogoue, ’remove’ is
only allowed to be activated if there is any element to remove from the buffer.

[count # O]

Figure 3. Dynamic model of class ’new-buffer’

A potential criticism on the introduced compatibility relation and its checking algorithm is the exponential effort
needed to construct and check reachability graphs. Even if
this argument can not be neglected, life cycle descriptions
tend to be not too complex from our experience. One reason
for this observation is that small interfaces (in terms of the
amount of methods for a type) are a good modeling style
anyway. Out of this, checking expenses should be no major
problem in the average case.

remove

[count e capacity]

[count <capacity]

[count 3 01
insert

insert

+
J

Figure 2. Dynamic model of class ’buffer’
Figure 3 gives the dynamic view assigned to a subclass
’new-buffer’ of ’buffer’. Class ’new-buffer’ extends its superclass with an additional method ’removeJew’. This
method is only allowed to remove an element out of the
buffer, if invoked immediately after ’insert’.
The first step of the algorithm described above checks
if the dynamic view of the subclass contains guards which
are more restrictive than their counterparts within the dynamic model of the superclass. Considering the example,
all guards remain unchanged. Thus, the next step of the
algorithm constructs super’ and sub’. Here, all guards are
removed from super and sub as well as the transition associated with method ’removeJew’ from the latter one. As
there are no transitions with neither incoming nor outgoing arcs in super’ and sub’, the result of the algorithm after
step five is given in figure 4 with the two reachibility graphs
for super’ and sub’. The last step of the algorithm checks
whether all life cycles of the superclass are element of the
life cycle model for. the subclass. For the given example
it can be easily observed with the help of the reachability
graphs that this condition holds. The formal test for this
property is based on branching bisimulation [ 131 (and due
to space limitations not given here).

( I.O)

(0.I)

U
remow

remove

Figure 4. RGsuperland RGsUbl
Another point is that our approach (as most others in
this area) does not take functional aspects into account, i.e.,
semantical substitutability is ensured with respect to object behaviour, only. From a theoretical point of view this
constitutes a necessary but not a sufficient condition/check
for semantical substitutability in object-oriented systems,
as super- and subclass method implementations may have
completely different side effects.

5. Conclusions and Future Work
We presented in this article requirements for the modeling and inheritance of life cycles in object-oriented systems. Based on a short survey on existing work a new approach was introduced, which meets most of the stated requirements and is thus suited to extend OOPr/T-Models.

346

[ 101 J. McGregor and D. Dyer. ’A note on inheritance and
state machines’. ACM Sojhvare Engineering Notes,
18(4), 1993.

The described algorithm is implemented within a tool
which supports OOPr/T-Model!; [20]. With this implementation we have to gain more experience with complex systems, in order to evaluate if the introduced compatibility
relation is suited for ’real world’ applications, i.e., it is to
check whether the approach is not too restrictive or not restrictive enough. If the usefulness of the proposal is indicated by non-trivial systems, future work in this area will
include the development of refinement rules which ensure
the introduced compatibility relation in a constructive way.
Another area of further investigation is the extension of the
presented work for the modeling of object-oriented realtime systems.

[ 111 C. A. Petri. ’Kommunikationmit Automaten’. Disser-

tation, Institut fur Instrumentelle Mathematik Bonn,
1962.
[ 121 S. Philippi.

’Visual Programming of Concurrent
Object-Oriented Systems’. Journal of Visual Languages and Computing, 12( 1), February 200 1.

[13] L. Pomello, G. Rozenberg, and C. Simone. ’A Survey
of Equivalence Notions for Net Bases Systems’. In
Advances in Petri Nets. LNCS 609, Springer, 1992.

References

[ 141 Rational Software Corporation.

’UML-Documentation 1.3’. ’www.rutional.com/uml’, 1999.

P. America. ’Designing ari Object-Oriented Programming Language with Behavioural Subtyping’. In
Foundations of Object-Oriented Languages. LNCS
489, Springer, Berlin, 1990.

[ 151 J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and

W. Lorensen. ’Object-oriented modeling and design’.
Prentice Hall, 1991.

T. Basten and W.M.P. van der Aalst. ’Inheritance of
Behavior’. Report 99/17, Eindhoven University of
Technology, The Netherlands, 1999.

[I61 G. Saake, P. Hartel, R. Jungclaus, R. Wieringa, and
R. Feenstra. ’Inheritance Conditions for Object Life
Cycles Diagrams’. In Workshop Forinule Grundlagen
fiir den Entwurf von Infornzationssystetnen. Technical
Report 3/94, University of Hannover, Germany. 1994.

K. Dhara and G. Leavens. ’Forcing Behavioral Subtyping Through Specification Inheritance’. In ’Proceedings of the Int. Confenwce on Software Engineering’, Berlin, Germany, 1996.

’Integrating Concurrency and Object-Orientation using Boolean, Access
and Path Guards’. In ’Proceedings of the International Conference on High Performance Computing ’,
Trivandrum, India, 1996.

[ 171 A. Sajeev and H. Schmidt.

J. Ebert and G. Engels. ’Specialization of Object Life
Cycle Definitions’. Technical Report 19-95, University of Koblenz-Landau, 1995.

’Covariance, Contravariance, and
Synchronization Constraints’. Technical report, Ohio
State University, 1996.

H. J. Genrich and K. Lautenbach. ’System Modelling
with High-Level Petri Necs’. Theoretical Computer
Science, Vol. 13(1), 1981.

[ 181 N. Soundarajan.

David Harel. ’Statecharts: A visual formalism for
complex systems’. Science of Computer Programming, 8(3):231-274, June 1987.

[ 191 M. Von der Beeck. ’A Comparison of Statecharts Vari-

ants’. LNCS 863, Springer, 1994.

[20] P. von Hutten. ’Modellierung eines Ray-Tracers mit
00Pr/T-Modellen’. Diploma Thesis (in german), University of Koblenz-Landau, 2000.

G. Kappel and M. Schrefl. ’Inheritance of Object
Behavior - Consistent Extensions of Object Life Cycles’. In Extending Informlation Systems Technology,
Proceedings of the 2nd Int. EastNest Database Workshop. Springer, 1994.

[21J P. Wegner and B. Zdonik. ’Inheritance as an Incremental Modification Mechanism or What Like Is and Isn’t
Like’. In European Conference on Object-Oriented
Programming - ECOOP’88, LNCS 322, Springer,
1988.

Y. Kuno. ’Solving Inheritance Anomaly Problems by
State Abstraction-Based Synchronization’. In ’Proceedings of the France-Ja>uanWorkshop on ObjectBased Parallel and Distributed Computing ’, University of Tsukuba, Tokyo, Japan, 1997.
B. Liskov and J. Wing. ’A behavioral notion of subtyping’. ACM Transactioms on Programming Languages and Systems, 16(6), 1994.

347


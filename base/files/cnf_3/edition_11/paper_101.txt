Designing a Multi-user 3D Environment System
Pham Minh Tri and Edmond C. Prakash
Division of Software Systems, School of Computer Engineering
Nanyang Technological University, Nanyang Avenue, Singapore-639798
ASurnkashiiZntu.edu.sg
They may work well on platforms other than PC under
simulation of Windows, but no performance
guarantees are offered.
5. These systems do not interoperate with each other.
6 . Different vendors use different standards to visualize
worlds and avatars.
7. Some vendors even do not encourage users to develop
their own worlds and avatars.

4.

Abstract

This study developed a multi-user 3 0 virtual
environment system. The system must achieve two goals:
- Portability: it can be embedded to any kind of
platSorm.
- Coherence with other system: it can reuse shared
objects like worlds and avatars from other systems.
Thefollowing work has been done as part of this research:
1. The design ossues have been explored in detail.
2. An architecture is proposed that overcomes
several existing limitations.
3. A functional prototype ,system that implements the
architecture has been implemented
4. The system has been tested and results are given.

As a result, if you build your worlds andor avatars
from one environment, you will find it almost impossible
to put them into operation in another environment. In such
cases, your creations won’t be able to go beyond their local
environment.
1.3 Purpose and Scope

1.

Introduction

RealMeeting was designed to go firther than those
limitations faced by pioneer networked virtual
environments. The main goal of this project is to build
such a system that supports any kind of platform users may
use. Not only PC users, but Mac users, Linux users and
many more are encouraged. To f d f i l l such a mission, the
complete system must be built in cross platform.

1.1 Background

The term virtual community refers to a group of
people communicating with each other through computer
networks. A virtual world is the: cyber-space inhabited by
virtual communities. In the past these spaces were simply
built with text. Chat rooms, conferencing systems and web
worlds are examples of these. Today, virtual worlds are
becoming visible, and dramatic two and three dimensional
graphical landscapes are fast spreading across the net.

Not less important is the ability to interoperate with
other system. Different from some systems that have fixed
worlds, RealMeeting should offer clients the right to
embed their own worlds created from other environments
to the system. Moreover, they can embed their avatars as
well. These avatars have f i l l privilege to enter and explore
RealMeeting’s worlds like other avatars. To achieve this
goal, it is essential to establish a set of standards for worlds
and avatars.

1.2 Literature Review
Several virtual world environment systems have been
implemented. Among these systems, the most prominent
are Worlds Chat[8], Active Worlds[9],
Onlive
Traveler[ lo], and Blaxxun[ 1 I].

RealMeeting was designed to run on the Internet and
Intranet. Towards RealMeeting, popularity in commercial
world is always one of the major considerations. To
increase the popularity, RealMeeting would use nothing
more than users’ existing infrastructure. This means you
don’t have to install any other hardware devices than those
you already have.

Although all of these systems have been used
extensively, they seem to have several problems in their
use.
1. They do not encourage platfiirms other than PC.
2 . Most of them require users to download a client
application beforehand.
3. These applications, however, run on Windows
9x/2000/NT only.

0-7695-1195-3\01 $10.00 0 2001 IEISE

RealMeeting always moves towards ease-of-use and
user-fi-iendliness. Attaining such a goal requires robust

697

2.2 Network Architecture

internal structure for RealMeeting. Therefore, the first
versions of RealMeeting would be more concentrated on
designing an effective and efficient skeleton of the system.
Once this vital part has been achieved, successive versions
would focus on increasing ease-of-use and userfriendliness.

2.

Typically, when a networked system is designed, the
most crucial factor is the network architecture. It
determines the flexibility and efficiency of a system.
Poorly designed architecture leads to a slow and hard-toupgrade system. Below are three different models of
network architecture that can be fit to the project. Each of
them has advantages as well as disadvantages. Depending
on the demand the project, an appropriate model is to be
chosen.

System Design

2.1 Design Issues
There are many little-understood, complex problems
concerning the creation and implementation of virtual
worlds and the evolution of virtual communities. In fact, it
is likely that most of the good questions have yet to be
posed. Technologists are still asking the question, "How
and what can we do?"; but the important questions may be
"How can it be used?", "Should we do it?", "What, in fact,
are we doing?" and "What is the impact of what we are
doing?".

It is essential to have a format for describing a virtual
world. The format must fulfill the following criteria:

Satisfying all those problems would go beyond the
scope of this project. Therefore, only the most essential
problems are selected. At the moment, a virtual world has
to filfill the following criteria:

-

-

-

-

-

2.3 Virtual World Standard

-

-

Unique identity: Each user accesses a world in a form
of a civilian. A civilian has a representation, called
avatar, so that others can see and interact with.
Shared space: Civilians in the same world must be
able to see the same space. If your civilian sees an
ocean of blue color, other civilians will see the same
color.
Shared sound: Civilians in the same world must be
able to hear the same sound emitted from an object.
Of course, the volume you can hear depends on the
starting volume of the sound as well as the distance
from you to the object that emits the sound.
Shared time: Any action done in a world must be
visualized to all civilians in real time. If your civilian
is jumping up, other participants will see your civilian
jumping at the same time.
Means of communication: Civilians communicate
with each other by sending communication messages.
Communication messages can be voice messages, or
text messages.

-

Authorability: Enable the development of computer
programs capable of creating, editing, and maintaining
files, as well as automatic translation programs for
converting other commonly used 3D file formats into
this format.
Be capable of implementation: Capable of
implementation on a wide range of systems.
Performance: Emphasize
scalable,
interactive
performance on a wide variety of computing
platforms.
Scalability: Enable arbitrarily large dynamic 3D
worlds.

Both worlds and avatars are stored in VRML format.
On the Internet, you can find many such VRML worlds
and avatars. A good resource of these is Avatara (David
Maloney, [6]).

2.4 Designing RMClient
RMClient is the RealMeeting's application running on
client machines. RMClient is a bridge connecting users to
a virtual world. As a user, you use RMClient to explore
worlds and communicate with other users. The whole
architecture of running a virtual world is transparent under
RMClient.

2.4.1 User Interface. The RMClient interface is shown in
Fig. 2.

Visualization of such virtual worlds arises a number of
technical issues - these include advances in visual
displays, digitized sound, parallelism and computer
networking. Each will be discussed when we go into
details of the design.

1.

2.

698

World Scene is where you see virtual worlds. It is
visualized and controlled by a VRML Browser. You
can also see other civilians through World Scene.
Message Board is where you receive general messages
related to the world you are in. These include public
messages and system notifications.

User List contain list of citizens currently in the
virtual world. To send a private message to a user, you
have to select hisher name in the User List.
Gesture Buttons are enabled if the avatar you select
has gestures. For this version, only gestures of avatars
in H-anim format (Bemie Roehl, [4]) can be detected.
System Buttons contain buttons related to system
...
commands. Their functions are:
a. Teleport: Teleport to another world or register
.
yourown.
b. Embody: Select another avatar or register your

commandslmessages, and world events are forwarded
immediately to the server without being examined.

2.5 Transfer Protocol
We need to design a network protocol that can
completely and efficiently describe the states of our
environment. The protocol will be used to send network
messages between clients and server. Types of message
that we need to relay are:

O W .

c.
d.

-

Whisper: Send a private message to a user.
OOBE: Toggle between two kinds of viewing:
inside-out or out-of-body. Logout.

-

2.4.2 Overall View. The architecture of RMClient is
described in Fig. 3.

-

The whole system is message-driven. Each component
sends messages to and receives messages from others. A
message can be a world event, a system message, a text
message, an action implying a gesture button is pressed, a
system command, a voice message, or a network message.

-

System
commandshnessages:
These
include
connecting/disconnecting the system, enterindexiting
a world, or registering new worlds andor avatars.
World messages: These involve in messages related to
objects in a virtual world. Examples are moving
objects, acting avatar gestures.
Communication messages: These are usually text
messages. Voice messages are converted to text
messages using voice recognition technology.
User info message: This includes viewindediting
information of a private individual.

There are two protocols available on the Internet that
is fit to our project. They are VRTP (Virtual Reality
Transfer Protocol) and VIP (VRML Internet Protocol)
(Stephen F. White, 1998). VRTP is a full-scale network
protocol, which is suitable for large-scale multi user
project. On the other hand, VIP is simple but sufficient for
our use. We will choose VIP instead of VRTP but we will
add more features to VIP to support our own needs.

RMClient’s processor runs a while loop to wait for
messages. When there is a message coming from the user
interface, the processor firstly interprets it and responses
an appropriate message to the interface if required. Then, it
converts the message to network message and sends to the
server to update information.
Every VRML node, or object, can be referred by a
program’s object reference. Anytime you move your
mouse to change your view’s position and orientation, the
Viewpoint object sends an event to the processor (via the
Viewpoint object reference). Conversely, when there is a
network message requesting to update the position and
orientation of an avatar, the pr’ocessor sends this message
to the corresponding avatar object as a world event to
change its position and orientation (via the Avatar object
reference).

VIP uses Socket technology to send data over
network. To do so, a socket server is opened in the server
machine. In order to communicate with this socket server,
clients need to know the server IP and the port at which the
socket server is opened. Therefore, these two values are
provided as parameters of the client application.
VIP controls sending messages over network. The
object field contains the source object’s id number (32 bit
integer). The type field contains the type of the message
(short integer). This type is much likely similar to
programming language types such as int, char, String, etc.
Some new types are added to support our extension. The
value field contains the message information.

2.4.4 Processor. The processor is the heart of RMClient. It
decides how messages are interpreted and dispatched.
Designing the processor is the most difficult step in
designing the system. The following diagram shows the
internal structure of the processor:

2.6 Designing RMServer

When there is a voice message coming up, the
processor translates the message into text message via a
voice recognizer. The text message is sent over network to
other clients. It is then reconverted to voice message via a
voice synthesizer and emitted to other clients’ sound
speaker. Other messages like: gesture actions, system

RMServer is the RealMeeting’s server application. It
is a standalone program. The purpose of the RMServer is
to monitor worlds. Therefore, no user interface is required.
Having received a message, RMServer interprets it,
updates information that it delivers, and dispatches it to
appropriate clients if necessary.

699

For example, when RMServer receives a private text
message, it first finds out the target user of the message.
Then it forwards the message to the user. In this example,
no information update is needed.

is the main advantage. And we inherit the power of Web
technology. The server IP and the socket port is also stored
as parameters of the applet so that clients can connect to
the socket server.

Another example is broadcasting an event. Suppose
RMServer receives a message implying the new position
of a citizen. It looks at the database to find out the user
who controls the citizen, as well as the world he/she is in.
Then, it updates the new position to hisher information
record. Finally, it forwards the message to other users
wandering in the world.

List of worlds contains information of all worlds
registered; and is saved in a user-readable wor1d.m file.
The file consists of several blocks. Each block is separated
by a line containing a ‘#’ character. The file ends by a line
containing a ‘$’ character. A block contains information of
a world stored in 4 lines. Respectively, they store the
world name, the world url, an url to a midi file that is to be
played when the user logs in to the world, and an url to an
image showing the world.

For each user connected to the server, a user thread is
established in RMServer to receive and dispatch messages
from the user. RMServer uses its processor to handle those
messages from user threads and update information in the
database. Like RMClient’s processor, RMServer’s
processor just waits for messages.

List of avatars is a little bit more complex. It is saved
in a avatar.txt file and is also separated by blocks in the
same manner. Each block has exactly 11 lines containing
different information about an avatar. The first line holds
the avatar name. The second line holds the avatar url. The
third line holds an image showing the avatar. The fourth
line holds the value of the avatar height, in metre. The next
3 lines contain a position offset vector of the avatar. The
last 4 lines contain the rotation vector and rotation angle of
the avatars. These values are required to adjust avatar
before embedding it to a world.

The processor classifies messages into two
groups: world related messages and world non-related
messages. World related messages are messages about an
action happening in a world. Such an action can be:
communicating among civilians, acting an avatar gesture,
walking in the world, and moving objects in the world.
World non-related messages are logging idout a world,
registering new avatar and/or world, embodying, and
changing user name.

The file formats used supports that keeping VRML
world files and VRML avatar files in the server is not
necessary, thus saving much of server storage. In fact,
most of the default VRML world files in this version are
located randomly over the Internet. Some of them are
saved locally a computer named PMTRI in NTU’s Local
Area Network. Only the addresses of the VRML files are
stored in the two lists above. If you find any difficulty in
locating such files, you can change the file address or even
use your own file by editing the lists.

In the CliendServer model, both of the groups can
be handled using one server application. However, in the
ClientlWorld Servermain Server model, messages of the
world related group are handled by their world server;
while world non-related messages are handled by the main
server. By this way, network slowdown is minimized and
the main server never gets overloaded.

3.2 Testing the System and Result

There is a need to keep the list of worlds registered as
well as the list of avatars registered. In this version, these
two lists are saved in files in the server. The list of worlds
is saved in the world.txt file and the list of avatars is saved
in the avatar.txt file. They are user-readable text files.

3.

The system was tested underlying different situations.
The most difficult situation was that there were 8 users
connected to the system. RMServer was running on a
400MHz PC workstation; other clients were running on
Windows 98/2000 machines. These machines were
connected under NTU’s Local Area Network. Their CPU
speed varies from 5OOMHz to 800MHz. Graphics
visualization ran well in this situation. Though, network
delay sometimes happened when clients sent many text
messages over network. However, this is only noticeable at
the server-side. In such cases, some clients had not
received a message before a series of messages arrived.
This could be due to the CPU speed of the server. Good
news is that no delay of avatars’ movement was detected.

Implementation and Results

3.1 System Implementation

Java was chosen as the programming language to
implement RMClient and RMServer. Instead of building a
standalone Java client application, we built a Java client
applet embedded in an HTML file. Beside the applet, the
HTML file contains another embedded object representing
the VRML scene. By doing this, we achieved two
advantages. We have full access to the VRML scene - this

700

we just need to send it to a multicast IP address and
the information will be broadcasted to all other user
joining the multicast group.
Services: The current system is short of services. In
this version, only text chat, gesture actions, and world
exploration are provided. More services like
exchanging user information, finding user, etc need to
be implemented. Functions: Interacting between two
citizens, interacting between citizen and world,
scripting, chatting with emoticons, sound effects are
essential to be implemented.
Security: Checking of user subscription, user logging,
checking of information when registering new world
andor avatar need to be implemented.
Attraction: Graphics visualization has to be improved.
Beside, user interface should be more friendly. A
creative idea is also essential to gain user’s interest.

Some feedbacks from users have been conducted. Below
are their comments to the system:
“So ugly. Everything is ugly. Need to upgrade everything.
” - said Le Nguyen Quang Khang, first year Computer
Engineering undergraduate.

“The scene view was so large thiit I felt a bit dizzy. Beside,
the system did not detect the sense of being touched by
other civilians.” - said Phan Minh Chau, first year
Engineering undergraduate.
“Very good lah. However, the movement of avatars was
not so smooth. Sometimes I saw a civilian standing in front
of me then it suddenly disappeared.” - said Nguyen Manh
Ha, first year Computer Engineering undergraduate.
“Perfect! Unluckily, there was no other interaction among
civilians beside communication. I expected more activities
rather than just acting gestures.” - said Pham Thanh Hai,
first year Engineering undergraduate.

Bibliography
Bemie, R. and Couch, J. and Reed-Ballreich, C.
and Rohally, T. and Brown, G., 1997. Late Night
VRML 2.0 with Java, Ziff-Davis Press,
Califomia.
Hopson, K.C., and Ingram, S. E, 1997.
Developing Professional Java Applets, Ziff-Davis
Press, Califomia.
Yusdi Santoso, 2000. Building a Networked 3D
Virtual Environment using VRML and Java,
Nanyang Technological University.
Bemie Roehl, 1999. Humanoid Animation Group
at http://www.ece.uwaterloo.cd-h-and.
White, S. F., 1998. Vnet at
http://www.csclub.uwaterloo.cdu/sfbhite/vnet/.
David Maloney, 2000. A V A T A R A - Virtual
Worlds and Avatars at
http://www.avatara.com.
Activeworlds.com, 2000. Active Worlds at
http://www.activeworlds.com.
Worlds.com, 2000. Worlds Chat at
http://www.worlds.com.
Onlive, 1998. Onlive Traveler at
http://www.onlive.com.
Blaxxun Interactive, Blaxxun at
http://www.blaxxun. com
Web3D Consortium at
http://www.web3d.orgl.

4. Conclusions and Recommendations
4.1 Limitations

Two main goals (portability and coherence with other
systems) were achieved. However, we had to sacrifice the
system’s speed and some other abilities. A good example
is sound effects. At the moment this paper was written,
speech technology was offered for Windows platform
only. Implementing voice message was therefore not
achievable.
Another limitation that was noticed is the network
bandwidth. As more users connect to the system, it gets
slower and network delays starts to happen. The system
was tested when there were a small number of users
connected. What will happen if: there are more than 100
users connected to the system‘? Will the server not be
overloaded? Those questions are yet under investigation.
4.2 Improvements
A lot of features need to be improved in the next
versions. They can be classified as follow:

-

Network architecture: In order to provide large-scale
integration environment, it lis essential to upgrade the
system to ClientlWorld ServedMain Server model.
Speed: The most interfering factor of the system speed
is the network bandwidth. A partial solution is to use
network multicasting IP. This way, we do not need to
send the information to each and every user, instead

70 1

\li)hll

Rrn>a!sor

Processor

Viewpoint object
viewpointPosit ion
viewpoint Orientation
Other world objects

viewpointorient ation

To this
user's

object
reference

Figure 1. An example of a virtual world
Figure 4. Handling world events

User
"4

-

LIS1
,

System

-- 'ft"aI1ds

Network
Message

Figure 2. User Interface

4-b

Figure 5. Deeper view of RMClient's processor
Figure 3. Overall structure of RMClient

702


:LinearProgramming Concept Visualization
(*)JeanPierre Charalambos and Ebroul Izquierdo (**)
(*)ImageProcessing and Computer Graphics
( " ) Department of Electronic Engineering
Research Lab, Dept. of Computer Sciences,
Queen Mary, University of London
National Universiv, Colombia
London E l 4NS, United Kingdom
empirically that both the visualization of the feasible
region and the path followed by the algorithm used to find
an optimal vertex are essential to understand the solution
process and the solution to the problem itself. In Fig. 1 a
feasible region of a 3D linear programming task is
outlined. In this context and due to th,e hierarchical nature
of algorithmic solutions to linear programming problems,
visualization is extremely important as a tool to help
researchers develop and test their techniques.
A visualization scheme that is highly suitable for
interactively drawing and visualizing the feasible region of
a given 3D-linear programming task is introduced in this
paper. It can be used for the better understanding of the
solution process when different methods devoted to
solving the underlying problem are applied, e.g., the
simplex method. The analysis leading to the presented
schema comprises sensitive analysis during the solution
process, interactive visualization of the feasible region, and
experimental testing of intermediate results. It is shown
that the design of an appropriate and simple vertex
representation is crucial to manage any order of
degeneracy. To deal with this paradigm and to some extent
to formalize it, the concept of adjacency invariance is also
introduced. The envisaged approach focuses on the
development of an interactive and highly accessible
visualization technique as a helping tool for the better
understanding of 3D-linear programming problems. If the
feasible region of a 3D-linear programming problem is
completely bounded, it is given by a convex polyhedra.
Thus, visualization of convex polyhedra intersection and
the feasible region of a 3D-linear programming problem
can be seen as equivalent tasks. Although several works
dealing with highly efficient methods for finding convex
polyhedra intersection can be found in the literature, most
of them describe either analytic solutions or they are only
concemed with the algorithmic complexity. Among several
papers dealing with efficient algorithms for intersecting
two convex polyhedra in the 3D-space, the following can
be highlighted: The first non-trivial algorithm to solve the
problem was presented by Muller and Preparata [ l ] in the
late seventies. It was also the first technique to achieve this
task in O(nlogn)time. Here n is a resonable measure of
the combined complexity of the two polytopes. Usually,
the number of halfspaces defining the polytopes is taken as
measure for the complexity. This work relies on the dual
relationship between polytope intersection and convex

Abstract
A visualization scheme a:; a tool to find the solution of
any 3D-linear programming problem is introduced. The
presented approach is highly suitable to draw and
visualize interactively the feasible region of a given 3 0 linear programming problem. It can be used for a better
understanding of the solution process when dgfferent
methods devoted to solve .!he underlying problem are
applied, e.g., the simplex method. The proposed technique
comprises sensitive analysis during the solution process
and interactive visualization of the feasible region. The
analysis leading to the introduced schema also shows that
the design of an appropriate and simple vertex
representation is crucial to manage any order of
degeneracy. To deal with this paradigm and to some extent
to formalize it, the concept of adjacency invariance is
introduced. Several experiments have been conducted to
test and assess the performance of the introduced concepts
and techniques.

1.

Introduction

Whenever we try to comrnunicate ideas or to find the
solution to problems arising from science and technology a
major challenge has to be tackled: to find the most
appropriate way to describe and express either the solution
process or the solution itself. For instance, using
conventional oral communica.tion varying emphasis may
be put on relevant words to stress key concepts or to give a
better image of the idea we want to put across.
Nevertheless, when solving complex mathematical
problems there are concepts that cannot be easily
expressed in words or demonstrated using simple formulas.
In those cases images and gTaphics are much better to
present and describe the underlying concepts. This fact
provided the origin of the popular sentence "a picture is
worth a thousand words". The rapid development of, and
increasing accessibility to, computer graphics programs
and their inherent visualization tools allow us to express
and present highly complex problems and solution
schemes in a simple manner.
In this paper we are interested in the visualization of a
specific class of problems and their solution process: linear
programming. In this case it has been established

529
0-7695-1195-3/01 $10.00 0 2001 IEEE

union. Other important techniques include Hertel et al. [2],
in which the planar sweep strategy is used and also
achieves O(nlogn) time. Yet another O(n logn)
algorithm follows by direct application of the hierarchical
representations of 3-polyhedra introduced by Dobkin et al.
[3]. Other important representation of 3-D polyhedra,
known as the doubly-connected-edge-list can be found in
Preparata and Shamos [4]. Chazelle's work [ 5 ] introduced
the first optimal approach to determine the intersection of
two polyhedra in linear time O ( n ) time. Basically, this
method is an improved version of the approach presented
in Dobkin et a f [3]. It uses the dual transforms previously
introduced by Muller and Preparata. Finally, inspired in
Chazelle's work and in contrast to it, Martin's optimal
algorithm [6] solves the problem in the primal space. Any
of the approaches for finding the intersection of two
convex polyhedra mentioned above, can be extended to a
generic method to find feasible regions of 3D-linear
programming problems.
1

"

_--

Hyperplane hl
Hyperplane h,
Hyperplane h,
Polytope P

addressed problem. We are aware of the fact that the same
goal can be achieved using more elaborated and
computationally efficient techniques but at the cost of
losing simplicity. Secondly, it is also straightforward to
conduct an experimental testing of intermediate results. In
addition to that the adjacency invariant concept is
introduced. Using this concept any order of degeneracy can
be easily represented. It can then be used, for instance, to
outline the path followed by the simplex method when the
optimal solution is sought.
The paper is organized as follows. In Section 2 the
novel interactive visualization technique to display and
find the feasible region of any 3D-linear programming
problem is described. Section 3 deals with the adjacency
invariant concept. Selected results from computer
simulations are reported in section 4 and the paper closes
with a summary and conclusions in section 5.

2. Visualization of the Feasible Region of
Linear Programing Problem
2.1 Notation
In this paper we follow the notation used in [7].Let p
be a nonzero vector in E d and k a scalar. The inequality
px I k denotes a constraint. A hyperplane h is a set of
the form { x : px = k } that divides E d into two
complementary regions, called halfspaces. Hence a
hdfspace is a collection of points of the form { x : px Ik }
and is denoted by h - ,

x3

Fig. 1: Feasible Region of a 3-Linear Program
As mentioned before all these works focus on the
complexity issue by defining the algorithmic complexity in
terms of the number of facets of the considered polyhedra.
In contrast, in this paper the problem is regarded from a
visualization point of view. We argue that linear
optimization problems arising from practical applications
are constrained by a small number of inequalities. Since
these constraints basically define the feasible regions, their
cardinality also defines the computational cost.
Consequently, in our case visualization of the solution
process and possible alternatives is essentially more
important than algorithmic complexity in the sense that it
is described in previous works from the literature. In
addressing this specific problem, this paper makes two
major contributions: firstly, the solution process can be
visualized dynamically and interactively using a
straightforward implementation and representation of the

or a collection of the form

{x: p x l k } denoted by h'.

The set of all halfspaces
defining a given linear program is denoted by H . A
convex polyhedron (or simply polyhedron) or polyhedral
set X is defined as the intersection of a finite number of
such halfspaces. A polytope P is a bounded polyhedra. If
X'E X and px'= k we say the constraint p x 5 k is tight
The hyperplanes associated
or binding or active at
with the defining halfspaces of X are referred as defining
XI.

hyperplanes of X . A point x of X in E d , is called a
vertex or extreme point, if x lies on some d lineraly
independent defining hyperplanes of X . In E" if more
than d defined hyperplanes pass through a vertex, then
that vertex is called a degenerate extreme point or a
degenerate vertex and the excess number of planes over d
is called its order of degeneracy. We say that hyperplane

h supports a polytope P if P c h- and h n P f 0 . If h
supports P , then h n P is called a face of P . One
dimensional faces are called edges and d - 1 dimensional
faces are calledfacets. The set of all vertices,of a polytope

530

P is denoted by V ( P ) .Analogously, the set of all edges
and facets of a polytope P I are denoted E ( P ) and F ( P )
respectively.

Feasible Region

2.2

First we need to identify and draw suitable boundaries
for the feasible region. This is done by applying the
following constraints:
1) - x , I O ,
2 ) - X 2 I O , 3) - x 3 < 0 , 4) X I S C , ,
5 ) x2 I c2 , 6 ) x3 I c3, where CI, c2 and c3 are suitable
constants defined by the user. As these halfspaces define a
totally bounded region in the: 3D space, the next processing
step consists of finding the polytope contained in this
region and specified by the n halfspaces defined by the
problem constraints. Two possible algorithms to build the
polytope generated by the intersection of n halfspaces are
estudied.
I)
Algorithm INTERXECT ( H ) :

recursively solve the problem. To find the intersection of
n halfspaces, first the intersection of only two of them is
sought. Then new intersections with each one of the
remaining halfspaces are built recursively. The fknction
Intersect-Convex-Regions finds the intersections of any
two polytopes. Any optimal technique from the literature
can be used. For instance, Chazelle's technique [ 5 ] , which
solves the problem in the dual space, or Martin's algorithm
[6],which solves it in the primal space. Both techniques
are optimal with complexity U ( n ) . The recurrence has
complexity U(nlogn), which is also optimal.
By applying Euler's formula it can be seeing that the
number of edges per facet is constant in the second
algorithm. Thus, the algorithm complexity is U ( n 2 ) .

A set H of n half-spaces in E 3
Input:
A polytope P or the empty space
Output:
ifcard ( H ) = 1

C t the unique halfspace h-

E

I

H

else

split H into sets H I and H2 of size [ n / 2 ] and

1.4

Fig. 2: Sequential search performed for fmding new intersections.

Cl t INTERSECT ( H I )
C2 t INTERSECT ( H2 )
C t Intersect-Convex-Regions (CI,C2)
end
\

Algorithm POLYTOPE ( H ) :

2)

A set H o f ' n half-spacesin E 3
Input:
A polytope P or the empty space
Output:
for (each halfspace in H 11
for (each facet f in P )
for (each border in f )
Find_" w-Points
Update-Facet
end

As mentioned before linear optimization problems
arising from practical applications are constrained by a
small number of inequalities. Thus, we are basically
concemed with low-scale problems in which the efficiency
difference between the two algorithms described before is
irrelevant. Since algorithm POLYTOPE give us better
means to adopt the adjacency invariant, we will use this
algorithm as a basis for the following discussions. Notice
that on the one hand complexity does not play any relevant
role and on the other hand the adjacency invariant is
independent of the selected approach. Consequently,
adopting algorithm POLYTOPE in the sequel does not
mean any loss of generality. Let us begin by making some
remarks with respect to our implementation of algorithm
POLYTOPE

end

Create-New-Facet
Render (Feasible Region)

% in

1-

P

YO interactively

end

The first algorithm is optimal in terms of asymptotic
efficiency. It is an extension of the technique described by
de Berg et al. [8] to solve 2D linear programming
problems. Here the divide-ad-conquer strategy is used to

53 1

Function Find-New-Points
finds the world
coordinates of the new vertices that emerge from the
intersection between the ith halfspace with the
polytope defined by the first i - l halfspaces. This
process is started by generating the polytope defined
by equations 1-6. Thereafter, we perform a sequential
search through adjacent borders of a given facet to
find the intersections. In order to avoid the drastic
approach of searching through all of them, when

2-

3.

traversing the borders of a facet a binary value is
assigned to each vertex according to the rule: if the
world coordinates of the current vertex is a point in
the ith halfspace then the binary value 1 is assigned,
otherwise it get assigned the binary value 0. Since it
cannot be more than two new vertex intersecting a
given facet, we know exactly when to stop the
searching process. See Fig. 2.
The two functions
Create-New-Facet
and
Update-Facet have been implemented specifically to
preserve the adjacent invariant of both the modified
facets and the new facet emerging at the current
iteration.

The processes described in 1 and 2 are particularly useful
for sensitive analysis in linear programming techniques
aiming at iterative path following towards the optimum
value, e.g., the simplex method. A detailed description of
these processes is given in the next section. The last
process is useful to determine the three equations to be
solved when the world coordinates of a new vertex v"
emerging from edge intersections are sought, see Fig. 4.
{.

.. .,

d+l?

Adjacency Invariant

To efficiently manage any order of degeneracy that
could arise running any region visualization algorithm, we
need to adopt an efficient facet neighborhood
representation for every vertex v at each facet of P . For
this we state the following invariant: Let a and p be the
two facets associated to each vertex v of a given facet f
that collide with facet f at vertex v . If the order of
degeneracy of vertex v is more or equal than I , then
facets, a and p , are those adjacent to the left and right of
facet f . Thus, facets a and p , are the facets forming the
borders with facet f meeting at v . See Fig. 3.

j'

Fig. 4: Halfspaces defining an emerging vetex.

To show how to keep the adjacency invariant of facets
42, ...,j - 1 and the jth facet at iteration j in constant time
we considered all intersection possibilities between the jth
plane corresponding to the jth halfspace and facet i , with
0 5 i j - 1 . These possibilities are outlined in Tab. 1.
Cases
1
2

Intersection Type
No intersection
Intersection in 1 Doint (for a vertex of facet i
Intersection with two adjacent vertex

Different cases for the intersection between a halfspace
and a facet of the polytope
Let us show how to keep the
M-)ar-ent facets at v e r t e x
r e s p e c t to f a c e t 2
a
I . To t h e l e f t :

2. To t h e

v

of facets

,...,

j - , depending on these six cases. Thereafter, it will be

invariant of emerging facets.

rLght:

Case 1: As the plane does not intersect the facet i , it
remains unchanged or it will be discarded. This case is
depicted in Fig. 5a.
Case 2: The plane intersects facet i at vertex v, thus, it
remains unchanged or it will be discarded. Fig. 5b
illustrates this case.
Case 3: The plane intersects facet i at the adjacent
v and v
j - I . If the
j is taken
halfspace covers facet i , it
instead of a at v and v' to represent the out side facet of
the edge. If the halfspace does not cover the facet i , it is
discarded. This case is depicted in Fig. 5c.

Fig. 3: Adjacency Invariant.

Observe that using this invariant the following
processes can be run in constant time O(1) :
1. The estimation of two adjacent facets meeting at
vertex v with facet f .
2. The estimations of all vertices of each facet colliding
at vertex v with facet f .
3. The estimation of the facet f' forming a border with
facet f .

532

Case 4: The plane int'xsects facet i at two nonadjacent vertex v and v' that from iteration j - I
respectively have w -a arid ,U - A as their associated

covered by the halfspace. 2) Facets p and j are
associated at vertex VI. 3) The corresponding regions are
preserved. Fig. 5e illustrates the case.
Case 6: The plane intersects facet i at points a and b
of two of his edges. From iteration j - 1 , a and ,U are the
outside facets at the intersected edges to which a and b
belong. Taking v as a and v' for b , w' is now a new
edge in facet i . Thus, 1) Facets 01 and j are associated at
vertex v . 2) Facets ,U and j are associated at vertex v'.
3) The correspondent regions are preserved. Fig. 5f
illustrates the case.
As the average number of vertex per facet is constant,
cases 1 to 6 can clearly be achieved in constant time O(1).
Specifically, this can be done using the function
Update-Facet in algorithm POLYTOPE.
Now we show how to keep the invariant for emerging
facets. For this let us assume that at iteration j a new facet
j emerges and that vertex v belongs to facet j . If vertex
v emerges in the middle of an edge, then the order of
degeneracy at v is zero. Consequently, the two facets that
define the edge are associated to vertex v . If vertex v
corresponds to an existent vertex, then facet j will be the
inside facet of two borders meeting at v . Thus, the two
facets in which j define these borders are necessarily
their associated outside facets at vertex v . Fig. 6 illustrates
this degeneracy case.

facets. w' is a new edge in facet i. Two cases are
considered: 1) j is taken instead of w -,U or a - A to
represent the out side facet of edge VV' (depending of the
region covered by the halfspace). 2) The corresponding
regions are preserved. Fig. 5d illustrates the case.
a)

b)

.......
w...
3.>
......;i-.....

. .... .

i 3 ,,j

,..-

,.>

......

... .I

*............

i

*.,.
<.j,.:

::,...........
{J;

*

....

Fig. 6: How to keep the adjacency invariant in emerging facets.
Fig. 5: The six cases considered in Tab. 1
Case 5: The plane intersects facet

As the average of the number of vertex per facet is
constant and this happen independently of new emerging
facets, the invariant can clearly be kept in constant time
O(1). Observe that this task is achieved using the function
Create-New-Facet in algorithm POLYTOPE.
Finally, it can easily be proven by induction on the
number of facets defining a polytope that the invariant
remains valid.

i at vertex v and at

point U of an edge. From iteration j - 1 and the
application of the adjacency invariant two cases are
derived: 1 ) vertex v has W - a! as its associated facets. 2)
,U is the outside facet at the intersected edge. Taking v' as
a , vv' is now a new edge in facet i . Three steps are
considered: 1) j is taken as ( i ) or 01 to represent the out
side facet of edge vv' at vertex v , depending of the region

533

is abundant and we are to determine its maximum
decrease.
We are particularly interested in sensitive analisys
visualization of a 3-linear program from a resource
analysis point of view. For this we use the following
algorithm:

4. Interactive Visualization
Once an algorithm to draw the feasible region of a 3linear program is available, sensitive analysis visualization
and testing can be conducted. These are crucial concepts
for the visualization of linear programming tasks. In this
section we describe how to obtain a suitable simulation of
the path followed by the simplex method when an optimal
vertex is sought.

4.1.

Algortihm D YNAMICRESOURCES (H , v* ) :
Input: Set H of m half-spaces in E3 representing

Path Following

the constraints and optimal Vertex v*
Output: A polytope P' that represents the new
feasible region according to the changed resources

To simulate the path following by the simplex method
when an optimal vertex is sought, the next algorithm is
used:

Classify_Resources
for (each abundant resource)
Determine-Decrease
Render (Feasible Region) %Updating
the original feasible region.
end
for (each scarce resource)
Determine-Increase
Render (New Region) YO In order to
augment the original feasible region.
end

Algorithm SIMPLEXPA TH ( P , c ):
Input:

Polytope P and Objective Function c

Output:

Optimal Vertex v*

v

*

t

V

YOv isany vertexof P

while ( v* is not optimal)
Render-Path

Select-Edge % one of all possible from
v' t v'

V*

The function Classifi-Resources can be implemented
as follows:
1. Discard constraints that are not resources.

YOv' is the vertex at the extreme
of the selected edge

end
Observe that by assigning v* t v we can show how
the build a first basic feasible solution. Function
Render-Path can be implemented by traversing a set of
rendered points in the surface of the polytope or by
traversing a set of arrows pointing out from one vertex to
another. The implementation of the function Select-Edge
is straightforward if the adjacency invariant is used.

4.2.

Sensitive Analysis

As stated by Taha [9], sensitive analysis (or dynamic
analysis) on a linear program allows us to check how the
feasible region and the optimal solution evolve, when some
of the parameters vary. This process can be performed
dynamically, i.e., it is not necessary to start the whole
process each time a parameter is changed. Relevant
variations are perceived when coefficients of the objective
function or the right-hand side of the constraints are
modified. Performing a controlled change over any of
these coefficients lead to significant changes of the optimal
vertex and the feasible region, respectively. Moreover if
the considered constraint represents a resource then if it is

binding at optimal vertex v * , we say the resource it
represents is scarce and we are to determine its maximum
increase, contrarily if it is not binding, we say the resource

2.

From the optimal vertex v' select the scarce
resources by determining the corresponding adjacent

facets at v .
The role of the two functions Determine-Decrease and
Determine-Increase are to find the maximum decrease and
increase of abundant and scarce resources respectively.
This is done by finding the new vertex where the
corresponding facets are intersected. In the first case, i.e.,
vertex V * is the optimal one. In Respect to the latter we
need first to distinguish two cases:
Case 1: The scarce resource increases but it does not
intersect any halfspaces whose corresponding planes do
not support the original polytope. Fig. 7a illustrates this
case.
Case 2: The scarce resource increases but it intersects
some halfspaces whose corresponding planes do not
support the original polytope. Figure 7b illustrates the case.
Observe however that in both cases the region increases
forming a new polytope P' whose set of facets F ( P ' )
must be a subset of:
1. The facet corresponding to the given scarce resource.
2. The facets adjacent to the facet corresponding to the
given scarce resource at optimal vertex
3. The emerging facets corresponding to some of the
halfspaces that do not belong to the original polytope.
V I .

534

In this case a new set of halfspaces H' should be taken
to estimate P'. This set I S chosen from the following
options:
I . The halfspace complementary to the halfspace
corresponding to the given scarce resource.
2. The halfspaces correspclnding to all facets in ii)
3. All halfspaces not contained in P .
Observe that the adjacency invariant plays a crucial
role in this simple strategy to estimate H ' . Furthermore, it
is important to stress that the input of the function Render()
in algorithm DYNAMICRESOURCES is a set of halfspaces
and its output is a polytope:. Thus, any of the algorithms
described in section 2 can be used as Render() function.
\c

help to improve the quality of teaching and to understand
basic mathematic conceDts.

....................

Fig. 8: A screenshot of the implemented system.

c opttclVc1 vortex

- a)

scar96

re.BD"rds

"-.............-

""Lila1
..=*CC*

plnn-

References

uer<o,.
rc,.,"rce
nor ; n P

b)

D. Muller and F. Preparata. Finding the intersection of
two convex polyhedra. Theoretical Computer Science,
71217-236, 1978.

- Fig. 7. Scarce resource analysis. a) Case 1, b) case 2.

S. Hertel, M. Mantyla, K.. Mehlhom y J. Nievergelt.
Space sweep solves intersection of convex polyhedra.
Acta Informaticu, 21(5):501-519, 1984.

5. Summary and Furthier Study
A comprehensive study and a scheme to visualize the
feasible region of a given 31)-linear programming task has
been presented. The visualizations scheme can be used for
the better understanding of the solution process when
different methods devoted to solving the underlying
problem are applied, e.g., the simplex method. The
performed
analysis comprises sensitive analysis,
interactive visualization of the feasible region and
experimental testing of intermediate results. It is shown
that the design of an appropriate and simple vertex
representation is crucial to manage any order of
degeneracy. To deal with this paradigm and to some extent
to formalize it, the concept of' adjacency invariance is also
introduced. The envisaged approach focuses on the
development of an interactive and highly accessible
visualization technique as a helping tool for the better
understanding of 3D-linear programming problems. A
system comprisisng the most relevant algorithms presented
in this paper has been implemfented, see Fig. 8. This system
has been designed to support teaching models based on
visualization.
'
The presented study can be expanded in three different
directions: Testing experimental gradient solution
algorithms. Developing objective coefficient analysis.
Inserting the system in a closed virtual environment, e.g.,
in an electronic book. This last objective will significantly

D. P. Dobkin y D. Kirkpatrick. Fast detection of
polyhedral
intersection.
Theoretical Computer
Science, 27:241-253, 1983.
F.P. Preparata y M.I. Shamos. Computational
Geometry: An Introduction. Springer-Verlag, New
York, 1985.
B. Chazelle. An optimal algorithm for intersecting
three-dimensional convex polyhedra. Technical
Report, Department of Computer Science, Princeton
University, February 1989.
A. K. Martin. A Simple Primal Algorithm for
Intersecting 3-Polyhedra in Linear Time. Technical
Report, Department of Computer Science, University
of British Columbia, July 1991.
Bazaara, J. Jarvis y H. Sherali. Linear Programming
and Network Flows. John Wiley and Sons. 1990.
M. De Berg, M. Van Kreveld, M. Overmars y 0.
Schwarzkopf. Computational Geometry: Algorithms
and Applications. Springer-Verlag, 1997.
H. Taha. Operations Research: An Introduction.
Prentice-Hall. 1997.

535


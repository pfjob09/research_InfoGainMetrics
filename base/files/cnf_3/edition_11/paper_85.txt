Generating Dynamic Shadows for Virtual Reality Applications
Sandra Sudarsky
Siemens Corporate Research, Inc.
755 College Road East
Princeton, NJ 08540
sudarsky @scr.siemens.com

Abstract
In this paper we discuxs the benefits of including
shadows into virtiinl reality applications arid propose a
solution to the problem of generating shadows .for .I\.natiiic scenes. I n order to achieve interactivity, we restrict tire problem to the case of polyhedral objects and
plcinar sufaces. We propose a new node us an extension
to VRML that ciirtoiiiciticrilly ;:merlites the shadow of the
underlxing polygonal model into user defined siyfaces.

they should be located and how they should be updated as
the object or the light sources change.
We present a solution to the problem of generating dynamic shadows restricted to polyhedral objects and planar
surfaces. The restricted problem can be solved very efficiently achieving interactive rates required in virtual reality
applications. We propose a new VlUvlL node, the shadow
node, which dynamically recomputes the shadows of the
target object as the scene changes.

2. Related Work
In this paper we focus on the problem of generating dynamic shadows due to point light sources. In what follows
we review some proposed techniques to compute hard
shadows based on area subdivision, z-buffer, shadow volumes and ray tracing algorithms.
The area subdivision approach presented by Atherton et.
al. [2] is a two-pass algorithm. that computes the shadows
cast by polygonal objects. During the first pass, polygons
in the scene are classified as shadowed or lit, subdividing
the polygons as necessary whenever they appear to be partially visible from the light source. The second pass is used
to actually render the polygons. The algorithm is simple but
computationally expensive for interactive environments.
Williams [ 121 proposed a two pass technique based on
the z-buffer to determine the areas of the scene that are
blocked from the light. Initially, the scene is rendered from
the point of view of the light source and the depth values of
the lit areas are stored in the z-buffer. The scene is then
rendered from the point of view of the camera, transforming
the object coordinates to the light source space and comparing the depth values to those stored in the z-buffer. If
the computed values are less than those in the z-buffer, the
corresponding pixel is shaded as being in shadow. This
technique it is not restricted to polygonal data but it suffers
from aliasing and precision problems.
Crow [SI presented a technique to detect shadow
boundaries by creating a shadow volume for each object in
the scene. A shadow volume is defined by a number of
shadow polygons bounded by the light source position and
each silhouette edge of the object. These polygons are used
to determine whether other objects are in shadow by testing

1. Introduction
In a three-dimensional world, shadows provide important perceptual cues about the relative positions, sizes,
shapes and orientations of objects in a scene [IO]. Without
shadows i t is difficult to determine the spatial relationship
between objects; an object may appear closer to the
viewer than another object while in actuality i t is further
away. In a scene without shadows i t is also difficult to
tell whether an object is sitting directly on top of another
object or floating in space.
Shadows have been extensively studied in the field of
computer graphics and a number of algorithms have been
proposed that generate very realistic shadows for static
scenes [ 1 I][6][41.Unfortunately, shadow computation is a
time consuming operation that cannot easily be performed
at interactive rates. Because of this complexity, interactive virtual worlds are often created without shadows and
often appear very artificial arid ambiguous. In fact, the
VRML (Virtual Reality Modeling Language) specitication [91 does not rcquire shadows to be generated. Standard VRML objects allow the light to pass through them
without casting any shadows. In order to compensate for
this shortcoming, some texts [ I ] suggest the creation of
fake shadows as flat semitransparent objects shaped to
resemble the projection of the object onto the appropriate
surface. However, it is a difficult task to figure out exactly what shape should these fake shadows have, where

595

objects or part of them cast shadows, avoiding insignificant
details to take part in the shadow computation.
Next we present the details of the algorithm, describe
the proposed node as an extension to VRML and discuss
some issues we faced during its implementation.

whether the ray of the scan line algorithm intersects more
front-facing than back-facing shadow polygons. A number of improvements to this algorithm have been published that incorporate efficient data structures to speed up
the computation.
Ray tracing algorithms [ 1 11 [4][6] produce excellent
shadows and they are not restricted to polygonal data.
Although a number of improvements have been published, ray-tracing algorithms remain expensive and impractical for interactive environments.
Blinn [3] described a technique to compute fast shadows of polyhedral objects onto a flat ground plane. The
shadow computation corresponds to the perspective projection of the object onto the plane as seen from the light
source. This formulation is very attractive as i t can be
written in terms of a standard perspective transformation
matrix. Although the algorithm is 'limited to planar surfaces, i t has the advantage of being very efficient and
simple to implement. However, this technique generates
correct shadows as long as the light source is located
above the object. As soon as the light source moves beneath a vertex of the underlying object, the corresponding
shadow vertex is clipped, producing abrupt changes in the
shadow object.
We follow the approach described in [ 3 ] as we are interested in generating dynamic shadows for Web environments. As we discuss in the following section, we propose a different formulation that allows the light sources
to move freely.
Although projecting shadows onto planar surfaces is
clearly an oversimplification of the general problem. it is
a big improvement compared to the way current VRML
worlds are constructed today. Currently, in most of thcse
worlds, shadows are cither not present, they are precomputed and static, or they are dynamic but hard coded
fora particular scene.

3.1. The shadow generation algorithm
Given a polygonal object with vertices Po, P I , ... Pn.,, a
point light source L and a plane, we compute the projection
of these vertices onto the plane from the point of view of
the light source. We calculate the intersection of the light
ray passing through each vertex and the plane to create another polygonal object with vertices P',,, P',, ... t",.,that
corresponds to the umbra, the portion of the shadow that
receives no light from the light source.

f

L

Figure 1. Intersection of ray and shadow plane
Let tis define a plane by its normal n^ and an arbitrary
point 4 on the plane. All the points p on that plane satisfy
the condition

ii . ( p - q ) = 0 .

Equation 1

Any point p on the line connectins the light source L and
a point P, can be written as

L+U(P, 4).

3. Approach
Shadows are created when an object blocks the rays
emitted by a light source. They can be generated by projecting the silhouette of one object onto another.
As we previously stated, we simplify the problem by
calculating the projection onto one or more planar surfaces. This restriction has the disadvantage that objects
would not cast shadows onto other objects unless the
polygons defining these later ones are specified as the
planar surfaces onto which shadows must be cast. However, this formulation has the advantage of providing
great user control, allowing the user to select the most
appropriate surfaces where shadows should be generated
according to the purpose of the animation. For example a
complex object may be defined to cast shadows onto the
floor and the walls while avoiding the object to cast shadows onto itself. In addition, the 'user can specify which

Equation 2

In order to find the intersection point bctwccn this line
and the planc, wc substitute p in Equation 1 by the point
defined by Equation 2 to obtain
11

=

'

o(q-L)

ii.(?-L)

.

Equation 3

The intersection point
Equation 4
P,' = L U (P, - L )
is then used as the coordinates of the corresponding shadow
vertex.
The algorithm becomes very simple. For each plane
and light source, we create a shadow object by duplicating
the original object and updating vertex coordinates accord-

+

596

ing to.Equation 4. However, there are a couple of special
cases that we need to pay special attention to.
One special case occurs when the denominator of
Equation 3 is greater than 0, meaning that the ray leaving
the light source and passing 1:hrough P; does not intersect
the given plane. Similarly, if the denominator is equal to
0, the light ray is parallel to the plane and there are no
solutions or the ray is on the plane in which case there are
an infinite number of solutions.
To solve this problem we propose using the following
heuristic. For any vertex fjwhose corresponding light ray
does not intersect the plane, we proceed as follows. For
each vertex Pj adjacent to Pi, we check whether the light
ray passing through Piintersects the plane (see Figure 2 ) .
If it does, then a new point f,,, is created to replace Pi
during the shadow computation. Otherwise, we proceed
to the next vertex Pi. After examining all these edges,
either a new point f,,*.was created or all the light rays
passing through the vertices Piadjacent to Pi fail to intersect the plane. In the first case, P : corresponds to the intersection of the shadow plane and the light ray passing
through the point Pnc,,. In the: later case, the vertex Pi can
be removed from the shadow computation.
The only question remaining is how to compute the
If we move the shadow plane in the dinew point f,,,,<.
rection of the normal until it liits the light source, we can
find the intersection point between the translated plane
Let us call this point Q. The point
and the edge

of the plane. In this case, for each edge having its vertices
on opposite sides of the plane, we compute the intersection
between this edge and the plane and use this intersection
point as the coordinate for the shadow node.
Finally, when the numerator is greater than 0 the light
source is under the plane and no further computation for
that light is required.

3.2. The VRML shadow node
We propose to extend VRML-97 with a node that generates dynamic shadows of IndexedFaceSet nodes. Below
we give the specification of this proposed shadow node.

shadow-node [
exposedField MFNode object []
exposedField MFNode shadowglanes []
exposedField MFNode shadow-lights []
eventln SFVec3f light-moved
eventln SFVec3f object-moved
eventln SFVec3f object-resized
eventln SFRotcition object-rotated
exposedField MFNode children [I
exposeclField SFVec3f translation 0 0 0
exposedField SFVec3f scale 1 I I
exposedField SFRotntion rotation 0 0 I 0

p,p,.

f,,, must then lie somewhere in the segment

I

E . The

The shadow node specifies the object geometry, the
planes and the light sources involved in the shadow computation. The object field is a grouping node composed of
possible nested IndexedFacedSets specifying the geometry
of the objects whose shadow must be computed. The
shadow-planes node defines the planes where the shadows
are to be projected while the shadow-lights specify the
light sources that can cast shadows.
The shadow object can receive four different kinds of
events that trigger a recomputation of the shadows on the
given planes. For example, a light source may move sending a light-moved event with its new position. Similarly
the object can rotate, change size, or move to a new location causing an object-rotated, an object-resized and an
object-moved event, respectively. As we will discuss in
the next section, these events are required to cause execution of the shadow calculation but the parameters passed arc
not actually used.
We implemented the shadow node as a PROTO in
VRML with a script node that performs all the shadow
computation in Java. Ideally though, the shadow computation should be performed inside the browser and in this
case, the shadow node interface would be defined as follows

precise ,location can be specified by a user-defined constant between 0 and 1 that indicates how distant from Q
the new point must lie. The smaller the constant, the
closer to Q the new point would be and the larger the
shadows we would obtain. This approach produces shadows that smoothly change as the light source moves
around the object.

//

'

J

/

Figure 2. Light ray does riot intersect the plane.
Another special case occurs when U < 1. This means
that the light source and the point P; are on different sides

597

whose vertices coordinate are generated using the projection defined by Equation 4. For example, the following
object defines a cube casting shadows on the ground plane.

shadow-node [
exposedField MFNode object []
exposedField MFNode shadowglanes []
exposedField MFNode shadow-lights [I

DEF Obj shadow-obj {
object (
children [
Shape (
appearance Appearance ( ... )
geometry newIndexedFaceSet (
coord Coordinate {
point [-.5 1 S, .5 1 .5, .5 1 - 5 -.5 1.5,
-.5 0 .5 , .5 0 .5 , .5 0 -.5, -.5 0-.5]

exposedField MFNode children []
exposedField SFVec3f translation 0 0 0
exposedField SFVec3f scale 1 I I
exposedField SFRotation rotation 0 0 I 0

I.
3.3. Implementation and VRML issues

1

Next we discuss some of the issues related to VRML
that we faced during our design and present the solutions
we found.
First, the above algorithm assumes that the vertex coordinates p,,, P , ...p,./ are defined with respect to a world
frame before we begin projecting the light rays into the
shadow planes. We compute these coordinates by travcrsing the object node and applying the appropriate transformations. Since this change of coordinate system is
also performed during the rendering pipeline, incorporating the shadows into the browser seems very appropriate.
Second, the shadow algorithm does not restrict the
number of lights that can cast shadows. When a light
source moves, i t is only the shadow cast by that light that
should be recomputed. However, in VRML we get an
event specifying that a light was moved to a new location
but there is no direct information regarding which light
this might be. Then, unless we test every light, we are
forced to recompute the shadows cast by all the light
sources. Similarly, if an object or part of an object
changes only the corresponding shadow should be recomputed, but again we have no information that would indicate what object triggered the event. However, all this
information is available to the browser.
Finally, we restrict our computation to polygonal objects whose geometry is defined using IndexFaceSet
nodes. The third problem we faced relates to a wellknown restriction of VRML; the coordIndex field in the
IndexFaceSet nodes is not fully exposed, these indices
can be set but they can not read [9]. Since we need access
to these indices for the shadow computation, we defined a
new node, which we called the NewIndexFaceSet. This
node mimics the IndexFaceSet node, but leaves the coordIndex field fully exposed. We added one extra Boolean
field that specifies whether a shadow for that node should
be computed to provide greater user control.
Modifying a standard VRML object to cast shadows is
very simple; the object geometry, the light sources and the
planar surfaces are defined using newIndexFaceSet,
shadow-lights and shadow-planes nodes respectively.
Each shadow is then created as an IndexFacedSet node

newindices [0, 1, 2, 3, -1,7, 6,5,4, -1,
0,4,5,1,-1,1,5,6,2,-1,
2,6,7, 3, -1, 3,7,4,0 I

I
1

1
I)

shadow-planes [
plane ( points

[-5 -3 IO, 5 -3 IO,
5 -3 -10, -5 -3 -101
indices [0, 1, 2, 31)

1
shadow-lights [USE light11

1
Incorporating the shadow computation into the browser
not only would avoid dealing with the issues discussed
above, but i t would also improve significantly the efficiency of the implementation.

4. Results
As discussed previously, shadows provide important
visual cues that help disambiguate the location of objects in
a 3D scene. For example, by looking at the scene shown
Figure3.a it may be difficult to answer the following questions: Is one box located higher than the other is’? Are the
boxes actually touching the floor’?Are the two boxes at the
same distance from the viewer’?

Figure 3. (a) Boxes without shadows. (b) Boxes
with shadows.

598

Figure 3.b shows the same 3D scene as Figure 3.a but
it includes the shadows that the two boxes cast on the
plane. Looking at this figurc we have a lot more information to answer the questions listed above. It is clear
from this figure that the box on the right is further away
from the user than the one or1 the left and that the box on
the left is actually touching the floor while the one on the
right is floating in space.
Figure 4 shows a cube having a different color on each
of its vertices. A shadow lay is drawn from the light
source passing through one of the object vertices and intersecting the shadow plane For testing purposes, the
shadow vertex, created at this intersection point, is colored with the same color as the corresponding vertex in
the original object. A sensor node is attached to the light
source to allow the user to interactively move the light in
the scene. The box is wrapped with a number of sensors
that allow us to translate, scale and rotate the object freely
while the shadows are updated in real time. As illustrated
by Figure 4, our implementation is not restricted to a single shadow plane.

Figure 5 shows a VRh4L model of a tree consisting of
12581 vertices and 23234 polygons'. The shadows cast by
the trees are computed at interactive rates while the user
moves the light source (represented by the small white
sphere) to simulate how the light changes throughout the
day. Figure 5 and Figure 6 illustrate the shadows cast by
trees during the summer and fall months, respectively.

Figure 4. Light ray and shadows cast into more
than one plane

Figure 6. Fall trees and their shadows at different
times of the day

Figure 5. Summer trees and their shadows at different time of the day

The interaction between light and form is a central element in art and architecture. Figure 7 presents an elegant
spiral staircase with its corresponding shadows. Note that
the shadow is cast in the floor as well as in the walls.

5. Applications
Besides greatly improving positional and depth perception, shadows arc important elements in a number of
applications. For example, energy efficient building design tries to minimize energy consumption by careful
evaluation of the building site, shape and orientation for
solar access [8]. Since sunshine is often desired during the
winter months but avoided (during the heat season, the
landscape must be carefully designed to cast shadows
during the summer months while allowing the sunshine to
pass once the leaves of planted shrubs drop to the ground.
Using shade effectively requires a study of the seasonal
changes as well as the sun position changes throughout
the day. The study of shadows is also important in landscape design since some pliints grow better under full
shadow while others require direct sunlight.

Figure 7. Shadows in architectural environments
I

The models used i n this paper are freely available from

htrp://www.3dcafe.com/

599

7. Acknowledgement

To further test our implementation, we downloaded a
freely available model of a hand. The model consisting of
1546 vertices and 2878 faces, was converted to VRML
and it was then augmented with a number of cylinder sensors to model each finger joint and their limits. Using this
hand, we created a number of virtual hand-shadows by
careful manipulation of the fingers (See Figures 8-9).

Many thanks to Rune Hjelsvold and Ken Hampel for
many fruitful discussions and valuable suggestions. The
author would also like to thank Arturo Pizano for his continuous support.

8. References
[ I ] Ames A.L.. D.R. Nadeau, J.L. Moreland. VRML 2.0 Sourcebook, 2nd Edition. John Wiley & Son, Inc.. 1997

[2] P.R. Atherton, K. Weiler, and D.P. Greenberg. "Polygon
shadow generation", Computer Graphics (SICGRAPH78 Proceedings), 12(3). Aug. 1978. pp. 275-281
[3] J. Blinn. "Me and my (fake) shadow", lEEE CG&A. 8( 1).
Jan. 1988, pp. 82-86.

[4] R.L. Cook. T. Porter and L. Carpenter, "Distributed Ray
Tracing", Coiiy~uterGraphics (SIGGRAPH8.I Proceedings), 18.
3, Jul. 1984, pp. 137-145.

Figure 8. Hand shadows (a) Rooster. (b) Dog.

151 F.C. Crow, "Shadow Algorithms for Computer Graphics".
Coinpiiter Grcipliics (SICGRAPH' 77 Proceedings). I 1 (2). p.p.
Jul. 1977. pp. 242-248

[6] E.A. Haines and D.P. Greenberg, "The light Buffer: A Ray
Tracer Shadow Testing Accelerator", IEEE C G U . 6(9). Sep.
1986, pp. 6-15.

[7] W.T. Reeves. D.H. Salesin, and R.L. Cook. "Rendering antialiased shadows with depth maps", COltl[JLikr G r q d i i a (SICGRAPH 87 Proceedings). 21(4). Jul. 1987. pp. 283-291.

Figure 9. Hand Shadows (a) Rabbit. (b) RainDear.

[8] R. Rogers. D. Nall. and D. Greenberg. "Computer graphics
input methods for building energy analysis". Cot~i~~iri~~r-Aitlt~d
D e s i ~ r9(3),
~ . July 1977, pp. 165--171.

6. Conclusions

[9] The Virtual Reality modeling language, International stan-

We discussed the importance of including shadows in
virtual reality applications and presented a solution that
permits dynamic shadow computation. Our approach is
restricted to polyhedral objects and planar surfaces. Although this is clcarly an oversimplitication of the gcneral
problem, our emphasis is on efficiency to achieve interactivity, which is essential for these applications. Our
approach permits a customizable design where the user
selects which objects should cast shadows based on their
importance or location in the scene, avoiding insignificant
details to take part in the shadow computation.
W e proposed a new node as an extension to VRML,
and presented a number of examples that demonstrate its
practicality. We defined the shadow node as a PROTO in
VRML where the shadow computation was incorporated
as a script node implemented in Java. We discussed some
of the issues particular to VFWL that we faced during our
implementation. Ideally, the shadow computation should
be performed by the browser during the rendering step.

dard-ISO/IEC/ 14772- 1 : I997

[IO] L.R. Wanger. J.A. Ferwerda. and D.P. Greenbcr,u, "Perceiving spatial rclationships in computer-penerated images". IEEE
CG&A. 12(3), May 1992. 44-58.
[ I I ] T. Whitted. "An improved illumination model for shaded
display", CACM. 23(6), June 1980. pp. 343-349.
[ 121 L. Williams, "Casting Curved Shadows on Curved Surfaces",
Cotiiprrter Grnpliics (Proceedings of SICGRAPH 78). I2 ( 3 ) . pp.

270-274.

600


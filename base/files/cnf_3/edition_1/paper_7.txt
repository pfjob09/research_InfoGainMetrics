2011 15th International Conference on Information Visualisation

Visualizing the Effects of Logically Combined Filters
Thomas Geymayer, Alexander Lex, Marc Streit, Dieter Schmalstieg
Institute for Computer Graphics and Vision
Graz University of Technology
Graz, Austria
tomgey@gmail.com, {lex,streit,schmalstieg}@icg.tugraz.at
It is common to use a combination of ﬁlters to continually
reﬁne the analysis result. In many cases, such combinations
are equivalent to logical operations [4], [5]. While a logical
AND is the most commonly used, other operations such as
OR, XOR and uNOT are feasible as well.
While the reduced data set itself becomes more manageable, the overall ﬁltering process and the individual effects
of ﬁlters on the data set becomes increasingly obfuscated.
To alleviate this, methods to visualize the combination of
applied ﬁlters have been developed. Hong Chen [6] for
example visualizes ﬁlters and other parameters of the visualization pipeline in a graph. However, to our knowledge,
there has not been any technique that conveys not only the
sequence of ﬁlters or brushes, but also the effects on the
data size. Inspired by Minard’s work, the famous Carte Figurative des pertes successives en hommes de l’arme franaise
dans la campagne de Russie 1812-1813 [7], which shows
the continuous reduction of men in Napoleon’s army during
his Russian campaign, we have developed a visualization
technique showing the effects of individual ﬁlters on a data
set.
Our primary contribution is an interactive visualization
technique for the effects of multiple ﬁlters, including the
effects of logical operators applied to combinations of ﬁlters.
This visualization technique enables users to understand the
effects of individual and combined ﬁlters. A secondary contribution is a general and detailed analysis of requirements
for visualizing multiple ﬁlters. Having these requirements at
hand, we demonstrate how the proposed technique satisﬁes
each of the speciﬁed requirements.

Abstract—Filtering data is an essential process in a drilldown analysis of large data sets. Filtering can be necessary for
several reasons. The main objective for ﬁlters is to uncover the
relevant subsets of a dataset. Another, equally relevant goal is to
reduce a dataset to dimensions to which either visualization or
algorithmic analysis techniques scale. However, with multiple
ﬁlters applied and possibly even logically combined, it becomes
difﬁcult for users to judge the effects of a ﬁlter chain. In this
paper we present a simple, yet effective way to interactively
visualize a sequence of ﬁlters and logical combinations of these.
Such a visualized ﬁlter-pipeline allows analysts to easily judge
the effect of every single ﬁlter and also their combination on
the data set under investigation and therefore, leads to a faster
and more efﬁcient workﬂow.
We also present an implementation of the proposed technique in an information visualization framework for the life
sciences. The technique, however, could be employed in many
other information visualization contexts as well.
Keywords-ﬁlter-pipeline, brushing, logical operations, interactive, data analysis, compound ﬁlter

I. I NTRODUCTION
Visualizing large amounts of data has been one of the
grand challenges of information visualization for over a
decade now. With ever more data being produced, the ability
to efﬁciently extract knowledge out of data becomes more
important. There are several ways to analyze large quantities
of data. Examples are aggregation or drill-down techniques,
focus and context methods, and so on. In the sense of visual
analytics [1], [2], visualization is combined with computational methods, such as machine learning or statistics.
However, in many cases, raw data has several undesired
attributes: parts of it can be redundant, noisy or irrelevant
for a given task. Also, most methods – either computational
or visual – do not scale arbitrarily. Fortunately, there is a
simple and yet effective method to reduce the data to a
manageable size: ﬁltering. Filtering allows parts of the data
to be removed, based on a given criteria. A ﬁlter can be
deﬁned visually or textually as a processing rule. Filters can
be based on fairly simple concepts, such as thresholds, or
on more complex processes, such as a statistical evaluation
of signiﬁcance. Related concepts are dynamic querying [3]
(selecting only a desired subset of a data set instead of
removing undesired parts) and to some extent, also brushing
(highlighting a subset of a data set).
1550-6037/11 $26.00 © 2011 IEEE
DOI 10.1109/IV.2011.52

II. R ELATED W ORK
Much of how we interact with large quantities of data
in visualization has its roots in the 1980s and early 1990s.
Becker proposed some basic principles for dynamic data
analysis [8], like linking & brushing – a technique that
is commonly used today. In 1992 Ahlberg et al. [3] conducted an experiment with dynamic queries performed on a
database with different combinations of graphical and textual
input and output, respectively. As the different parameters
used for the dynamic queries have the effect of reﬁning
the data set, this work is an early example of dynamically
adapted ﬁlters.
47

A common example is an initial ﬁlter that removes
noisy data. If such a ﬁlter removes a lot of data
items, the consequences of subsequently applied, ﬁnegrained ﬁlters become hard to perceive, due to the
small change relative to the initial ﬁlter. One solution
would be to use logarithmic scales for the amount of
data removed. However, as log scales are not intuitive,
we believe that the ability to hide ﬁlters is superior.
6) Show Filter Efﬁciency
When a ﬁlter is visualized in relation to a previous
ﬁlter, it is impossible to judge its effect on the global
data set, since only the effects on the already ﬁltered
data set is shown. To make a user understand the
consequences and the efﬁciency of a ﬁlter better,
an effective ﬁlter visualization technique should also
enable a user to see how much data a ﬁlter would
remove from the complete data set.

In 1995 Martin and Ward propose an improvement of
the XmdvTool which contains methods to combine multiple
brush operations with different logical operations [4].
A recent example of an approach of ﬁltering high dimensional data can be found in [9] where cross-ﬁltering across
multiple views is presented.
These works lay the foundation for modern visualization
systems which widely employ combined ﬁlters or brushes
to reﬁne data sets or selections. However, only very few
systems visualize these combinations in an explicit way.
One notable exception is the work by Hong Chen [6]
where node-link diagrams are used to visualize operations
like a brush or selections. He also employs combined nodes
which visualize logical or analytical operations. However,
while individual operations are visualized, the effects of the
operations on the data are not.
III. P ROBLEM A NALYSIS
Users often ﬁnd it hard to remember the steps conducted
to get a speciﬁc result [9]. To support analysts and reduce
the required cognitive load, we believe that an explicit
representation of the ﬁlter sequence helps to understand the
interdependencies between and consequences of ﬁlters. We
elicited the following main requirements for such a ﬁlterpipeline meta-visualization technique:
1) Show Sequence
As ﬁlters are typically applied sequentially, it is essential to show the ﬁlters in the sequence they were
applied.
2) Show Consequences
To allow a user to judge how much data is removed by
a ﬁlter, a ﬁlter visualization needs to show how many
elements a ﬁlter reduces.
3) Show and Create Compositions
A simple sequence of ﬁlters is equal to logical AND
operations (i.e., show all elements which are not
removed by ﬁlter X and ﬁlter Y). Other logical operations such as OR and XOR cannot be visualized as
easily. It is essential that such compositions are adequately represented in a dedicated ﬁlter visualization
technique.
In addition to the visualization of composed ﬁlters,
it should also be possible to create composed ﬁlters
based on pre-existing ﬁlters.
Aside from these main requirements for a ﬁlter visualization technique, there are several other requirements which
provide added beneﬁt to users:
4) Modify Filters
An interactive ﬁlter visualization technique should
enable a user to modify a ﬁlter (i.e., change its
parameters), to remove a ﬁlter and to move a ﬁlter
to another position in the sequence of ﬁlters.
5) Hide Filters
In some cases it may be desirable to hide ﬁlters.

In the following section we will describe how we address
each of these requirements and challenges to create a simple
and yet effective ﬁlter visualization technique.
IV. M ETHOD
Similar to the visualization of the reduction of men in
Napoleon’s army [7], we render each ﬁlter as a quadrilateral
where the left side represents the input and the right side the
output of the ﬁlter (see Figure 1). The size is chosen so that
the largest visible ﬁlter always ﬁlls the available height, and
the length is equally distributed over all visible ﬁlters. The
height of the left edge of the ﬁlter encodes the elements
going in, while the height of the right edge encodes the
elements going out of a ﬁlter. Consequently, the difference
in height (which is known to be the most powerful visual
variable [10]) as well as the slope of the top edge to allow
the user to easily judge the effect of the ﬁlter. To convey
a sense of absolute numbers, we also chose to show the
number of current elements and the number of elements each
ﬁlter removes from its input. This can be seen more easily
in ﬁgure 2.

Figure 1: Sequence of ﬁlters. The result is equivalent to a
logical AND operation of the ﬁlters.

48

A. Basic Sequence of Filters
We show a sequence of ﬁlters as an equivalent to the
logical AND operation, which simply concatenates one ﬁlter
after each other, such that the output of a ﬁlter is passed to
the next ﬁlter as input. This simple, yet effective method
satisﬁes Requirements 1 and 2.

no ﬁlter is completely occluded. The height on the left side
of each ﬁlter is the total input of the compound ﬁlter and
the height on the right side of each ﬁlter represents its
individual output. Additionally, in the background, the union
of all ﬁlters is rendered, visualizing the total inﬂuence of the
combined ﬁlters on the ﬁlter-pipeline. In our example, this
is the largest ﬁlter with the light yellow background.
It is also of interest to know which part of the input that
passes all ﬁlters, which is the intersection of all individual
sub-ﬁlter outputs (the result of an AND operation). We visualize this by adding another quadrilateral on top. According
to the characteristics of set intersection this will always
be the smallest quadrilateral (in Figure 2 it is rendered in
green). This information can also be confusing to the user
and misinterpreted as an additional ﬁlter. Thus, we only
show it if the user moves the mouse over the ﬁlter. This
allows him to detect inefﬁcient ﬁlters, i.e., ﬁlters that only
contribute few or even no elements, apart from the elements
also contributed by the other ﬁlters.
A problem with this approach is that it becomes cluttered
easily. We found that for as little as three ﬁlters, especially if
they are similar in terms of their efﬁciency, it is not easy to
distinguish individual ﬁlters. Furthermore, it discontinues the
ﬂow of the data through the ﬁlter-pipeline, as all sub-ﬁlters
have dead ends on their right sides without an equivalent at
the left side of the next ﬁlter. Consequently, we devised an
alternative method which addresses both issues.

B. Compound Filters
For more advanced ﬁlter-pipelines, combinations of multiple ﬁlters into a single ﬁlter can be necessary. We provide
the possibility to create meta-ﬁlters where all involved (sub)ﬁlters are combined in one ﬁlter in the sequence of toplevel ﬁlters. This can be achieved by dragging an existing
ﬁlter and dropping it onto another already created ﬁlter. The
whole meta-ﬁlter’s input data is passed to each sub-ﬁlter.
The output is then calculated based on the desired logical
operations – most commonly an OR.
In order to visualize this combination, we experimented
with two different approaches. One is to stack every involved
sub-ﬁlter on top of each other (by means of a virtual z-axis
orthogonal to the page) and embed this stacking into the
overall meta-ﬁlter. Alternatively, we embed all sub-ﬁlters in
the top-level meta ﬁlter without overlaps. In the following,
we will brieﬂy discuss the advantages and disadvantages of
each method.

Figure 2: Two ﬁlters combined with logical OR, both subﬁlters stacked over each other. The largest ﬁlter with the
light yellow background is the resulting ﬁlter (A|B), the
purple and red ﬁlter are the combined sub-ﬁlters (just A
or just B) and the green ﬁlter on top of all ﬁlters represents
the intersection of the elements ﬁltered by both sub-ﬁlters
(A&B).

Figure 3: Two ﬁlters (labeled with A and B) combined
with logical OR, visualized in parallel. The large ﬁlter in
the background, rendered in light yellow, is the resulting
ﬁlter. The left edge of the resulting ﬁlter is connected with
the sub-ﬁlters using curved surface. On the right side, all
intersections between the elements that are passed to at least
one of the sub-ﬁlters are visualized – elements contributed
only by ﬁlter A (A&!B), elements contributed only by ﬁlter
B (B&!A), and elements contributed by both, ﬁlter A and B
(A&B).

Stacked Sub-Filters: As each sub-ﬁlter of the combined
ﬁlter receives the same input, it is intuitive to render all
sub-ﬁlters on top of each other at the same location (see
Figure 2). The ﬁlters are sorted from top to bottom, where
the topmost sub-ﬁlter (in our example rendered with a purple
color) is the least effective one (the one that removes the
least elements from the input data), thus guaranteeing that

49

Separate Sub-Filters: As the sub-ﬁlters in a compound
ﬁlter operate in parallel (contrary to the sequence of ﬁlters
on the top-level), we considered also expressing this property
in the visualization technique. Consequently, we render the
sub-ﬁlters at a smaller scale in parallel inside the resulting
compound ﬁlter. To provide a continuous ﬂow of the data
through the ﬁlter-pipeline, we connect the input of the
compound ﬁlter to each sub-ﬁlter using curved shapes (see
Figure 3). The shapes use the same color as the respective
sub-ﬁlters, with transparency increased to allow a user to
see the overlapping regions. Inspired by Kosara et al.’s work
on categorical data visualization [11], we then calculate all
possible intersections between the contributed elements of
every sub-ﬁlter. Consequently, for a composition of two
ﬁlters, if the underlying operation is an OR, there are two
categories of elements: Those which are contributed by only
one sub-ﬁlter, and those that are contributed by both. We
render each set with a trapezoid using the same color as we
did for the incoming surfaces (see Figure 3). To make the
relative size of the set intersections more obvious, we use
the space right of the ﬁlter to show the set sizes in detail.
Moving the mouse over an intersection shows which ﬁlters
are intersected for this sub-set.
With the technique of using separate sub-ﬁlters embedded
in a meta-ﬁlter, we have successfully addressed Requirement
3.

If at least one ﬁlter is hidden, we show a button on the left
margin to again display the hidden ﬁlters.

(a) Large ﬁlter followed by two small ﬁlters.

(b) The same pipeline but with the ﬁrst ﬁlter hidden.

Figure 4: Hiding ﬁlters: By pressing the arrow button below
the ﬁlter, the ﬁlter and all ﬁlters left of it are hidden. The
example shown reduces the visible pipeline to only two
ﬁlters which are scaled to the whole available height, as
depicted in the lower image. Notice that the relative changes
and the composition of the compound ﬁlter are much more
visible when compared to the upper ﬁgure. By clicking on
the button on the left border, the hidden ﬁlter can be made
visible again.

C. Modifying Filters
The described ﬁlter visualization lends itself to allow
interaction with the ﬁlters themselves. As discussed in
Requirement 4, the essential operations are: modify, remove
and move. We provide intuitive access to those features, for
example by drag and drop for moving ﬁlters, or by double
clicking on a ﬁlter for modifying it.

D. Hiding Filters
E. Show Filter Efﬁciency

We have already discussed the issue of combinations of
strong ﬁlters that initially remove large portions of the data,
and more sensitive, reﬁning ﬁlters that remove only smaller
parts (see Section III, Requirement 5). Another issue, aside
from the inability to perceive the effects of ﬁlters removing
only a view elements, is the fact that composed meta-ﬁlters
containing several sub-ﬁlters are hard to see because of
the tiny amount of space available. These problems are
illustrated in Figure 4. As a solution to this problem, we
provide the possibility to hide a number of ﬁlters at the
front of the ﬁlter-pipeline. This way, the remaining ﬁlters
can be scaled up to the whole height, which makes their
subtle effects on the ﬁlter-pipeline, as well as the embedded
ﬁlters visible again. The effect is shown in Figure 4.
Below each ﬁlter, there is a button that enables the analyst
to hide all ﬁlters from the front up to the corresponding ﬁlter.

As every ﬁlter in the pipeline gets the output of its
preceding ﬁlter, the amount of elements ﬁltered is smaller (in
most cases) than if it were applied on the whole input data
set. However, as discussed in Section III, Requirement 6, it
can be useful to get an idea on how the ﬁlter would behave
if it were applied to the whole data set. This, for example,
is desirable when the data is ﬁltered to meet a pre-condition
for a feasible runtime of a given algorithm. In such a case,
a user can apply different ﬁlters at the same time, and judge
whether he could meet the requirements with fewer ﬁlters.
We address this challenge by overlaying an transparent
version of the ﬁlter, showing its size as if it was the only
ﬁlter in the pipeline, on mouse over. This is shown in Figure
5.

50

Figure 5: When hovering over the ﬁlter, its full size is shown
in the background.
Having fulﬁlled all of the elicited requirements, we will
now discuss how the described visualization technique is
embedded in an information visualization framework, and
give some examples on how the ﬁlter-pipeline is used.

Figure 6: Example of using Caleydo with the described ﬁlterpipeline view opened in the bottom right part of the window.
VI. I MPLEMENTATION D ETAILS

V. V ISUALIZATION E NVIRONMENT

The Caleydo visualization framework [12] is written in
Java and is based on the Eclipse Rich Client Platform
(RCP)2 . The framework is designed in a modular manner
where a minimal core contains integral parts, such as the
data management, the event system, etc.. Everything else is
outsourced into separate and completely independent plugins which communicate with each other by using the core’s
message-based event mechanism.
Each view can either use the Standard Widget Toolkit
(SWT)3 to create a user-interface by using the default
widgets provided by the operating system, or for graphically
more advanced or three dimensional user-interfaces use the
OpenGL API provided by the Java Bindings for OpenGL
(JOGL)4 .
In order to synchronize all views, the data set containing
the data to by analyzed is stored centrally, so that each view
can access it. View changes are handled ﬁrst by the view
under interaction itself and then propagated to all other views
which in turn update their visualization based on the new
context.
The statistical ﬁlters use the R statistics toolkit [14]
for calculating the ﬁlter elements which are added to the
corresponding list.

The ﬁlter-pipeline view is a part of the Caleydo visualization framework1 [12], developed at our institute. It is intended to be used for the analysis of large data sets from the
life science domain, more speciﬁcally genetic and clinical
data. Its multiple coordinated view system provides different
ways to explore the loaded data set. For example, to explore
gene expression data parallel coordinates, a hierarchical heat
map, scatterplots and many further views are available.
As the initially loaded data sets in this domain are often
very large, different types of ﬁlters are usually applied to
reduce the size of the viewed data set, which is especially
relevant to enable manual analysis performed by the user.
The different views support various ways of brushing and
consequently ﬁltering data. In parallel coordinates it is
possible to ﬁlter data where the gene expression values
never leave a given interval and therefore, for example ﬁlter
genes that are neither over- nor underexpressed. Another
possibility to create a ﬁlter is to use the angular brush [13]
which removes experiments with a deviation exceeding a
visually speciﬁed threshold from the gene expression value
of the selected gene of a speciﬁc experiment.
Caleydo also provides computational ﬁlters commonly
used in gene expression analysis. One example is the foldchange ﬁlter that removes all elements which change less
than a speciﬁed n-fold change to a reference experiment.
Other examples are statistical variance tests, which ensure
that outliers within control groups, which may be the result
of errors in measurement, are removed.
The described ﬁlter-pipeline is used in Caleydo to convey
the effects of complex combinations of ﬁlters. A typical
scenario is shown in Figure 6.

VII. C ONCLUSIONS AND F UTURE W ORK
As the amount of data to be analyzed is constantly growing, ﬁltering it is a crucial part in the processing pipeline.
Therefore, it is important that an analyst is supported in
understanding complex sequences as well as compositions
of ﬁlters. Visualization of those ﬁlters in the proposed
ﬁlter-pipeline is an ideal tool for this task. It allows us
2 http://www.eclipse.org/home/categories/rcp.php
3 http://www.eclipse.org/swt/

1 http://www.caleydo.org

4 http://jogamp.org/jogl/www/

51

52


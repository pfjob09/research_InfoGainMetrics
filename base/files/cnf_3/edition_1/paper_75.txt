2011 15th International Conference on Information Visualisation

Edge routing and bundling for graphs with ﬁxed node positions
ˇ
Miroslav Cerm´
ak, Jiˇr´ı Dokulil
Department of Software Engineering
Charles University
Prague, Czech Republic
(cermak,dokulil)@ksi.mff.cuni.cz

Jana Katreniakov´a
Department of Computer Science
Comenius University
Bratislava, Slovakia
katreniakova@dcs.fmph.uniba.sk

fast edge drawing with nodes drawn as rectangles, ideally
allowing for real-time updating of the drawing while the user
changes position of a node (or multiple nodes). The intended
application of the algorithm is software like visual database
schema designers [4] or UML modeling tools [5]. Such
applications allow the user to position nodes (tables, UML
classes, etc.) and connect them with edges. This lets the user
place the nodes so that it suits his or her needs, for example
to group them according to the subset of the problem they
are related to. However, choosing the correct path for the
edges is also often left to the users, which is a tedious task
but the users usually do not put any semantics into the way
the edges are routed – they only want to make the drawing
clear and potentially aesthetically pleasing. Quite often, they
just make sure that the edges do not cross any nodes along
their path, which is a necessity [6].
These factors make the task an ideal opportunity for
graph drawing techniques. It also provides us with a set of
limitations and guidelines for creating a good algorithm. On
one hand, it tells us what will the data look like, on the other
hand, it provides us with the possibility to better evaluate the
results by relating them to the speciﬁc real-world scenario.
Measuring usability by performance on application speciﬁc
tasks has already been successfully tried, for example by
Purchase [7].
The rest of the text is organized as follows. First, in the
Section II, we brieﬂy describe the edge routing algorithm
that our solution is based on and our modiﬁcations to the
algorithm. The Section III describes our contribution – the
edge bundling algorithms that we have designed on top of
the edge routing algorithm. The ways in which we have
evaluated the algorithms are described in the Section IV.
Finally, the Section V concludes the text.

Abstract—In some graph drawing scenarios, the positions
of the nodes are already deﬁned and cannot be modiﬁed
(for example, they were provided by the user) and the graph
drawing techniques are only used to draw edges between the
nodes. The number of nodes in such cases tends to be relatively
small (tens or hundreds of nodes at most) however the users
want to see all of the edges. Various edge routing techniques
can provide such services, but if the graph is dense, the drawing
can get rather hard to read due to the high number of lines
required to visualize the edges. In such cases, clarity can be
improved by bundling individual edges (more precisely parts
of their drawing) into larger groups and draw as a single line.
In this paper, we provide several different techniques for edge
bundling based on an edge routing algorithm, compare and
evaluate them.
Keywords-edge routing; edge bundling

I. I NTRODUCTION
There are applications for graph drawing techniques that
do not allow the nodes to be repositioned. The most common
reason for this limitation is that the nodes were positioned
by the user to the locations where he or she wants them, so
moving them around is out of question. If this is the case,
the graph drawing is only called upon to handle drawing of
the edges that connect the nodes. This rules out many graph
drawing algorithms since they handle drawing of nodes and
edges simultaneously – they position the nodes so that the
edges can be nicely drawn between the nodes. Furthermore,
the arbitrary positioning of the nodes may rule out even more
algorithms, since the node positions may not be suitable for
some edge drawing algorithms – for example the edges may
not be positioned on layers. A common way of tackling the
problem is to use some kind of edge-routing algorithm [1],
[2], [3].
While these algorithms prevent edges from crossing the
nodes, thus providing theoretically sound solution to the
problem, the readability of such drawings can still be improved. One way of reducing the visual clutter created by
routing many edges through a limited space is to use edge
bundling. These techniques join some of the lines into larger
bundles, thus cleaning up the drawing.
In the following text, we propose one such algorithm. It
is an extension of an existing edge routing algorithm. It is
aimed at relatively small graphs, where it should provide
1550-6037/11 $26.00 © 2011 IEEE
DOI 10.1109/IV.2011.47

II. E DGE ROUTING ALGORITHM
In [2] we have proposed an algorithm for edge routing
for ﬁxed nodes positions in cases where the nodes do not
overlap. The basic idea of the algorithm is quite straightforward. It starts by drawing the edge as a direct line between
the source node and the destination node. Then it reroutes
the line (creates a polyline in several steps where in each
step it splits one segment of the polyline into two connected
475

on both sides (incoming and outgoing) and takes the order
of angles from the side that has higher number of distinct
values. This order is the ﬁnal ordering of the lines at the
corner.
As we were still not completely satisﬁed with the results,
we have also added a line snatching feature to our corner
handling algorithm. If there is a line passing close to the
corner but without bending there, we add a new bend to the
line at the corner and add it to the lines that are handled
by the algorithm. This improved the drawings since such
lines were often obscuring the tightly packed lines bending
around a corner.

segments) away from the nodes that intersect with the line.
The algorithm does not alter the positions of the nodes and
it is therefore possible to use it in conjunction with any
node placement algorithm, or even in situations where the
nodes are positioned by the user. Another advantage of the
algorithm (the one we rely on heavily in our work) is the
fact, that it only works locally with just one edge and is
even able to process a line that connects arbitrary points in
the drawing, not only lines that connect two nodes.
Let us brieﬂy describe the way the algorithm works, since
it may help the reader understand the rest of the paper
and the drawings produced by our software. It starts with
a straight line that connects two nodes. The algorithm then
ﬁnds a node that intersects the line (there can be more of
them, in which case any one of them can be used) and then
reroutes the line so that it avoids the node by splitting the
line – it adds a new “bend” and forms a polyline with two
segments. The bend is positioned at one of the corners of
the intersecting node. Which corner exactly is determined by
a heuristic algorithm that attempts to ﬁnd a locally optimal
solution that provides the best chance of making the line
completely avoid the node. Still, in some cases, splitting the
line into two parts is not sufﬁcient to completely avoid the
node. In that case, the algorithm determines the best partial
solution and the rerouting is completed in a subsequent
iteration of the same algorithm. In any case, the algorithm
is iterated until all crossings are eliminated.
One drawback of this solution is that it may create
unnecessary bends on the line. For example, when the line is
rerouted to avoid node a it bends around one of the corners
of a. It may then be further rerouted to avoid node b, but this
subsequent rerouting takes the line so far that it would avoid
a anyway. Then it is unnecessarily bent near a. To avoid
such situations, the line is straightened after the rerouting is
complete. This means that each bend is tested, whether it is
necessary and it is removed if it is not (if the line would
still avoid all nodes even without the bend).
This way, the algorithm reroutes all edges so that they
avoid all nodes. However, if more lines were bent around the
same corner, they would pass the same spot and even bend
there, which would make them impossible to distinguish. For
that reason, these lines are then ordered according to another
local optimization function and then placed at increasing
distances from the corner. The optimization function tries to
(locally) minimize the number of line crossings created by
this step. For an example, see the Figure 1.
The optimization function used to order the lines used
by our edge bundling algorithms is different from the one
originally proposed (in [2]). Based on our experience and
the images produced by our implementation, we decided
to use a more simple, but much faster algorithm that also
considers the angles at which the lines approach and leave
the corner, but it uses a simpler algorithm to convert it to
the ﬁnal ordering. It checks the number of distinct angles

III. B UNDLING OF E DGES
The main idea behind edge bundling is to remove visual
clutter in a drawing of a graph by partially reducing the
number of distinct lines in the drawing by changing the
drawing of the lines so that some of them follow the
same path for a certain distance. The bundling effect is
usually expressed visually by drawing the bundled portion
as a thicker line, usually in proportion (logarithmic) to the
number of lines that have been rerouted to follow that path
[8], [9].
In the following text, we assume that all edges are drawn
as polylines that consist of one or more connected segments.
A bundle is a set of polylines that all share one or more
segments, i.e., there is a segment s such that each polyline in
the bundle contains a segment whose endpoints have exactly
the same coordinates as s or s reversed (start- and end-points
interchanged).
One of the requirements for the bundling algorithm is that
all information has to be preserved, which means that the
edges may not be bundled in such a way that the user will not
be able to identify which edges were originally connected
and which were not connected. An example of such situation
is a double sided fork. There is no way of telling whether the
top node on the left side is connected to the top or bottom
node on the right side.
For this reason, we only do one-sided bundling. This
means, that for any bundle b, all nodes of the bundle share
a segment s where one of the endpoints of s is a node n.
We call the node n the root of the bundle b. Furthermore,
if any two polylines p1 and p2 share segments s1 , . . . , sn ,
these segments form a continuous line starting at n. In other
words, once a polyline splits from the bundle, it may not join
it again further along its path.
First, the graph is drawn without any bundling, only using
the edge routing algorithm described in the previous section.
This provides us with basic information on the directions in
which the polylines that correspond to the edges of the graph
should lead. Then we modify the drawing by bundling some
of the edges.
Because we assume that the scenarios we target provide
high chance of “central nodes” (nodes with high degree

476

(a) Before Rerouting

(b) Non-distinguishable edges
Figure 1.

(c) Ordered edges

(d) Wrong order of edges

More edges passing the same corner

direction and distance for the ﬁrst segment in the bundle.
However, such segment may cross a node (different from
n), which is not acceptable. For this reason, we ﬁnd df inal ,
which is the maximum distance that is less than dmin and
which prevents the segment of such length (that leaves n in
direction aavg ) from crossing any node (other than n). We
denote x the point that lies df inal distance away from n in
the direction aavg .
Then, we replace all polylines li with new ones, that are
formed by two sets of segments: the segment that connects
n to x (the bundled segment) and the polyline from x to the
original endpoint end(li , n) of li . This polyline is created by
applying edge routing algorithm to a straight segment that
connects x to end(li , n).
This would only create bundles with one bundled segment.
To create longer bundles, the algorithm is then repeated on
a slightly different input:
• point x is used instead of node n
• edges from the bundled group (i.e., those that have been
just bundled and their drawings pass the point x) are
considered to be the edges adjacent to the point x
• the bundled segment connecting n and x is not considered to be part of the polylines that represent the edges
in further steps of the algorithm.
In other words, the algorithm is then run as if we added
a new node to the position of x and split all edges from the
group at that point.

and high importance to the user), we start the bundling by
selecting a node with the highest degree. If there are more
such nodes, we pick one in such a way that on subsequent
runs of the algorithm on the same data the same node is
selected. In our implementation, we select the node with the
lowest identiﬁer (a number assigned to each node for easier
manipulation). Then, we perform a local bundling steps. This
is one of the algorithms described in the following sections
that processes only edges incident to the selected node and
tries to bundle them. This of course only creates bundles
rooted at the selected node.
After bundling, we remove all edges that have been bundled from further bundling (to facilitate one-sided bundling)
and also remove the selected node from the list of possible
starting nodes. Then we repeat the algorithm until no more
starting nodes are available. This means that we execute N
iterations of the local bundling algorithm where N is the
number of nodes in the graph.
A. Direction of the ﬁrst segment
The ﬁrst algorithm (referred to as “ﬁxed-angle” in the
rest of the text) is very straightforward. The area around
the starting node n is split into k regions r1 , . . . , rk . The
value k is a constant speciﬁed at the start of bundling. Each
region ri is deﬁned by angles ai and bi . Then ri contains
all points whose angle in polar coordinates centered in n is
in the half-closed interval [ai , bi ). The angles are deﬁned so
that they split the whole angle into equal slices, i.e. a1 = 0,
bk = 2 ∗ Π, a(i+1) = bi , and bi − ai = 2∗Π
k .
Then the polylines that correspond to the edges incident
to the current node n are divided into k groups. Each group
gi contains polylines l1 , . . . , l|gi | such that for each of the
polylines, the segment closest to the current node (denoted
start(li , n)) lies in ri . Since the segments are straight and
start in the origin of the polar coordinate system we are using
to divide them into groups, inner points of each segments
lie in the same region as well as the opposite endpoint.
All polylines in a group are bundled into one bundle. To
do so, we ﬁrst need to ﬁnd a good representation for the
bundle in the drawing. We compute the average angle aavg
of all angles in which the starting segments start(li , n) leave
the node n. Then we compute the minimum of the lengths
of segments start(li , n), denoted dmin . This is the intended

B. Variable angle
The “variable-angle” algorithm is a modiﬁcation of the
ﬁrst algorithm. It only changes the way polylines are split
into groups. The difference is that the number of groups
is not a pre-deﬁned constant. Instead, it is determined each
time polylines are split int groups. First, a critical angle
is determined. The process is iterative and starts with the
value of Π/2. The system then checks whether the maximal
angle between any two adjacent segments from start(li , n)
is larger than the critical angle. If not, the critical angle is
halved and the process is repeated until a suitable angle is
found.
After the critical angle is found, polylines are grouped
into groups like this:

477

1) Find a gap large enough to contain the critical angle.
Set the end of the gap as the current position.
2) Take the ﬁrst segment s1 after the current position
and all other segments si such that s1 and si form
an angle that is smaller than the critical angle. Create
a new group which consists of polylines that contain
these segments. Set current position to the end of the
group.
3) If there are ungrouped polylines, goto 2.
The idea behind this algorithm is to provide high number
of groups for nodes that have edges leaving in all directions.
Otherwise, smaller groups (larger critical angle) is used.

No bundling
Fixed angle
First bend
Variable angle
Clustering

G1
3,03
3,18
3,23
2,96
2,47

G2
2,15
3,02
2,14
3,21
2,62

G3
3,36
3,12
3,29
3,18
2,40

Table I
W EB SURVEY RESULTS – AVERAGE RATING FOR DIFFERENT GRAPHS

cluster. This creates a polyline m. Then we only take the
part of the polyline that is outside the bounding box (denoted
m ). The end of the polyline is the point x.
The polyline for each edge is obtained by concatenating
m and the polyline created by applying the edge routing
algorithm to the line from x to the destination of the edge
(the node connected to the starting node by the edge).
An example of the result is shown in the Figure 2.

C. First bend
The “ﬁrst-bend” variant is yet another variant of the ﬁrst
algorithm. In this case, a group is formed by the polylines
whose ﬁrst bend (the end of the segment start(li , n)) is at
the same position.

IV. E VALUATION

D. Routing to node clusters

We have evaluated the algorithms proposed in the Section
III in three ways. To quickly get some basic feedback from
a large group of users, we posted an online survey where
the visitors could rate drawings produced by the individual
algorithms. To get a more detailed results, we also performed
a user study in a controlled environment. The last set of
results was obtained by measuring objective criteria like
number of edge crossings.
We have focused more on the ﬁrst two ways of evaluation
the algorithms, since they are currently believed to be better
for assessing the readability of graph drawing techniques.
As an illustration, in [10] authors state that commonly used
graph drawing aesthetic criteria (as listed for example in
[11]) are not based on experimental data.

A different approach to edge bundling is based on node
clustering. Instead of making a decision only based on
the direction in which the polylines leave the origin and
then iterating the algorithm to create longer bundles, this
approach ﬁrst determines the point where the bundle splits
and them creates the path to and from that point.
However, it keeps the basic structure of repeatedly selecting the node with the highest degree, bundling adjacent
edges and removing the starting node and bundled edges
from further processing. The difference is in the way the
adjacent edges are bundled.
First, the nodes connected to the starting node are clustered according to their position on the plane. The clustering
algorithm works like this:
1) For each node, create a cluster that contains only that
node. The center of that cluster is the position of the
node.
2) Find two clusters c1 and c2 whose centers are closest
to each other.
3) Create new cluster cn by joining c1 and c2 . The center
of the cluster is obtained by averaging the coordinates
of the nodes in the cluster.
4) Remove clusters c1 and c2 .
5) If the minimal distance between centers of any two
clusters is below a speciﬁed threshold, goto 2.
The threshold speciﬁed in the last step is computed from
the dimensions of the area occupied by the nodes adjacent
to the center. At the moment, we are using one quarter of
either width or height of the area, depending on which is
larger.
Each cluster is then processed individually. First, we ﬁnd
a bounding box for each cluster. Then, we ﬁnd a route to
the cluster by applying the edge routing algorithm to a line
connecting the starting node to the bounding box of the

A. Web survey
The online survey was intentionally simple, requiring the
visitors to spend only a few minutes (the average time was
5 minutes). It consisted of three sets of ﬁve images. Each
set was a drawing of the same graph, but created using the
ﬁve possible bundling algorithms (four from section III and
no bundling at all). All images from the set were presented
to the user along each other (but in a random order) and the
user was requested to rate them on a 1 to 5 scale, with 1
being the best and 5 being the worst. The aggregate result
may be sen in the Table I. Columns labeled G1, G2, and G3
show the results for each of the three different graphs used
in the survey.
When the survey ended we had nearly 120 responses. The
actual number ranges from 110 to 118 for the individual
images, since not everyone rated all of them.
The results are similar for G1 and G3, but not so with the
G2 graph. It was a small and relatively simple graph with
10 nodes and 20 edges. With this graph, the users clearly
preferred the version without any bundling. This is not as

478

Figure 2.

Example of clustering-based edge bundling

surprising, since in such a small graph it is easily possible
to track each individual edge even without bundling. The
“ﬁrst bend” algorithm performed just as well, but it is due
to the fact, that it was not able to create any bundles, thus
producing the same graph as the no-bundling version. The
clustering-based algorithm also scored quite well, but again,
it was only able to create two bundles. The other two (ﬁxed
and variable angle ﬁrst segment bundling) did create more
bundles (about twice as much), but scored badly.
The G1 and G3 graphs were much larger (both contained
50 nodes and 40 edges). In these cases, all options reached
similar scores, except for the clustering-based algorithm
which reached signiﬁcantly better scores for both graphs.

No bundling
Fixed angle
First bend
Variable angle
Clustering
U SER

type 1
96.2%
95.3%
97.5%
92.4%
97.0%

type 2
99.0%
98.4%
99.2%
98.5%
99.6%

type 1
2.77s
3.88s
3.97s
4.34s
3.88s

type 2
0.25s
0.32s
0.22s
0.27s
0.20s

Table II
– ACCURACY AND TIME

STUDY RESULTS

2) One of the nodes was displayed in a clearly visible
color (different from the colors used in the other task
type). The user was asked to mark (click) all nodes
directly connected to the highlighted node and then
click the Done button.

B. User study

The type of each task was also selected at random, but
the probability of the ﬁrst task type was 80%, leaving 20%
chance for the second type. This ratio was chosen to reduce
the time required by the test, since the second task type is
signiﬁcantly more time consuming. Since the tasks are very
repetitive, we wanted to keep the total time of the test low.
With this setup, one test took about 10 minutes (plus the
brieﬁng and debrieﬁng).
The average results are displayed in the Table II. The ﬁrst
two columns show the accuracy with which the users picked
the Yes/No answer correctly (task type 1) and the accuracy
with which they picked the right nodes (task type 2). The
second two columns show the time elapsed before the user
clicked the Yes or No button (task type 1) and the average
time it took the user to select a single node (task type 2).
The results suggest that it is best to use no bundling at all
for determining whether two nodes are connected (it is a bit

For the “ofﬂine” user study, we asked the users to come
to us and perform a test on our computers under our
supervision. First, each user was individually briefed on the
tasks to complete, then a series of 100 tasks was performed
by the user uninterrupted. Each task displayed a new random
graph with the same properties (50 nodes, 40 edges) where
edges were bundled by an algorithm chosen randomly from
the same ﬁve possibilities as in the online survey.
Purchase [12], [13] and Ware [14] used evaluation based
on the response time and correctness rate and we decided to
follow in their footsteps. For this reason, we faced the user
with the following two types of tasks, mixed at random:
1) Two nodes of the graph were displayed in a clearly
visible color and the user was asked to determine if
the two nodes are directly connected by an edge. The
answer was given by clicking Yes or No button.

479

less accurate, but much faster), but clustering seems to be
the best choice for the second task type (it is both faster and
more accurate). Still, the no-bundling solution also provides
decent performance.

No bundling
Fixed angle
First bend
Variable angle
Clustering

C. Measurements without user involvement
Another set of tests we have performed to evaluate different bundling methods is measuring some objective properties
of the drawings.
The ﬁrst, most obvious, criterion is the number of edge
crossings in the drawing. An important factor to note that
if a line crosses a bundled segment, we only count is
as one crossing, not the number equal to the number of
bundled edges. As a result of this, the number of edge
crossings is signiﬁcantly reduced when bundling is used,
since there are fewer lines to cross. This means that there
are fewer occurences of two lines crossing each other in
the produced drawing but not necessarily a lower number of
edge crossings from the formal point of view.
There is no bundling method that clearly outperforms the
other methods under all circumstances. The average values
for 10 graphs with 50 nodes and 100 edges are shown in
the Table III. The number of crossings may seem high, but
it is a very dense graph.
Another measure we explored was the reduction of the
total length of all polylines used in the drawing. As Ware
states [14], this is one of the most important edge drawing
criteria (along with the number of crossings and continuity),
but it is often overlooked. Our rationale for including the
criterion is, that we want to make the drawing as clear as
possible and the lines are what makes it more difﬁcult to
read. Thus reducing the space taken by the lines should
help. We cannot reduce the number of the lines, due to the
requirement that all information has to be preserved – the
number of lines has to stay equal to the number of edges.
We can only make the lines occupy less space by making
them shorter or bundling them.
Once again, no algorithm was able to come out best in
all tests, but all of them managed to provide signiﬁcant
reduction of the total line length, except for the ﬁrst-bend
bundling algorithm, which consistently provided the worst
results, some times being able to reduce the length only by
less then 10%. The rest of the algorithm was able to provide
between 20% and 45% reduction of the total line length. The
average values are once again shown in the Table III.
Furthermore, we assessed the size of the maximal bundle.
These test showed us some clear trends: not surprisingly,
the ﬁrst-bend algorithm produced the smallest bundles.
But more interesting were the results of the cluster-based
bundling, which creates smaller (maximal) bundles than
ﬁxed- and variable- angle bundling. This may not necessarily
be a negative result for the cluster-based bundling but we
think it is an interesting observation. Again, for the average
value of the maximal bundle size, refer to the Table III.

number of
crossings
1935
775
1065
747
818

length
reduction
0%
35%
21%
38%
40%

maximal
bundle
1
21.2
8.8
23.3
12.2

Table III
O BJECTIVE CRITERIA – NUMBER OF CROSSINGS ,

LENGTH REDUCTION
AND SIZE OF THE MAXIMAL BUNDLE

No bundling
Fixed angle
First bend
Variable angle
Clustering

min
0.1 ˚
0.24 ˚
0.22 ˚
0.22 ˚
0.24 ˚

2˚
58.5
11.2
18.2
10.9
11.1

5˚
68.8
14.7
27.9
14.0
14.9

10 ˚
86.3
20.8
44.3
19.0
21.5

Table IV
C RITERIA BASED ON ANGULAR RESOLUTION

The last set of criteria are concerned with the angular
resolution, i.e. the minimal angle between two segments that
leave a certain node. We measured the exact value of the
angle, but also counted the number of situations where two
neighboring segments form an angle smaller than a speciﬁed
threshold. In other words, the number of situations, where
the angle between lines that leave a node is small and it may
be difﬁcult to clearly distinguish them. The values of the
minimal angle are not very encouraging, since it is usually
well below one degree, but they are usually improved when
edge bundling is used.
The angular resolution shows no clear trends that would
differentiate the various bundling algorithms. However, the
statistics that show the number of segment pairs that form
angle smaller then a threshold do provide more interesting
reading. In all of the test that we performed, the numbers
decreased signiﬁcantly for all bundling algorithms and all
three values of threshold (2, 5 and 10 degrees). Once again,
the ﬁrst-bend bundling consistently scored last, with the
other three techniques providing very similar results, usually
reducing the numbers by about three quarters. The result for
the same data sets as in previous cases are shown in the Table
IV.
The last metric we tested was the time required to
generate the drawing. The Table V shows times taken by
the algorithms on graphs with varying number of nodes
and edges (10 nodes – 20 edges, 50 nodes – 100 edges,
200 nodes – 1000 edges). For small graphs (10 nodes, 10
edges), the time required by all the algorithms was less than
15 milliseconds. For slightly larger (50 nodes, 40 edges)
the times ranged from 20 to 60 milliseconds, with the ﬁrstbend bundling being by far the fastest bundling algorithm,
and variable-angle bundling ﬁnishing last, but only slightly
slower than the ﬁxed-angle bundling. The clustering-based

480

No bundling
Fixed angle
First bend
Variable angle
Clustering

10N 20E
1.6ms
6.3ms
2.4ms
5.0ms
3.9ms

50N 100E
83ms
197ms
105ms
226ms
124ms

R EFERENCES

200N 1000E
3.7s
11.6s
5.6s
11.3s
5.8s

[1] T. Dwyer and L. Nachmanson, “Fast edge-routing for large
graphs,” in Graph Drawing, ser. Lecture Notes in Computer
Science, D. Eppstein and E. Gansner, Eds. Springer Berlin
/ Heidelberg, 2010, vol. 5849, pp. 147–158.

Table V
P ERFORMANCE ( TIME TO COMPUTE LAYOUT )

[2] J. Dokulil and J. Katreniakova, “Edge routing with ﬁxed node
positions,” in IV ’08: Proceedings of the 2008 12th International Conference Information Visualisation. Washington,
DC, USA: IEEE Computer Society, 2008, pp. 626–631.

algorithm took slightly longer than the ﬁrst-bend algorithm,
but still signiﬁcantly outperformed the ﬁxed- and variableangle bundling. The same relative speeds were maintained
even in further test with large graphs. Graphs with 50 nodes
and 100 edges took between 62 and 222 milliseconds to
draw. This is roughly the size of the graphs we expect to be
present in the scenarios where our edge bundling techniques
would be used. The largest graph we tested (200 nodes, 1000
edges) can no longer be drawn in real-time while the user
changes node positions – they took from 3.7 to 16 seconds
depending on the algorithm, node positions and edges (we
tested several random graphs with the desired node and edge
count).
The implementation of the algorithms used in the test
was not heavily optimized. A great improvement in the
speed could be for instance gained by using spatial indexing
structures for crossings detection and segment lookup.

[3] K. Freivalds, “Curved edge routing,” in Fundamentals of
Computation Theory, ser. Lecture Notes in Computer Science,
R. Freivalds, Ed. Springer Berlin / Heidelberg, 2001, vol.
2138, pp. 126–137.
[4] E. M. Haber, “Visual schema management for database
systems,” Ph.D. dissertation, The University of Wisconsin Madison, 1995, supervisor-Ioannidis, Yannis.
[5] G. Booch, J. Rumbaugh, and I. Jacobson, Uniﬁed Modeling
Language User Guide, The (2nd Edition) (Addison-Wesley
Object Technology Series). Addison-Wesley Professional,
2005.
[6] K. Sugiyama, Graph drawing and applications for software
and knowledge engineers, ser. Series on software engineering
and knowledge engineering. World Scientiﬁc, 2002.
[7] H. C. Purchase, J.-A. Allder, and D. A. Carrington, “Graph
layout aesthetics in uml diagrams: User preferences,” J.
Graph Algorithms Appl., vol. 6, no. 3, pp. 255–279, 2002.

V. C ONCLUSIONS

[8] A. Lambert, R. Bourqui, and D. Auber, “Winding roads:
Routing edges into bundles,” Comput. Graph. Forum, vol. 29,
no. 3, pp. 853–862, 2010.

In this text, we have presented several edge bundling
algorithms. Based on the evaluation we have performed
with the algorithms, the best version is the clustering-based
variant. It scored best in the usability study and also in
the online survey. It is also on of the fastest variants. On
the whole, it is able to provide better experience to the
user while having small impact on the performance on the
application.
There are several ways in which our results may be
improved. During the user evaluation and debrieﬁng interviews we have identiﬁed critical situations, which caused
errors in user’s understanding of the graph. We detected
two main problems. First, we need to eliminate edge bends
near edge crossings (especially near edge crossings with
bundled edge). In some drawings, the distance between the
edge bend and the edge-crossing was under the resolution
capabilities of a humans eye and this caused the two edges to
be indistinguishable. Second, the point at which the bundle
leading to a cluster splits into individual lines should be
further from the bounding box of the cluster.

[9] A. Telea and O. Ersoy, “Image-based edge bundles: Simpliﬁed visualization of large graphs,” Comput. Graph. Forum,
vol. 29, no. 3, 2010.
[10] W. Huang and P. Eades, “How people read graphs,” in proceedings of the 2005 Asia-Paciﬁc symposium on Information
visualisation - Volume 45, ser. APVis ’05. Darlinghurst,
Australia, Australia: Australian Computer Society, Inc., 2005,
pp. 51–58.
[11] I. G. Tollis, G. Di Battista, P. Eades, and R. Tamassia,
Graph Drawing: Algorithms for the Visualization of Graphs.
Prentice Hall, July 1998.
[12] H. C. Purchase, “Which aesthetic has the greatest effect on
human understanding?” in Graph Drawing, ser. Lecture Notes
in Computer Science, G. D. Battista, Ed., vol. 1353. Springer,
1997, pp. 248–261.
[13] H. Purchase, “Performance of layout algorithms: Comprehension, not computation,” Journal of Visual Languages &
Computing, vol. 9, no. 6, pp. 647 – 657, 1998.

ACKNOWLEDGMENT
This work was supported by the grant SVV-2011-263312
and the grant 28910 of the Grant Agency of the Charles
University. The work was also supported by the grant
202/10/0761 of the Czech Science Foundation.

[14] C. Ware, H. Purchase, L. Colpoys, and M. McGill, “Cognitive
measurements of graph aesthetics,” Information Visualization,
vol. 1, pp. 103–110, June 2002.

481


2011 15th International Conference on Information Visualisation

Web-Based 3D Visualisation for Biomedical Applications
Hui Wei, Enjie Liu, Xia Zhao, NJB McFarlane, GJ Clapworthy
Centre for Computer Graphics & Visualisation, University of Bedfordshire, UK
{hui.wei, enjie.liu, xia.zhao, nigel.mcfarlane, gordon.clapworthy@beds.ac.uk}
or slim client, and will be maintained by the service
provider at the remote site which means no burden falls
on the users. Since the application will be built, deployed
and maintained by specialised companies, users can
experience high-quality services at a low cost. The
platform-independent and language-independent features
of web services give developers great flexibility, and
web service composition provides the possibility to reuse existing software as part of a completely new
application at great cost saving.
A pure browser-server solution may lose some
functionality when dealing with the graphical aspects of
an application. However, an X3D browser such as
Bitmanagement BS Contact [4] can be embedded in a
web browser to support 3D visualisation. Transferring
large data sets over Internet may also cause unacceptable
delays in some cases, but the proposed approach
provides a solution to this problem.
The method brings the following benefits:
• a cutting tool widget, which is an extension of an
existing VTK [5] widget and described in [6,7] is
wrapped as a web-based application;
• interaction speed is increased by using client-side
visualisation; users operate on 3D medical data on
their local machine rather than on the server, so, with
the help of locally installed resources, the data
processing is more efficient;
• the data transfer load is balanced between the client
and server – users either read data from their local
machines or from remote interfaces to the Storage
Resource Broker (SRB) data grid used in projects such
as LHDL [8] and VPHOP [9] to store 3D medical data;
• the proposed approach works in four different
scenarios, in particular, the web server can include
other necessary web services, thus extending the
functionality that can be offered to the end user;
• the proposed approach is generic in web development,
and can be used in many other applications.
A specific challenge in our approach is how to
resolve local environment configuration and the
corresponding data archiving and computation. There are
two main desired goals: users do not needed to pre-install
any software; anyone may interact with their local or
remote medical data online without any prior knowledge
of the software.

Abstract
This paper proposes an easy way to perform webbased 3D interactive visualisation, which accepts two
data resources, local and remote, as input and copes
with two types of algorithm, built-in and remote. The
focus of this paper is the biomedical area. Today’s web
technology makes it possible to use software maintained
on a remote server. The approach described provides a
virtual client environment, in which users can employ
remotely installed software interactively using any
standard browser. The proposed approach is a generic
one and can be used in many other application areas.
Keywords: 3D visualisation, medical data, web services,
VTK, digital library.

1. Introduction
The Internet is being used increasingly for 3D
applications. Despite the latency associated with any
Internet operation, these applications can often involve
user interactions of high complexity. For example, [1]
involved the telecontrol of a robot via the Internet and
included a successful live demonstration at a distance of
over 8,000 km.
In recent years, 3D web visualisation techniques
have sprung up in many fields. Their use interweaves our
daily life and study. In the biomedical area, 3D
visualisation gives end users an intuitive way to
understand medical data.
This paper describes a web-based system for the 3D
visualisation of biomedical applications. Its use is
illustrated by a study in virtual surgery – this is a
demonstrator that is a web-based extension of a system
developed within the VPH2 project [2]. VPH2 is creating
a surgical planning system for left ventricular
dysfunction that will be deployed in the relevant clinical
departments in the near future.
An independent web-based system for surgical
planning and training involving medical personnel at
different sites is described in [3]. It is likely that this is a
precursor of further development in this area.
Users benefit from the usability of web-based
applications: they are easy to use via a standard browser
1550-6037/11 $26.00 © 2011 IEEE
DOI 10.1109/IV.2011.74

632

3. System design

The remainder of the paper is organised as follows. In
Section 2, we introduce related work on web-based
visualisation. Section 3 describes the architecture design
in detail, while some tools and techniques used in the
implementation are described in Section 4. Finally, we
present a summary and discuss future work in Section 5.

The proposed system architecture shown in Fig. 1
indicates how we deploy modules in the system between
the client and server.
Some of the modules are downloaded to the user’s
PC and run there in an applet form, so we separate the
system into two parts, client and server, during our
description. It is a relatively thin client. Whether the
programs are executed on the server side or on the
client’s machine is transparent to the user.
The client side includes applets contained in the web
pages and some libraries hosted in the user’s machine for
local interactive visualisation. Its main function is to
configure the user environment, read the user’s data and
render the data in interactive way to assist further
exploration. It is also used to retrieve and reset
parameters for further processing on the server side.

2. Related work
In recent years, several ways have been introduced
for deploying 3D objects on the web.
JavaView, is visualisation software that allows the
display of 3D geometries and interactive geometry
experiments over the Internet. It offers full web
integration and is independent of the operating system.
However, it may not satisfy some requirements such as
needed for the cutting tool used in our example
application or for viewing medical volume data, as in
Wang et al. [10]. However, VTK provides widgets that
can easily extract parameters from the user side and it
can also render volume data. [11,12] show some
examples of the use of JavaView.
Java3D is an addition API to Java for displaying 3D
graphics. It has a higher-level object-oriented interface
compared with openGL, and calls openGL in the JNI
layer. It also offers extensive 3D sound support.
However, in some applications, a variety of data formats,
such as DICOM, STL, VRML, and jpeg are used, and.
VTK give us greater benefits on this aspect. [13] uses
Java3D for 3D molecular visualisation.
JOGL is a Java wrapper library of openGL
sponsored by Sun. It provides full access to the OpenGL
functions, and integrates with the Java GUI: AWT and
Swing. It enables hardware-supported 3D graphics
written in Java. Cipriano et al. [14] presented a web
server that allows users to quickly explore an abstracted
protein surface using JOGL.
Comparing JOGL with VTK, the latter is more
object-oriented for the Java API. It has a series of highlevel design goals which make its API simple and it can
be readily assembled into larger systems [15]. The
former provides low-level bindings for OpenGL. VTK
also provides many existing widgets which allow the
user to flexibly choose accurate parameters.
Furthermore, VTK also has a mechanism by which one
can automatically generate a Java API, which is very
helpful to extend it if using a C++ based server and Java
based client.
Ajax3D [16] combines Ajax with x3d and is the
standard for real-time 3D on the web. Ajax
(Asynchronous JavaScript and XML) combines existing
technologies, including html, css, JavaScript, Dom,
XML, xmlhttpRequest object, and so on. It allows users
to exchange data asynchronously between the browser
and server without reloading the entire current page.
X3D[17] is a royalty-free open standards file format and
run-time architecture to represent and communicate
among 3D scenes and objects using XML.

Figure 1. System Architecture
An applet is delivered to the client side, so it is
executed on the user’s machine after it has been retrieved
from the server. This, allows us to use it as our client to
realize local rendering by using resources from the user
machine – CPU, RAM, etc. An applet running in a web
browser is often restricted by a set of security policies – a
sandbox. But it can be granted permission or be signed to
perform tasks outside the sandbox. As granting
permission requires users to configure the policy file in
the client machine, it is not an easy thing for them to do.
So, we choose to sign our applet to obtain the user’s
permission – the user needs only to click a button to
confirm that they trust the applet. By this, the client may
access restricted resources on the user’s machine, such as
the file system.
When users visit the web page, the resource deploy
module detects if they have the necessary visualisation
functions locally. If not, this module will deploy these
resources on the user’s machine. In our case, it will
deploy the visualisation plug-ins for exploring the data
on their local machine. Since this module lies on the
client side, it can access the user’s machine directly.
The data adapter module reads data from local or
remote machines. The remote data interface may be
SOAP, XML-RPC, HTTP, FTP or other web-based
proxies. We access these data remotely and save them on
the user’s machine. Hence, the visualisation module can

633

treat local and remote data in the same way, since both
now lie on client side in an acceptable format.

a public attribute or invoke a public method of an applet.
An applet can communicate with a servlet, which is a
lightweight application running on the server side, or
with other applets. This feature is very useful – we can
use sever applets to build a multi-view application,
allowing users to explore data through different views
(e.g surface and slice-based) simultaneously. These
features of applets allow us to construct interactive,
dynamic and informative applications.
Although VTK supplies a Java wrapper, the wrapper
cannot work independently. It takes the form of an
interface (JNI actually) and needs support from VTK
dynamic-link libraries. When a method is called, through
its Java API, the method invokes its library automatically
through the interface. These dll files are deployed on the
client side by the resource deploy module before running
further functions, such as visualisation .
VTK supplies the developer with many examples of
3D widgets: interactive tools that can be embedded in the
visualisation. The example in this paper is a 3D triangleshaped widget, originally developed as a VTK extension
in [6,7] as one of the surgeon-requested cutting tools in
the surgical planner application mentioned earlier. The
triangle widget features basic functions, such as resize,
drag, rotate, plus some extra functionalities. It is intended
to act as a tool for punching holes though a surface, so it
should initially appear at a position facing the camera,
and its allowable area of motion should not exceed the
boundary of the input surface data. After each user
interaction, it should readjust its position to “stick” as
closely as possible to the surface and realign itself with
the surface normal.
The VTK Java wrapper mechanism can also be used
to extend a class. An extended VTK class will generate a
corresponding *java.cxx file and a *.java file for the Java
wrapper automatically. The newly generated .class file
will be packaged in a vtk.jar file, which can be invoked
by a Java applet. The main algorithm written in a C++
class will be exported as a shared library, which can be
invoked automatically by its Java interface.
VTK gives the developer a pre-defined set of events
and actions and a way to override default actions. It also
provides a way to translate native mouse and keyboard
events into vtk Events. This makes it possible to use Java
UI events to interact with the vtk object. Our triangle
widget VTK extension inherits these advantages.
Surface data as an input parameter data for a
triangle widget is read separately in both Java code and
native code on the client side. To avoid passing complex
object parameters through JNI, a string of local paths is
passed from Java code to native code. Both sets of code
are stored on the client side, so they can both read the
data easily.

3.1. Resource deployment
Visualisation resource libraries are stored in a folder
on the web server, for any client to download, when
needed – for this, the client program needs to know the
URL of the web server. An applet can obtain the URL
string of the host containing it in its init method. After
these libraries are stored locally, the client program may
load them into JVM.
The life cycle of an applet is determined by methods
that are called by JVM automatically in the following
sequence: static block, init, and start. To ensure that
these libraries are loaded before use, and are loaded only
once, the load operation is done in the static block of an
applet. After that, the visualisation functions in these
libraries are ready for use on the client side. However,
this inevitably produces a conflict between the logic
order and code execution order, which may mean that
these tasks cannot be executed in a single applet.
A solution is to separate them into two applets(see
Fig. 2)– the first fetches the server URL and stores the
resources in the init method; and the second loads the
libraries in the static block. To ensure that these two
applets run in the correct order, a JSObject class, which
is a wrapper of JavaScript objects, is used in the first
applet to invoke a JavaScript function in the web page to
redirect the current page to a new page containing the
second applet.
Get server URL Æstore resourceÆ load libraries in JVM
Init()
Æ
init()
Æ
static block

Figure 2. Load Library.

3.2. Visualisation
Applets can be run in any browser that has the
appropriate version of a Java plug-in. Our web page,
which contains an applet, will detect whether a user has
the Java plug-ins installed, if not, the page will direct
them to be installed.
The applet is now a mature technique and, with the
latest development of Java plug-ins, an applet can be
specified with a heap size larger than the default
maximum through an HTML tag in the web page
containing the applet. The heap size can be defined by
the users for different applets individually, which makes
a more flexible usage of the applet possible.
As a web technique, the applet also has a strong
communication ability. It can visit an element value on
the web page or a JavaScript method through the
JSObject class. In contrast, a JavaScript method can visit

3.3. Data resources
To access remote data resources, we embed our
systems into PhysiomeSpace [18], which supplies users
with an interface to download this data. The medical data

634

Figure 3-A Module collaboration of remote data rendering

Figure 3-B module collaboration of using remote algorithm
the widget class to transform a parameter object from an
XML file and take further computational tasks. The
classes in this layer are organised in an object-oriented
way. To give a simple Java interface, the function
interface layer includes many JNI functions. Every
function answers for one algorithm by invoking classes
in the two lower layers, so these functions can be
invoked by the algorithm adapter module.

defined in the project is the Virtual Medical Entity
(VME) [19], which can be accepted directly in any
MAF-related project. As our server integrated the MAF
library as an algorithm set, this data format can be read
directly from the server side. However, our client only
contains VTK library, this data cannot be read directly.
Fortunately, the web service function provided in
PhysiomeSpace supplies an interface for visiting user
data to be managed in the system in a VTK-acceptable
file format (vtk, .stl, .vrml, etc). To process a case in
which the data has to be read both on the client side for
visualisation and on the server side for data processing,
we use these two different ways of loading remote data
separately for the client and server.
For the convenience of ordinary users viewing
medical data on their local machine, a small interface for
file open was created to allow them to choose the precise
data from the file system. As rendering runs on the client
side, once the permission is granted, users have the rights
to visit the local file system and use local resources.

3.5. Module collaboration
3.5.1. Remote data visualisation
Once users log on to PhysiomeSpace, they are
allocated their own sandbox to keep their own data.
Through PhysiomeSpace, the user may choose data
stored in the SRB repository with MAF VME format.
Fig. 3-A shows how to render the remote data at the
client. An applet in visualisation module sends a request
to a servlet in the workflow control module with the data
id. The servlet informs the data adapter to get URL of
the remote data in a VTK accepted format. Data adapter
module invokes the right web based algorithm to process
the remote data. The result data in VTK accepted format
is then generated and the URL of the new data is
returned to the client. Then the applet invokes the client
side data adapter to download this data into a local data
folder for further operations, such as visualisation.

3.4. Algorithm set
PhysiomeSpace offers users many web-based
algorithms for medical data processing. However, these
services are pre-defined and limited.
To provide a more extensive and richer algorithm set,
our built-in algorithm set is based on MAF. MAF is an
open source framework containing several libraries such
as VTK and ITK. We use MAF as an algorithm library,
rather than an application. We classify these algorithms
into three layers. The foundation layer is the MAF
library. The upper two layers are both dynamic link
libraries. The extend layer contains new algorithm
classes extended from MAF and widget classes extended
from VTK. The widget classes are needed on both the
client and the server side. The server-side algorithms use

3.5.2. Remote processing
When data are being processed on the server side, data
and algorithm resources are needed. There are 4 cases for
data and algorithm combinations to be dealt with:
• Local data – built in algorithm: the web server needs
a copy of the data from the client, so the data must be
uploaded from the client to the server by http proxy.
• Local data – web service algorithm: if the web service
reads the data from the data repository, an import
635

service is needed to load the local data into data
repository; the file id is passed to the server.
• Remote data – built in algorithm: the web server has
to download the data in its original format; the data
file id is passed to the server side from the client.
• Remote data – web service algorithm: the server side
does not need to download the data, only the file id is
chosen from the interface; data acquisition and data
processing are done in the web services.

Java code, JVM has already started when Java code is
executing, and modification is difficult. To get around
this, the declared static field sys_paths of the class
ClassLoader which contains this java.library.path is set
to null; the class can then be initialised automatically.
Another way to deal with it is to choose an existing
path in java.library.path, manually or automatically. The
latter would choose a JRE path that already exists (see
Section 3.2).

Fig. 3-B shows how to process remote data using webbased algorithms. An applet in the visualisation module
invokes the operation extract module which extracts
parameters from the widget object. The operation extract
module will capture a snapshot of the run-time operation
parameters and organise these in an XML file. The
applet then invokes the data adapter module to upload
the XML file to the server. It sends a request to the
workflow control module to look up the algorithm for
processing the data. If the algorithm adapter module
finds a matching algorithm in the built-in algorithm set,
the client then uploads the data file to the server,
otherwise, the web service algorithm will read the data
from the remote resource.
After processing the data, a new data set is created
and, with the data file URL returned to the client, the
data adapter module on the client side can use the URL
to download the data to the local machine. Finally, the
visualisation module uses the new data file to update the
View produced.

4.2. Example application: simulated surgery
Fig. 4 shows a model of the left ventricle of a heart
derived from an MRI image and visualised as a
triangular mesh surface. The original desktop, clientside, version of this simulation has been described in [6,
7]. The user can interactively view the data on the web
from any angle with two styles: position sensitive and
motion sensitive.
A triangle widget, coded as a VTK extension
appears on the surface. It has three shape handles and
one normal handle. When one of the shape handles is
active, the user can drag it to change the size and shape
of the triangle. When the normal axis is active, the user
can rotate the plane of the widget around the normal.
When the normal handle or the edge of the triangle are
active, the triangle can be dragged to a new position. A
3D x,y,z coordinate axis is shown as a position reference
and set at the centre of the data bounds.
The triangle widget is a cutting tool – when the user
is satisfied with the shape and position of the widget,
they may use a cutHole button to punch a hole through
the surface. The picture with a hole in the surface shows
the resulting data, as processed by the server side built-in
algorithm. The surface is cut by a triangular prism with
parameters extracted from the triangle widget. From the
wireframe graph we can see that the resulting data is
decimated on the server side, in this case to 20% of the
original size, to improve the speed of the interactive
transfer between client and server.

4. Implementation
4.1. Configure client environment automatically
A trusted applet can access the properties of, and
read or write files to, the client system. File systems on
different clients are organised differently on different
platforms, or even on the same platform. We leave the
users free of trouble by setting up a configuration file.
However, we do not want to keep this information in the
database, so we create two local folders: a data folder
and a library folder. The local data folder is used to store
data downloaded from the remote site and the local
library folder is used to store VTK libraries for
visualisation. In this way, the reading of data and the
execution of code can be performed locally at high
speed. As the user now permits our code to visit the local
system, two paths should be created.
The data folder is easy to choose. When users log on
to their operating system (Windows, Unix or Linux), a
home directory is given to them, separating the user data
from the system-wide data. By reading a system property
user.home, this unique path can be built, A new folder is
then created to store the data downloaded from the
remote site.
The library folder should be set to a path where
JVM can read the library. Sun Java reads .dll files kept in
the java.library.path. This system property contains the
local path in the path environment variable. Libraries in
this path can be loaded by JVM. However, when we run

5. Conclusions and future work
This paper has described a way of performing webbased 3D interactive visualisation – a virtual client
environment. Users used a standard browser to perform
simulated surgery and could decide on the shape and
boundary of a ‘cut’ using remotely located visualisation
tools. The approach accepts two data resources (local
and remote) as input and two algorithm resources (builtin and remote). The proposed approach is generic and
can be used in other projects that use VTK or, indeed, in
other systems that use C++ in their applications.
In the future, for the remote algorithm aspects, we
shall make use of the new axis2 features to create new
web services, for example, invoking web services
asynchronously. JAX_WS supports both polling and
callback when calling web services asynchronously.
Large datasets and complex graphics processing may
cause delays, but these asynchronous mechanise may

636

Figure 4 Heart
improve user satisfaction. They may go on to operate our
interactive view on the client and after completing the
processing, the view will be updated automatically.
Another useful development is the support for Message
Transmission Optimized Mechanism (MTOM), by which
the user can send and receive binary attachments such as
images or files along with web service requests. The
binary data may be contained within the XML document
or as an attachment outside it.
From the visualisation perspective, we shall create a
multiview system to supply users with a broader variety
of viewing modes with which to explore their data.

[12]

[13]

[14]

[15]

References
[1]

I R Belousov, R Chellali, G J Clapworthy, Virtual
Reality Tools for Internet Robotics, Proc IEEE
International Conference on Robotics & Automation
(ICRA-2001), Seoul (Korea), May 2001, pp. 1878-1883
[2] VPH2: www.vph-vph2.eu
[3] Y Ning, X J Guo, X R Li, X F Xu, W J Ma, The
Implementation of Haptic Interaction in Virtual Surgery,
Proc. 2010 Int’l Conf on Electrical & Control
Engineering, June 2010, pp. 2351-2354
[4] Bitmanagement BS Contact: www.bitmanagement.com
[5] VTK: www.vtk.org
[6] X Lin, N J B McFarlane, Y Zhao, G J Clapworthy, F
Dong, A Radaelli, Visualisation of Left Ventricular
Dysfunction in the Virtual Pathological Heart, Proc. 7th
Int’l Conf on Biomedical Visualisation (MediVis10),
London, July 2010, pp. 635-640
[7] N J B McFarlane, X Lin, Y Zhao, G J Clapworthy, F
Dong, A Redaelli, O Parodi, D Testi. Visualisation and
Simulated Surgery of the Left Ventricle in VPH2, Royal
Society Interface Focus, 2011 (in press)
[8] LHDL: www.livinghuman.org/
[9] VPHOP: www.vphop.eu/
[10] T Wang, Y Zhao, E Liu, G J Clapworthy, X Zhao, H
Wei, F Dong, Using Web Services as Functional-Level
Plug Ins for Interactive 3D Medical Visualisation, Proc.
14th Int’l Conf on Information Visualisation (IV10),
London, July 2010, pp. 617-622
[11] K Polthier, S Khadem, E Preuss, U Reitebuch,
Publication of Interactive Visualisations with JavaView,
in (Eds: J Borwein, M Morales, K Polthier, J F

[16]
[17]
[18]
[19]

637

Rodrigues) Multimedia Tools for Communicating
Mathematics, Springer Verlag, 2002
M Majewski, K Polthier, Using MuPAD and JavaView
to Visualise Mathematics on the Internet, Proc. 9th Asian
Technology Conf in Mathematics, 2004, pp. 465-474
R Ding, J Z Gao, B Chen, J I Siepmann, Y Liu, WebBased Visualisation of Atmospheric Nucleation
Processes Using Java3D, Proc 9th IEEE/ACM Int’l
Symp. on Cluster Computing & the Grid, May 2009, pp.
597-602
G Cipriano, G Wesenberg, T Grim, G N Phillips Jr, M
Gleicher, GRAPE: GRaphical Abstracted Protein
Explorer, Nucleic Acids Research Advance, May 2010,
Published online Vol. 38, Web Server issue W595–
W601,doi:10.1093/nar/gkq398
W J Schroeder, K M Martin, W E Lorensen, The Design
and Implementation of an Object-Oriented Toolkit For
3D Graphics and Visualisation, Proc 7th IEEE
Visualisation 1996 (VIS '96), October 1996, pp. 93-101
T Parisi. Ajax3d: The Open Platform for Rich 3D Web
Applications, www.ajax3d.org/whitepaper/.
X3D specifications. www.web3d.org/x3d/specifications/
PhysiomeSpace: www.physiomespace.com
M Viceconti, C Zannoni, D Testi, M Petrone, S
Perticoni, P Quadrani, F Taddei, S Imboden, G J
Clapworthy. The Multimod Application Framework : A
Rapid Application Development Tool for Computer
Aided Medicine, Comput. Methods Programs Biomed,
85(2):138–151, 2007


12th International Conference Information Visualisation

Edge Routing with Fixed Node Positions∗
Jiˇr´ı Dokulil
Faculty of Mathematics and Physics,
Charles University, Prague, Czech Republic
dokulil@ksi.mff.cuni.cz

Jana Katreniakov´a
Faculty of Mathematics, Physics and Informatics,
Comenius University, Bratislava, Slovakia
katreniakova@dcs.fmph.uniba.sk

Abstract

that there is at least some free space between nodes). The
edges are drawn as polylines. The computation itself is relatively simple and very fast. The basic algorithm is presented in Section 2 and a post-processing step that visually
improves the drawing in Section 4.
Despite its relative simplicity, the algorithm is sufficient
for many tasks. And the simplicity of the computation and
results (no curves) allow us to easily address some specific
situations, like the situation when many edges bend along
one corner of a node and the user is no longer able to tell
them apart. Our solution of this problem is described in
Section 3.

The two basic problems of graph drawing – drawing of
nodes and drawing of edges – are often handled by one
algorithm that finds suitable positions for both nodes and
edges. However, there are situations where positions of
nodes are fixed, for instance if they were defined by the user
or the exact position of the nodes is somehow significant. In
these cases we need an algorithm that draws only the edges
no matter what the positions of the nodes are. This paper
presents one such algorithm. We present the very basic version of the algorithm followed by two ways of improving it
to produce better looking and clearer results.

2 Rerouting of Edges
The basic idea of this algorithm is quite straightforward.
We start by drawing the edge as a direct line between the
source node and the destination node. Then we reroute the
line (we create a polyline in several steps where in each
step we split one segment of the polyline into two connected
segments) away from the nodes that intersect with the line.
This algorithm does not make any use of the layered structure.
Suppose that we need to connect nodes vA a vB . The
final polyline is constructed by a function Reroute. The
computation starts by calling Reroute(vA , vB ).
The Reroute algorithm makes use of a function
Crosses that determines if the line and a certain vertex intersect and if they do, it determines what type of intersection
it is (see below for the list of the types).

1 Introduction
One of the problems in graph drawing is drawing of
edges. There are several approaches to it. One class of
them are algorithms that handle node and edge positioning
at the same time, like the popular force-directed approach
[6]. But sometimes it is not possible to move the nodes. For
instance, their positions may have been defined by the user.
Or we may not want to alter their positions when we add
new edges to the already displayed graph.
The other class are algorithms that take node positions as
their input and only draw the edges. Some of them are sophisticated, using advanced path-finding algorithms, spline
curves, . . . [7, 3]. The algorithms further differ by their suitability for different classes of graphs. Some of them can
only handle specific types of graphs (e.g. trees, hierarchical graphs, . . . ), other handle general graphs even with very
complex shapes that the edges must avoid (they use a general path-finding algorithm).
Our algorithm, presented in this paper, is designed to
handle a general drawing of any graph where nodes are
drawn as rectangles (only constrained by the requirement
∗ This research was supported by the Czech Science Foundation under
the contract no. 201/05/H014 and VEGA 1/3106/06

1550-6037/08 $25.00 © 2008 IEEE
DOI 10.1109/IV.2008.11

626

(1)

(2)

(3)

(4)

(5)

(6)

(a) Before Rerouting

(c) Selecting different ε

(b) Non-distinguishable edges

(d) Wrong order of edges

Figure 1. More edges passing the same corner
Another auxiliary function is M inCut. Given a node
v, line L and four points P1 , P2 , P3 a P4 , it determines
whether it is better to reroute L through P1 .P2 , P3 or P4 . It
picks the point where the area cut from the v by the rerouted
L is the smallest one.

3 Solution for more edges
A slight problem is the ε variable. If all edges passed
the nodes in the same distance ε then it would result in
edge crossings and the user would not be able to distinguish
the edges (as you can see in Figure 1(b)). This problem is
avoided by selecting a different ε for each edge passing a
certain corner of a node.

The Reroute algorithm finds (using the Crosses function) a node that intersects the line (there can be more of
them, in which case any one of them can be used) and then
reroutes the line so that it avoids the node. In some cases,
splitting the line into two parts is not sufficient to completely avoid the node. In that case, the M inCut function is
used to determine the best partial solution and the rerouting
is completed in a subsequent call to the Reroute function.

More formally, in the beginning of the Rerouting algorithm we select a distance δ, that determines the neighborhood of the displayed node, in which no edge can be drawn.
In both auxiliary function of the algorithm modified coordinates of the lower left corner ([x(v) − δ, y(v) − δ]) and size
((H(v) + 2 · δ) × (W (v) + 2 · δ)) are used for each node v.
In the Reroute function we use the parameter δ instead of
the parameter ε.
Now, all edges avoid passing the δ neighborhood of the
node. But all edges passing the same corner meet at the
same point. Let us assume, that edges e1 . . . ek should pass
around this corner. We set the ε variable for the edges as
ε(ei ) = i · (δ/k). The property, that no edge passes the
node is preserved. Moreover, the edges are distinguishable
(see Figure 1(c)).
However, even if no two edges bend in the same point,
the situation may be hard to read because of too many edge
crossings near the corner (as you can see in Figure 1(d)).
It is caused by the wrong order of the edges passing the
corner. We need to order the edges correctly before we set
the parameter ε for each of them. But what is the “correct”
order of the edges?
Let R = [x, y] be the modified coordinates of a certain
corner of a node w (for example for the lower left corner of w the modified coordinates are x = x(w) − δ and
y = y(w) − δ) and let R = [x , y ] be the modified coordinates of the opposite corner of w. If an edge e = (u , v )
needs to pass around the corner [x, y], then u and v (the
bends or endpoints of the edge e before and after the bend
at the coordinates R) are in opposite half-planes defined by
−−→
p = RR .

R EROUTE(L = [x1 (L), y1 (L)], [x2 (L), y2 (L)])
1 for each v in V \ {vA , vB }
2
do c ← C ROSSES (L, V )
3
if c = 0
4
then break;
5
6 U L ← [x(v) − ε, y(v) + H(v) + ε]
7 LL ← [x(v) − ε, y(v) − ε]
8 LR ← [x(v) + W (v) + ε, y(v) − ε]
9 U R ← [x(v) + W (v) + ε, y(v) + H(v) + ε]
10
11 switch
12
case c = 0 : return L //no intersection
13
case c = 1 : P ← U L //upper lef t
14
case c = 2 : P ← LL //lower lef t
15
case c = 3 : P ← LR //lower right
16
case c = 4 : P ← U R //upper right
17
case c = 5 : P ← M IN C UT(v, L, U L, LL, LR, U R)
18
case c = 6 : P ← M IN C UT(v, L, U L, LL, LR, U R)
19
20 return R EROUTE([x1 (L), y1 (L)], P )⊕
21
⊕R EROUTE(P, [x2 (L), y2 (L)])

Because the only cases not resolved immediately are
cases 5 and 6 (from the cases listed above) and they can
only produce crossings of types 1-4, this cannot result in an
infinite loop of calls to Reroute.

627

(a) Edges passing a corner

(b) Finding a suitable permutation

(c) Ordered edges

Figure 2. Edge ordering
Let e1 , e2 , . . . ek (where ei = (ui , vi )) be the edges passing around the corner R and ui , vi are the last bends on
ei before passing around R. As the Reroute algorithm is
not concerned with the direction of the edges, WLOG let
u1 . . . uk be the bends lying in one half-plane and v1 . . . vk
are lying in the opposite one. Furthermore, we define
ϕi = R Rui and ψi = R Rvi (see the image below).

π2 (v)}|. For the set of permutations P = {π1 . . . πk } the
Kendal-τ distance collects all disagreements. K(P, π ∗ ) =
Σki=1 K(πi , π ∗ ).
For k = 2 is the crossing of permutation problem easy
to solve. It can be shown, that having P = {π1 , π2 }, the
Kendal-τ distance K(P, π) for each π is greater or equal to
K(P, π1 ) = K(P, π2 ). However, there are more optimal
permutations. They can be found from a straight-line drawing of π1 and π2 (see Figure 2(b)). Consider an arbitrary
curve from left to right that crosses each straight line (v, v)
for v = 1 . . . n exactly once (we call such a curve a pseudoline.) This yields a permutation π ∗ by listing the elements
in the order in which they were crossed. Any permutation
obtained in such a way is optimal [2].
Now, we know how to order the edges in one corner.
But the edges passing two corners of the same node are not
completely independent. There might be some edges with
bends near two corners of the node. The solution is easy.
We order the edges in each corner, one after the other.
More formally, we begin with the lower left corner LL
of the node w (the opposite corner is the upper right corner
U R). Let e1 . . . ek be the edges passing around this corner.
We set the “ends” of each edge as the last bend on the edge
before passing around the corner. It may be, that this bend
is not completely executed yet (i.e. we know only, that it
passes around some corner R but we do not know the actual
distance) – in this case we set the approximate bend coordinates (i.e. the coordinates of the corner R). Let the last
bends of an edge ei be (ui , vi ). WLOG let u1 . . . uk be the
−−−−−→
bends contained in the half-plane defined by p = LL, U R
and the lower right corner of w. Similarly we get v1 . . . vk .
The permutations π1 and π2 are defined as before. The
common ranking π ∗ is constrained as follows:

Let π1 and π2 be the permutation of e1 . . . ek . The permutations are constrained as follows:
π1 (ei ) < π1 (ej ) if

ϕi < ϕj

π2 (ei ) < π2 (ej ) if

ψi < ψj

If the order of some edges is undefined we may order
them arbitrarily. As you will see later, this does not affect
the solution. Now, we have two permutations of the edges
e1 . . . ek . We should order the bends of these edges near
the corner R so that we minimize their crossings. We get a
special case of the crossing of permutation problem.
The crossing of permutation problem [2] is to combine
several rankings π1 . . . πk on U , in order to obtain a common ranking π ∗ , which can be regarded as the compromise
between the rankings. The goal is to find the best possible
common ranking, where the notion of ‘best’ depends on the
objective. It is formally expressed as a cost measure or a
penalty between πi and π ∗ ; the common version takes the
sum of the penalties. We use an often used Kendal-τ distance [1]. For two permutations π1 and π2 is the distance
K(π1 , π2 ) equal to |{(u, v) | π1 (u) < π1 (v) ∧ π2 (u) >

π ∗ (ei ) < π ∗ (ej )

if

π1 (ei ) < π1 (ej )

or

ei ≈π1 ej ∧ π2 (ei ) < π2 (ej )

The ei ≈π1 ej means that in the half-plane corresponding to π1 , the edges ei and ej lead away from the bend in

628

(a) Before rerouting

(b) Bends at the lower left corner

(c) Bends at the upper left corner

(d) Bends at the upper right corner

(e) Bends at the lower right corner

(f) Final positions of bends

Figure 3. Example of ordering

exactly the same direction. If there were still some edges,
whose order is not defined by π ∗ , it means, that their both
ends have the same direction and we can order them arbitrarily. It is obvious, that π ∗ is the optimal common ranking.
After we have ordered the edges passing around the
lower left corner, we continue with the upper left corner.
As the bends u1 . . . uk we chose those, which could be
used in previous ordering (i.e. points contained in the same
half-plane as the lower left corner). As the permutation π1
defined by the u1 . . . uk is primary, we achieve, that the ordering from previous corner is preserved also by this corner.
This way we continue clockwise around the node. An
example of the final ordering is shown in the Figure 3.

polyline.
Another possibility is to try removing not just a single
bend but rather a continuous sequence of bends [8].
These simple approaches do not provide optimal results.
There are situations, where we can reduce bends even if no
bend can be removed directly. One such situation is shown
in the Figure 4(b).
However, for each polyline that represents an edge, we
can straighten each bend as much as possible. We reuse the
Reroute function for this purpose. In one step, we handle
three adjacent bends (or endpoints) and we start at one end
of the polyline and continue towards the other end. The
Reroute is executed on the straight line that is obtained by
removing the middle bend. The output is a new polyline,
that avoids crossing nodes. If the new polyline is “better”
than the original polyline with one bend, then we replace
the original polyline by the new one.
More formally, let P = P1 . . . Pi−1 Pi Pi+1 . . . Pk be a
polyline that represents an edge. We start with the bend P2 .
Now, suppose that we have come to handle the bend Pi . Let
P = P1 . . . Pl (P1 = Pi−1 and Pl = Pi+1 ) be the result
of Reroute(Pi−1 Pi+1 ). If any of the points Pj is a corner
of a node already used in P except for corners adjacent to
Pi−1 or Pi+1 , the rerouting was somehow “bad” (however,
this does not occur in practice) and is always rejected. Oth-

4 Polyline straightening
When the Reroute function is used, the edge is guaranteed to avoid all vertices. But the results are not entirely satisfying from the user’s point of view. The problem
is that the resulting polyline is often unnecessarily complex – it contains more bends than necessary. So, after
the edge rerouting is complete, we simplify the polyline.
The simplest way is to check each bend of the polyline and
test, whether removing the bend would create a edge-vertex
crossing. If not, we remove the bend, thus straightening the

629

(a) Situation before rerouting

(b) Nonreducable bends

(c) Shifting a bend

(d) Less bends

Figure 4. “Difficult” example for polyline straightening
erwise let l be the length of the polyline Pi−1 Pi Pi+1 and l
the length of P . If the length l is less than l, the rerouting
is accepted as a better solution and the edge is represented
by
P1 . . . Pi−1
P1

algorithm is used. We use it directly after the Reroute algorithm, before the ordering algorithm (the algorithm described in the Section 3), because until the straightening
of the edges is finished, the list of edges passing around
each node is not final – new bends can be created and old
bends can be removed. Therefore we do not place the bends
on their final positions (the ordering algorithm) until we already know all approximate routs of all edges.
The Figure 5(a) gives an example before straightening is
performed, while the Figure 5(b) is the same situation after
straightening. The images are screenshots of our RDF visualizer [4, 5]. Originally, we have developed the edge routing
algorithms to work with the visualizer and the triangle layout algorithm used in the visualizer, but it turned out to be
applicable even to different layouts.

Pi+1 . . . Pk = P1 . . . Pk+l−3
. . . Pl

After solving the problem for this bend, we move along
the polyline to the next bend. As the next bend, we have
two possibilities. If the number of bends in P was 0, then
the next bend is again Pi . Otherwise, we really move along
the polyline and handle the bend Pi+1 . This way we move
through the whole polyline, until we get to the last bend.
The algorithm is finite. In each step the number of bends
on the polyline that have already been processed grows – we
do not remove any bends that have already been processed
and always process one. There can be at most one bend of
the polyline around each corner of any node in the displayed
graph, so the number of bends is finite. Thus the algorithm
must finish after a finite number of steps.
Moreover, the algorithm gives us shorter (or same
length) edge, as it was before, since in each step we use
the new polyline only if it was shorter. The length of edges
is common used aesthetic criteria for drawing edges and together with the low number of bends it provides very nice
looking edges.
Having a shorter polyline for an edge, we can once again
apply the bend-removing algorithm to reduce the trivial
bends which occur because we moved only in forward direction along the polyline.
The whole straightening process is only a heuristic. It
may not provide optimal results (both in the sense of finding the shortest polyline and finding the “best looking” solution). However, it is a easy-to-understand, straightforward
algorithm that does provide satisfying results in many common situations.
At the end, we should mention, where the straightening

5 Conclusion and future work
We have presented the algorithm for edge rerouting
along with two ways of improving it. The final version can
be used to quickly draw edges in situations where nodes are
drawn as rectangles and their positions are fixed.
As we have already mentioned in the introduction, the
simplicity of the algorithm and the produced drawing allows us to easily handle some specific situations. One of
the situations we would like to explore in the future is when
there are many edges originating in the same node and leading away in a similar direction. We may be able to group the
edges together and draw them as one line (probably a thick
one).
Another aspect we would like to explore is the ability to
add labels to the edges. Although it can be done by simply
adding the label e.g. to the middle of the edge, the produced
results are far from satisfying.

References
[1] J. Bartholdi III, C. A. Tovey, and M. A. Trick. Voting schemes
for which it can be difficult to tell who won the election. Soc.
Choice Welfare, 6, 1989.

630

(a) no straightening

(b) straightening

Figure 5. Examples of edge rerouting

[2] T. C. Biedl, F. J. Brandenburg, and X. Deng. On the complexity of crossings in permutations, 2007. Preprint submitted to
Elsevier Science.
[3] D. P. Dobkin, E. R. Gansner, E. Koutsofios, and S. C.North.
Implementing a general-purpose edge router. In Proceedings
of the 5th International Symposium on Graph Drawing, pages
262–271. Springer-Verlag Berlin Heidelberg, 1997.
[4] J. Dokulil and J. Katreniakov´a. Visualization of large schemaless rdf data. In International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies (UBICOMM 2007), includes: SEMAPRO 2007, WSNEXT 2007,
MUTL 2007, VVSSearch 2007, pages 243–248. Los Alamitos: IEEE Computer Society, 2007.
[5] J. Dokulil and J. Katreniakov´a. Visual exploration of rdf data.
In SOFSEM 2008: Theory and Practice of Computer Science,
pages 672–683. Springer-Verlag Berlin Heidelberg, 2008.
[6] T. M. J. Fruchterman and E. M. Reingold. Graph drawing
by force-directed placement. Software - Practice and Experience, 21:1129–1164, 1991.
[7] T. Reinhard, C. Seybold, S. Meier, M. Glinz, and N. MerloSchett. A novel algorithm for line routing in hierarchical diagrams. Technical Report ifi-2006.08, University of Zurich,
2006.
[8] T. W¨urthinger. Visualization of java control flow graphs,
2006. Bachelor thesis at Institute for System Software, Johannes Kepler University Linz.

631


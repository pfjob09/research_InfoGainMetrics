12th International Conference Information Visualisation

Visualisation of Coupling and Programming to Interface
for Object-Oriented Systems
Peter Rosner, Srikumar Viswanathan
Faculty of Business, Computing & Information Management
London South Bank University
rosnerpe@lsbu.ac.uk
to assess different metrics results alongside each other.
Recent work has been undertaken [17], [18] to present
OO metrics in a graphical form to deal with this issue.
Polymetric views enable the expression of several
different pieces of information about a class in the form
of a simple rectangle. Such a polymetric node can have
several possible attributes: for example, two to determine
the position of the node, one to determine node width,
one to determine node height, and one to determine
colour shading intensity. The tool CodeCrawler [19]
provides a “System Complexity” view in which no
metrics are used to determine node position, but the
NOA (Number of Attributes) metric determines node
width, the NOM (Number of Methods) metric
determines node height, and the LOC (Lines of Code)
metric determines the node colour. Colouring shade
ranges between white and black with darker shades
representing higher values of the LOC metric.
Code Crawler also provides visualisation of OO
coupling that follows what appears to be the norm, for
example in [15], where lines are used to connect coupled
classes together resulting in diagrams that may appear
somewhat congested and tangled.
A 3D variant of polymetric views is provided by
Code City [20]. Here classes are represented as
‘buildings’ with their height and width representing the
same metrics as that described above. Height is NOM;
both width and depth are NOA, giving the ‘buildings’ a
square base. The ‘buildings’ are grouped in 3dimensional form into clusters representing class
packages. Hierarchical containment in packages is
represented by clusters within clusters of ‘buildings’.
Standard library classes are represented as ‘suburbs’.
In the tool JCTIViz [29] used for visualising metrics
in Java systems, we use a variant of polymetric views
that provides 3-dimensionality in a different fashion.
Rather than placing the nodes representing classes or
interfaces in a 3D landscape, the depth dimension of the
3D box itself is proportional to a metric value. In the
case of JCTIViz this value is the degree of coupling from
the class or interface as indicated by CBO.

Abstract
A 3-dimensional variant of the ‘polymetric views’
approach for visualising metrics within an objectoriented software system is presented. This variant
provides simultaneous display of several metrics
including coupling, the contribution made by coupling to
interface rather than to concrete class, and an indication
of behavioural polymorphism. A tool, JCTIViz, is
described that implements this visualisation for Java
systems and preliminary results from applying the tool
are presented. Future enhancements to the approach and
the tool are outlined.
Keywords--- OO metrics, visualisation, Java,
interface, coupling.

1. Introduction
Traditional object-oriented (OO) metrics such as [5],
[6], [7], [22] aim to provide complexity indicators for
object-oriented systems that facilitate estimations of
system characteristics such as fault incidence, testing and
maintenance effort.
OO metrics can also be used to identify parts of a
system with high complexity that potentially require
remedial action. We focus in this paper on the metric
Coupling between Objects (CBO) as proposed by
Chidamber and Kemerer [6], [7] as part of their widely
used and empirically studied (as summarised in [11])
original suite of 6 metrics. In particular we separate out
coupling to concrete class from coupling to interface –
the former considered, according to object-oriented
design principles, to be undesirable and the latter
considered positive. Coupling to interface also allows for
more rigorous testing by enabling ‘mocks’ or stubs to
replace coupled-to classes during development [23].
Chidamber and Kemerer’s CBO does not distinguish
between coupling to concrete class and coupling to
interface. The motivation for measuring coupling to
interface is discussed further in Section 2.
The usage of OO metrics is hampered by the fact
that the results are in numerical form making it difficult

1550-6037/08 $25.00 © 2008 IEEE
DOI 10.1109/IV.2008.96

575

Additionally a graphical technique (described in
Section 4) is used to indicate a subset of a particular
metric by a thicker line segment for the subset value. In
JCTIViz we use this technique to separate out coupling
to concrete class from coupling to interface
The technique of a thickened line segment along a
dimension is also used in JCTIViz to indicate the
proportion of methods in the target class that are
potentially invoked polymorphically via an implemented
interface or an abstract super class. The reasoning behind
this is to gain an insight into the extent to which a class
is likely to have been designed to participate in a looselycoupled collaboration with other classes. It is envisaged
that being able to examine the extent of potential
invocation of a class via interface alongside the
incidence of fanout coupling via interface will provide an
indication of the degree to which loose coupling has
been designed into a system. Other metrics that analyse
the incidence of polymorphism [1], [5], [21] are
significantly different and do not address these concerns.
This section has set the scene for the threedimensional approach to software metrics visualisation
as described in more detail in the rest of the paper.
Section 2 will examine further the motivation for
measuring coupling to interface; Section 3 will describe
the calculated metrics in more detail; Section 4 will
describe their visualisation model implemented by
JCTIViz, and Section 5 will describe the tool in more
detail; Section 6 will show some sample results; Section
7 will describe future work.

maintenance overhead involved in the use of interfaces
also needs to be made [14].

3. Definitions of the metrics
CBO was originally defined in [6] as follows: “CBO
for a class is a count of the number of non-inheritance
related couples with other classes”. Coupling within the
inheritance hierarchy for the measured class was ignored.
The definition was later changed to “CBO for a class is a
count of the number of other classes to which it is
coupled” [7], thereby allowing for inheritance-related
couples to be counted. There is a further clarification that
“two classes are coupled when methods declared in one
class use methods or instance variables defined by the
other class”. CBO counts a single couple to a class or
interface even if several cases of the couple to it are
found – for example a case of a call to constructor of
class A and several method calls on class A are treated as
one couple.
Table 1 shows a comparison of this interpretation to
that of two other tools used for the calculation of the
CBO metric: CKJM [26] and iPlasma [24]. For CKJM,
the data in this table was generated by a combination of
tests and reading the user documentation. For iPlasma
the data was obtained purely from tests, since no details
of CBO analysis are provided in the documentation.
In our interpretation for JCTViz, the following are
included in CBO analysis for a target class: the classes
(including inner classes) of objects that are used to make
method calls; classes whose constructors are called; a
class extended by the target class; interfaces
implemented by the target class; the classes accessed via
public attributes of another class. Excluded from the
CBO analysis are cases of usage of library rather than
application classes; object-reference method parameters
and local variables that are never used for method
invocation; inner classes that are defined but not used.
We define a metric Coupling to Interface (CTI) as a
count of a subset of CBO where only object references
via a Java interface or abstract class are included when
performing the coupling count. The name JCTIViz is
derived from Java CTI Visualisation. (It was decided not
to include calls to overriden methods in determining CTI
even though these involve potential programming to
interface; this is because overriden subclasses may or
may not be present in the class set being analysed – for
example in the case of a framework designed to serve a
variety of applications not present in the system)
We also define a metric Number of Descendant
Methods (NODM) which is a count of all methods that
are implementations of abstract methods specified in an
abstract superclass or in an interface implemented by the
target class.

2. CBO and coupling to interface
Several studies including [4], [11], [16], [25], [28]
have been carried out examining correlation between the
major metrics suites and fault incidence. The results vary
in these studies with differing reports of the correlation
of fault-proneness with CBO and with other metrics. A
more limited amount of research [8] has also focused on
correlation of metrics with quality indicators such as
maintenance and rework effort.
In these studies of CBO no distinction is made
between coupling to interface and coupling to concrete
class. A reasonable hypothesis would be that for classes
with a high proportion of the coupling being to interface,
the correlation to indicators such as fault incidence, or
rework and maintenance effort may be less pronounced.
A fruitful area of future research would be to carry out
empirical work to investigate this issue. Maybe only for
cases where the ratio of couples to interface as against
couples to concrete class is low, can the CBO metric can
be considered a reliable indicator of fault-proneness or
rework and maintenance effort. Or maybe better
correlation can be obtained by modifying CBO so that
couples to interface are not counted. Thus we consider
coupling to interface is a useful metric to explore.
It should be emphasized, however that firm quality
conclusions should not be drawn from high indicators of
programming to interface. A trade-off against the extra

576

Table 1: Comparison of CBO interpretations
Criteria for inclusion in CBO

CKJM

iPlasma

JCTViz

Non-library classes (including inner classes) and interfaces of methods called

y

y

y

Non-library classes (including inner classes) of constructors called

y

n

y

Non-library class extended by target class

y

n

y

Non-library interfaces implemented by target class

y

n

y

Any usage of Java SDK library classes

n

n

n

Any usage of library classes outside of classes being analysed

y

n

n

Types of reference attributes declared but not used as targets for method calls

y

n

n

Types of local reference variables declared but not used as targets for method calls

n

n

n

Types of reference method-parameters declared but not used as targets for method calls

y

n

n

Types of references to public attributes of another class

n

y

y

the implementation of abstract or overriden
methods – that is the NODM value.
• Also, the right edge along the depth (z-axis) is
thickened and extended to represent the CTI
metric as defined in Section 2.
Our 3D box is a variant of a polymetric node and
this connection is also evident in the fact that we use
NOA and NOM for the front face of the 3D box. A
polymetric node can represent up to five metrics. Our 3D
box can potentially represent much more than that by
thickening visible edges and colouring visible sides of
the box, but at this point we have limited our graphical
representation to five metrics. CBO, CTI and NODM are
the three other metrics that we will visualise (Figure
1(b)). CBO will be plotted along the depth or z-axis of
the box. CTI, being a subset of CBO, will also be plotted
along the z-axis. A thicker line is used so as to
distinguish CTI from CBO visually. Similarly, NODM is
plotted along the right vertical edge of the front face of
the box. NODM is a subset of NOM.
It is felt that the introduction of colours outside of
the black to white range would not be necessary for the
information to be conveyed, would unnecessarily limit
the output medium for visualisation especially for hard
copy output, and would not be appropriate for colourimpaired users.

4. The visualisation representation
For the visualisation of our coupling and
polymorphism metrics, we propose a three-dimensional
version of the “polymetric views” concept. In Figure 1
we compare a single polymetric node representing a
given class with our proposed visualisation for a single
class.
The main characteristics of our proposed
representation are:
• Each class or interface is represented by one
node.
• The node is a white 3D box with a black outline
drawn on a 2D plane. The box is not coloured.
The 2D plane is sufficient since at this point we
do not require any sort of 3D interaction. This is
also in keeping with the simplicity of the
polymetric view that we are building upon.
• The height and width of the 3D box are
determined by standard Number of Methods
(NOM) and Number of Attributes (NOA)
metrics.
• The depth of the 3D box is determined by the
CBO metric, which is part of the proposed
metrics set, described in Section 2, for JCTIViz
• The right vertical edge of the front face of the
3D box is thickened and extended to a height
that indicates how much of NOM accounts for

577

Figure 1. A Polymetric Node (a) and the proposed JCTIViz Node (b) The implementation of JCTIViz
BCEL is very useful for static analysis of code
behaviour within bytecode, especially for purposes such
as calculating metrics. The fact that JCTIViz can
perform the metrics calculations on .class files means
that source files do not need to be present – a significant
advantage when compared to metrics tools that rely on
the presence of source code.For our visualisation, we
elected to draw the 3D boxes on 2D planes in the same
vein as standard 3D bar graphs using G [13], a Java
graphics library that is scene-graph based thereby
providing much more capabilities than standard Java 2D.
It has features to rival a 3D environment, but is 2D
based.

5. The implementation of JCTViz
JCTIViz follows the example of CKJM [26] in using
the Apache Byte Code Engineering Library (BCEL) [2]
for implementing the metrics. The BCEL API provides a
number of useful ways to parse and access information
within a .class file. A .class file contains bytecode and is
generated by Java compilers from Java source code.
When given a .class file, a BCEL ClassParser
object encapsulates access to the file in a JavaClass
object. We then use a variety of methods on this object to
get information from the .class file.

Figure 2 View of JPetstore in JCTIViz

Figure 3 Partial View of Eclipse in JCTIViz

578

Figure 4 Partial View of ArgoUML in JCTIViz

Figure 5 Partial View of OptimalJ in JCTIViz
Although our simple 3D box visualisation model
could just as easily be implemented using standard Java
2D, we opted to use G in anticipation of future iterations
of our proposed tool needing to use some of the
advanced features of G.
Extremely high values of coupling are not displayed
in the visualisation. We set an upper limit on all the
metrics that are being visualised, so while a box with
high values will look significantly different from other
boxes, it will not occupy too much space in the
visualisation. Although not currently implemented, it is
envisaged that clicking on a box will take the viewer to a
list of classes or interfaces that the measured class or
interface is coupled to.

6. Running JCTViz and some results
Even in its current form as a prototype tool, JCTIViz
proved to be fast and highly scalable and was able to
analyse and visualise applications ranging from small
systems to much larger ones. For instance, on a desktop
personal computer (Pentium 4, 2.4 GHz, 1 Gbyte RAM),
running JCTIViz on Spring JPetStore, the Spring [27]
version of the popular J2EE BluePrint application, took
less than 1 second for all 73 classes. For ArgoUML [3],
an open-source UML modelling tool with over 1500
classes, JCTIViz took 6 seconds.
Figure 2 shows the visualisation for the Spring
JPetStore sample application. Spring is currently

579

emerging as the leading lightweight Java server side
application framework and its strong support for the
inversion of control pattern [12] naturally leads to design
involving programming to interface. In the visualisation,
the lengths of the z-axis components of the boxes are
shown to be present in most of the classes. As can be
seen, however, there is good presence of programming to
interface and polymorphic behaviour. The classes that
make use of dependency injection are clearly identifiable
from the solid line portion of the z-axis coupling
dimension.
It is interesting to note from the visualisation that
programming to interface is not universally employed
throughout the system, even for a sample application
based on a framework that promotes loosely coupled
systems. This is an example of how caution is required to
avoid simplistic conclusions concerning quality from a
reading of these visualisations.
Figure 3 shows a partial view of some classes from
the Eclipse [10] interactive development environment.
Only four of the classes shown have coupling to
interface. Polymorphic behaviour is also sparse. Most of
the classes have quite small NOA and NOM values, but
are significantly coupled to other classes.
Figure 4 shows a partial view of visualisation for
ArgoUML produced by JCTIViz.
OptimalJ [9] is a popular model-driven development
tool for creating enterprise Java applications. It is a
commercial, closed-source Java-based tool and despite
the absence of source code, JCTIViz can perform the
metrics analysis based on the .class files. Figure 5 shows
a partial view of some classes in OptimalJ. Almost every
class presented in the visualisation has 100% coupling to
interface as shown by the thick lines along the depth of
the boxes. There is also a good presence of potential
polymorphic behaviour as indicated by the thick vertical
lines.

can be used to indicate CTI intensity instead of
the thick lines along the z-axis. Similarly,
instead of the thick vertical lines along the right,
the front face of the 3D box can be shaded to
show the level of polymorphism. Alternately,
both methods can be implemented and the user
can choose a preferred visualisation option.
• A transition to a 3D graphics environment,
providing 3D objects in a 3D landscape (rather
than the current linear ‘3D bar graph’ approach)
and visual nesting of class packages in the style
of CodeCity. This would involve revamping of
the existing visualisation model providing for
complex user interaction.
Additionally we have proposed further more general
research to distinguish between coupling to interface and
coupling to concrete class in correlation analysis with
quality indicators such as fault detection and
maintenance/rework effort.

8. Conclusions
This paper, has outlined a tool for providing an
alternative graphical representation of coupling within an
object-oriented system, exploring, extending, and
modifying existing approaches to visualisation of such
systems. Even at a prototype stage, the results generated
by our tool so far show that it can be used to gain
important insights into the characteristics of a system.
Especially significant are the novel ways for providing
visual indicators of the degree to which coupling to
interface and potential polymorphism are present,
although we recommend caution in deducing quality
conclusions from these, since programming to interface
can and often does involve other maintenance overheads.
We conclude that future work on the metrics model
and visualisation model is expected to be fruitful.

7. Future work

9. References

The following changes are envisaged for JCTIViz:
• An interactive facility to allow classes and
interfaces coupled to the target class to be
navigated to. An additional facility will be
offered to show coupling fanout lines for an
individual class interactively. Empirical work
with developers will be needed to test out this
graphical model combining coupling size
represented by the depth dimension for all
nodes with selective display of line coupling for
an individual node. Such empirical work would
involve a comparison with the more crowded
conventional representation where fanout
coupling lines for all nodes are shown.
• The tool can be expanded to include a whole
host of metrics with the viewer selecting which
metrics to visualise and along which axis of the
3D box.
• Similar to the polymetric views, colouring the
right side face of the 3D box in shades of grey

[1]

[2]
[3]
[4]

[5]

[6]

580

Abreu, F.B. and Carapuça R. Object-Oriented Software
Engineering:
Measuring
and
Controlling
the
Development Process, Proceedings of the 4th
International Conference on Software Quality, McLean,
USA, October 1994
Apache Software Foundation, BCEL [Online] Available
from: http://jakarta.apache.org/bcel/, 2006
ArgoUML
[Online] Available from http://argouml.tigris.org/
Briand, L.C.,Wuest, J., Ikonomovski, S. and Lounis, H.
Investigating Quality Factors in Object Oriented
Designs: An Industrial Case Study, Proceedings of
International Conference of Software Engineering, pp
345-354, 1999
Brito e Abreu, F. and Melo, W. Evaluating the Impact
of Object-Oriented Design on Software Quality,
Proceedings of the 3rd International Symposium on
Software Metrics, Washington DC, USA, IEEE
Computer Society, pp 90-99, March 1996
Chidamber, S.R. and Kemerer, C.F. Towards a Metrics
Suite for Object Oriented Design. Conference

[7]
[8]

[9]

[10]
[11]

[12]
[13]
[14]

[15]

[16]

[17]

[18]

[19]
[20]

[21]

[22]
[23]

Proceedings on Object-Oriented Programming Systems,
Languages, and Applications, Phoenix, USA, November
1991, New York: ACM Press, pp. 197-211, 1991
Chidamber, S.R. and Kemerer, C.F. A Metrics Suite for
Object Oriented Design. IEEE Transactions on Software
Engineering, 20(6), pp. 476-493, 1994
Chidamber, S.R., Darcy D.P., and Kemerer, C.F.
Managerial Use of Metrics for Object-Oriented
Software: An Exploratory Analysis. IEEE Transactions
on Software Engineering, 24(8), pp. 629-639, 1998
Compuware,
OptimalJ
–
Model-driven
development for Java [Online] Available from:
http://www.compuware.com/products/optimalj/
default.htm, 2007
Eclipse Foundation, Eclipse – an open development
platform
[Online] Available from http://www.eclipse.org/, 2007
El Eman, K., Benlarbi, S., Goel, N.and Raj, S.N., The
Confounding Effect of Class Size on the Validity of
Object Oriented Metrics, IEEE Transactions on Software
Engineering Vol 27, pp 630-650, 2001
Fowler, M. Inversion of Control Containers and the
Dependency Injection pattern [Online] Available from:
http://martinfowler.com/articles/injection.html, 2004
GeoSoft G – Java 2D Graphics Library [Online]
Available from: http://geosoft.no/graphics/, 2004
Ghassemi, M.D. and Mourant, R.R. Evaluation of
Coupling in the Context of Java Interfaces. Addendum to
the 2000 Proceedings of the Conference on ObjectOriented Programming, Systems, Languages, and
Applications, Minneapolis, USA, New York: ACM
Press, pp 47-48, October 2000
Graham, H., Yang, H.Y., and Berrigan, R. A Solar
System Metaphor for 3D Visualisation of Object
Oriented Software Metrics. Proceedings of the 2004
Australasian symposium on Information Visualisation Volume 35, pp. 53-59
Gyimóthy, T., Ferenc, R. and Siket, I. Empirical
Validation of Object-Oriented Metrics on Open Source
Software for Fault Prediction, IEEE Transactions on
Software Engineering, Vol 31, No 10, pp 897-910, 2005
Lanza, M. and Ducasse, S. Polymetric views - a
lightweight visual approach to reverse engineering. IEEE
Transactions on Software Engineering, 29(9), pp. 782795, 2003
Lanza, M. and Marinescu, R. Object-Oriented Metrics in
Practice: Using Software Metrics to Characterize,
Evaluate, and Improve the Design of Object-Oriented
Systems. Leipzig, Germany: Springer, 2006
Lanza, M. CodeCrawler - Polymetric views in action.
Proceedings. 19th International Conference on
Automated Software Engineering, pp. 394-395, 2004
Lanza, M. and Wettel, R. Visualizing Software Systems
as Cities. VISSOFT 2007: 4th IEEE International
Workshop on Visualizing Software for Understanding
and Analysis, pp. 92-99, 2007
Liu, X. and Periyasamy, K. A New Metrics Set for
Evaluating Testing Efforts for Object-Oriented
Programs, Proceedings of the Technology of ObjectOriented Languages and Systems, pp 84-93, 1999
Lorenz, M. and Kidd, J. Object Oriented Software
Metrics: A Practical Guide. Prentice-Hall, 1994
Mackinnon, T., Freeman, S., and Craig, P. Endo-Testing:
Unit Testing with Mock Objects. In: eXtreme
Programming and Flexible Processes in Software

[24]

[25]

[26]
[27]
[28]

[29]

581

Engineering – XP2000, Cagliari, Sardinia, Italy, June
2000
Marinescu, C., Marinescu, R., Mihancea, P.F., Ratiu, D.,
and Wettel, R. iPlasma:An Integrated Platform for
Quality Assessment of Object-Oriented Design,
Proceedings of the 21st IEEE International Conference
on Software Maintenance, Budapest, Hungary,
September 2005
Olague, H.M., Etzkorn, L.H., Gholston, S. and
Quattlebaum, S. Empirical Validation of Three Software
Metrics Suites to Predict Fault-Proneness of ObjectOriented Classes Developed Using Highly Iterative or
Agile Software Development Processes, IEEE
Transactions on Software Engineering, Vol 33, No 6, pp
402-419
Spinellis, D. ckjm - Chidamber and Kermerer Java
Metrics [Online]: http://www.spinellis.gr/sw/ckjm, 2006
SpringSource Spring Framework [Online] Available
from: http://www.springframework.org/, 2008
Subramanyam, R. and Krishna, M. Empirical Analysis
of CK Metrics for Object-Oriented Design Complexity:
Implications for Software Defects. IEEE Transactions on
Software Engineering Vol 29, No 4, pp 297-310 April
2003
Viswanathan, S.S. Coupling Metrics and Visualisation,
Dissertation for Master of Science, London South Bank
University, 2007


Connectivity Compression for Three-dimensional Planar Triangle Meshes
Kanuengnij Kubola and Henry Chu
The University of Louisiana at Lafayette, Center for Advanced Computer Studies,
P.O. Box 44330, Lafayette, LA 70504-4330, U.S.A.
{Email: cice@cacs.louisiana.edu}

Abstract
We describe a new algorithm for coding the
connectivity information of three-dimensional planar
triangle meshes. Vertices of a mesh are placed on a
two-dimensional grid. The connectivity pattern of the
grid is implicit and hence the only information that
needs to be encoded is the diagonal links. We present
experimental results that show that the new method
has a low connectivity cost of 2.1 bits per vertex on
average.

1. Introduction
Graphical display of a three-dimensional (3D)
surface is the most effective means for
communicating to a user an observed scene, such as a
terrain, or a scientific computation result, such as a
surface plot. In a 3D scene, object surfaces are
tessellated as meshes, consisting of polygonal patches,
the simplest of which is a triangle. Triangular meshes
are widely used also because graphics hardware often
optimizes its performance for rendering triangles. In
an increasingly networked society, the ability to
render a 3D scene via a remote, either wired or
wireless, connection allows a much greater variety of
applications, such as surveillance, telemedicine, and
telerobotics.
With remote connection, fast data transfer
becomes very significant especially for interactive
graphic applications containing 3D models. This kind
of application can contain a large number of models
and each model contains many thousands of vertices
and polygons. A very large model with millions of
triangles can slow down the data traffic and lead to an
unacceptable performance.
The general representation of triangle meshes
contains a set of vertices and a set of triangles or
connectivity. The set of vertices consists of the
coordinates of vertices and it may sometimes include

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

normal vectors and a set of texture vertices. The
connectivity contains a series of triangles, each of
which is represented by three vertex indices.
The connectivity cost of a mesh is measured in
terms of the number of vertices. Let V be the total
number of vertices. A simple binary code requires that
log2(V) bits be used to represent these vertex indices.
Thus, at least 3log2(V) bits is needed per triangle so
that 3Tlog2 (V) bits are needed when T is the total
number of triangles. From the Euler formula, the
number of triangles for simple meshes is about twice
the number of vertices. Therefore without any
compression it costs approximately 6Vlog2 (V) bits for
a set of triangles with V vertices.
Different connectivity compression methods for
triangle meshes have been proposed in the literature.
Turan [1] presents an encoding scheme of unlabeled
connected planar graphs and maps using 12V bits.
Keeler and Westbrook [2] improve Turan’s work and
their encoding scheme for planar graphs and maps
needs 4.6V bits for the connectivity cost.
Gumhold and Strasser [3] introduce a
compression algorithm that uses seven building
operations to assign the traversal order for the mesh.
The mesh can be rebuilt from its compressed form
using the operation codes as well. Using Huffman
encoding, the compression uses between 3.4V and
4.3V bits.
Touma and Gotsman [4] encode the connectivity
of a mesh using three operations: add, split, and
merge. The key idea of this method is to encode the
number of the incidence edges and analyze the other
cases automatically using this number. Using a
combination of run-length and entropy encoding to
compress their codes, the connectivity cost is 0.2V
bits for very regular meshes. For smaller and less
regular meshes, the connectivity cost is between 2V
and 3V bits.
Taubin and Rossignac’s method [5] uses a
peeling-orange-skin style by cutting a mesh along the
edges that corresponds to a vertex-spanning tree.
After cutting the edges, it produces a simply

connected polygon. A vertex spanning and a trianglespanning tree are used to represent the mesh. After
compressing these two trees using run-length coding
algorithm, the compression result is about 4.4V bits.
In [6], Rossignac presents an algorithm that
encodes each triangle at a time using five operation
codes. Starting from an arbitrary edge and traversing
along a spiraling vertex-spanning tree, it identifies an
operation code according to a classification of its
adjacent vertices and edges. The compression result is
between 3.4V and 4V bits for any mesh with few
handles and bounding edges. After applying entropy
encoding to the connectivity encoding, it gives 2.6V
bits plus 32000 bits for a dictionary.
Recently, King and Rossignac [7] claim a
guaranteed 3.67V bits for compressing the
connectivity of planar triangle graph using their new
codes to improve the compression rate from
Edgebreaker’s encoding.
We propose a new method for coding the
connectivity information of a mesh. In our method,
the vertices from each fetched triangle are placed on a
grid and the connectivity information made implicit
by the grid do not need to be encoded. Hence, we can
improve the connectivity cost for planar triangle mesh
to 1.39V bits for a best case, and 3V bits for the worst
case using Huffman coding. The connectivity cost of
this approach is, on average, 2.1V bits.
In the next section, we describe our new
connectivity coding algorithm. Experimental results
are presented in Section 3. Finally, we draw some
concluding remarks in Section 4.

2. New connectivity coding algorithm
The motivation for our new coding algorithm is
as follows. Consider a planar triangle meshes in
which each vertex has no more than eight links to the
other vertices around it. This mesh can be rearranged
as a grid while preserving the linkage information
(Figure 1). From this observation, we recognize that
for any such simple meshes, if we can line those
vertices on a grid according to their connectivity to
the other vertices around them and keep their
connectivity information, we can present a new face
connectivity representation that can reduce a great
deal of storage cost.
The new connectivity coding algorithm has four
steps: grid filling, object boundary detection,
connectivity encoding, and connectivity compression.
We present them in order in the following.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

2.1. Grid filling
Grid filling is the most critical step of the new
algorithm. Triangles from the list are processed, or are
considered as active, one at a time. If it is the first
triangle on the list, we can simply place its three
vertices on the grid. For each subsequent triangle, if it
has less than two of the three vertices already on the
grid, we keep it on the list for processing later.
An active triangle then has either two or all three
of its vertices already on the grid. The key step is to
assign the first and the second indices in the triangle
according to their order in the triangle and their
appearance on the grid. In most rendering methods
for a mesh, the vertices of each triangle are traversed
in a fixed direction, either clockwise or
counterclockwise, for the whole mesh. Let a triangle
with three vertices indexed j, k, and n, denoted <vj, vk,
vn>, be active. If vj and vk are already on the grid, then
vj is assigned to be the first vertex of this triangle.
Likewise, if vk and vn has already been placed on the
grid, then vk is considered to be the first vertex of this
triangle. On the other hand, if vj and vn are already on
the grid, then vn instead of vj is assigned to be the first
vertex because of the traversal order.
For each triangle, we find a suitable location on
the grid for each vertex of the triangle so that it
connects properly to the other vertices. It is possible
that there are more than one possible locations to
place the vertex, and that choosing the wrong location
will result in incorrect connection of the vertex to
others. This in turn may make placement of some
latter vertices to be impossible. Therefore, a
Backtrack scheme is used when the grid has not been
filled properly. The Backtrack scheme is called when
there is an error on filling the grid. The idea of the
Backtrack scheme is that it will reset every filling
information from the current point back to the last
location that there are two possible locations to
choose from.
Consider the placements of the vertices of a
triangle on the grid. The first vertex can be placed
without any constraints. There are eight possible
nearest neighboring locations of the second vertex
relative to the first.
In four of these eight
configurations, there are two allowable locations to
place the third vertex.
In the other four
configurations, there is only one location to place the
third vertex.
The location of the third vertex is constrained
because of the traversal order and because the three

vertices must form a triangle. Consider one of these
configurations, as shown in Figure 2. Suppose we
traverse the vertices in a clockwise fashion. In this
example, the second vertex is placed to the right of
the first vertex and occupies the cell numbered 3,
relative to the first vertex. The third vertex must be
directly linked to the second vertex and so cells
numbered 0, 7, and 6 are not possible locations. The
positions to the right of Cell 3 (outside the block of 9
cells in Figure 2) are not possible locations because
they do not have a direct link back to the first vertex
to make a triangle. The third vertex cannot be in any
of the positions above the second vertex (cells 1 and
2) because it would violate the traversal order. This
leaves only the immediate lower and the lower left
positions for the third vertex (cells 4 and 5). The
allowable positions for the other seven cases can be
derived similarly.
If the third vertex cannot be placed because the
allowable positions are occupied, Backtrack is called.
If two allowable positions are available, the one that is
not taken is noted in the history list so that Backtrack
can use it later.
If all three vertices of an active triangle are
already on the grid, we check to see if the vertices are
connected properly according to the active triangle. If
so, the triangle is popped from the list; otherwise,
Backtrack is called.
At the end of Grid Filling, the vertices are placed
on the nodes of a 2D grid. At each node, the vertex is
assumed to be connected to any existing neighbor to
the left, right, above, and below. In addition, a node
can have one or more diagonal links.
These
connectivities are recorded at the node.

2.2. Object boundary detection
Because not all of the grid nodes are populated
after the Grid Filling process, we want to extract that
portion of the grid that contains vertex information.
This portion is typically centered on the grid buffer
and we use a simple scheme to detect an occupied
grid from eight directions, viz. top, right, bottom, left,
upper left corner, upper right corner, lower right
corner, and lower left corner. The resulting bounding
polygon can have up to eight sides. All the nodes
inside the bounding polygon that do not have a vertex
are marked with a special symbol of “-1”.

2.3. Connectivity encoding
The reduction in connectivity storage costs in our
method lies in the fact that some of the connectivity
patterns are implicit, and hence not coded. By
arranging the vertices on the grid, each vertex is

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

assumed to be connected to its neighbors above,
below, left, and right of it. If we scan the vertices row
by row from the top left, we only need to consider the
connectivity codes to the neighboring vertices to the
upper right and the lower right. There are five
connectivity conditions: (1) the grid is blank,
corresponding to the “-1” symbol noted above; (2) the
vertex has no diagonal link to the right; (3) the vertex
has a diagonal link to the upper right neighbor; (4) the
vertex has a diagonal link to the lower right neighbor;
and (5) the vertex has diagonal links to both neighbors
to the right.
At the end of connectivity encoding, the symbol
stream consists of (i) the bounding polygon
information; (ii) the set of vertices on the grid in raster
scan order; and (iii) the sequence of connectivity
codes, corresponding to the abovementioned five
conditions.

2.4. Connectivity compression
In Connectivity Compression, we compress the
new encoded connectivity representation obtained
from the Connectivity Encoding process using a
source coder such as huffman coding based on the
probabilities of the connectivity symbols. Each of the
five conditions coded in the Connectivity Encoding
step is translated to a binary code word.

2.5. Decoder
The encoder outputs a binary stream based on
placing the mesh triangles on a grid, essentially
eliminating the need to encode the implicit links. As
such, the encoding is lossless and so the decoder only
needs to undo each of the four steps in the encoder.
The Huffman code is translated back to a symbol
stream. The bounding polygon information is used to
note the beginning row and columns of the vertices.
The list of vertices is combined with the blank
overhead to place the vertices on the populated grid
nodes. The connectivity code at each node adds any
existing diagonal links. The triangles can then be
extracted and an equivalent mesh containing the
vertex and triangle lists is reconstituted.

3.

Results and analysis

We studied the performance of the proposed
connectivity compression algorithm using a number
of meshes representing different terrains. An example
mesh is shown in Figure 3. We used a total of five
data sets with different number of vertices and
triangles. Their sizes are shown in Table 1.

Similar to many meshes, especially those that
represent terrain data, the data sets we used have a
rectangular support. Consequently, there are no blank
nodes inside the bounding polygon: every node is
occupied by a vertex. These therefore represent the
best case scenario for our compression algorithm. We
use the occurrences of the various symbols (Table 2)
to construct the Huffman code for each set. The
connectivity cost can be computed by multiplying the
occurrence of a symbol with the length of its
corresponding codeword (Table 3). In this best case,
the average length of the Huffman codeword for each
vertex is 1.39 bits averaging over all the data sets, so
that the connectivity cost is estimated at 1.39V bits.
The overhead introduced by having blank nodes
inside the bounding polygon will add to the
connectivity cost, degrading the compression
algorithm. The frequency of the blank symbol (“-1”)
depends on the degree of convexity of the mesh
support on the grid. We extrapolate the degradation
of performance by setting the frequency of the blank
symbol to 0.25 and 0.5 of the total. The new
frequencies are then used to determine new sets of
Huffman codes, and the connectivity costs are
averaged over the data sets.
When the blank symbol frequency was set to 0.25
of the vertices, the average Huffman code word length
was 1.70 bits. Since the encoded data contain the
connectivity codes of V vertices plus 0.25V for the
additional blanks, the connectivity cost is (1.7V +
1.7×0.25V) = 2.1V bits for this average case. When
the number of blank symbols increases to 0.5 of the
total number of vertices, the average Huffman code
word length became 1.83 bits. The connectivity cost
then becomes 2.75V bits.
We note that in a worst case scenario of having
all five symbols being equally probable, the Huffman
code word length is 2.4 bits and the connectivity cost
becomes 3V bits.

4.

References
[1]

[2]

[3]

[4]

[5]

[6]

[7]

G. Turan. On the succinct representations of graphs.
Discrete Applied Mathematics, vol. 8, pp. 289-294.
1984.
K. Keeler and J. Westbrook. Short encodings of
planar graphs and maps. Discrete Applied
Mathematics, no. 58, pp. 239-252. 1995.
S. Gumhold and W. Strasser. Real time compression
of triangle mesh connectivity. Proc. ACM Siggraph
98, pp. 133-140. 1998.
C. Touma and C. Gotsman. Triangle mesh
compression. In Proceedings Graphics Interface 98,
pp. 26-34. 1998.
G. Taubin and J. Rossignac. Geometry compression
through topological surgery. ACM Transactions on
Graphics, vol. 17, no. 2, pp. 84-115. 1998.
J. Rossignac. Edgebreaker: Connectivity compression
for triangle meshes. IEEE Transactions on
Visualization and Computer Graphics, vol. 5, no. 1.
1999.
D. King and J. Rossignac. Guaranteed 3.67V bit
encoding of planar triangle graphs. In Proceedings of
11th Canadian Conference on Computational
Geometry, pp. 146-149. 1999.

9

1
8 1

1

7
1 0

3 5

1
9 8 1
1 2 4 7
1 0 3 5 6

Concluding remarks

We presented a new method for encoding the
connectivity information of a mesh of triangles.
Experimental results show that the new method can
compress the mesh using fewer bits than methods
reported in the literature. The limitation of the
proposed method is that no vertex can have more than
eight links to its neighbors. We note that if the mesh
contains any vertex that has more than eight links to
the other vertex around it, we can simplify such
meshes to reduce the number of edge links to less than
or equal to eight by applying a mesh simplification
algorithm. This modification will result in a slightly
lossy compression method.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

Figure 1. Placing a triangle mesh on a 2D
grid. A triangle mesh (left) can be
arranged into rows (center) and then as a
2D grid (right).

0

1

7
6

2
3

5

4

Figure 2. Placing the three vertices of a
triangle on a grid. In this example, the
second vertex is placed to the right of the
first. This leaves only two allowable
positions for the third vertex because of
the vertex traversal order.

Table 1. Size of the data sets used in the
experiments.
Data set
Landscape 1
Landscape 2
Landscape 3
Landscape 4
Landscape 5
Landscape 6

Number of
Vertices
900
972
2,809
5,625
64,400
155,013

Number of
Triangles
1,682
1,820
5,408
10,952
127,782
308,416

Table 2. Number of occurrences of various
symbols for different data sets.
Data set
Landscape1
Landscape2
Landscape3
Landscape4
Landscape5
Landscape6

No. of
0s
519
72
1,559
3,080
25,141
96,941

No. of
1s
348
0
1,188
2,469
39,055
57,781

No. of
2s
25
865
45
63
100
138

No. of
3s
8
35
17
14
104
153

Table 3. Connectivity cost of data sets.
Data set
Landscape1
Landscape2
Landscape3
Landscape4
Landscape5
Landscape6

Figure 3. A data set used in our
experiments. Mesh “landscape 3” has
2,809 vertices and 5,408 triangles.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

No. of
Vertices
900
972
2809
5625
64400
155013

No. of
Bits
1322
1114
4138
8263
90053
213514

Bits per
Vertex
1.4689
1.1461
1.4731
1.4687
1.3983
1.3774


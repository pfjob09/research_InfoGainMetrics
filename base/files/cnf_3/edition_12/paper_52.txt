CO-planar Shape-Fitting Using the Rotating Squares Algorithm
C.Maple
Department of Computing and Information Systems,
University of Luton, Luton, Beds, L U l 3JU.
carsten.maple@luton.ac.uk
Abstract
Rotating Squares is a method based upon the
Marching Cubes algorithm of Lorensen and Cline, [4].
I t is used as a method for storing a piece-wise linear
approximation of a 2 dimensional object, see [l].A p proximations to two distinct shapes can then be easily
compared to f i n d common boundary segments. However, it is also possible to use the algorithm to determine how to align the two shapes an a plane, such
that they have the longest possible boundary segment
in common. I t is this issue that is addressed herein. Examples are given in which, while finding alike
boundary segments, the Rotating Squares algorithm
does not provide a n edge along which the two shapes
can be aligned without intruding upon one another.
W e present a simple test that can be used to indicate
any space-sharing violation. Since the motivation for
this work arose in three dimensions we go o n to give
considerations necessary for lifting the algorithms to
three dimensions.

1. Introduction
The Marching Cubes algorithm of Lorensen and
Cline, is a surface rendering technique used to produce 3D images given point data from 3-space. The
data is given on orthogonal grids over parallel planes;
two consecutive slices are used to define a marching cube, four neighbouring pixels that form a square
from each. The pixel data is transformed into values
of either 0 or 1; a 0 corresponding to a vertex lying
outside the surface, a 1 corresponding to all other vertices. This information is then used t o determine the

way in which the surface intersects a cube, if indeed
it does. The Marching Cubes algorithm then uses
rendering techniques produce 3D images. The rotating squares algorithm does not utilise the rendering
component of the marching cubes algorithm.
Section two of this paper gives an overview of the
rotating squares algorithm and section three highlights problems using the method when trying to fit
shapes in a plane. A method is produced, in section
four, that overcomes the problems shown in section
three , before we summarise and conclude in section
four.

2. Rotating Squares
As in [l], we begin by defining the marching
square. This can be used t o give a piecewise-linear
approximation to a two-dimensional shape. An image is, usually, electronically scanned and the bitmap
pixel values then used t o give function values over a
grid. If a shape is defined by a series of equations
over intervals, then these are used to determine the
enclosed shape which is then used to define the function values over a uniform grid. Each gridpoint is assigned a value of either 0 or 1, depending on whether
or not that point is on the surface. The values are
then used to assign a value to each square that denotes the manner in which the shape boundary and
square coincide. The linear approximations used along with corresponding indices are shown in Figure
1. We will use simple examples to demonstrate the
marching squares algorithm. Let us assume we are
considering two shapes, shape A and shape B , that

343
0-7695-0743-3100$10.00 0 2000 IEEE

0 0 0 c 1 0 0 1 1 M
0

1

2

3

4

5

6

To find similar boundary segments the representation of shape A , A, is compared to a conjugate of
the representation of shape B , B' (b:,j = 15 - b i , j ) ,
where

1

uaommmai.
8

9

10

II

12

13

14

15

/ 15 15 13 12 14 15 15 15 15
15 13 8 0 4 12 14 15 15
15 9 0 0 0 0 4 1 4 1 5
1 5 1 1 1 0 0 0 0 6 15
1 5 1 5 9 0 0 0 0 6 1 5
2 3 1 6 15
1513 8 0
7 15 11 7 15
( 15 11 3
3

Figure 1: The approximations index.

Figure 2: The approximations to shapes A , B , and
A,respectively.

A=

0
0
0
0
0
0
0

2 7 1511
4 14 15 15
0 6 1515
2 7 15 15
6 15 15 15
4 14 15 15
0 6 13 14

7
15
15
15
15
15
15

1 5 9
13 8
9 0
11 1
15 9
13 8
11 1

0
0
0
0
0
0
0

,

This shows the similar boundary segments, given
by the non-zero elements listed above. This algorithm stores unnecessary function values, leading to
unnecessary computation and storage. The boundary squares algorithm however combats this by only storing significant function values and minimising
the number of trivial function value computations. The boundary squares algorithm effectively tracks
the boundary edge using a table.
To find alike boundary sections, the boundaries of
the two shapes must be traversed in opposite directions. For our earlier examples we obtain the following two one-dimensional arrays. Traversing Shape A
in a clockwise direction gives

A = (2,3,1,2,3,1,9,8,13,9,11,1,9,8,13,11,1,
8,12,12,4,14,13,8,4,6,14,4,6,2,7,6,

a=

( 0 0
0 2
0 6
0 4
0 0
0 2
, 0 4 1

2
7
15
14
6
7
2 1

3
15
15
15
15
15
2

1
11
15
15
15
13
8

0
3
15
15
15
12
0

0

0

0

1
11
15
15
14
4

0
1
9
9
9
8

0
0
0
0
0
0

14,4,2,7);
and Shape B anticlockwise yields

E3 = (2,7,2,6,4,14,6,7,2,4,12,12,8,13,12,14,
4,8,9,9,9,1,11,1,3,1111,3),

344

it-<’

giving

i

B‘ = (13,8,13,9,11,1,9,8,13,11,3,3,7,2,3,1,
11,7,6,6,6,14,4,14,12,4,14,12).

f

.

>

We see that d[8..16] = B’[2..10], giving the common boundary edge segment expected. The rotating
squares algorithm can be used to test for common
edge segments from four orientations at once using
Figure 3.
Consider Shape A, Figure 2c, Shape A rotated
through n l 2 anti-clockwise and Shape B. We have,
for Shape A traversed in a clockwise direction

.>
)

.._I.

,

*

.

..* ......

.
.. ...

.,

.

.~

. . ..
i

.
. . ...I

,..+

:

.,...... ,
,

:*

A

^

,

.

.

.

_,.~.
.

Figure 3: The approximations to shapes C and D.

C

= (1,3,3,3,1,7,1,1,7,7,1,3,1,3,1,7,7,3,7,1,
7,3,1,1,3,3,3,1,7,1,7,1,1,7,3,3,3,3).
For D’we obtain

and for Shape B anti-clockwise

Z?

= (14,12,8,12,8,12,12,14,12,14,12,8,14,8,
8,12,8,14,14,8,12,12,8,12,14,8,12,8,14,
14,8,8,14,8,12,12,12,8),

D’

=

(7,1,7,7,3,7,7,3,1,7,1,1,7,7,1,3,1,3,1,7,
7,3,7,1,7,3,7,1,7,1,7,3,3,3,7,1,1,7,7,

3,3,3,3,3).

Comparing these we see that C[4..23] = D‘[8..27].
This shows the longest similar boundary segment between the two, yet by observation, we can see that
these two shapes cannot fit together along this edge,
if they are to remain co-planar. Let us define the
origin, (0,O) in the zy-plane, to be at the point corComparing these we see that 2[4..12] = B’[5..13]. responding to the centre of the square C[4], and place
Again this the the common edge segment expected. Shape D with the centre of the square of D’[8] also at
the origin. We see that both shapes occupy space in
( - l , O ) , amongst others. The two shapes with rigid
3. The Co-planarity problem
boundaries cannot be placed fitting along that edge,
whilst remaining co-planar. We present, in the nexWhen using any of the methods mentioned in
t section, an algorithm to determine whether or not
the previous section, it can be seen that whilst they
there is a space sharing violation when two shapes
do find a common boundary segment, they do not
are joined along an edge.
consider whether or not, if placed together along this
edge, the two shapes intrude upon one another. We
give an example of shapes that give rise to such prob- 4. An algorithm for shape-fitting in a
lems. We shall use very simple examples for illustraplane
tion purposes. Consider the two shapes with approximations shown in Figure 3.
Denoting a reference point as the origin, we can
Using the rotating squares algorithm applied in a compute the coordinates of all grid squares on each
of the shape’s boundary. In order to determine if the
clockwise direction to Shape C gives
giving,

345

shapes are co-planar we compute the function values of the boundary grid squares using an inverse
Boundary Squares algorithm. That is, we simply
use the inverse mapping of that used for Boundary
Squares. The boundaries of two diffent shapes may
pass through the same grid square in some instances.
If one shape occupies a square and has a boundary
squares value of 1, then as long as the other shape
that has a boundary through this grid square, does
not have a boundary value that corresponds to the
lower left pixel being on the surface, there is no space
sharing violation. It is a simple task to construct a
table that has premitted combinations of boundary
values in a single grid square.
The algorithm for co-planar shape fitting in a plane
can be foramlised as follows:

1. Given Rotating Squares representations of two
shapes, find the best match using a string compare.
2. Let the first common boundary square for both
shapes be at the origin, (0,O).

3. For each shape, compute the function values of
all boundary grid squares not in the common
edge segment.
4. Store each functional value and the corresponding boundary grid square coordinate in an array
of width 3, for each shape, C X Y and D X Y , say.
The first row should contain the x coordinates,
the second the y and the third is the boundary
squares value.

We will demonstrate this algorithm by example.
Given Rotating Squares representations of the two
shapes earlier, find the best match using a string
compare. We let the origin, (0,O) of the xy-plane,
lie at the location of the centre of the first common
boundary square of both shapes. In this example,
therefore, the origin is in the centre of the square C[4]
and D[8]. For Shape C the grid squares coordinates
and its corresponding functional value is stored in a
two-dimensional array, C X Y , such that C X Y [i,11
and CXY[i,2] contains the coordinates (z,y) and
CXY[i,3] contain the boundary value for C[i]. As
we do not need to compute the boundary value of
the common edge segment, we begin the array at the
first non-common boundary square. We assume that
we approach this square from the left direction; although any direction can be chosen. The array C X Y
is given below:
2
2
1
0 -1 -2 -2
CXY=
-7 -8 -8 -8 -8 -8 -7
8
12 12 12 4
14
1
-3 -3 -4 -4 -3 -3 -3
-7 -6 -6 -5 -5 -4 -3
14 4
2
6
4
7
6
-3 -3 -3 -2 -1
-2-1
0
0
0 )
6
6
2
3
3

(

Applying the same process, we construct
2
2
3
3
4
4
DXY=
-7
-6 -6 -5 -5
-4
8 13 8 13 8
9

5. For each i , j , such that CXY(i, 1) = D X Y ( j , 1)
and C X Y ( i , 2 ) = D X Y ( j , 2 ) , check that the
boundary value combination is permitted.
6. If all boundary value combinations are permitted, then the shapes can be aligned, along the
common boundary edge segment, in the plane.

(

DXY:
4
4
-3

-2

9
9
4
3
3 4 4 2 3 1 0
- 1 - 1 0 0 1 1 1 1 1
1 1 1 1 3 8 1 3 3 3 3
-1 -2 -2 -3 -3 -2 -1 -1
0
0 - 1 - 1 - 1 0
1
1
3 2 7 2 4 1 2 8 3

1

To establish if the shape’s fit is co-planar, the
function
values of common coordinates in C X Y and
7. If the alignment fails, find the next longest comD
X
Y
are
investigated. We see that both shapes ocmon edge segment and repeat steps 4-6.
cupy (2, -7), but the boundary values are 1 and 8 re8. This process is continued until the length of the spectively, and this is a permitted combination (the
next longest common edge segment is lower than 1 means that the lower left vertex is part of shape
some prescribed length.
C , and the 8 means that the upper left vertex is part

346

;i.;.,
I

give rise to a space sharing violation. To examine
the shapes with regard to the existence of a valid
translation, we only require the common boundary
~ . .
in terms of the rotating squares algorithm, not in
..*.
..................
terms of the indexing as per the previous section,
.~
, ."
+
though we shall use this indexing to aid clarification
.. 1
. .. -. _..
. " .
of the example. We also note that we only wish to
determine whether or not a valid translation exists,
Figure 4: The approximations to shapes E , and F , we do not need to find it.
respectively.
The rotating squares algorithm applied to shapes
E and F yields a common boundary segment represented by the sequence
of shape D.) There is, however, a combination at
( - 3 , O ) that is not permitted.
. .. .. .

--

...

.,.

..

I

i

~

s =

5. Considerations for application of the
algorithms in three dimensions
We have thus far restricted attention to two dimensions. The ultimate goal however, is to detect
how to three dimensional objects may lock together. In this section we outline considerations required
when extending these algorithms to three dimensions.
We now consider Figure 4, which has two shapes
E and F that can be seen to have a good fit in two dimensions, without any space-sharing violation.
There is however a problem if we wish to place the
shapes together along this common edge without lifting one the two shapes into the third dimension. That
is, there is no 'slide' (a combination of translation
and rotation) that can be performed in the plane
such that the two shapes can come together. Obviously this is a rather trivial problem in two dimensions, since we could just lift one piece. However, in
a three dimensional scenario this is not possible. It
would, therefore, be useful to have some test to determine whether or not such a slide was possible. If
we can develop this in the two dimensional case, it
may give inspiration to solving the problem for three
dimensions. We present here a simple test to ascertain whether there is a linear translation that can be
used to move the two shapes together when originally
apart.
If we consider shapes E and F and apply the ideas
already mentioned in this paper, we can find that
the shapes have a common boundary that does not

with respect to a clockwise traverse of the shape
E . This sequence is invariant to the orientation of
the shape modulo 7 1 2 , hence while we consider the
shape E as given, we realise that we can make the assumption that this is the correct orientation without
explicitly knowing i t . We shall investigate, primarily,
whether the two shapes can be joined by a slide along
a line perpendicular to the edge defined by the initial
7 in the sequence.
We now present an argument that can be used to
determine whether or not there is a 'neck' in the common boundary edge, as in the case of shapes E and
F ( the neck can be seen to be between the left of
square (0,-1) and the left of square (0,-2),using indexing as in the previous section.) In order to determine
whether or not a valid translation exists, we develop
the notion of an angle-sum. The way in which we do
this is to consider the angle between the edge along
whose perpendicular we are attempting to translate
(we shall call this the reference edge), and each other
edge represented in S. We denote the angle relative
to a clockwise direction. Hence, the angle between
the edge represented by the first 1 in S, and the edge
represented by the first 3 in S is ~ / 4 whereas
,
the angle between the edge represented by the first 3, and
the edge represented by the second 7 is - ~ / 4 . We
give a table that shows the angle between two edges
with the rotating squares index given.
In order to determine the angle between the reference edge and any other edge in s, we simply use an

347

squares can be developed in three dimensions to form a compact method to store information on protein
structure. Any comparisons between three dimensional objects would require the use of graph matching techniques rather than string matching methods,
Table 1: A table showing the angle between consec- and this work is currently ongoing at the University
utive edges
of Luton.
inductive rule. The angle is given by adding the angle
between the previous edge and the edge of reference
to the angle between the Previous edge and the current edge. If the angle is greater than 7r/2 then we do
not have a valid translation along the reference edge.
Equally, if the angle is less than -7r/2, then there
does not exist a valid translation (this represents a
neck in the other shape we are trying to fit.)
We now let the reference edge take all values in
S to allow us to determine whether or not a valid
translation exists.
In the
Of shapes E and F 9 we have
the
sequence
with reference edge represented by the first 7 in
(0,~ / 4 , 0 , 0 , 0- ,~ / 4 ,-7~12,- ~ / 4 ,-7~12,- 3 ~ 1 4 ,-IT,
- 3 ~ 1 4 ,- 1 ~ 1 2-, ~ / 4 ,- 1 ~ 1 4 ) .
We can see here that this translation is not valid.
We should note that if implementing this in an
algorithm, we do not need t o use every edge as a
reference edge. Any edges that give rise to a zero in
a sequence of angle sums, is obviously parallel to that
particular reference edge, and so can be eliminated as
a candidate reference edge.

References

s:

6. Conclusions and further work
In this paper we have refined the rotating squares
algorithm to the point where consideration of violation of the rigid nature of the objects is considered. We have also given a further test to determine whether or not one of the two object requires
lifting in the third dimension before two shapes can
be placed together. This should also make it more
useful when extended to three dimensional docking
problems. Some of the algorithms presented herein
can now be extended to three dimensions in a fairly
strightforward manner. It is hoped that the rotating

348

[l] Donafee, A., Maple, C., (2000) Rotating Squares
Journal of P a t tern Recognition, submitted.

[21 Heiden, w.7 Goetze, T.7 Brickman% J . 7 (1993)
Fast generation of Molecular-Surfaces from 3D
Data Fields with an Enhanced Marching Cube
Algorithm, Journal of Computational C h m istry, 14, 2, 246-250.
[3] Levitt, D.G., Banaszak, L.J., (1992) Pocket - A
Computer-Graphics method for Identifying And
Displaying Protein Cavities and Their Surrounding Amino- Acids, Journal of Molecular Graphics, 10, 4, 229-234.
[4] Lorensen, W.E., Cline, H.E., (1987) Marching
Cubes: A High Resolution 3D Surface Construction Algorithm, Computer Graphics, 21, 4, 163169.
[5] Zhou, C., Shu, R.B., Kankanhalli, M.S., (1994)
Handling Small Features in Isosurface Generation Using Marching Cubes, Computers &
Graphics, 18, 6, 845-845.
[6] Zhou, C., Shu, R.B., Kankanhalli, M.S., (1995)
Adaptive Marching Cubes, Visual Computer,
11, 4, 202-217.


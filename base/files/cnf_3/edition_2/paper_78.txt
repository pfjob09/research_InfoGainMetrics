2010 14th International
Information
Conference
Visualisation
Information Visualisation

Bobox Model Visualization
Jiˇr´ı Dokulil
Faculty of Mathematics and Physics,
Charles University, Prague, Czech Republic
dokulil@ksi.mff.cuni.cz

Jana Katreniakov´a
Faculty of Mathematics, Physics and Informatics,
Comenius University, Bratislava, Slovakia
katreniakova@dcs.fmph.uniba.sk

Abstract

approaches to graph visualization relevant to our problem.
The Section 4 describes the algorithm we have created to
visualize Bobox models. The last section concludes the paper.

The Bobox project is a parallelization framework based
on the idea of putting together a number of simple components to create a data processing, non-linear pipeline.
The structure (the model) of the pipeline a directed graph,
but with several specific properties. In order to display
the pipeline in a debugger application that is a part of the
framework, we have adapted some of the graph drawing algorithms to leverage the specific properties and challenges
found in Bobox model visualization.

1

2

Writing software that can execute in parallel in C++ using just the services provided by the operating system is
a very complex and error prone task. To make it easier,
several libraries and compiler extensions have been created. The Bobox framework is one such technology. It
provides a run-time environment that is used to execute a
non-linear pipeline in parallel. The pipeline consists of
computational components provided by the user and connecting parts that are part of the Bobox framework. The
structure of the pipeline is defined by the user but the communication and execution of individual parts is handled by
the run-time based on several rules and the pipeline’s structure. This simplifies the design of the individual computational components, since communication, synchronization
and scheduling are handled by the framework.
The main idea behind Bobox is to connect a set of relatively simple computational components into a (non-linear)
pipeline. The data then flow through the pipeline, which
controls the execution of the individual computational components. The components are executed in parallel, when
they have data to process. But each computational component is guaranteed by the system not to be executed in parallel. Furthermore, the interface between the components and
the rest of the system is created to eliminate any possible
race conditions when reading inputs and writing outputs.
So if the components do not communicate by other means
than by sending messages over the pipeline, they need not
handle problems common to parallel programming.
In Bobox, the user first specifies a model. The model defines the way in which the individual computational components are connected. The model is then instantiated to
produce a model instance. There are several elements that
form the model instance.

Introduction

One of the main trends in software development today is
parallel processing of data [7, 10]. Most CPUs sold today
have more than one core and with multiple slot CPUs and
HyperThreading technology [1], one computer node may
easily reach 32 physical cores and 64 logical threads in the
near future. On the other hand, the performance of the individual cores is increasing very slowly due to physical limits,
most notably to maintain manageable levels of heat output.
We may expect, the number of cores and logical threads will
further increase.
The Bobox project is a framework and library that is designed to allow programmers to easily create complex, nonlinear pipelines that execute in parallel. The structure of
such pipeline is defined by a model, which is a graph that
defines the way in which the individual components of the
pipeline are connected.
During the development of the system, we realized that
we need a way to visually present the model. Due to some
specific features of the way the model is put together and the
requirement to display textual information withing the visualization, we decided to adopt some of the already-known
visualization algorithms to better suit our needs.
The rest of the paper is organized as follows: the following section briefly introduces the Bobox project, Bobox
models and their properties. The Section 3 describes several
1550-6037/10 $26.00 © 2010 IEEE
DOI 10.1109/IV.2010.79

Bobox

527
537

They differ mostly on the placement of the vertices. Each
of them have some pros and cons. First of all we introduce
them briefly.

Box is the computational component mentioned in the
previous text. It has zero or more inputs and zero or more
outputs in the pipeline. Via represents one link in the
pipeline. It connects one output of one box to one or more
inputs of other boxes. The link only provides one-way data
transfer. Envelope is the smallest unit of data transfered
through the pipeline. When a box sends an envelope to one
of its outputs it is sent to the appropriate via. The via then
makes a copy of the envelope for each box on the receiving
end of the link and sends the copy to the appropriate box.
The model is an almost exact image of the structure of
the instance. It is composed of box models and via models
that define the types of boxes and the links to be used in the
model instance. This model may often be a complex structure and in common scenarios it is computer generated – a
query written in a query language is translated to a Bobox
model specific to the query and then executed to produce
the query results. Debugging such complex parallel computation is very complicated, so the computation creates a
log that can later be displayed. To understand the logs, the
user must be familiar with the way the model looks. It is
not sufficient to know that a box B just sent some data to its
outputs, the user needs to know what the output is.
To give the user some idea, it is best to visualize the
Bobox model. The visualization has to be an interactive
part of the tool that displays the logs, it has to be compact
and clear. Although the model is a directed graph, there are
some specific features that can be used by the visualizer to
produce better drawing. The most interesting properties are:

3.1

Layering-based Algorithms

The layering algorithms place the vertices on layers. The
commonly used hierarchical approach (originally presented
in [9]) consist of four basic steps (see Figure 1):
Layer assignment step: The vertices are assigned to horizontal layers. The concept of layering of a digraph is
similar as topological numbering. The layering should
be as compact as possible.
Proper layering: The resulting layering should be proper
(i.e. every edge should connect vertices in neighbouring layers). This can be achieved by adding dummy
vertices on edges with span bigger than 1.
Crossing reduction: Having a proper layered digraph we
reduce number of crossings by ordering vertices on
each layer. In fact, the problem of minimizing edge
crossings in layered digraph is NP-complete [5], hence
various heuristic algorithms are used for this purpose.
Horizontal coordinate assignment step: By
replacing
dummy vertices introduced in second step, bends in
edges may occur. This step should minimize the angle
of bends by choosing the x-coordinate for each vertex.

3.2

Grid-based Algorithm

• the graph is conencted,
The grid-based algorithms instead of the layering-based
place the vertices into a grid and the edges are oriented upwards (or downwards).
An example of grid-based algorithms is the visibility approach (first presented in [3, 2]), which uses a so-called visibility representation of the graph. A visibility representation Γ of a graph (see the Figure 2(b)) is an alternative way
of drawing graphs, where each vertex is drawn as a horizontal (vertex) segment Γ(v) and each edge as a vertical (edge)
segment Γ(e). The only intersection of the edge segments
and vertex segments are the top and bottom points of the
edge segments, which are common with segments of vertices to which the edge is incident. Having the visibility
representation, we get the positions of vertices by replacing
each vertex segment with one point of the line (Figure 2(c)).
The edges are connecting incident vertices containing some
part on their edge segment. We obtain drawing where edges
are represented by polylines.
Because the visibility representation requires a planar
graph, the first step in visibility approach algorithms must
be planarization. The algorithm is mostly used for drawing
planar acyclic st-graphs – i.e. for planar acyclic graphs with
exactly one sink and one source.

• there is one source and one sink in the graph,
• in general, the graph is not a DAG, but there are very
few (often zero) edges that create cycles

3

Graph visualization

A drawing of a graph is its representation on the plane.
Formally, the drawing of a graph is a function which maps
vertices of the graph to distinct points of the plane and edges
to simple curves with ends in adjacent vertices.
In order to effectively draw a graph, we would like to
take into account a variety of properties. Aesthetic criteria
attempt to characterize readability by means of general optimization goals. Commonly adopted graph drawing aesthetics include minimizing crossings, area, bends (in orthogonal
drawings), slopes (in polyline drawings) and maximizing
smallest angle or display of symmetries. However, for different models and visualizations the important criteria may
vary.
For the visualization of acyclic graphs, we use two basic types of algorithm – layering and grid based algorithm.

538
528

1
1

2

1

3

3

4

2

3

1

2

3

4

4
2

5

5

5

5
4

6

6

(a) Directed Graph

6

(b) Proper Layered Digraph

6

(c) After Crossing Reduction

(d) Final Drawing

Figure 1. Hierarchical Approach
9

9

9
7

8

6

8

4

7

6

4

5
3

7

8

5

5
3
2

3
2

2
1

1
(a) Directed Graph

6

4

1

(b) Visibility Representation

(c) Polyline drawing

Figure 2. Visibility Approach

4

Visualization of Bobox

vertices of G such that the numbering fulfills the condition (u, v) ∈ E(G) ⇒ number(u) <= number(v) +
weight(u, v). An optimal (weighted) topological numbering is (weighted) topological numbering, where for each
vertex v the number(v) cannot be reduced.
Graph G∗ = (F, E ∗ ) is said to be dual to the graph
G = (V, E) if E ∗ = {(f, g) | ∃e ∈ E(G) \ (s, t) :
f = lef t(e) and g = right(e)}. We also call the edge
(f, g) ∈ E ∗ to be dual to the edge e ∈ E if f = lef t(e)
and g = right(e). It is obvious, that the dual graph to a
planar st-graph is also planar st-graph.
The properties of the dual graph used in the algorithm
are depicted bellow.

For the visualization of the model of Bobox we have to
draw a directed graph. However, the vertices of the graph
should not be points on the plane. Since the vertices should
contain some amount of text, they should be visualized as
rectangles with some (already known) width and height.
In this section we first give a more detailed algorithm for
the visibility representation and then modify this algorithm
for the purpose of the Bobox model visualization.

4.1

Visibility Approach Algorithms

In previous section we briefly described the visibility approach. Since the algorithm for visualization of the Bobox
model is based on this approach, we need to describe these
algorithms in greater detail.

e
left(e)

First we list some terms, we will use in further text.
A topological numbering of G is numbering of the vertices of G such that the numbering fulfills the condition
(u, v) ∈ E(G) ⇒ number(u) < number(v). An
weighted topological numbering of G is numbering of the

right(e)

left(v)

v

right(v)

The visibility representation of a planar st-graph is constructed by the following algorithm.

539
529

graph G and its dual to compute the coordinates. Instead of
it, we do not use unified weights of edges.

V ISIBILITY R EPRESENTATION(G)
1 G∗ ← Dual graph of G
2
3 X← OPTIMAL TOPOLOGICAL NUMBERING OF G*
4 Y← OPTIMAL TOPOLOGICAL NUMBERING OF G
5
6 for each v in V
7
do Γ(v) ←
8
LINE [X(left(v)),Y(v)] to [X(right(v)-1),Y(v)])
9 for each e = (u, v) in E
10
do Γ(u, v) ←
11
LINE [X(left(e)),Y(u)] to [X(left(e)),Y(v)]

The y-coordinate of the vertex in visibility representation
is influenced by the numbering in the st-graph G. We make
the weights on these edges equal to the height of the vertex
(the space the vertex needs on the y-axis). More formally,
the weight of the edge e = (u, v) will be weight(u, v) =
height(u). After the weighted topological numbering step,
it is assured that the number assigned to all descendants of
u is greater or equal than the number assigned to u plus
its height. This means that the vertex u has enough space
for its height on the y-axis. Moreover the vertex does not
influence vertices on independent paths (i.e. paths with no
common edges with the path between s and t containing u).

Having the visibility representation, we get the positions
of vertices by replacing each vertex segment with arbitrary
point of the segment. The edges connecting incident vertices follow the edge segment, except for the immediate
neighborhood of the vertices. We obtain the polyline drawing.

The x-coordinate is more difficult. We need to evaluate the edges in the dual graph. Just to remember, the
set of edges in the dual graph of G was defined as E ∗ =
{(f, g) | ∃e ∈ E(G) \ (s, t) : f = lef t(e) and g =
right(e)}.
Trivially, the weight of the edge (f, g) ∈ E ∗ , dual to
the edge e = (u, v) ∈ E is the maximum of widths of
the neighboring vertices u and v. However, if some vertex
(even a wide one) has many neighbors – for example many
children – its width can be ’divided’ between these vertices.
Therefore we set two values for each vertex:
weightin (v)
=
⌈width(v)/degin (v)⌉ and
weightout (v) = ⌈width(v)/degout (v)⌉.
The edge
(f, g) ∈ E ∗ dual to the edge e = (u, v) ∈ E has weight
equal to the maximum of weightout (u) and weightin (v).
Although these weights are not optimal (in future we
plan to improve the evaluation), the visibility representation guarantees enough space to put the rectangles into the
resulting grid (see an example in Figure 3(f)).

P OLYLINE(G=(V,E))
1 for each v in V
2
do P (v) ← arbitrary (xv , yv ) from Γ(v)
3 for each e = (u, v) in E
4
do if (y(v)-y(u)=1)
5
then LINE P(u) to P(v).
6
else POLYLINE P(u) to P(v)
7
through (x(Γ(u, v)), y(u) + 1)
8
and (x(Γ(u, v)), y(v) − 1)

4.2

Modification of the Algorithm

If we want to use one of traditional graph drawing
approaches and algorithms for visualizing the model of
Bobox, we have a problem. To recall the drawing of a graph
is formally a function which maps vertices of the graph to
distinct points of the plane and edges to simple curves with
ends in adjacent vertices. But in the model of Bobox, the
vertices are boxes and vias. They both have some width
and hight to fit the text into their representation on the plane.
Thus they cannot be represented as points and we need to
modify the algorithm.
The trivial solution – to place the rectangles in the drawing in the final step – gives insufficient results (see in Figure
3(c)). The problem is caused by the different distribution of
’big’ vertices on independent paths (in this case vertices B
and F). We propose to modify already the visibility representation step so, that we assure, that the rectangles would
have enough place.

The modified algorithm for constructing visibility representation is outlined bellow:
M ODIFIED V ISIBILITY R EPRESENTATION(G)
1 for each v in V
2
do weightout (v) ← ⌈width(v)/degout (v)⌉
3
weightin (v) ← ⌈width(v)/degin (v)⌉
4
5 for each e = (u, v) in E
6
do weight(e) ← height(u)
7
8 G∗ ← Dual graph of G
9
10 for each (f, g) in E ∗
11
do let e = (u, v) ∈ E(G) : f = lef t(e) and
12
g = right(e)
13
weight((f, g)) ←
14
max{weightout (u), weightin (v)}
15

Having planar st-graph G and the heights and widths of
its vertices (see Figure 3(a)) we first construct its dual G∗ .
The basic algorithm for constructing the visibility representation used the topological numbering of the vertices of the

540
530

(a) St-graph

(d) Weights on edges

(b) Visibility representation

(e) Weights on edges of dual graph

(c) Result of basic algorithm

(f) Result of modified algorithm

Figure 3. Algorithm modification

of G. Unfortunately, finding a maximum planar subgraph is
NP-hard and only heuristics are used to this task (the best
available algorithm is described in [6]). Now, we can either
add dummy vertices instead of potential crossings to get a
planar graph or handle the non-planar edges separately (for
example, draw them later using the rerouting algorithm [4]).
After the planarization step, we have a planar st-graph.
The algorithm requires also the acyclicity of the graph.
Therefore, it may be necessary to remove or rotate some
of the edges (for this purpose we can use the algorithm described in [8]).
This way, any Bobox model can be modified to meet the
requirements imposed by our layout algorithm.

16 X← OPTIMAL WEIGHTED TOP. NUMBERING OF G*
17 Y← OPTIMAL WEIGHTED TOP. NUMBERING OF G
18
19 for each v in V
20
do Γ(v) ←
21
LINE [X(left(v)),Y(v)] to [X(right(v)-1),Y(v)])
22 for each e = (u, v) in E
23
do Γ(u, v) ←
24
LINE [X(left(e)),Y(u)] to [X(left(e)),Y(v)]
To construct the final drawing of graph from the visibility representation, we need to place vertices (rectangles)
and edges. Due to the construction of the visibility representation the rectangles have enough space and can be put
directly into the representation in a way similar to the original algorithm. The only requirement is, that the top side of
the rectangle representing vertex v should be placed on the
segment Γ(v).
Drawing of edges can be either handled like in the original algorithm, or the rerouting algorithm [4] can be used.

4.3

5

Conclusions

To address a specific problem of Bobox model visualization, we have adopted the visibility approach to handle
nodes with pre-defined width and height. The design was
greatly affected by the specific graph properties of Bobox
models.
In the future, we intend to further study the properties
of real-life Bobox models, created by e.g. SPARQL or
XQuery compilers. Based on these observations, we may
further improve the drawing.
One of the more obvious improvements is optimizing the
weights used in the dual graph to create narrower drawing.

Input

The graph of the Bobox model is not necessarily a planar
acyclic st-graph. Therefore it is possible, that we need to
perform some pre-processing.
Having a st-graph G we first find some planar subgraph
541
531

A more complex improvement is to move some of the nodes
to a lower level, which may be less crowded, to conserve
even more space and reduce the total width.

Acknowledgments
The work was supported by the grants SVV-2010261312, GACR 202/10/0761 and VEGA 1/0726/09.

References
[1] Shameem Akhter and Jason Roberts. Multi-Core Programming. Intel press, 2006.
[2] G. Di Batista, R. Tamassia, and I. G. Tollis. Constrained Visibility Representations of Graphs. Inform.
Process. Letter, 41:1–7, 1992.
[3] G. Di Battista and R. Tamassia. Algorithms for Plane
Representations of Acyclic Digraphs. Theoretical
Computer Science, 61:175–198, 1988.
[4] Jiri Dokulil and Jana Katreniakova. Edge routing with
fixed node positions. In IV ’08: Proceedings of the
2008 12th International Conference Information Visualisation, pages 626–631, Washington, DC, USA,
2008. IEEE Computer Society.
[5] M. R. Garey and D. S. Johnson. Crossing Number is
NP-Complete. SIAM Journal on Algebraic and Discrete Methods, 4(3):312–316, 1983.
[6] M. J¨unger and P. Mutzel. Maximum Planar Subgraphs
and Nice Embeddings: Practical Layout Tools. Algorithmica, 1(1):1–25, 1996. special issue on Graph
drawing, edited by G. Di Batista.
[7] M. F. Khan, Ray Paul, Ishfaq Ahmed, and Arif
Ghafoor. Intensive data management in parallel systems: A survey. Distributed and Parallel Databases,
7(4):383–414, 1999.
[8] P. N. Klein, S. Rao, M.Rauch, and S. Subramanian.
Faster shortest-path algorithms for planar graphs. In
Proc. ACM Symp. on Theory of Computing, 1994.
[9] K. Sugiyama, S. Tagawa, and M. Toda. Methods for
Visual Understanding of Hierarchical Systems. IEEE
Transitions on Systems, Man and Cybernetics, pages
109–125, 1981.
[10] Patrick Valduriez. Parallel database systems: open
problems and new issues. Distributed and Parallel
Databases, 1(2):137–165, 1993.

542
532


2009 13th International Conference Information Visualisation

Visual Graph Comparison
Keith Andrews, Martin Wohlfahrt, and Gerhard Wurzinger
IICM, Graz University of Technology, Austria
kandrews@iicm.edu

Abstract

into a single reference model.
The following prerequisites for a first prototype were formulated:

Researchers and analysts in many fields are sometimes
confronted with the task of comparing and contrasting
two similar but different graphs or networks. This paper
presents a technique and prototype tool to support the visual
comparison of graphs and the interactive reconciliation of
candidate graphs into a single reference graph. Given two
input graphs and a set of similarities between nodes, the Semantic Graph Visualiser (SGV) computes a merged graph
and allows the analyst to visually compare and contrast the
two input graphs. In a specific example, given two differing models of essentially the same business process derived
from different sources, a process engineer can visually compare them and reconcile them into a single reference model.

1. Assume the two input graphs have are similar
“enough”. if they are too dissimilar, then the merge
graph is meaningless.
2. Assume node similarities are calculated externally and
given with the two input graphs.
User and task anlysis then led to the following requirements:
1. Support interactive editing and management of node
similarities.
2. Present two process models side-by-side.
3. Support a wide range of graph layout algorithms.

1. Introduction

4. Visually “flag” similarities and differences.

Researchers and analysts in many fields are sometimes
confronted with the task of comparing and contrasting
two similar but different graphs or networks. This paper
presents a technique and prototype tool to support the visual comparison of graphs and the interactive reconciliation
of candidate graphs into a single reference graph. Given two
input graphs and a set of similarities between nodes, the Semantic Graph Visualiser (SGV) computes a merged graph
and allows the analyst to visually compare and contrast the
two input graphs.
This work was motivated by a specific example from the
field business process modeling (BPM). In the DYONIPOS
project [4, 15], task instances (individual examples of workflows) are recorded and are used to assist process engineers
build and maintain reference models for business processes.
The business processes are essentially modeled as graphs,
with nodes and edges conforming to a set of predefined semantics (semantic graphs). Given two somewhat differing
models of essentially the same business process, typically
derived from different sources, a process engineer would
like to be able to visually compare them and reconcile them

5. Provide synchronised interaction between the two
models.

978-0-7695-3733-7/09 $25.00 © 2009 IEEE
DOI 10.1109/IV.2009.108

6. Generate a suggestion for a reconciled (merged) graph,
which a business process engineer can then edit.
The Semantic Graph Visualiser (SGV) is a first prototype of an interactive graph comparison system. Figure 1
shows the Semantic Graph Visualizer comparing two process graphs representing workflows involved in buying a
computer.
SGV assumes that its two input graphs are similar
“enough” (Prerequisite 1). This prerequisite is checked
outside of SGV. In the DYONIPOS project, task instances
(individual examples of workflows) are recorded and compared to reference models for business processes. Both task
instances and reference models are examples of semantic
graphs. The similarity between two semantic graphs is calculated as a weighted sum of structural (number of nodes,
number of edges, number of cycles, maximum in-degree,
maximum out-degree, etc.) and semantic (labels, keywords,
metadata) similarity components [10]. Lu and Sadiq [12]
62

Figure 1: The Semantic Graph Visualizer (SGV) comparing two process graphs representing workflows involved in
buying a computer.
discuss a number of similarity metrics which help in the
discovery of business process variants.
The similarity values between pairs of semantic graphs
can then be used for two purposes:

mark areas. In TreeJuxtaposer, the equivalence between
nodes is computed within the system using a measure which
compares sets of leaf labels beneath potentially equivalent
nodes. For business process models, corresponding nodes
often have different labels for the same thing. Context and
metadata are often necessary to decide on potential equivalence, hence SGV adopts the approach of computing node
equivalence externally.
Holten and van Wijk [7] use icicle plots and edge bundles to visually compare hierarchies. They also use external
similarity matching algorithms to determine whether nodes
in the two input trees should be considered equivalent.
Diehl et al [3] calculate a merge graph (they call it a super graph) to determine node positions which do not change
(much) in the context preserving the user’s mental model for
dynamic graph drawing.
Brandes et al [1] propose stacking related graphs in 2.5
dimensions, by computing a layout for a union graph and
stacking separate layers for each set of edges (pathway).
The calculation and layout of a union graph is similar to the
approach of SGV. However, SGV allows external definition
and interactive modification of equivalence and uses a sideby-side layout.

• To search for graphs similar to a given reference graph,
producing a ranked list of matching graphs. Pairs of
similar graphs are then passed to SGV for visual comparison.
• To generate a similarity map where similar graphs
form visual clusters (thematic landscape). Figure 2
shows an example of visual clustering of semantic
graphs from the DYONIPOS project.

2. Previous Work
For the visual comparison of hierarchies, significant
work was done by Munzner et al in the TreeJuxtaposer [13].
In particular, TreeJuxtaposer scales to trees containing over
a hundred thousand nodes by using progressive rendering
and collapsible AccordionTree navigation to provide guaranteed frame rates and by guaranteeing visibility for land-

63

[6] format. A configuration file (also in XML) contains
the names of the two graphs plus a list of node similarities. Figure 3 shows two candidate process graphs
for the process of developing a new software application. SGV constructs a similarity matrix S containing the similarities between each pair of nodes. Where
no equivalence is given, SGV assumes a similarity of
zero.
2. Find Matching Nodes
Figure 2: A similarity map of recorded task instance
graphs produced by DYONIPOS [4]. Close proximity
indicates similar task graphs. A process engineer might
then examine neighbouring graphs side-by-side using a
system like SGV. [Image courtesy of Michael Granitzer, Know-Center Graz.]

Nodes are chosen to match (be equivalent) according
to the similarity values in S, by maximising the sum
of similarities using the Hungarian Algorithm (see the
discussion below). Each node in G1 can match at
most one node in G2 (and vice versa). In order to reduce the number of similarity measures considered by
the matching algorithm, a threshold setting can be applied, below which all similarities are considered to be
zero. This results in an assignment Sm , where matching nodes are coloured green, as shown in Figure 3.

In the field of ontology alignment, Lanzenberger et al
[11] describe a visual tool called AlViz which uses clustering and side-by-side graph visualisation to help an analyst
compare two similar ontologies.
Schreiber [16] produces side-by-side visual layouts for
graph comparison. The algorithm works by identifying subgraphs (distinct sets of edges over the same base set of
nodes) representing metabolic pathways. Identical nodes
in each of the graphs are then temporarily clustered so that
they are placed in the same horizontal layer. Variants of
business process models often do not have exactly the same
node labels, so in SGV node equivalence is determined externally in advance and can then be interactively adjusted.
Graph comparison is also receiving increasing interest
in the field of bioinformatics. As Ogata et al [14] state:
“. . . graph comparison is expected to become most useful
for understanding higher order cellular functions encoded
in the network of interacting molcules.” They use an input
matrix of node equivalences and a heuristic to detect local
similarities between two graphs. However, they do not visually display these similarities interactively.

3. Create Merged Graph
A merged graph Gm is created by combining the two
input graphs and considering the matches from Sm .
First all nodes and edges from G1 are added to Gm .
Then, all non-matching nodes from G2 are added to
Gm . Finally, all edges from G2 are added to Gm and
wired. Edges which connect to matching nodes from
G2 have to be connected to the matching nodes from
G1 . This is illustrated in Figure 4.
4. Lay Out Merged Graph
One of the layout algorithms from SGV is run to lay
out the merged graph (it could also be laid out by hand,
if so desired). This is illustrated in Figure 5.

3. Semantic Graph Visualiser (SGV)

5. Propagate Changes to Original Graphs

The Semantic Graph Visualiser (SGV) implements a set
of standard graph drawing algorithms on top of the JGraph
graph library [8], including Sugiyama-style layered graph
drawing [9, 17] and several variations of force-directed
placement [2, 5].
Visual graph comparison in SGV proceeds in six steps:

Once the merged graph has been laid out, the positions
of its nodes can be propagated back to the two original
graphs, to make side-by-side comparison easier. This
is illustrated in Figure 6.
6. Manually Edit merged Graph

1. Read Two Input Graphs
The process engineer can now manually reconcile the
merged graph by replacing labels and repositioning
nodes.

Two candidate graphs, G1 and G2 , are read into SGV.
The graphs are assumed to be sufficiently similar. Currently, the SGV prototype reads graphs in GraphML

64

Figure 3: Find matching nodes. Two candidate process models for developing a new software application
are visible at top and bottom. At this stage, the central
display simply shows them overlaid.

Figure 5: Lay out merged graph. The merged graph
has been laid out with a layered Sugiyama-style algorithm and now takes up much more horizontal space.

Figure 6: Propagate changes to original graphs. The
positions of nodes in the upper and lower graphs are
now changed to reflect the layout of the merged graph
and make comparisons easier. At this point, the process
engineer can manually reconcile the merged graph by
replacing labels and repositioning nodes.

Figure 4: Create merged graph. The central display
now shows a merged graph, but without any layout being performed. Equivalent nodes from the top (blue)
and bottom (green) graphs have been merged into one.

4. Finding Matching Nodes
shows the calculated assignment Sm , which maximises the
sum of the included similarity values. Matched nodes are
indicated in green. Each row and each column may only
contain one green cell.

The node matching problem merits special mention.
Node similarities are typically distributed over the similarity matrix and several potential candidates exist to become
matching nodes for any given node. In order to obtain unambiguous matches, matches have to be chosen from the
similarity matrix, such that the sum of the similarity values
is maximised. This is an example of the classic assignment
problem in combinatorial optimisation, and can be solved
using the Hungarian Algorithm.
Figure 7a shows an example similarity matrix containing several potential matches for nodes a, b, c, d, e and
A, B, C, D, E. Only nodes f and F are an unambiguous
match.
After applying the Hungarian Algorithm, Figure 7b

5. Future Work
Anecdotally, graphs of several dozen up to perhaps a
hundred nodes can be used with current layout algorithms.
For larger graphs, some kind of graph zooming functionality would need to be built into SGV and the three views
(G1 , Gm , and G2 ) synchronised to the same zoom level.
The Hungarian Algorithm solves assignment problems
in O(n3 ). This time complexity is adequate for current input graphs in the business process setting, which generally

65

using Layout in Two and a Half Dimensions. Journal of Integrative Bioinformatics, 1(1):119–132, January 2004. ISSN 1613-4516. doi:10.2390/biecoll-jib2004-2 . http://journal.imbio.de/articles/
pdf/jib-2.pdf .

(a) A similarity matrix S. Red cells are tagged indicating potential conflict:
there are several potential matches for nodes a, b, c, d, e and A, B, C, D, E.
Only nodes f and F are an unambiguous match and are coloured green.

[2] M. Chalmers.
A Linear Iteration Time Layout Algorithm for Visualising High-Dimensional
Data. In Proc. Visualization’96, pages 127–132.
IEEE Computer Society, San Francisco, California, USA, October 1996. doi:10.1109/VISUAL.
1996.567787 .
http://www.dcs.gla.ac.uk/
matthew/papers/vis96.pdf
.
˜

(b) The assigned similarity matrix Sm . The green cells indicate matching
nodes. The grey cells have been considered for a match but were rejected.

[3] S. Diehl, C. G¨org, and A. Kerren. Preserving the Mental Map using Foresighted Layout. In Proc. Joint Eurographics/IEEE TCVG Symposium on Visualization
(VisSym 2001), pages 175–184. Eurographics, May
2001. http://www.st.uni-trier.de/˜diehl/
pubs/VisSym01.pdf .

Figure 7: The Hungarian Algorithm matches nodes
such that the sum of similarity values is maximised.
have a few dozen nodes and edges, but alternative strategies
would have to be examined for larger input graphs.

[4] DYONIPOS. DYnamic ONtology based Integrated
Process OptimiSation. 2008. http://dyonipos.
at/ .

6. Concluding Remarks
The main contributions of SGV are:

[5] T. M. J. Fruchtermann and E. M. Reingold. Graph
Drawing by Force-Directed Placement. Software:
Practice and Experience, 21(11):1129–1164, 1991.
doi:10.1002/spe.4380211102 .

1. Interactive management of node similarities. The user
can explicitly adjust node similarities and set a threshold value, both of which interactively influence the
node matching process.

[6] GraphML. The GraphML File Format. 2008. http:
//graphml.graphdrawing.org/ .

2. Side-by-side visual comparison of graphs. Two similar candidate input graphs can be interactively visually
compared side-by-side.

[7] D. Holten and J. J. van Wijk. Visual Comparison of Hierarchically Organized Data. Computer
Graphics Forum, 27(3):759–766, May 2008. ISSN
0167-7055. doi:10.1111/j.1467-8659.2008.01205.x
. http://www.win.tue.nl/˜dholten/papers/
visual_comparison_eurovis.pdf .

3. Interactive reconciliation into single merged graph.
Under the control of the user, two similar input graphs
can be analysed and interactively reconciled into a single merged reference graph.

[8] JGraph. Java Graph Visualization. 2008. http://
www.jgraph.com/ .

7. Acknowledgements
The DYONIPOS project was financed by the Austrian
Research Promotion Agency ( http://www.ffg.at )
with strategic objective FIT-IT funding under project contract number 810804/9338. The project partners included
Know-Center Graz, Graz University of Technology, m2n,
Hewlett-Packard, and the Austrian Federal Ministry of Finance.

[9] M. Kaufmann and D. Wagner, editors. Drawing
Graphs: Methods and Models. Springer LNCS Tutorial 2025, April 2001. 3540420622. doi:10.1007/3540-44969-8 . http://www.springerlink.com/
content/xkru1gvnyh5p/ .
[10] M. Kr¨oll, A. S. Rath, N. Weber, S. Lindst¨adt, and
M. Granitzer. Task Instance Classification via Graph
Kernels. In Proc. Mining and Learning with Graphs
(MLG’07). Universita degli Studi di Firenze, August 2007. http://mlg07.dsi.unifi.it/pdf/
14_Kroll.pdf .

References
[1] U. Brandes, T. Dwyer, and F. Schreiber. Visual Understanding of Metabolic Pathways Across Organisms

66

[11] M. Lanzenberger and J. Sampson. AlViz - A Tool
for Visual Ontology Alignment. In Proc. Tenth International Conference on Information Visualization
(IV’06), pages 430–440. IEEE Computer Society
Press, July 2006. doi:10.1109/IV.2006.18 .
[12] R. Lu and S. Sadiq. On the Discovery of Preferred
Work Practice Through Business Process Variants.
In Proc. 26th International Conference on Conceptual Modeling (ER 2007), pages 165–180. Springer
LNCS 4801, November 2007. doi:10.1007/978-3540-75563-0 13 .
[13] T. Munzner, F. Guimbreti`ere, S. Tasiran, L. Zhang,
and Y. Zhou. TreeJuxtaposer: Scalable Tree Comparison Using Focus+Context with Guaranteed Visibility.
ACM Transactions on Graphics, 22(3):453–462, July
2003. ISSN 0730-0301. doi:10.1145/882262.88229
. http://www.cs.ubc.ca/˜tmm/papers/tj/tj.
camready.pdf .
[14] H. Ogata, W. Fujibuchi, S. Goto, and M. Kanehisa. A
Heuristic Graph Comparison Algorithm and its Application to Detect Functionally Related Enzyme Clusters. Nucleic Acids Research, 28(20):4021–4028, October 2000. ISSN 0305-1048. doi:10.1093/nar/28.20.
4021 . http://nar.oxfordjournals.org/cgi/
reprint/28/20/4021.pdf .
[15] A. S. Rath, M. Kr¨oll, K. Andrews, S. Lindst¨adt,
M. Granitzer, and K. Tochtermann. Synergizing Standard and Ad-Hoc Processes. In Proc. 6th International Conference on Practical Aspects of Knowledge
Management (PAKM 2006), pages 267–278. Springer
LNCS 4333, November 2006. doi:10.1007/11944935
24 .
[16] F. Schreiber.
Comparison of Metabolic Pathways using Constraint Graph Drawing. In Proc.
First Asia-Pacific Bioinformatics Conference (APBC
2003), pages 105–110. Australian Computer Society,
February 2003. http://crpit.com/confpapers/
CRPITV19Schreiber.pdf .
[17] K. Sugiyama. Graph Drawing and Applications for
Software and Knowledge Engineers. World Scientific,
March 2002. 9810248792. http://www.wspc.com/
books/compsci/4902.html .

67


On Shape to Specifications Adequacy
Yvon Gardan, Christian Minich, Denis Pallez
Computer sciences laboratory
Metz University, France
{gardan,minich,pallez}@lrim.sciences.univ-metz.fr
Abstract
Computer Aided Design now aims to provide
designers with a support during the early stages of design.
The purpose is to translate the client’s specifications into
a shape as automatically as possible. However, the
processing of a text in natural language is still out of
reach. We then assume that the client’s specifications are
manually translated into intermediate specifications
composed of intermediate constraints upon physical
parameters. Our efforts concern the transformation of
these intermediate specifications into a shape, precisely
the way to compute whether a shape satisfies the
intermediate specifications or not. We first study the case
in which the shape is a single primitive solid; we shall also
give elements to choose the instance that best fits the
specifications. Then, we shall study the extension of the
method to solids defined by a combination of primitive
solids.

1. Introduction
Computer Aided Design now aims to provide
designers with a support during the earlier stages of
design. The purpose is to translate the client’s
specifications into a shape as automatically as possible.
Studies we have listed in that field concern modelling of
design methods or modelling of design products [1].
All the methods (value analysis, SADT, FAST,
QFD…) express a function as a verb and complements.
Thus, their automation implies a semantical processing of
a text written in a natural language, which is still far
beyond computer science capabilities. However, we retain
the attempt of [2, 3] which aims at a system that is able,
under some strong assumptions, to carry out a design
without assistance: products are supposed to be described
in term of rules and design methods in term of meta-rules.
This supposes a very significant formalisation work,
which has only been undertaken in very limited sectors.
Analogy [4, 5, 6, 7] has also been the subject of an indepth study, based in particular on artificial intelligence
techniques. It encounters two main difficulties: detection

of similarities between two products or two specifications
and adaptation to the new product of previous design
solutions.
The efforts in product modelling relate either to the
data structure or to the treatments based on these
structures. For a structure to be complete, it must contain
the history, the shape and the behaviour of the product.
The proposals found in the bibliography generally do not
lead to such a structure. Exceptions are the FBS diagram
[8, 9, 10], which really approaches this objective, and, to a
lesser extent, other tools, which primarily work at a
behavioural level. Consequently, simulation tools are right
now operational: for example qualitative behaviour
analysis [11, 12, 13, 14] or insertion of functional
redundancies in order to improve reliability. An attempt to
take subjective functions into account can also be
mentioned. It consists in expressing subjective criteria as
combinations of objective criteria [15].
As it is difficult to automate the design methods and
as data structures are still inadequate, specifications to
shape automatic translation remains generally out of reach,
excepted in the field of routine designs (gear box,
microprocessor, kitchen…). In such a context, shape and
structure of the product are well known and it is possible
to write a program that generates them from a small set of
functional parameters.
Although it is economically less fundamental, we
would like to come within a more innovative context, in
which the designer has no definite idea of the shape or the
structure of the product. As a complete automation is not
possible yet, the complexity of the problem must be
reduced: functional information can frequently be
expressed as a set of constraints involving so called
physical parameters, defined as quantifiable and
measurable entities referring to the physical world. For
instance, a table is convivial if it is convex (every guest
faces the others), if its perimeter is greater than
Max_nb_persons × 0.9 meter (everybody has enough
space), if the distance between two points does not exceed
5 meters (everybody can ear the others)… Thus, our
simplifying assumption is that the client’s specifications
are translated by the designer into intermediate

specifications composed of intermediate constraints upon
physical
parameters
(for
instance
perimeter >
Max_nb_persons × 0.9). The previous example shows that
this offers the option of taking into account subjective
functions, like conviviality or beauty, as suggested in [15].
Our efforts concern the transformation of these
intermediate specifications into a shape. This raises several
questions such as shape generation and shape quality
calculus. This paper addresses the latter problem, precisely
the way to compute whether a shape satisfies the
intermediate specifications or not.
We shall first give some definitions. Then, we shall
detail the method for checking whether a primitive solid
satisfies the intermediate specifications and we shall
propose some reflections on the way to perform the same
operation on a complex solid.

2. Satisfaction degree
Let us recall that the client’s specifications are
supposed to be translated into a set of intermediate
constraints, which represents the design intent in a
computational format. An intermediate constraint can be
more formally defined as a quadruple <PP, Op, Exp, W>.
PP is a physical parameter. Op is one of the mathematical
relations among {<, >, =, ≠…}. Exp is a real arithmetical
expression that may contain other physical parameters; its
value is called the wanted value. W is the relative weight
of the constraint in comparison with the other constraints
of the intermediate specifications.
We define the Satisfaction Degree SDic(s) of an
intermediate constraint ic by a given shape s as a real
number in the [0,1] interval. This number expresses the
quality with which s satisfies the intermediate constraint
ic. If SDic(s) is near zero, the constraint is badly satisfied,
if it is near one, the constraint is well satisfied. The
method to compute SDic(s) changes depending on whether
s is a primitive solid or a complex object.
We define the Satisfaction Degree SDispec(s) of the
intermediate specifications ispec by a given shape s as a
real number in the [0,1] interval. This number expresses
the quality with which s satisfies the intermediate
specifications ispec. As each constraint is affected a
weight, the SDispec(s) can be computed by the following
formula, which simply is a weighted average of the
constraints satisfaction degrees (n is the number of
intermediate constraints):

6'

V

 
LVSHF

=

∑ 6' V ⋅ :
∑:

1≤ L ≤ Q

LF L

1≤ L ≤ Q

 

LF L

LF L

Figure 1. Satisfaction degree of the specifications as
a weighted average of intermediate constraints SDs
It can be noticed that this formula does not depend on
the type of s. Therefore, it can be applied provided that the
satisfaction degrees of the intermediate constraints are
known.
We shall also call the computation of the SDispec(s)
the estimation of s.
It can be noticed that a formula similar to the one of
Figure 1 is used in [15], to estimate the satisfaction degree
of so-called functional constraints of a product whose
structure and parameters are known. Consequently, their
estimation method allows an automatic tuning of
parameters but it is dedicated to a given object whereas
our method is designed to be applied on any type of
object. We shall see in the next chapter that this might
provide the user with a support during the shape
generation rather than during the shape optimisation.

3. Primitive solids
3.1. Estimation of a primitive solid
Let us assume we want to estimate the satisfaction
degree of the specifications by a given primitive solid
whose parameters values are known. For instance, we
want to know whether a box, whose length, height and
width respectively equal 10, 20 and 8, correctly satisfies
the intermediate specifications. To distinguish these
parameters from the intermediate parameters, the former
are called terminal parameters.
The first step of the estimation consists in computing
the physical parameters values from the terminal
parameters. To perform this process, we need formulas or
algorithms whose inputs are the terminal parameters and
whose results are the physical parameters values. During
the first designs, the user has to give these formulas. Little
by little, the system knowledge will increase and it will be
more and more possible to reuse existing formulas or to
allow the user to combine them, which will save him from
using terminal parameters. For example, suppose that the
volume of a sphere is needed for a given design. There are
three options:
• We already know how to compute the volume from
the radius of a sphere…

• We just know how to compute the surface of the
sphere: the user only has to give the formula that
links the surface and the volume.
• No formula about the sphere is known; the user has
to express the computation of the volume from the
terminal parameters, that is to say the radius.
The computed value of the physical parameter is
called real value. Once it is known, the satisfaction degree
of the intermediate constraint (SDICi) is deduced from the
gap between the wanted and the real values and from a
curve that depends on the mathematical relation used in
the constraint (Op).
The aspects of the curves are given in Figure 2.
SD

SD
1

0.8
0.5

1

wanted 16
value

real
value

2

wanted
value

(for instance : 15)

SD
1

SD
1

0.5

3

wanted
value

4

wanted
value

Figure 2. Mathematical relations curves (>, =, <, z)
for SDs computation
Curve 1 is associated with relation “>”. It is designed
in such a way that the larger the real value is, the larger the
satisfaction degree will be. Most probably, not all
constraints can be ideally satisfied. That is why, curves are
such that, when the constraint is not satisfied, the
satisfaction degree does not necessarily equal zero. This
justifies that, in the above example, the wanted value is the
inflection point of the curve: it has been agreed that the
wanted value corresponds to a 0.5 satisfaction degree. The
designer experiment might lead him to associate another
satisfaction degree with the wanted value. As an example,
suppose the intermediate constraint is “surface > 15”. If
the real value is 16, the satisfaction degree will be around
0.8.
Curve 2 is associated with relation “=”. It is designed
in such a way that the nearer the real and the wanted value
are, the larger the satisfaction degree will be. The shapes
of other curves are motivated by similar reasonings (curve
3 corresponds to relation “<” and curve 4 to relation “z”).
Other curves might be used instead of those of Figure
2, provided that they have similar behaviours.

Once the satisfaction degrees of all intermediate
constraints are known, the satisfaction degree of the
specifications can be computed as indicated in chapter 2.

3.2. Selection of the best primitive solid
Naturally, the estimation must help the choice of the
instance of a primitive that best fits the intermediate
specifications. An intuitive approach might be to let every
parameter vary on IR (eventually IR+), to estimate each
corresponding instance and to memorise the best one.
Obviously, this is computationally unrealistic. That is why
the method we adopted consists in two steps:
• Narrowing the parameters variation intervals with
the help of intermediate constaints. The principle
can be illustrated by the following example:
suppose that the intermediate constraints are
“Surface > 16”, “Surface < 20” and suppose that
we are studying the sphere. The two constraints can
be transformed into the following terminal
constraints: “R > 2/√π” and “R < √(5/π)”. The
radius variation interval has thus been reduced to
[2/√π,√(5/π)]. The translation of the intermediate
constraints into terminal constraints is difficult
because, in most cases, a physical parameter is a
function of several terminal parameters. Formulas
involved in these computations are the opposite of
those that are used to estimate a primitive solid.
Thus, we also think that, little by little, the software
knowledge will increase and relieve the user of
expressing those translations by himself.
• The Cartesian product of all the intervals represents
the potential solutions space among which the best
solution has to be chosen. Four approaches can be
envisaged. One can first retry a systematic
approach by an exhaustive discrete traversal. One
can also think in a formal manner by looking for
the extrema of SDispec(s); as SD is an analytical
function from IRn to IR (n is the number of terminal
parameters), the zeros of its partial derivatives can
be computed in order to obtain the maximum.
However, to know which ones correspond to
maxima, the Hessian matrix, and sometimes the
Taylor’s development, have to be computed. This
raises many numerical problems. The third
approach consists in using an iterative method,
such as the Gradient. The main drawback is that it
gives only local extrema. Finally, heuristics seem to
offer a good compromise between performance and
accuracy. Both simulated annealing and genetic
algorithms seem adapted in our case. We give some
elements to proof the feasibility. Classical problems
of the simulated annealing are random modification

of the current solution, entropy calculus, initial and
final values of the temperature. The modification
can be performed by randomly selecting a terminal
parameter and by randomly choosing the quantity
to be added or subtracted to it (one just has to check
that the parameter stays inside its interval). The
entropy is the satisfaction degree of the
specifications. The initial temperature must
guarantee that all modifications are accepted at the
beginning of the algorithm, that is to say e-∆E /
Init.Temperature
is near one. As ∆E at most equals one, it
suffices to choose the initial temperature very
superior to one. For similar reasons (e-∆E /
Final Temperature
near zero), the final temperature can
be zero. Classical problems of genetic algorithms
are solution coding, solutions crossover and
mutations. A solution can be coded by simply
enumerating the values of the terminal parameters.
The crossover mechanism consists in randomly
choosing values in the two parent solutions.
Finally, to mutate a solution, one just has to change
one or more parameters with random values.
Whichever the solutions space traversal method is, it
will be necessary to check whether terminal parameter
values n-uple (tpv1, tpv2, …, tpvn) belongs to the solutions
space, for instance after a random modification of the nuple. This operation raises difficulties because of the
variation intervals dynamic aspect: when the value of one
of the terminal parameters is set, it may happen that the
variation intervals of other terminal parameters change.
For example, suppose that one intermediate constraint is
“perimeter < 20” and suppose we are looking for the
rectangle that best fits the intermediate specifications.
“perimeter < 20” implies “width + height < 10”, so, for a
given width w, the height varies in [0, 10-w].
Consequently, the variation interval of the height is
dependent of the width value. Thus, to check whether a nuple belongs to the solutions space, one has to check
whether the terminal constraints, from which intervals are
computed, are satisfied.

3.3. 2D implementation
We have implemented the methods described above
to assist a designer with choosing the 2D-primitive shape
(circle, box and triangle) that best fits specifications made
of several intermediate constraints. This was done in C++
using a commercial Rapid Application Development tool.
The approach used to traverse the solutions space is
simply an exhaustive discrete search. For each candidate
shape, the satisfaction degrees of specifications and of all
intermediate constraints are dynamically displayed as
status bars (Figure 3).

The dynamic and continuous evolution of the shape
and of the corresponding SDs provides the end-user with a
comfortable tool to visualise numerous solutions.

Figure 3.
application

Software’s

screenshot

of

our

C++

4. Complex shapes
Generally, parts satisfying the specifications are not
single solids but combinations of primitive solids, called
complex shapes, or assemblies of complex shapes. We do
not address assemblies in this paper because it implies the
use of mechanisms that increase the complexity of shape
generation. Thus, automatic generation of the shape means
automatic generation of a CSG tree. One way to approach
this problem is to generate numerous trees and to select the
best ones with the help of an estimation process. This
chapter proposes some reflection axes about the estimation
process of a complex shape described by a CSG Tree. As
we assume the CSG tree is known, there exist two
possibilities for estimating the complex shape: with or
without incremental boundary evaluation.
In the first situation, the boundary representation of
the complex solid is computed by recursively combining
the sub trees of every node. Then, algorithms are needed to
compute the real values of the physical parameters of the
resulting solid. Once the values are known, the same
reasoning as in chapter 3.1 can be applied to compute the
intermediate constraints satisfaction degrees and the shape
estimation. This sparks off two comments.
For the moment, the only solution we envisage to get
the required algorithms is to ask the user or a computer
scientist to program them. However, here again, it will
probably be less and less necessary to solicit the user, as
the knowledge of the system will increase. Besides, CAD
software already propose many specialised functions
(mass, surface, outflow… computations) that could
probably be used. Finally, let us notice that no better
solution is proposed even in the most recent knowledge
based systems: when a user is up to add a rule in the base,

the methods which query the model in order to get the
values involved in the rule must be available. If they are
not, they have to be programmed.
In addition, the need for a boundary representation is
not necessarily a drawback. In current CAD software, two
models are simultaneously maintained: a design history
(which approximately looks like a CSG tree, although this
is masked by recent formalisms such as form features) and
an evaluated model, that is to say a boundary
representation. Thus, the B-Rep is available and its use in
the estimation process causes no extra computations.
However, a current trend in CAD research aims to
decrease the role of the B-Rep in favour of semantically
higher level models. Thus, basing treatments on a B-Rep
goes against this trend.
To estimate a complex shape without evaluating the
CSG tree (chapter 3.1), one needs to deduce recursively
the intermediate constraints satisfaction degrees from
those of the leaves.
As the intermediate constraints SDs are known for the
primitive solids at the leaves of the tree, a first option is to
deduce, at a given node, the SD of every intermediate
constraint from the SDs of its sons. We briefly envisaged
this eventuality but it quickly appeared that it is
unrealistic. Let us illustrate that with an example. Suppose
that the specifications demand a stable object. A cube on
the floor is very stable: when pushed, it does not roll. So,
the satisfaction degrees of this particular constraint are
very high, near one, for the cubes at the leaves of the
following tree (Figure 4.a). However, according to their
dimensions and positions, the resulting object may be
stable (Figure 4.b) or unstable (Figure 4.c). Consequently,
the knowledge of the sons’ satisfaction degrees is not
sufficient to compute the father’s satisfaction degree.

5. Conclusion and future works
This paper presents our studies of the possibilities to
automatically check whether a shape satisfies the
specifications.
Our opinion is that this operation can not be
performed without a human support, whether the shape is
simple (a primitive solid), or complex (combined object).
However, it seems that the software will be more and more
self-sufficient as its experience will grow, particularly for
simple shapes.
Of course, these works aim to provide the designer
with a support during the generation of a shape satisfying
given specifications. For instance, the estimation function
might be interfaced with a tool able to generate a large
number of CSG trees in order to invalidate automatically
all the unsatisfactory propositions.

6. Acknowledgements
We thank E. Perrin, Computer Aided Functional
Design team at Metz University, for contributing to
discussions that lead to this paper.

7. References

∪

(a)

only possible to approximate the physical parameter very
imprecisely. For instance, consider A ∪ B, A ∩ B and A –
B, where A and B are two primitive solids whose volumes,
vA and vB, are known. The volume of the resulting object
respectively varies in [max(vA, vB), vA + vB], [0, min(vA,
vB)], [0, vA]. This is the best approximation we can provide
without evaluating the object, which would bring back to
the very first method.
As a conclusion, we think that the use of a boundary
representation is the only option that offers real prospects.

(b)

(c)

Figure 4. The combination of two stable simple
shapes (a) may be stable (b) or unstable (c)
As the satisfaction degrees are calculated from
physical parameters’ values and as physical parameters of
the leaves are calculable (chapter 3.2), another approach
could be to recursively obtain the root’s physical
parameters with the help of its sons’ physical parameters.
However, all the attempts we made, concluded that it is

[1] C. Minich, and D. Pallez, “Vers des outils informatiques
d’assistance aux phases amont de la conception – Etat de l’art”,
Revue internationale de CFAO et d’informatique graphique,
Hermes eds., 14, 1999.
[2] H. Takeda, “Towards multi-aspect design support
systems”, Technical Report NAIST-IS-TR94006, Nara Institute of
Science and Technology, Nara, Japan, February 1994.
[3] H. Takeda, and T. Nishida, “Integration of aspects in
design processes”, Artificial Intelligence in Design, Kluwer
Academic Publishers, J. S. Gero and F. Sudweeks editors, 1994,
pp. 309-326.
[4] A. K. Goel, “Design, Analogy and Creativity”, IEEE
Expert Intelligent Systems & Their Applications, 12(2),
May/June 1997, pp. 42-48.
[5] K. Börner, “Structural similarity and adaptation”, Proc.
Third European Workshop Case-Based Reasoning, SpringerVerlag, New York, pp. 58-75.
[6] L. Qian, and J. S. Gero, “A Design Support System
Using Analogy”, Proc. Second Int’l Conf AI in Design, Kluwer

Academic publishers, Dordrecht, The Netherlands, 1992, pp.
795-813.
[7] S. Bhatta, A. Goel, “From design experiences to generic
mechanisms: model-based learning in Analogical Design”, AI in
Engineering Design, Analysis and manufacturing, special issue
on machine learning in design, 10, 1996, pp. 131-136.
[8] T. Tomiyama, Y. Umeda, and H. Yoshikawa, “A CAD
for functional Design”, Annals of CIRP’93, 1993, pp. 143-146.
[9] Y. Umeda, M. Ishii, M. Yoshioka, Y. Shimomura, and
T. Tomiyama, “Supporting conceptual design based on the
function-behaviour-state modeller”, Artificial Intelligence for
Engineering Design, Analysis and Manufacturing, 10, 1996, pp.
275-288.
[10] M. Ranta, M. Mäntylä, Y. Umeda, T. Tomiyama,
“Integration of Functional and Feature-based product
modelling -- the IMS/GNOSIS experience”, Computer Aided
Design, 28(5), 1996, pp. 371-381.

[11] T. Kiriyama, T. Tomiyama, H. Yoshikawa, “The use
of qualitative physics for integrated design object modelling”,
Proceedings of Design Theory and Methodology, ASME Press,
L. A. Stauffer éd, 1991, pp. 53-60.
[12] Y. Umeda, T. Tomiyama, “Functional reasoning in
design”, IEEE Expert Intelligent Systems & Their Applications,
12(2), March - April 1997, pp. 42-48.
[13] O. Salomons, “Dynamic tolerance analysis using
bondgraphs”, Proceedings DETC'98, September, Atlanta, 1998.
[14] University of Twente, Netherlands, http://www.rt.el.
utwente.nl/20sim/clp.htm.
[15] Y. Shimomura, S. Tanigawa, H. Takeda, Y. Umeda, T.
Tomiyama, “Functional evaluation based on function content”,
Proceedings of ASME Design Engineering Technical Conference
and Computers in Engineering Conference, Irvine, California,
18-22 August 1996.


2012 16th International Conference on Information Visualisation

Force-Directed Graph Visualization with Pre-Positioning:
Improving Convergence Time and Quality of Layout
1

Jie Hua , Mao Lin Huang 1,* , Weidong Huang 2 , Junhu Wang3 and Quang Vinh Nguyen4
1
Faculty of Engineering and IT, University of Technology, Sydney, Australia;
2
CSIRO ICT Centre, Australia;
3
School of Information and Communication Technology
Griffith University, Gold Coast, Australia;
4
School of Computing, Engineering and Mathematics, University of Western Sydney, Australia
{*Corresponding Author E-mail: Mao.Huang@uts.edu.au}
to automatically position vertices and edges on the
screen. Many graph visualization algorithms have been
proposed in the literature and they attempted to produce
visually pleasant and easy-to-read graph drawings [1,
12]. Among them, force-directed algorithms are most
widely used in various application domains for drawing
graphs. This is due to the facts that force-directed
algorithms are usually easy to understand, easy to
implement and that the resulting pictures can be
aesthetically pleasant.
A typical force-directed algorithm treats a graph as a
physical system which has two forces: a spring force and
a repelling ring force. The spring force is applied on the
two vertices of an edge. When a spring is pressed, the
two vertices are pushed apart, while when a spring is
stretched, the two vertices are pulled towards each other.
The purpose of the spring force is to keep edges as equal
to the natural spring length as possible. The repelling
ring force is applied on every pair of vertices. The
purpose of this force is to prevent vertices from being too
close to each other. Starting with a random positioning of
vertices, a force-directed algorithm computes the
combined force on each vertex first, and then moves
them accordingly to new positions. This process is
repeated until the convergence of energy is reached.
These algorithms always seek an equilibrium
configuration of forces to reach a locally minimized
energy of layout. This is usually achieved by using a
simple “follow your nose” algorithm that smoothly
moves all nodes from their initial positions to the final
positions through iterations towards an equilibrium
configuration of forces. In general, the “follow your
nose” algorithm works as follows, with nodes initially
placed at random locations of a geometrical plane. At
each iteration (that could be implemented as an
animation loop), the total force applied on each node is
computed, and each node is moved in the direction of the
force by a small amount, thus maintaining the human
mental map.
Therefore, as a tradeoff of such animated
positioning, most of force-directed layout algorithms are
slow in reaching an equilibrium configuration of forces.

Abstract
Modern visual analytics tools provide mechanism for
users to gain unknown knowledge through effective
visual interactions for user to quickly understand the
progress of algorithms and adjust the input parameters
on intermediate visualizations that towards the
production of most satisfied outcome. This requires the
quick production of a sequence of graph visualizations.
However, the traditional force-directed graph drawing
algorithms are very slow to reach an equilibrium
configuration of forces. They usually spend tens of
seconds producing the layout of a graph converge. Thus,
they do not satisfy the requirement of rapid drawing of
graphs. This paper proposes a fast convergence method
for drawing force-directed graphs. We essentially precalculate the geometrical position of all vertices before
applying a force-directed layout algorithm to reach the
energy minimization of the graph layout. The
experimental results have shown that this approach
could not only reduce the convergence time but also the
number of edge crossings that approves the quality of
layout significantly.
Keywords--- graph visualization; graph drawing;
data analytics; information visualization; forcedirected.

1. Introduction
Graph visualization is a process of mapping relational
data structures into node-link diagrams so that the data
relationships can be easily perceived by end users. A
graph, composed of a set of vertices and edges, can be
drawn in many different ways by simply changing the
positions of vertices. Research has shown that the quality
of layout can significantly affect how information can be
perceived by the end user [12, 13]. A good layout of
graph allows users to understand data more easily, while
a bad layout can hide the data pattern from users and
make human graph comprehension difficult [1]. Graph
drawing research concentrates on designing algorithms
1550-6037/12 $26.00 © 2012 IEEE
DOI 10.1109/IV.2012.31

124

In other words, the convergence time spent in moving
nodes from their initial positions to their final positions is
quite long. It usually takes tens of seconds to complete
an equilibrium configuration of forces to reach the final
layout. For more details on force-directed algorithms,
you may see [18].
However, typical visual analysis tools require
mechanisms to quickly produce a sequence of graph
drawings for the online interaction and processing of
large analytical data [2]. Thus, the existing force-directed
layout algorithms cannot satisfy the requirement for
visual analysis processes that require the drawing a
sequence of graphs rapidly.
Many attempts have been made to improve the
situation by introducing user interactions during the
process (e.g., [3, 4, 5]). For example, Nguyen and Huang
[4] developed a new technique called EncCon. This
technique uses a rectangular division algorithm to draw a
graph recursively. The purpose of this approach is to
make most of the space, and at the same time maintain a
good layout of hierarchical graphs. Do Nascimento and
Eades [15] have developed a genetic algorithm for
drawing directed graphs based on an interactive
framework. This framework combines automatic graph
drawing methods with inputs of human skills, allowing
users to focus on parts of the drawing and domain
knowledge based on layout constraints. Do Nascimento
and Eades [14] have proposed a more general framework
called user hints. This framework includes user
interactions as part of optimization process to solve
complex and difficult problems.
This paper proposes a fast convergence method for
drawing force-directed graphs. We essentially precalculate the geometrical position of all vertices before
applying a force-directed layout algorithm to reach the
energy minimization of the graph layout. The
experimental results have shown that this approach could
not only reduce the convergence time but also the
number of edge crossings that approves the quality of
layout significantly.
The rest of the paper is organized as follows. We first
briefly review related work with a focus on interactive
graph drawing algorithms in section 2. Then a traditional
force-directed algorithm is introduced in section 3. In
section 4, we present our interactive graph drawing
approach in section 4, followed by our experimental
results in section 5. The paper concludes in section 6
with future work.

novel navigation approach called WebOFDAV [3]. This
approach applies a force-directed animated layout
algorithm that provides users with a visual guide of the
web journey while maintaining user’s mental map.
Huang et al. [2] studied online graph drawing that
addresses issues with visualization and navigation of
huge graphs. A model for online graph drawing and an
application of such models in a system called OFDAV
are described. In this system, a new force-directed graph
drawing algorithm is used so that a continuous sequence
of layouts can be presented and the layouts can meet
some aesthetics and mental map requirements.
The second is to propose new force-directed methods
to improve aesthetics. For example, Didimo et al. [7]
proposed two algorithms based on topology-driven
force-directed framework that ensures good trade-offs
between aesthetics. The algorithms combine two
classical graph drawing approaches: force-directed and
topology-shape-metrics. Eades et al. [8] proposed a new
cosine force to improve the aesthetic of large crossing
angles. Lin et al. [9] proposed an edge-edge repelling
force to increase angular resolution. Huang et al. [5, 10,
16] proposed a since force to optimize angular
resolution.
The third line of research is to apply a pre-positing
procedure to improve the quality of drawings. For
example, Bertault [6] proposed an iterative drawing
algorithm based on a force-directed approach. This
approach uses an improved classical spring algorithm to
ensure that no new edge crossings are produced after
applying a classic graph drawing algorithm in the graph.
Our approach is different from previous approaches
described above. Our approach introduces a precalculation of initial positions of nodes before a classic
algorithm is applied. It has two steps: the first step
includes moving some of the vertices to certain positions
in order to improve the quality of the initial layout. After
this, an algorithm is applied on the drawing with the
improved layout. More details and experimental results
are presented in the sections that follow.

3. A Classic force-directed algorithm
The force-directed algorithm’s is to position nodes with
as few crossing edges as possible by assigning forces
among the set of nodes and edges for drawing graphs in
an aesthetically pleasing way. The spring forces are used
to keep all elements in reasonable distances: not too
close and not too far.
The force-directed algorithms achieve this by
assigning forces amongst the set of edges and the set of
nodes. The entire graph is then simulated as if it were a
physical system. In the force-directed algorithm, we need
to calculate all the forces work on every element, and
then place them to suitable position to avoid edge
crossings. There are three steps for each iterative
calculation.
1) Calculate the effect of attractive forces fa(d) = d2/k
between adjacent vertices;

2. Related work
Force-directed graph drawing methods have undergone
further developments in both research and application in
the past decades. At the same time, many classic forcedirected algorithms have been fine-tuned and extended to
meet specific visual requirements of application
domains. These further developments and refinements
can be classified into three lines of research. The first is
to modify force-directed algorithms to satisfy application
requirements. For example, Huang et al. presented a

125

2) Calculate the effect of repulsive forces fr(d) = ík2/d
between all pairs of vertices;
3) Finally stop the iteration if fa and fr tend to be not
changed.

3.1. Move all nodes Vkcc on the circle whose centers
are Vkc and radius D * L (where L=2) with
average degree

360 0
¦Vkc

where d is the distance between two vertices and k is the
optimal distance between vertices.
The time complexity of the force-directed algorithm is
O(|V|2+|E|), which means the computational time
depends on the number of the vertices, the edges and the
iteration . We could reduce the complexity of elements’
placements via providing a graph with fewer edge
crossings. Furthermore, it may reduce the computational
time complexity without deleting any vertices and edges
to some degree.

4. Our Approach
Figure 2: Example of step 3

This section describes the details of our two-step
algorithm. The first step is to move nodes to improve the
quality of the initial layout. Generally, K-node is moved
to the centre of the displaying frame. Then, it moves all
the nodes that have a direct connection from the K-node
to the circle whose radius equals the distance D. Finally,
it moves all the other nodes around their parents. The
process is applied a classical force-directed algorithm.

4.

E.g. In Figure 2, {n4, n1, n8} are the elements of
Vkc , {n0, n7, n10} are the elements of Vkcc. The
average angle is 360o / 3 = 120o and the radius
is D *2. {n0, n7, n10} are located around n12 on
the circle with center n12.
Repeat step 3 until every node has its desirable
location.

Detailed description of the algorithm at this step is
shown as follows:

5. Evaluation Experiments

1. Find out node Vk with the most edge crossings and
then move it to the center of the frame;
2. Find out all nodes Vkc that have direct connections to
the Vk. Move all nodes Vkc on the circle with center

Evaluation is important to evaluating the efficiency and
effectiveness of algorithms in graph drawing and data
visualization [5, 13]. We provide randomly graphs in our
experiments. The evaluation also measures running time
and the number of edge crossings. Details of the
experiments are described as follows.

point Vk, whose radius D and average angle

360 0
¦Vkc

5.1. Methodology
We have carried out an evaluation experiment using
these initial graphs with random vertices, including the
comparison for computation time. The steps are shown
below:
1. Create trees with random vertices and edges that
follows Rome graph rules;
2. Apply the traditional force-directed method on the
initial trees. The computing time t1;
3. Apply our method to change the initial positions of
every element. Then, the traditional force-directed
method is applied on the improved initial trees. The
computing time is t2;
4. Comparing the computing time of the t1 and t2.

Figure 1: An example showing step 1 and 2.
E.g. In Figure 1, n12 is vertex Vk and {n4, n1, n8} are all
vertices Vkc, then we put n12 to the centre of the frame
and {n4, n1, n8} around n12 on the circle with the center
pointer n12, the average degree is 360o / 3 = 120o and
radius D (i.e. edge’s length)

5.2. Creating the random trees
We create random trees according to the rules of the
Rome graph. Random positions are added for testing the
computing time with the same trees of the same
positions. In our experiments, we have created 55 trees

3. Find out all nodes Vkcc that have direct connections to
Vkc

126

with a range from 15 vertices to 70 vertices. An example
of a tree generating from our experience is as follows:
<graphml>
<graph edgedefault="undirected" id="G">
<node id="n0" position=750_400/>
<node id="n1" position=562_280/>
<node id="n2" position=1032_518/>
<node id="n3" position=97_483/>
<edge id="e0" source="n0" target="n2"/>
<edge id="e1" source="n0" target="n1"/>
<edge id="e2" source="n1" target="n2"/>
</graph>
</graphml>

5.3. Termination condition
Figure 4: After applying force-directed method
on the original tree

The algorithm will stop when the forces in the forcedirected algorithm are changing by small amounts. This
indicates the difference between two calculations is
sufficiently small so that the balance is reached.
Although the energy is minimal at this balanced stage,
edge crossings may still be visible in this process.
5.4. Computational time
The unit is 1ms and the precision is 55ms. In
comparison to the running time of force-directed
algorithm, that normally is larger than 1000ms, we
believe that the running cost for precision process is
acceptable. In our experiments, we only count the
computing time of the algorithm. The running time for
drawing graphs is not included. This aims to minimize
the influence of the visualization in the computation. Our
pre-positioning time is ranged from 15ms to 47ms for the
experimental data sets whose number of vertices are |V|
= {15,16, …, 70}.
Figure 3 shows an example of a tree structure with
45 vertices. Positions of vertices are placed randomly in
this figure. Figure 4 is visualization after applying the
force-directed process on to the data set from Figure 3.
This figure shows much clearer view although the
hierarchical structure is not clear. Figure 5 is the view
after applying the first step of the layout algorithm.
Figure 6 illustrates the visualization at the final stage
after the force-directed is applied on the result of the first
stage at Figure 5. This figure presents clearly the
structure of the tree with much fewer edge overlaps.

Figure 5: After applying our method on the
original tree

Figure 6: After applying force-directed method
on the improved tree based on figure 5
Figure 3: Original tree with 45 vertices and 44
edges placed randomly.

127

The tests results of the graphs above are shown below:
|V|

45

Time
(1ms)
(Original)
15537

Edge
Crossing
(Original)
2

Time
(1ms)
(Method)
15

Time
(1ms)
(After)
12075

|V|

Edge
Crossing
(After)
1

49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70

Table 1: Compare the running time and edge
crossings before / after using our method for
the examples showing at Figures 3 to 6.

5.5. Evaluation results
Our experiments were carried out using Windows 7 on
an Intel Pentium P6100 at 2.00 GHz and 4G RAM of
memory. The definitions of each title in table 3 are as
follows:
• |V|: The vertices number;
• Time(Original): The time used for achieving balance
via the original force-directed method;
• Time(Method): The time used for providing the
improved initial graph via our method;
• Time(After): The time used for achieving balance
via the original force-directed method working on the
improved initial graph.
|V|

15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48

Time
Edge
(1ms)
Crossing
(Original) (Original)
3806
0
3635
0
4165
0
4150
0
4665
0
5585
0
5679
0
5631
0
7192
0
6240
0
7098
0
6724
0
6879
2
7192
1
8034
0
8486
0
8549
0
8970
2
11450
0
12044
1
10733
2
10889
6
13681
0
12339
3
13026
0
13557
1
14867
2
13510
2
14836
4
19640
0
15537
2
22745
7
17488
1
18908
1

Time
(1ms)
(Method)
16
16
15
16
15
16
15
16
16
16
15
15
15
16
16
16
16
15
16
15
16
16
16
16
15
16
15
16
15
15
15
31
15
16

Time
(1ms)
(After)
2512
2964
3261
3214
3557
3760
4150
3760
4025
4882
4914
5351
5194
5866
6620
6396
6474
6786
6849
7083
8565
8612
8361
9126
9469
10530
9890
10390
11763
11138
12075
12979
12590
13058

Time
Edge
(1ms)
Crossing
(Original) (Original)
23072
0
19765
4
19437
3
20530
3
27705
1
26006
7
28299
2
26646
2
23790
0
33525
1
31559
2
29095
2
31075
10
34554
4
32464
3
37893
3
29921
5
45552
1
41481
0
37269
8
44382
1
38454
6

Time
(1ms)
(Method)
31
15
16
16
16
16
31
15
15
31
31
31
31
47
31
31
31
31
47
47
31
32

Time
(1ms)
(After)
13603
14024
13869
15194
16099
15475
17660
18174
19625
18502
21107
21388
23962
22090
23057
25928
24617
22777
29235
25850
29780
30810

Edge
Crossing
(After)
0
0
1
2
0
0
0
0
0
0
1
0
0
1
4
0
1
0
0
0
3
3

Table 2: Compare the Convergence time and
edge crossings before / after using our method
of the experiments from 15 nodes to 70 nodes.

Edge
Crossing
(After)
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
2
1
1
0
1
0
1
1
0
0
4
1
1
0
0

We provide detail experiments results at table 2. The
results show that our method reduces the processing time
and edge crossings. With this, it provides an improved
and higher-quality visualization in comparison to the
traditional forced-directed algorithm. Furthermore, we
notice that our method can reduce the edge crossings for
most trees.
Figure 7 indicates that our method reduces the
computational time for algorithm convergence in
comparison with the original force-directed algorithm. In
the figure, the red line indicates the time spent for
original force-directed method to reach the convergence
without pre-positioning and dark-green line indicates the
convergence time of our algorithm with pre-positioning
of nodes.

Figure 7: Time reduction for algorithm
convergence in comparison with the original

128

[10] Huang, W., Eades, P., Hong, S.H. & Lin, C.C. 2010,
Improving Force-Directed Graph Drawings by
Making Compromises between Aesthetics. In
ProcVL/HCC’10, 176-183.
[11] Huang, W. 2007: An Eye Tracking Study into the
Effects of Graph Layout. Technical Report Number
639, University of Sydney.
[12] Huang, W., Hong, S.-H. and Eades, P. (2006) How
People Read Sociograms: A Questionnaire Study. In
Proc. Asia Pacific Symposium on Information
Visualization (APVIS2006), 199-206.
[13] Helen C. Purchase 1998: Performance of Layout
Algorithms: Comprehension, not Computation. J.
Vis. Lang. Comput. 9(6): 647-657.
[14] Do Nascimento, H.A.D. & Eades, P. 2005: User
hints: a framework for interactive optimization.
Future Generation Comp. Syst. 21(7): 1171-1191.
[15] Do Nascimento, H.A.D. & Eades, P. 2002: A Focus
and Constraint-Based Genetic Algorithm for
Interactive Directed Graph Drawing. HIS 2002: 634643.
[16] Huang, W., Huang, M.L. & Lin, C.C. 2011,
Aesthetic of angular resolution for node-link
diagrams: Validation and algorithm. VL/HCC 2011:
213-216
[17] Huang, X. & Lai, W., 2005, Clustering graphs for
visualization via node similarities. J. Vis. Lang.
Comput. 17, 3 (June 2006), 225-253. Elsevier Ltd.
[18] Brandes, U. (2001) Drawing on Physical Analogies.
In Drawing Graphs: Methods and Models, 71-86.

force-directed layout algorithm. The
experiments are conducted with a variety of
data sets whose sizes are ranged from 15 nodes
to 70 nodes.

Conclusions and future work
We have presented a new fast convergence method that
reduces the time complexity and improves the quality of
tree visualization using force-directed algorithm with
pre-positioning. We essentially pre-calculate the
geometrical position of all vertices before applying a
force-directed layout algorithm to reach the energy
minimization of the layout. The experimental results
have shown that this approach could not only reduce the
convergence time but also the number of edge crossings
that approves the quality of layout significantly In the
future, we will carry out further experiments on various
large size data sets including general graphs.

References
[1] Battista, G.D., Eades, P., Tamassia, R. & Tollis, I.G.
1999, Graph drawing algorithms for the
visualization of graphs, Prentice-Hall, New Jersey,
USA.
[2] Huang, M.L., Eades, P. & Wang, J. 1998, On-line
animated visualization of huge graphs using a
modified spring algorithm, Journal of Visual
Language and Computing, no. vl980093, pp. 623645.
[3] Huang, M.L., Eades, P. & Cohen, R.F. 1998,
Webofdav – navigating and visualizing the web online with animated context swapping, Computer
Networks and ISDN Systems, 30(1), pp. 638-42.
[4] Nguyen, Q.V. & Huang, M.L. 2005: EncCon: an
approach to constructing interactive visualization of
large hierarchical data. Information Visualization
4(1): 1-21.
[5] Huang, M.L., Huang, W. & Lin, C.C. (2012)
Evaluating Force-Directed Algorithms with a New
Framework. The 27th ACM Symposium on Applied
Computing (SAC’12), Trento, Italy, 25 Mar - 29
Mar, 2012.
[6] Bertault, F. (1999) A force-directed algorithm that
preserves edge crossing properties. In Proc. the 7th
International Symposium on Graph Drawing
(GD’99), LNCS vol. 1731, Springer, 351-358.
[7] Didimo W., Liotta G. and Romeo S.A. (2010)
Topology-driven force-directed algorithms. In Proc
GD’10, 165–176.
[8] Eades, P., Huang W. and Hong, S.H. (2009) A
Force-Directed Method for Large Crossing Angle
Graph Drawing. TR No. 640, University of Sydney.
[9] Lin, C.C. & Yen, H.C. 2008, A new force-directed
graph drawing based on edge-edge repulsion, 9th
International
Conference
on
Information
Visualization IV2008, 6-8 July, London, England,
pp. 329-34.

129


2012 16th International Conference on Information Visualisation

Solving the range searching problem for region bounded by a convex surface
V. Tereshchenko, O. Socolov, A. Fisunenko
National Taras Shevchenko University of Kiev
vtereshch@gmail.com,alex.sokols@gmail.com, alf.via@gmail.com
Abstract

Next we consider the data structures which are used
for efficient search. Basically, all data structures are treestructure, which is similar to quad/oct-tree region (quad /
oct- tree region) [6], k − d trees [7] and BD-trees (BDtree, fair-split tree) [8]. In particular, in [1], [3], [4] it is
indicated that BBD-tree, which is a generalization of the
BD-tree with an additional function of shrinking. All data
structures are tree with O(log2 N ) height. They are differed only by the balance factor of trees and by a factor
indicating the ratio of the division of corresponding node
of the tree by hypercube’s hyperplane for finding successors (for BD-tree and BDD-tree it is 1/3, for k − d trees
and quad-tree -1/2).
In paper [9] an efficient range searching algorithm for
a query region which is limited by a curvilinear boundary
(for example by a circle) is proposed. It gives the asymptotic complexity of the search O(logN ) and O(N 2 ) for
preliminary processing and memory. Let us consider this
algorithm in more details. During pre-processing a grid
of N 2 points is constructed. Nodes of the grid are points
whose coordinates are combinations of elements of the input set of all coordinates. Using this matrix a quadtree is
built. Vertices of the quadtree contain a set of points which
belongs to the current half-plane. Let us suppose, for example, that the query region is a circle. We divide it into
four quadrants. For each such quadrant, with the boundary
as a monotone function, vertices of the quad-tree belonging
to this quadrant are searched.
Asymptotic values of existing approximate local searching algorithms for semi-groups are summarized in the Table 1. Table 2 summarizes asymptotic complexity estimates for exact local searching algorithms in Euclidean
space. In both tables ε ∈ (0, 1)- an approximation coefficient; d is a dimensionality of space.
In this paper we propose modification and generalization of the approach presented in [9] for the multidimensional case with O(logN ) search time and O(N logN )
memory.

In this paper we consider one of the approaches to
solving the range searching problem for a range which is
bounded by a convex surface in Euclidean d-dimensional
space. In particular, we propose a method of range searching which gives query time O(logN ) and uses O(N logN )
memory where N is cardinality of an input data set. It
is enabled by applying optimal data structures for storing
points in nodes of a quadtree.
Keywords— range searching,
dimensional space, quadtree.

1

convex

surface,

d-

Introduction

This paper considers one of the approaches to solving the range searching problem for the region which
is bounded a convex surface in Euclidean d-dimensional
space E d .The range searching problems have almost been
investigated completely. Nevertheless problems still exist
in case of a linear restriction on memory where exact methods do not reach asymptotically possible lower bounds of
the complexity. We shall call a method as an exact method
if it gives the correct answer for a query. In turn, approximate methods we will call those methods, which give answer with a specific error. The models of errors can be
specified as relative [1] and absolute [2]. Use of an approximate method is appropriate in the case if there are
strict restrictions on memory for execution of an algorithm
[1- 4]. In situation when there are linear constraints on
available memory exact algorithms cannot work in multilogarithmic time because of lack of memory for building
an efficient data structures.
In [1 -5] the authors reduce the problem in a space
( d , Q) (F 1) (Q-query region) to problems in space
(X, R)(F 2), where X - a set of random variables, and R subset of a powerset 2X . We introduce weights for vertices, which form semigroups (S, +). For convenience,
elements of a set X are called points and elements from
the set R - intervals. Using Vapnik-Chervonenkis (VC) dimension [5] for the exact range searching
√ algorithm in a
circle this construction gives time O( N logN ) and preprocessing costs and memory O(N logN ).
1550-6037/12 $26.00 © 2012 IEEE
DOI 10.1109/IV.2012.85

2 The proposed method.
We shall formulate the range searching problem using example of the multidimensional sphere in Euclidean
491

Table 1: The comparisons of approximate algorithms.
Source Preprocessing

Query time complexity

[1]
[2]

O(N log N )
O(N + 1/ed )

O(log N + 1/ed )
O(1/e(d−1)/2 )

[10]

No information

O( (N/ log N )m1/d

1−(d−1)/d(d+1)

Memory
estimation
O(N )
O(1/ed )
) O(m)

Table 2: The comparison of exact algorithms.
Source Preprocessing

Query time complexity

trivial 0
[9]
O(N log N )
[5]
O(N log N )

O(N )
O(log
√ N)
O( N log N )

Memory
estimation
O(N )
O(N 2 )
O(N log N )

3. Then we make a matrix of dimension K =
N × N × ... × N , where coordinate node will be recorded

space.
The range searching problem (for sphere). Let S be
a set of N points in E d , we need to define subset S ,where
S ⊆ S containing points which lie in the region bounded
by sphere of radius r.
In general, the region can have any geometric form
formed by a convex surface. Let us construct a grid between points A(a1 , a2 , ..., ad ) and B(b1 , b2 , ..., bd ). So we
get all possible combinations of coordinates of points A
and B, where the i − th coordinate may be either from A
or B. Thus, each point splits the space Rd onto 2d halfspace.
Definition. Cartesian Product of d range-segments
[l1 , r1 ] × [l2 , r2 ] × ... × [ld , rd ], which is written as vectors
of these ranges G = ([l1 , r1 ], [l2 , r2 ], ..., [ld , rd ]), where
li ≤ ri , i = 1, d will be called as a Hypercube of space
Rd .

d

in each cell (we consider the cut of the matrix K in the
plane (x1 , x2 ) at fixed values of all other coordinates),
Fig.1. It can be presented in another form, Fig.2.
ˆ (Fig. 2) contains at least one value of
Thus, matrix K
the set of P in each row for other fixed coordinates.
4. On the next step we construct a quadtree [6], [11],
ˆ in which each vertex contains a
using the built-matrix K,
hypercube G = ([l1 , r1 ], [l2 , r2 ], ..., [ld , rd ])(where li , ri ∈
[1, N ], i = 1, d) and the set of points S ⊆ P , which fall in
this hypercube.
5. The quad-tree is built recursively using the following
rules:
a) Let us assume that we have a case, when the vertex contains hypercube G = ([l1 , r1 ], [l2 , r2 ], ..., [ld , rd ]), where
li , ri ∈ [1, N ], i = 1, d. Next, we find set of points for the
given tree which are included to the given tree by checking
either point of the set P belongs to a given hypercube G.
If the set S is empty for vertex of this tree then it will not
be built further. So we do not have points of set P in the
leaves of the tree further but only zero points.
b) Taking into account, that each point splits the space Rd
onto 2d half-spaces, we get that 2d branches come out from
each node. Consequently, we will get new 2d hypercubes
by bisecting each range segment of a hypercube vector and
gluing all possible combinations of these halves one to another:

2.1 Constructing a solution of the problem.
We can offer two variants (A and B) of preprocessing
and corresponding data structures. Let us describe the preprocessing algorithm based on [9].
Preprocessing and data structures (variant A):
1. We organize a set of input points P , firstly it will be
done for coordinate x1 , then for x2 , and so on, including to
xd . We get an ordered set of points P = {p1 , p2 , ..., pN }.
The complexity of sorting operations is θ(N log2 N ), where
N = |P | is a power of set of input points. As a result of
this division we get a grid.
2. The grid nodes contain points from a set P and the
points that are combinations of different coordinates elements of points P : N ET (pi , pj ), i = 1, N , j = i + 1, N ,
we call them zero-points.

([l1 ,

492

l1 + r 1
l2 + r2
ld + rd
], [l2 ,
], ..., [ld ,
]),
2
2
2

⎛
⎜
⎜
K(x13 , ..., x1d ) = ⎜
⎜
⎝

(x11 , xn2 , ..., x1d )
(x11 , xn−1,2 , ..., x1d )
.
.
(x11 , x12 , ..., x1d )

(x21 , xn,2 , ..., x1d )
. .
(x21 , xn−1,2 , ..., x1d ) . .
.
.
(x21 , x12 , ..., x1d )
. .

(xn1 , xn2 , ..., x1d )
(xn−1,1 , xn−1,2 , ..., x1d )
.
.
(xn1 , x12 , ..., x1d )

⎞
⎟
⎟
⎟
⎟
⎠

Figure 1:
⎛ ˆ
k(1, n, i3 , ..., id )
⎜ .
⎜
ˆ 3 , .., id ) = ⎜
K(i
⎜
⎝ .
ˆ 1, i3 , ..., id )
k(1,

.
ˆ 1 , 2 , i3 , ..., id )
k(i
.

ˆ n, i3 , ..., id ) ⎞
. k(n,
⎟
.
⎟
⎟,
⎟
⎠
.
ˆ
. k(n, 1, i3 , ..., id )

Figure 2:
where
ˆ 1 , i2 , ..., id ) =
k(i

([

([l1 ,

([

p, if ∃p with coordinates (xi1 1 , xi2 2 , ..., xid d )
0, else

.

2. Building a data structure (quadtree) is the same as in
variant A.
Thus, the vector V requires O(d × N ) memory. Time
of building of a quadtree is the same as for the variant A O(N log2 N ). The tree requires memory O(N log2 N ), because we will always have N points at every level and taking into account, that the height of the trees is O(log2 N ),
we get a sought estimation.

l1 + r 1
l2 + r 2
l d + rd
, r1 ], [l2 ,
], ..., [ld ,
]),
2
2
2
l1 + r1 l2 + r2
ld + rd
], [
, r2 ], }..., [ld ,
]), . . . ,
2
2
2

l2 + r2
ld + rd
l1 + r 1
+ 1, r2 ], [
+ 1, r2 ], ..., [
+ 1, rd ]).
2
2
2

2.2 Algorithm
The main steps of the algorithm:
1. Without prejudice to the generality we consider one
of the 2d parts of space, in which part of sphere is a monotone function. For example, it is a hypercube of space
GR = ([x∗i , x∗i + R])di=1 . This fragmentation is made by
the center of sphere C(x∗1 , x∗2 , ..., x∗d ).
2. We find the hypercube
G∗ = ([l1∗ , r1∗ ], [l2∗ , r2∗ ], ..., [ld∗ , rd∗ ]),
ˆ (or vecwhere li∗ , ri∗ ∈ [1, N ], i = 1, d on the matrix K
tor in V, depending on the type of preprocessing), which
corresponds to range of space Rd limited by the hypercube GR+ . Because all elements are arranged in a matrix
ˆ for all coordinates, the location of G∗ is done in time
K
O(log2 N ).
3. The next stage is a search in the created tree. Moving
through nodes of the tree, from the root to leaves, we check
the following conditions:
a) If the hypercube G in the vertex of the tree is completely belongs to GR+ , then go to step d).

We previously establish set Si = S,i = 1, 2d for each
child vertex.
c) For each new vertex of the tree we go to the step a).
ˆ and the corresponding tree uses O(N d )
Matrix K
memory. The complexity of constructing the tree is
O(N log2 N ). Now let us consider the modification of preprocessing of variant A which reduces memory usage.
Preprocessing and data structures (variantB):
1. So we make d vectors of corresponding coordinates
of points set P , which were taken separately from each
point, and sort them. We obtain d vectors of ordered numbers V = {((x1i , x2i , ..., xni ))di=1 |j = 1, d, q = 1, N , ∃pk },
where pk ∈ P and xqj = xk,j , all possible combinations
of values actually correspond to elements of the matrix K.
So we don’t need to store all information for matrixes K
ˆ It is enough to keep a set of sorted coordinates of
and K.
points.

493

eralized, not limiting by only the spherical query ranges
only. For a query range bounded by hyperplanes, it is possible to organize a search on every part of space, where
the hyperplanes are monotone functions. We can do it the
same way as for our algorithm, changing only the rule of
cutting off branches of the tree for the given function and
selection rule for the space.

b) If the hypercube G in the vertex of the tree does not
belong to GR+ , then the elements of the set S will not be
included into a sphere and search in this vertex will stop.
If the hypercube G intersects with the hypercube GR+ ,
then go to step f ).
d) If for element xmin = (ximin
,1 , ximin
,2 , ..., ximin ,d )
1
2
imin

imin

imin

d

of matrix K (or xmin = (x11 , x22 , ..., xdd ) for V),
min
min
which has minimal indices (imin
1 , i2 , ..., id ), (where
min
ij = lj , j = 1, d) from hypercube of the vertex
G = ([l1 , r1 ], [l2 , r2 ], ..., [ld , rd ]), the inequality
d
j=1

References
[1] Arya S., Mount D.M. Approximate range searching.
Computational Geometry: Theory and Applications,
17:135-163, 2000.

2
2
(x∗j − ximin
,j ) ≤ R is not true, then all elements of
j

[2] Fonseca G.D. da, Mount D.M., Approximate range
searching: The absolute model. Computational Geometry: Theory and Applications, Elsiver, 43:434444, 2010.

the set S of the corresponding sub-tree will be outside of
the sphere, or S - empty set.
e) If for element xmax = (ximax
,1 , ximax
,2 , ..., ximax
,d )
1
2
d
imax

imax

imax

(or xmax = (x11 , x22 , ..., xdd ) for V), of the matrix
, imax
, ..., imax
),
K, which has a maximum indices (imax
1
2
d
max
(where ij = lj ,j = 1, d) from hypercube of the vertex
G = ([l1 , r1 ], [l2 , r2 ], ..., [ld , rd ]), the inequality
d
j=1

[3] Arya S., Malamatos T., Mount D. M. Space-time
tradeoffs for approximate spherical range counting.
In Proc. 16th Annu. ACM-SIAM Sympos. Discrete Algorithms, pages 535-544, 2005.

2
2
(x∗j − ximax
,j ) ≤ R is executed, then all elements
j

[4] Arya S., Malamatos T., Mount D. M. The effect
of corners on the complexity of approximate range
searching. Pro. of the 22nd annual symposium on
Computational geometry, pages 11-20, 2006.

of the set S of the corresponding sub-tree lie in the ball.
f) Else, we recursively run the algorithm for the descendants of the current vertex of the tree and go to step a).
Thus we will get a set of points, which are included into
given part of the ball. Time of the algorithm work is determined by a search on 2d - branching tree and equals to
O(log2d N ) for the worst case. We apply the item 2) for all
2d parts of the ball surface (sphere). Each of such parts is
a monotone function. Farther, applying a point 3) with the
modified subitems of d) and f), we will get the set of all
points which belong to the ball. Total time of search will
be O(2d log2d N ). For fixed d, the time complexity of algorithm will be O(logN ) with using O(N logN ) storage. At
the same time, preprocessing in variant A results in O(N d )
of memory use.

3

[5] Chazelle B., Welzl E. Quasi-optimal range searching
in spaces of finite VC-dimension. Discrete Comput.
Geom., 4:467-489,1989.
[6] H.Samet. The Design and Analysis of Spatial Data
Structures. Addison Wesley, Reading, MA, 1990.
[7] F. Preparata and M.I. Shamos. Computational Geometry: An introduction. Springer-Verlag, Berlin, 1985.
[8] P. B. Callahan and S. R. Kosaraju. A decomposition of multi-dimensional point-sets with applications
to k-nearest-neighbors and n-body potential fields.
In Proc. 24th Annu. ACM Sympos. Theory Comput.,
pages 546-556, 1992.

Implementation

The proposed algorithm is implemented in Java. It gives
independency on a platform and the computer architecture
requiring only Java virtual machine to be installed. Execution of the algorithm using different test data sets has
shown correspondence with presented estimations.

4

[9] Tereshchenko, Vasyl’ M.; Kas’yanov, Andrij A. On
an approach to the solution of a local search problem.
Visn., Ser. Fiz.-Mat. Nauky, 3:265-269, 2006.

Conclusions

[10] H. Bronnimann, B. Chazelle, and J. Pach. How
hard is halfspace range searching. Discrete Comput.
Geom., 10:143-155,1993.

We offered one approach to solving the range-searching
problem for the region which is bounded by a convex
surface in E d . On the example of region bounded by a
sphere in E d , we presented an algorithm that executes a
regional query in the report mode in O(log N ) time and
uses O(N log N ) for preprocessing and storage. The implementation of algorithm confirmed the indicated complexity estimations. Moreover, an algorithm can be gen-

[11] M. de Berg, M. van Kreveld, M. Overmars, and
O.Schwarzkopf. Computational Geometry: Algorithms and Applications, Springer-Verlag, Berlin,
Germany, 2nd edition, 2000.

494


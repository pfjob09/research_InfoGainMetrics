2012 16th International Conference on Information Visualisation

Debugging the Execution of Distributed Algorithms
over Anonymous Networks
Thomas Morsellino, C´edric Aguerre, Mohamed Mosbah
LaBRI, CNRS, Universit´e de Bordeaux
351, cours de la Lib´eration
33405 Talence, France
{morsellino, aguerre, mosbah}@labri.fr
Abstract—Computing the global state of an asynchronous
distributed system is a widely studied problem and finds a
plethora of solutions under different assumptions. Most of them
do not correspond to real-life requirements. In this paper, we
address the global snapshot and the global predicate evaluation
problems in anonymous and asynchronous networks. We present
a fully-distributed solution which allows the debugging and the
monitoring of such networks. We show that our contribution can
be easily implemented and added as a new feature in existing
simulation softwares by describing specifications of the used
model and details of the development process. As an illustration,
a debugging layer is implemented on the ViSiDiA platform.

field.
Besides, the design and validation of distributed applications
depends on the analysis and understanding of underlying algorithms that must be proved, implemented, debugged and tested.
The emergence of simulation softwares is an important step
towards this objective. A visualization of running algorithms,
with the ordered observation of data transfers and property
changes over the network, is of great help. A quantification of
all events occurring over the network leads to the evaluation
of distributed algorithms in terms of complexity or global
performance.
Hence, there exist three important challenges in developing
a complete solution for distributed algorithm debugging. First,
the state of a distributed system, also called its global state,
is defined by the state of each process and the state of each
channel (or equivalently by the set of local snapshots): it is
precisely a (global) snapshot. Thus a snapshot of a distributed
system is an instantaneous map of it, where each process
(resp. each channel) is labelled by its state. As is explained
by Tel [3] (p. 335-336), the construction of snapshots may be
useful in designing and debugging distributed algorithms or
in the evaluation of global predicates (GPE, for short) of the
distributed system, i.e., properties which remain true as soon
as they are verified. Moreover, if the system must be restarted
(due to a failure of a component), it may be restarted from the
last known snapshot (and not from the initial configuration).
Hence, how can we compute such a global snapshot using
only local information processes exchange?
Second, what if processes do not have unique identifiers or
do not wish to divulge them for privacy reasons? Finally, these
debug information must be available along with the algorithm
execution. How can we obtain an efficient computation and visualization of debug information along with simulation events
display?

I. INTRODUCTION
Consider situations of natural disasters such as floods.
Spatial areas must be covered with a large number of sensors
to assist rescue teams. The spontaneous, asynchronous and
distributed features of such a network make the monitoring
of what is currently happening an issue. For instance, one
would like to check whether the water level is under a specified
threshold for each sensor. When the water is lower than the
threshold at one sensor, this sensor verifies if the condition also
holds at its neighbors and the neighbors of its neighbors and so
on. If a sensor have detected a problem, a domino-effect can
occur, i.e., sensors with no problem are becoming problematic
(i.e., the flood is spreading) and the monitoring has to be
done again from the beginning. No solution is usable under
this setting without any knowledge on the underlying network
[1]. This impossibility is reinforced by the analysis proposed
by Guerraoui and Ruppert [2] in which they consider that a
vast majority of papers on distributed computing assume that
processes have unique identifiers or do not want to share their
private data due to privacy or security concerns. A distributed
approach have to be considered and addressed for which the
only possible assumption may be the number of processes
(sensors) that have been deployed.
Many complex information systems require a large number
of servers and machines, interconnected on either local or
remote networks. Such distributed applications aim at making
several processes collaborate to the execution of a same task.
Problems are raised concerning concurrent access to resources,
critical failure detection, or even process communication strategy. The generalization of heterogeneous and large networks
thus involves substantial studies in the distributed algorithm
1550-6037/12 $26.00 © 2012 IEEE
DOI 10.1109/IV.2012.80

A. Our Contribution
To address the aforementioned challenges, this paper
presents a complete, stable framework named ViSiDiA for
the simulation, visualization and debugging of distributed
algorithms in anonymous networks. Our approach relies on
both the development of a new fully-distributed debugging
technique with solid theoretical fundaments, and the design of
464

an interactive simulation viewer offering a high level, simple
interface to implement and test new algorithms.
This paper has the following contributions. We propose an
original method to debug the execution of distributed algorithms with which global information can be computed from
local data collection in the context of anonymous networks.
Debug information is then exploited along with the execution
of asynchronous distributed algorithm. We present a platform
for creating, visualizing and simulating distributed networks.
This is of particular interest when testing and thus debugging
new algorithms. We incorporate a visual debugger to this
platform, and extend its Application Programming Interface
(API, for short) to easily design new distributed algorithms.

A. The Model
Our model is the usual asynchronous message passing
model [3]. A network is represented by a simple connected
graph G = (V (G), E(G)) = (V, E) where vertices correspond to processes and edges to direct communication links.
The state of each process p is represented by a label λ(p)
associated to the corresponding vertex v ∈ V (G); we denote
by G = (G, λ) such a labelled graph. We assume the network
to be anonymous [2], [11]: the identities of processors are
not necessarily unique or, for privacy and security reasons,
processes do not share their identities during computation
steps.
We assume that each process knows from which channel
it receives or it sends a message, i.e., for each u ∈ V (G)
there exists a bijection δu between the neighbors of u in G
and [1, degG (u)]. We will denote by δ the set of functions
{δu | u ∈ V (G)}. The numbers associated by each process
to its neighbors are called port-numbers (also called doornumbers) and δ is called a port-numbering of G. We denote
by (G, δ) the labelled graph G with the door-numbering δ.
Let p be a process. Let q be a neighbor of p, i.e., pq is a
channel. The state associated to p is denoted by state(p).
The multiset of messages in transit associated to pq is denoted
by Mpq (initially Mpq is empty). state(p) and the set of
Mqp define the local snapshot with respect to the process p.
We recall that a snapshot of a distributed system is a map
of the network where the vertices and the edges are labelled
by the states of the corresponding processes and channels.
A snapshot is feasible (i.e., corresponds to an instantaneous
global state of the system or a global state that the system
could have reached) if for each channel pq, from the process
p to the process q, the set of messages received by q is a
subset of the set of messages sent by p.
We consider asynchronous systems, i.e., no global time is
available and each computation may take an unpredictable (but
finite) amount of time. Note that we consider only reliable
systems: there are no message loss or duplication. We also
assume that the channels are FIFO (First In First Out). In this
model, a distributed message passing algorithm D is given by
a local algorithm Dp , that every processes p should execute.

B. Related Work
Many notions and algorithms concerning snapshots and
global predicates evaluation can be found in [4]. A dedicated
process is usually in charge of determining if the global state of
a distributed system satisfies a global predicate. Such a process
starts the Chandy-Lamport algorithm, collects processes and
channels states, computes a network map, and finally tests if
the labelled network satisfies the given property. To collect or
to analyze local snapshots, different assumptions may be done
(see [5]): processes have unique identifiers, there is exactly
one initiator or one collector process. The analysis may be
done thanks to a wave. As is explained in [5]: A wave is a
flow of control messages such that every process in the system
is visited exactly once by a wave control message, and at
least one process in the system can determine when this flow
of control messages terminates. Furthermore wave sequences
may be implemented through a traversal structure such as a
tree or a ring. Some papers present specialized algorithms to
obtain efficient algorithms to evaluate particular properties of
networks [6], [7], [8], [9], [10]. In any case, it is assumed
that processes have identifiers and/or that there is exactly one
initiator.
No such possibilities exist under our assumptions. As for as
we know, our method is a new emerging solution for global
snapshots computation and GPE over anonymous networks
without any knowledge about the underlying network.

B. The Chandy-Lamport Snapshot Algorithm
For clarity, we briefly recall the Chandy-Lamport algorithm
[12]. The aim of a snapshot algorithm is to construct a system
configuration defined by the state of each process and the state
of each channel.
We assume that the Chandy-Lamport algorithm (Algorithm
1) is initiated by at least one process p which: saves its state
state(p), sends a marker on each outcoming port and for
each incoming port memorizes messages which arrive until it
receives a marker through this port. When a process receives
for the first time a marker, it does the same thing that an
initiator; the incoming channel by which it receives for the
first time a marker is saved as empty.
Each process p is equipped with a boolean variable localsnapshotp initialized at f alse and indicating if the process

C. Summary
The rest of this paper is organized as follows. First, we
recall in Section II notions we use in our approaches. The
design of debugging algorithms is detailed and explained in
Section III. Section IV describes and assesses our prototype
used to monitor the behavior of a distributed system within a
simulation software before drawing conclusions and sketching
current and future works in Section V.
II. PRELIMINARIES
The presentation and definitions given in this section follow
[3] (p. 45-47).

465

p has recorded its state and the state of incoming channels.
Each process p maintains a multiset of messages Mp,i , initially
Mp,i = ∅, for each incoming channel i of p.

A. Checkpoint Algorithm: Termination Detection of the Snapshot Algorithm
A first step to answer the above requirement is given
by the termination detection of the computation of all local
snapshots. It requires that all processes certify, in a finite
computation, that they have completed the computation of
their local snapshot. The algorithm by Szymanski, Shy, and
Prywes (the SSP algorithm for short) [15] does this for a region
of pre-specified diameter; the assumption is necessary that an
upper bound of the diameter of the entire network is known
by each process. In the sequel this upper bound is denoted by
β and we assume that each process knows it.
We consider a distributed algorithm which terminates when
all processes reach their local termination conditions. Each
process is able to determine only its own termination condition. SSP’s algorithm detects an instant in which the entire
computation is achieved.
Let G be a graph, to each process p is associated a predicate
P (p) and an integer a(p). Initially P (p) is false and a(p) is
equal to −1. Transformations of the value of a(p) are defined
by the following rules. Each local computation acts on the
integer a(p0 ) associated to the process p0 ; the new value of
a(p0 ) depends on values associated to neighbors of p0 . More
precisely, let p0 be a process and let {p1 , ..., pd } the set of
processes adjacent to p0 .
• If P (p0 ) = f alse then a(p0 ) = −1;
• if P (p0 ) = true then a(p0 ) = 1 + M in{a(pk ) | 1 ≤ k ≤
d}.
We assume that for each process p the value of P (p)
eventually becomes true and remains true for ever.
To apply the SSP algorithm, each process p is endowed with
two variables: a(p) ∈ Z is a counter (initially a(p) = −1),
a(p) represents the distance up to which all processes have the
predicate true; A(p) ∈ Pﬁn (N × Z)∗ encodes the information
p has about the values of a(q) for each neighbor q. Initially,
A(p) = {(i, −1) | i ∈ [1, degG (p)]}.
Previous explanations lead to the design of Algorithm 2.
From this algorithm, we can compose the application of the
Chandy-Lamport algorithm and the SSP algorithm to enable
each process to detect an instant where all processes have
completed the computation of their local snapshot. In some
sense, a(p) represents the distance up to which all processes
have completed the computation of the local snapshot.
If a process has completed the computation of its local
snapshot then it changes the value of a(p) to 0 and it informs
its neighbors. When a process p receives a value a(q) for some
neighbor q via the port i then it substitutes the new value
(i, a(q)) to the old value (i, x) in A(p). Finally, p computes
the new value a(p) = 1 + M in{x | (i, x) ∈ A(p)}.
A process p knows that each process has completed the
computation of its local snapshot as soon as a(p) ≥ β.
Thus we add a boolean variable snapshotp initialized at
false; it indicates if the process knows wether all processes
have completed the computation of the local snapshots. When

Algorithm 1: The Chandy-Lamport snapshot algorithm.
Init-CLp : {To initiate the algorithm by at least one process p such that
takenp = f alse}
begin
record(state(p)) ;
takenp := true;
send< mkr > to each neighbor of p;
For each port i the process p records messages arriving via i
R-CLp : {A marker has arrived at p via port j}
begin
receive< mkr >;
mark port j;
if not takenp then
takenp := true;
record(state(p)) ;
send< mkr > via each port;
For each port i = j the process p records messages arriving via i in
Mp,i
else
The process p stops to record messages from the channel j of p;
record(Mp,j )
if p has received a marker via all incoming channels then
local-snapshotp := true

If we consider an execution of The Chandy-Lamport algorithm we obtain a consistent snapshot within finite time after
its initialization by at least one process (see [3] Theorem 10.7
). In particular:
Fact 1. Within finite time after the initialization of the ChandyLamport algorithm, each process p has computed its local
snapshot (local-snapshotp = true).
Once the computation of local snapshots is completed (for
each process p the boolean local-snapshotp becomes true),
the knowledge of the snapshot is fully distributed over the
system. The next question is “how to exploit this distributed
knowledge?”.
As mentioned by Raynal [1]: Providing an algorithm for the
calculation of a global state is a basic problem in distributed
systems. Several solutions exist: global clock simulation [1],
wave algorithms [13]. But they suppose that processes have
unique identifiers, have global colors associated to each computation of a global state or have a particular knowledge about
the topology of the network.
These solutions are not available in the context of anonymous networks with no distinguished process and no particular
topology. In the next Section, we show how to answer the
previous question.
III. SNAPSHOT ALGORITHMS FOR ANONYMOUS
NETWORKS
This section presents our solutions, which are formally
described in [14], and the corresponding algorithms we propose to address the global snapshot and the global predicate
evaluation problems.

∗ For

466

any set S, Pﬁn (S) denotes the set of finite subsets of S.

of the SSP algorithm over the local predicate to check
whether the predicate holds is the whole network,
5) if the local snapshot of the process p is such that the
predicate is not satisfied then it sends a signal to inform
every process and at least another global snapshot must
be computed. Variables of Algorithm 1 and Algorithm
2 (Figure 2) are reseted and snapshotp = f alse.

Algorithm 2: The SSP algorithm.
Init-SSPp : {To initiate termination detection on the process p such that
P (p) = true }
begin
a(p) := 0;
m := Min{x | (i, x) ∈ A(p)};
if m ≥ a(p) then
a(p) := m + 1;
send< a(p) > to each neighbor of p;

C. Weak Snapshot Algorithm
We assume that the network is anonymous and that several
processes can be initiators of computations. Each process
knows only an upper bound on the size of the network, denoted
β. Under these hypotheses, no process can compute a map
of the network. We prove that each process can compute a
graph covered by the network, i.e., a weak snapshot. Classical
properties, as stable properties, studied through snapshots can
be still studied thanks to a weak snapshot.
a) Some definitions: In the following, we will consider
directed graphs (digraphs) with multiple arcs and self-loops. A
digraph D = (V (D), A(D), sD , tD ) is defined by a set V (D)
of vertices, a set A(D) of arcs and by two maps sD and
tD that assign to each arc two elements of V (D): a source
and a target (in general, the subscripts will be omitted). A
symmetric digraph D is a digraph endowed with a symmetry,
that is, an involution Sym : A(D) → A(D) such that for
every a ∈ A(D), s(a) = t(Sym(a)). In a symmetric digraph
D, the degree of a vertex v is degD (v) = |{a | s(a) = v}| =
|{a | t(a) = v}|.
Let (G, λ) be a labelled graph with the port-numbering δ.
We will denote by (Dir(G), δ) the symmetric labelled digraph
(Dir(G), (λ, δ)) constructed in the following way. The vertices
of Dir(G) are the vertices of G and they have the same labels
in G and in Dir(G). Each edge {u, v} of G is replaced
in (Dir(G), δ) by two arcs a(u,v) , a(v,u) ∈ A(Dir(G)) such
that s(a(u,v) ) = t(a(v,u) ) = u, t(a(u,v) ) = s(a(v,u) ) = v,
δ(a(u,v) ) = (δu (v), δv (u)) and δ(a(v,u) ) = (δv (u), δu (v)).
Note that this digraph does not contain multiple arcs or loop.
The notion of coverings and of symmetric coverings are
fundamental in this work; definitions and main properties
are presented in [17], [18]. This notion enables to express
“similarity” between two digraphs.
A labelled digraph D is a covering of a labelled digraph
D via ϕ if ϕ is a homomorphism from D to D such that
for each arc a ∈ A(D ) and for each vertex v ∈ ϕ−1 (t(a ))
(resp. v ∈ ϕ−1 (s(a )), there exists a unique arc a ∈ A(D)
such that t(a) = v (resp. s(a) = v) and ϕ(a) = a . We recall
that if D1 is a covering of D2 via the homomorphism ϕ then
there exists an integer α such that for each vertex u of D2 the
cardinality of ϕ−1 (u) is equal to α.

R-SSPp : {An integer < α > has arrived at p via port j}
begin
receive< α >;
A(p) := (A(p) \ {(j, x)}) ∪ {(j, α)};
m := Min{x | (i, x) ∈ A(p)};
if (m ≥ a(p) and P (p) = true) then
a(p) := m + 1;
if a(p) ≥ β then
p detects the entire termination: the predicate P is true for each
process;
else
send< a(p) > via each port;

snapshotp is true for each process p, local snapshot p enables
to restart a system if there is a failure. As explained in [4] p.
456, the saved state is called a checkpoint, and the procedure
of restarting from a previously checkpointed state is called
rollback recovery.
B. Global Predicate Evaluation Algorithm
Let A be a distributed algorithm and E be an execution
of A. From the checkpoint algorithm proposed in Section
III-A, we can run once again the SSP algorithm to evaluate
global predicates such as stable properties or graph invariants.
The most obvious predicate is the termination detection of
the monitored algorithm A: an execution E has terminated if
and only if all the processes are passive and all the channels
are empty. Thus to detect the termination of the execution
E, it suffices that from time to time (to be defined) at least
one process initializes the computation of a snapshot and if
its state is passive and its incoming channels are empty it
must detect if the same property holds for all the processes. In
this way, we obtain an algorithm to detect global termination
of the execution of a distributed algorithm. These repeated
termination queries are analogue to the solution described by
Santoro in Section 8.3 of [16].
As a corollary, this procedure can be extended to evaluate
other global predicates. It requires SSP to be done over some
local predicates. Thus, from local snapshots, one can detect
an instant of the execution in which a global predicate holds.
An example of such a predicate is depicted in Section I. The
main ideas are:
1) at least one process initiates the computation of a
snapshot (Algorithm 1),
2) each process p detects an instant where the computation
of its local snapshot is completed,
3) each process p detects an instant where the computation
of all local snapshots is completed: snapshotp = true,
4) if the local snapshot of the process p is such that the
local predicate P holds then p initiates an occurrence

Definition 1 (Weak Snapshot [14]). Given a simple connected
labelled graph G = (G, λ) with a port-numbering δ which
defines a snapshot of a network G. Let D = (Dir(G), δ) be
the corresponding labelled digraph (Dir(G), (λ, δ)). Let D be
a labelled digraph such that D = (Dir(G), δ) is a covering
of D . The labelled digraph D is called a weak snapshot of
G.

467

(λ(v), n(v), N (v), M (v), a(v), A(v)) where λ(v) ∈ L is
the initial label of v computed by preceding algorithm;
n(v) ∈ N is the current number of v computed by the
algorithm (initially n(v) = 0); N (v) ∈ N × L × N2
is the local view of v. At the end of the execution, if
(m, , i, j) ∈ N (v), then v has a neighbor u whose number
is m, whose label is and the arc from u to v is labelled
(i, j). Initially N (v) = {(0, ⊥, 0, i) | i ∈ [1, degG (v)]}. M (v)
is a set, it is the mailbox of v and initially M (v) = ∅. It
contains all information received by v during the execution
of the algorithm. If (m, , N ) ∈ M (v), it means that at some
previous step of the execution, there was a process u such
that n(u) = m, λ(u) = and N (u) = N . Note that a(v)
and A(v) are used to check up to which the weak snapshot
computation is computed.
A message sent by a process u via the port i to the process
v has the following form < (n, , M, a ), i > where n is the
current number n(u) of u, is the label λ(u) of u, M is the
mailbox of u, a is the value of the counter a(u) and i = δu (v).
During the execution of the algorithm MW −S , each process
v attempts to get an identity which is a number between 1 and
|V (G)|. Once a process v has chosen a number n(v), it sends
it to each neighbor u with the port-number δv (u). When a
process u receives a message from one neighbor v, it stores
the number n(v) with the port-numbers δu (v) and δv (u). From
all information it has gathered from its neighbors, each process
can construct its local view (which is the set of numbers of
its neighbors associated with the corresponding port-numbers).
Then, a process broadcasts its number, its label and its mailbox
(which contains a set of local views). If a process u discovers
the existence of another process v with the same number then it
should decide if it changes its identity. To this end it compares
its local view with the local view of v. If the label of u or
the local view of u is “weaker” for the lexicographic order,
then u picks another number — its new temporary identity —
and broadcasts it again with its local view. At the end of the
computation, each process has computed a graph (D, δ ) such
that (Dir(G), δ) is a symmetric covering of(D, δ ).
The digraph (D, δ ) is a weak snapshot of (Dir(G), δ) and
is reconstructed by each process. From this snapshot, stable
properties such as deadlock, garbage, termination and token
loss, represented as graph invariants can be detected at each
process (see also [14] for more proofs and details).

We propose in Algorithm 3 to use previous algorithms with
an adaptation of the Mazurkiewicz algorithm [19] to permit
each process to compute a weak snapshot of the network.
In some sense, a weak snapshot is the “global view” or
the “maximal knowledge” of the distributed system that each
process can obtain ([20], Theorem 5.5) by only knowing its
size (or a bound on its size). These facts are summarized by:
Proposition 1. Let G be a distributed system. Stable properties such as termination detection, deadlock and garbage
collection detected in a snapshot G of G can be detected in
any weak snapshot of G. Furthermore, if processes know the
size of G then loss of tokens can be also detected in a weak
snapshot.
Under our assumptions, we cannot compute a snapshot.
Nevertheless from the previous proposition, we can solve
stable properties detection. It suffices that: at least one process
initiates Algorithm 1 (see Section II-B). Then, each process
detects an instant where the computation of all local snapshots
is completed (Algorithm 2) and at least one process initiates
the computation of a weak snapshot. Thus, each process
detects an instant where the computation of the weak snapshot
is completed and decides about the stable property.
Algorithm 3: Algorithm MW −S .
I : {n(v0 ) = 0 and no message has arrived at v0 }
begin
n(v0 ) := 1;
M(v0 ) := {(n(v0 ), λ(v0 ), ∅)};
for i := 1 to deg(v0 ) do
send < (n(v0 ), λ(v0 ), M(v0 ), a(v0 )), i > through port i ;
R : {A message < (n1 , 1 , M1 , a1 ), i1 > has arrived at v0 through port j1 }
begin
Mold := M(v0 );
aold := a(v0 );
M(v0 ) := M(v0 ) ∪ M1 ;
if n(v0 ) = 0 or
∃(n(v0 ), , N ) ∈ M(v0 ) such that (λ(v0 ), N (v0 )) ≺ ( , N ) then
n(v0 ) := 1 + max{n | ∃(n , , N ) ∈ M(v0 )};
N (v0 ) := N (v0 ) \ {(n , , i1 , j1 ) | ∃(n , , i1 , j1 ) ∈
N (v0 )} ∪ {(n1 , 1 , i1 , j1 )};
M(v0 ) := M(v0 ) ∪ {(n(v0 ), λ(v0 ), N (v0 ))};
if M(v0 ) = Mold then
a(v0 ) := −1;
A(v0 ) := {(i , −1) | 1 ≤ i ≤ deg(v0 )};
if M(v0 ) = M1 then
A(v0 ) := A(v0 ) \ {(j1 , a ) | ∃(j1 , a ) ∈ A(v0 )} ∪ {(j1 , a1 )};
if ∀(i , a ) ∈ A(v0 ), a(v0 ) ≤ a and a(v0 ) ≤ β then
a(v0 ) := a(v0 ) + 1;
if M(v0 ) = Mold or a(v0 ) = aold then
for i := k to deg(v0 ) do
send < (n(v0 ), λ(v0 ), M(v0 ), a(v0 )), k > through port k;

IV. VISUALIZING THE DEBUG INFORMATION
This section presents the corresponding implementation of
previous algorithms. We develop a debugging layer within a
visualization software to address the global snapshot and the
global predicate evaluation problems.

b) Computing a weak snapshot anonymously: Let (G, δ)
be a labelled graph with a port numbering δ. We assume that G
is anonymous and each process of G knows an upper bound,
denoted β, of the diameter of G. We present an algorithm,
denoted MW −S , which computes a weak snapshot, i.e., a
labelled digraph (D, δ ) such that (Dir(G), δ) is a covering
of (D, δ ).
The label of each process v is a tuple

A. The ViSiDiA Platform
ViSiDiA† (Visualization and Simulation of Distributed Algorithms) is a tool aiming at simulating and visualizing
the execution of distributed algorithms. Relying on a strong
† http://visidia.labri.fr

468

consider an anonymous and a fully-distributed model. Thus,
we underline that it can be easily developed and added as
a debugging feature within a simulation and visualization
software such as ViSiDiA. Hence, we allow designer of
distributed algorithms to know what happened and lead to the
point where something goes wrong. This feature also enables
to know in a distributed manner what is globally going during
a particular execution of an algorithm by detecting several
stable properties such as deadlocks and termination.
As a first perspective, a checkpoint and rollback recovery
system is under implementation. It will be an extension of the
simulation commands of ViSiDiA by adding a previous and a
next buttons. With these buttons, users will be able to browse
among checkpoints taken during any execution. Besides, user
oversight can be released by computing weak snapshots. We
plan to focus on this technique, and to visualize the graphs
within each process in a multi-scale approach. Finally, our
theoretical basis will be extended to rewriting rules and
mobile agents.

theoretical basis [21], ViSiDiA proposes several models for
distributed algorithms such as message passing, mobile agents
and moving sensors. Distributed algorithms can be easily
tested on ViSiDiA by the means of an API. Distributed
networks can be defined using an editor in ViSiDiA. Algorithms are run along with a visualization which respects events
sequencing. We present here new extensions of ViSiDiA.
B. Monitoring and debugging feature
c) Message passing: Consider a distributed system in
which a process crashes: the corresponding thread is deadlocked, whereas its neighbors are still waiting for its termination. We want our debugger to propagate the information
“a neighbor has crashed”. As the debugging operator cannot
be the deadlocked thread itself, we associate to each process
a second thread used for debugging. A process has now two
threads: one for algorithm execution, the other for debugging.
In the console now transit both execution and debug messages.
A process distributes each message according to its type to the
appropriate thread. The debugging thread monitors both the
algorithm thread and its incoming messages. If the algorithm
fails, all messages are processed by the debugging thread
(Figure 1).

R EFERENCES
[1] M. Raynal, Networks and distributed computation. MIT Press, 1988.
[2] R. Guerraoui and E. Ruppert, “What can be implemented anonymously?” in DISC, 2005, pp. 244–259.
[3] G. Tel, Introduction to distributed algorithms. Cambridge University
Press, 2000.
[4] A. D. Kshemkalyani and M. Singhal, Distributed computing. Cambridge, 2008.
[5] A. D. Kshemkalyani, M. Raynal, and M. Singhal, “An introduction
to snapshot algorithms in distributed computing,” Distributed Systems
Engineering, vol. 2, no. 4, pp. 224–233, 1995.
[6] F. Mattern, “Algorithms for distributed termination detection,” Distributed computing, vol. 2, pp. 161–175, 1987.
[7] G. Bracha and S. Toueg, “Distributed deadlock detection,” Distributed
Computing, vol. 2, no. 3, pp. 127–138, 1987.
[8] K. Marzullo and L. S. Sabel, “Efficient detection of a class of stable
properties,” Distributed Computing, vol. 8, no. 2, pp. 81–91, 1994.
[9] A. D. Kshemkalyani and B. Wu, “Detecting arbitrary stable properties
using efficient snapshots,” IEEE Trans. Software Eng., vol. 33, no. 5,
pp. 330–346, 2007.
[10] A. D. Kshemkalyani, “Fast and message-efficient global snapshot algorithms for large-scale distributed systems,” IEEE Trans. Parallel Distrib.
Syst., vol. 21, no. 9, pp. 1281–1289, 2010.
[11] D. Angluin, J. Aspnes, D. Eisenstat, and E. Ruppert, “The computational
power of population protocols,” Distributed Computing, vol. 20, no. 4,
pp. 279–304, Nov. 2007.
[12] K. M. Chandy and L. Lamport, “Distributed snapshots: Determining
global states of distributed systems,” ACM Trans. Comput. Syst., vol. 3,
no. 1, pp. 63–75, 1985.
[13] J. Matocha and T. Camp, “A taxonomy of distributed termination
detection algorithms,” Journal of Systems and Software, vol. 43, no. 3,
pp. 207–221, 1998.
[14] J. Chalopin, Y. M´etivier, and T. Morsellino, “On Snapshots and Stable
Properties Detection in Anonymous Fully Distributed Systems (Extended Abstract),” in Proceedings of the 19th International Colloquium
on Structural Information and Communication Complexity (SIROCCO),
vol. 7355. LNCS, 2012, pp. 207–218.
[15] B. Szymanski, Y. Shy, and N. Prywes, “Synchronized distributed termination,” IEEE Transactions on software engineering, vol. SE-11, no. 10,
pp. 1136–1140, 1985.
[16] N. Santoro, Design and analysis of distributed algorithm. Wiley, 2007.
[17] J. L. Gross and T. W. Tucker, Topological graph theory.
Wiley
Interscience, 1987.
[18] P. Boldi and S. Vigna, “Fibrations of graphs,” Discrete Math., vol. 243,
pp. 21–66, 2002.

Fig. 1: Message passing at process scale. A process contains a mailbox
and two threads: one for algorithm execution, the other for debugging. Left:
In normal case, messages are routed according to their type. Right: If the
algorithm crashes, the debugging thread takes over.

d) Visual components: The ViSiDiA graphical interface
contains a button to launch the debugger during an algorithm
execution. Debug information shows up as a tree view for
processes and incoming channels, and some evaluated global
predicates are listed in another panel. These information can
also be visualized when the mouse hovers over a node. We are
currently developing an improved visualization based on weak
snapshots. Weak snapshot computed by each process appears
close to each node in ViSiDiA. See Section III for details on
debug information nature.
e) API extension: Debugging features have been added
to the ViSiDiA API. Algorithm developers can thus monitor
the value of specified variables and test if a global predicate
occurs, just adding a few lines of code.
V. CONCLUSION
In this paper, we present a complete debugging solution
which relies on a fully distributed architecture and does not
assume particular hypothesis on the network. Several processes
can initiate the debugging process at any time and each process
only have to know a bound on the size of the network. We

469

[19] A. Mazurkiewicz, “Distributed enumeration,” Inf. Processing Letters,
vol. 61, pp. 233–239, 1997.
[20] D. Angluin, “Local and global properties in networks of processors,” in
Proceedings of the 12th Symposium on Theory of Computing, 1980, pp.
82–93.
[21] B. Derbel and M. Mosbah, “Distributing the execution of a distributed
algorithm over a network,” in INFOVIS’03, july 2003, pp. 485 – 490.

470


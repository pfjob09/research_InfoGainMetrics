Information Visualization of Multi-dimensional Cellular Automata using GPU Programming
St´ephane Gobron, Daniel Mestre
Movement and Perception Laboratory, Federative Research Institute Marey
UMR 6152, CNRS, University of Aix-Marseille II, Luminy, F-13009 Marseille, France.
{stephane.gobron, daniel.mestre}@univmed.fr

Abstract
We propose a method for generating all possible rules of multidimension Boolean cellular automata (CA). Based on an original encoding method and the programming of graphical processor units (GPU), this method allows us to visualize the CA information flow in real-time so that emerging behaviors can be
easily identified. Algorithms of first and von Neumann neighborhood second degrees are detailed with their respective Fragment
Shaders programs. As symmetrical CA rules are especially useful in many research fields, we propose an encoding technique to
automatically derive their codes; we then apply this technique to
identify the 4096 possible cases for surface CA. To show the efficiency of our model a set of converging global behaviors are listed
and described. In the last part of the paper we present methods
for developing Moore neighborhood in two and in three dimensions. Finally we discus issues concerning computation and the
visualization of non-Boolean and higher dimension CA.
Keywords—Cellular automaton, information visualization,
emerging behavior, real-time imaging, GPU programming,
computer graphics.
1

Introduction

This paper focuses on the cellular automaton (CA) multi-dimensional
representation and behavior identification in the visualization and
information domains.
In any natural phenomena, the complex behavior and diversity that can be observed at a macroscopic level are essentially
due to the fact that there are numerous particles in continual interaction. Furthermore, when working at one level, a description
in terms of the preceding level can unify phenomena that were
previously considered as individual cases. In fact, CA embodies such multi-level observations as it consists, at low levels of a
set of change of states –called ”rule”–and at high levels we can
observe an emerging behavior. CA is a powerful tool which only
refers to states, rules, and time: CA rule is a set of change of states
for all possible states of every cell in its neighborhood. Hence, in
order to simulate multi-behavior surface effects, CA appears to be
a relevant prospect field of research. Unfortunately, CA emerging phenomena are very often impossible to predict by theoretical
approaches [23]. To help researchers identify these emerging behaviors, we propose real-time graphical visualization tools which
allow massive computational CA change of states for fast renderings. Let’s first present the literature and the structure of the
paper.
1.1

Background

This study belongs to the fields of CA and computer graphics
(CG) applied to multidimensional information visualization (IV).

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

Figure 1: Information visualization of a 2D-CA: an example
of equivalent rule (symmetrical rule #1370) at step t and t+1;
see section 4 for details.

Literature dealing directly with computer graphical CA has become more and more prevalent, especially since GPU programming became popular [3, 21] and following the publishing of a
fundamental book by Stephen Wolfram [23] which covers all practical aspects of CA. If we assume that every structure with interacting elements is a type of CA, references will actually be too
numerous to mention. That is why we refer the reader to [8]
where a non exhaustive list of well-known references in fields
relative to formal, classical, and applied CA is provided, as well
as CG and GPU programming. Nevertheless, with respect to CA,
and GPU here is a selection of very recent publications on various
research directly related to IV.
• Theoretical CA neighbors and global behavior [12];
• CA and IV: Social behavior [22]; Species competition and evolution [2]; Biology: tumor growth [18], bacteria swarming [24], Epidemiology prediction [16]; Image compression [14].
• GPU and IV: Surgery [11]; Graphical shadow research [25]; realistic local illumination and multilayered thin film interference [4];
fast fourier transform [5].

We did not find however any paper referring to information
visualization of CA based on GPU as is our approach in this paper.
1.2

Overview

This paper is organized as follows. For non-specialists of OpenGL
Shading Language (GLSL) [15,13] (URL: [20]), we begin in section 2 by presenting GPU programming, CA general concepts,
and the software and hardware contexts. Section 3 presents classical first dimensional Boolean CA including twenty of its most
famous rules. Section 4 describes how to extrapolate to direct

neighborhood in 2D, emphasizing a technique to identify symmetrical rules. A set of non-symmetrical and symmetrical graphical results are then presented. Key ideas concerning higher dimensions and non Boolean CA are detailed in sections 5. Finally,
section 6 concludes the paper and outlines some related future
work.

2

Introduction to GPU and CA

In order to increase CA computations we use a GPU programming based approach. The following section introduces concepts
relative to graphical processor units (GPU) and cellular automaton (CA) which will be used in this paper.
2.1

Graphical processor unit

Over the last few years, GPU programming has increased CPU
computational capacity by a factor of about twenty [3, 9, 19, 7].
The formal Shaders algorithms used in this paper, is based on a
previous work on artificial retina simulation [7]. As the current
paper focuses on the information visualization of CA, only main
ideas underlying Shaders software development are presented.

Figure 3: Details of the linking between CPU and GPU.

was one of the challenges solved in this paper (see rule and CAkey code definitions in subsection 2.3). Finally, (see the light
green zone in figure 2) Shaders pointers can be released by detaching and then deleting the Shaders program using respectively
the glDetachObjectARB() and glDeleteObjectARB() ARB functions.
2.2

Hardware, software, and rendering technique

All algorithms presented in this paper were developed in C++ on
Microsoft Windows XP-pro using M SV C++, the graphical library OpenGL [15], and the OpenGL Shading Language (GLSL)
[13]. CA and corresponding graphical results were computed and
rendered using 3.105 cells using a XeonT M CP U (3.19 GHz)
with 3 Gb of RAM (note that for this application 512 Mb is
largely sufficient) and a NVidia Quadro 3500 graphical card. Indeed, to highlight the efficiency of the method presented in this
paper, our technique offers real-time performances on cheap and
easily available computing systems.
Figure 2: Basic CG-engine algorithm using GLSL.

2.3

CA vocabulary, concept and definition

Figure 2 presents a basic OpenGL graphical engine including the three key sections which allow the C++ program (CP U )
to communicate with the Shaders program (GP U )–in our case
OpenGL Shading Language (GLSL). A solution to the non-obvious
ARB initialization calls (shown in light pink figure 2) is proposed in figure 3 and consists of the following six steps:
1. associate a Vertex and Pixel Shaders pointers to source files;
2. compile Vertex and Pixel Shaders programs;
3. if compilation is fine...
4. ...and from a unique Shaders program pointer...
5. ...then attach Vertex and Pixel pointers to the Shaders program;
6. finally, link them all together.

The main loop (see the light blue zone in figure 2) which allows cellular buffers to be consider as textures and copied back
to matrices, is detailed in [7]. Notice that once C++ and Shaders
programs are linked, data transmission can be performed. However, to maintain the high performance of the algorithm, the communication and the number of Shaders-code lines have to be kept
to a minimum. Developing a single Shaders program –for each
type of CA—allowing any possible solutions to be visualized,

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

Figure 4: Multidimensional CA geometric representations:
(a) 1DCA; (b, c, and e) 2DCA; (d and f) 3DCA.
Here is a short introduction to some important CA concepts
such as notions of CA type, neighborhood, rule, change of state,
and CA-key code.

βCA
0
0
0
...
1

Cellular automaton types are presented in figure 4 which illustrates most 1st , 2nd , and 3rd dimensional CA. A CA-type depends on its dimensional domain and its number of neighbors.
For instance, we can see that for the 2nd dimension, three types
of CA neighborhoods exist:

βCB
0
0
1
...
1

βCC
0
1
0
...
1

βCx,y
ϕ1
ϕ2
ϕ3
ϕi
ϕ23

Table 1: 1D-Boolean CA truth table.

• figure 4(b) the classical grid direct neighborhood –also called van
Neumann neighborhood;
• figure 4(c) the hexagonal grid neighborhood;
• figure 4(e) the classical grid indirect neighborhood –also called Moore
neighborhood.

As previously said, a CA rule is a set of change of states
where all possible states of every cell in the neighborhood is defined. For instance, for a unique set of Boolean values of ϕ1 ,
ϕ2 ,... , ϕ8 the truth table 1 represents one rule of the Boolean 1DCA (also note 1Db CA). A CA-key code is the encoding of a rule,
e.g. one of the fractal emergent behavior in figure 5 has a CAkey code of 146. The CA-key code –instantiating a CA-rule—is
a fundamental notion used in this paper. In fact, to be able to
produce a general method and as data transmission between CPU
and GPU can only be done by a limited number of parameters
(which varies depending on the generation of the graphical card),
we need to use the CA-key and find a way to decode it in the
Shaders program. The encoding of this key is proportional to the
number of possible rules (ρ), which unfortunately increase exponentially (see sections 4 and 5). Hence, considering that the state
of a cell C remains in a discreet domain of n possible cases, (for
instance, n would be 2 for Boolean, 256 for unsigned char integer), the number of neighbors of C is N . Then, the maximum
value of the key is shown by equation 1 where C represents the
number of possible combinations of the neighborhood states.
C

ρ = n with C = n

(N +1)

⇒ρ=n

n(N +1)

(1)

For more details concerning general and theoretical concepts
related to CA, we strongly advice Stephen Wolfram’s pedagogic
book [23]. Now that basic concepts and the hardware context
have been defined, we move on in the following section to propose a model for computing any rule of 1D-CA enabling the visualization of the corresponding data flow.

3.1

GPU-accelerated 1Db CA Fragment Shaders model

Considering a root image P (∆x , ∆y ) where ∆x and ∆y are respectively column and row numbers, P can only be interpreted
in the GP U as a texture T (0.0 ... 1.0, 0.0 ... 1.0). Then for
any Φ 1Db CA rule, we need to find the Boolean change of state
corresponding to the next row. In particular, for any cell C[x,y+1]
at time t, we have:
C(t+1)[x,(y+1)] = Φ(C(t)[x−1,y] , C(t)[x,y] , C(t)[x+1,y] )

(3)

3

Using equation 1, the current possible rule ρ is 22 = 256.
Among these 256 possible rules, a rule Φ can also be interpreted
as a set of 8 Boolean values (ϕ):
∀Φi ∈ (0..255)i | ∃Φb ∈ ([0..0]..[ϕ1 ..ϕ8 ]..[1..1])b

(4)

As texture has to be used with length and height ranging from
0.0 to 1.0, we must define δx and δy as the texture thickness of
one line and one row, so that:
1
1
and δy =
(5)
δx =
∆x
∆y
Then we can find the texture coordinates τ () of the three cells
CA , CB , CC (cell neighborhood, respectively the upper left, central, and right cells) necessary for the change of state using a vectorial translation:

−−−−−−→

τ (CA ) = τ (Cx,y ) + (−δx , −δy )
−−−−−→
∀Cx,y : τ (CB ) = τ (Cx,y ) + (0.0, −δy )
(6)

−−−−→

τ (CC ) = τ (Cx,y ) + (δx , −δy )
From that point, we use the Boolean state function β() defined on
a cell Cx as:

3

One dimensional cellular automata

β(Cx ) = (Σ(Cx .R, Cx .G, Cx .B) < 1.5)b

Unidimensional CA defined as a set of c cells Cx are represented
as a 2D-matrix –often as a textured triangular picture when using
a single root. Every line is related to each change of state which
occur over time. Therefore, for each row y, the Boolean states of
C –which we symbolize by β(Cx )—at a time t + 1 has to satisfy:
β(Cx )@(t + 1) = β(C(t+1)[x,y+1] )

(2)

A less formal way to interpret equation 2 is to say that a row
y represents the y th change of state at time t which means that
y and t are equivalent in this dimension –see figure 5. On this
basis, the next sub-section 3.1 formally presents the Pixel Shaders
structure of the one dimensional Boolean CA.

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

(7)

In the domain of computer graphics (CG) [6], the most common representation of colorimetry is the RGBα four components. In 1D, first the alpha parameter is not being used, and
second the 3 other parameters represent a waist of memory, i.e.
three real numbers to encode a Boolean... We will see in section 5
that RGBα-textures can be used in a much more efficient way.
Thus to find the final new state of a cell C, we only have to use
the truth table 1 with equation 7.
Finally, we can deduce equation 8 and therefore, the CA-key
code of 1Db CA can be transmitted to the Shaders program in one
byte Tb .
βCx,y = ϕ(βCA βCB βCC )b

(8)

3.2

βCA
0
0
0
...
1

1D results and observations

Our 1Db CA model has a constant computational rate of about
876 millions change of states per second.

βCB
0
0
0
...
1

βCC
0
0
0
...
1

βCD
0
0
1
...
1

βCE
0
1
0
...
1

βCx,y
ϕ1
ϕ2
ϕ3
ϕi
ϕ25

Table 2: 2Db CA van Neumann truth table.

βCA
0
0
1
1

βCB
0
1
0
1

βCx,y
Tb1 : ϕ1..8
Tb2 : ϕ9..16
Tb3 : ϕ17..24
Tb4 : ϕ25..32

Table 3: Another way to encode 2Db CA van Neumann using four bytes.

4.1

Figure 5: Twenty of the most popular 1D Boolean CA –also
called 1Db CA; here the x-axis represents the automate cells
and y-axis the time.
Figure 5 presents various examples of unidimensional Boolean
CA with their respective rule number using a texture of 640 by
480. The four classes of feedback behavior (see [23]) that CA
can exhibit are shown, i.e.: convergence to a fixed, homogeneous
state (e.g. rule 54); a chaotic aperiodic structure (e.g. rule 101); a
simple separated periodic pattern (e.g. rule 105); and a recursive
periodic but acyclic behavior (e.g. rule 193). Notice that these
results appear slightly inclined as they were rendered in 3D. In
the following section 4 we present a solution to visualize second degree direct neighborhood data flow, and eventually identify
emerging behaviors with their respective CA-key codes.

4

As hexagonal grids are incompatible with our current CG texture method, and Moore neighborhood requires too much data to
be transmitted to the Shader program, we focus on the study of
direct neighborhood grids (see section 5 for higher degree CA).
Analogous to Φ1D shown in equation 4, the term Φ2DvN has
to be encoded by a set of Boolean, only that time with 64 bits:
[ϕ0 ϕ1 ..ϕ64 ]. CG texture δx and δy as well as Boolean state function β() remain the same. Of course, in 2D, x and y are required
for information visualization. Emerging behaviors can directly
be identified by graphical texture forms, shapes, or silhouettes.
Behaviors involving time then have to be evaluated through animation sequences. A, B, D, E being the four neighbors of the
central cell C, corresponding texture coordinates τ () (see equation 6 and figure 4(b)) are now defined by:
τt+1

5

• ρ2DvN = 22 = 4294967296

4.3 billion, and a key of 4 bytes;

• ρ2DH =

7
22

18 billion billion, and a key of 16 bytes;

• ρ2DM =

9
22

1.34 10154 rules, and a key of 64 bytes.

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

CB

CA
CC
CE


CD

=

−−−
→
 −
τ(t) (Cc ) +  (−δx , 0)

Two dimensional cellular automata

Following from the previous section on 1Db CA our next goal
is to design a general Shaders algorithm to visualize any rule of
Boolean CA in two-dimension. The structure of this section is
similar to the previous with subsection 4.1 presenting a formal
algorithm of 2Db CA, subsection 4.2 a set of six examples. In
the domain of real-time imaging, symmetrical CA can be very
useful (CG surface texture [17, 10], image analysis [7]) that is
why in the last two subsections 4.3 and 4.4 we propose a specific
technique to automatically derive those symmetrical rules. Three
rules ρ2DvN , ρ2DH , and ρ2DM can be associated to the van Neumann, hexagonal, and Moore neighborhoods –see figure 4(b), (c),
and (e). From equation 1 we can deduce that:

GPU-accelerated 2Db CA Fragment Shaders model

−−−→
(0, −δy )
→
−
0
−−→
(0, δy )


−−→ 
(δx , 0) 

(9)

From the truth table 2, we can notice that the transmitted
CA-key code [Tb1 , Tb2 , Tb3 , Tb4 ] corresponds to each of the four
combinations of ϕA and ϕB . Hence, we can reuse a single byte
decoder similar to the one developed for 1D − CA –see table 3.
This method saves around 75% of the Shaders lines and therefore
the algorithm is three to four times faster.
4.2

General case results

Figure 6 proposes six examples of van Neumann 2Db CA initialized with a single bit set to ”1” placed in the center of the
texture. However based on very simple changes of states, these
CA illustrate how complex the emerging behaviors can become:
(a) generates a silhouette of a quarter circle; (b) presents a complex fractal shape based on a recursive pattern with empty triangles in the upper left corner and non-ordered cellular sets on

Figure 8: Examples of real snowflakes presenting symmetrical patterns.

Figure 6: Example of 2Db CA asymmetrical rules generated
from a single root.

the right; figure 6 (c) shows acyclic fractal patterns texture and
regular fractal in silhouette; (d) belongs to a family of polygonal
shape generation; (e) demonstrates that order and chaos can coexist in a triangle silhouette; (f) belongs to a family of leaf shape
generation.

Figure 9: All possible cases of central symmetry in direct
2Db CA.

from truth table 2; a graphical interpretation of Si is presented
figure 9.Then each bit of [ϕ1 ..ϕ32 ] correspond to the sequence
presented table 4. Reciprocally, we have now to derive for any
[S1 ..S1 2] symmetrical key, its corresponding four byte key (Ta ,
Tb , Tc , Td ). As every byte is encoded on sequence of eight bits
(from higher to lower powers of 2, e.g. Tb ≡ [b8 b7 b6 b5 b4 b3 b2 b1 ]b ),
we can derive the table 5. Finally, based on table 5, the general
four bytes key code for any symmetrical rule can be deduced as
shown in table 6.
4.4

Figure 7: An example of 2Db CA asymmetrical rules generated from a complex root: fluid/sedimentation-like simulation

Figure 7 illustrates a example of fluid and sedimentation like
simulation. Based on an initial face texture pattern shown figure 7(a1 ), the first steps (a2 ) to (a6 ) show melting and stalactitelike sedimentation. Then from (a7 ) to (a11 ) three information behaviors can be visualized: half-dynamic (see figure 7(b1 )), static
(stalactite and stalagmite-like –see (b2 )),and pure cyclic (pure
fluid-like–see (b3 )).
4.3

General case results

Our direct-neighbor 2Db CA model has a constant computational
rate of about 189 million change of states per second. As demonstrated in the above sub-section, only 4096 symmetrical rules exist. These can be divided into three fields of application: image analysis, surface convection detection, and pattern memory1 .
Based on triple roots texture, figure 10(a) illustrates how powerful
a CA tool can be in finding contours. The first contour CA is proposed in figure 10(b) converging after 5 steps to (c) –symmetrical
key #2254. The second contour CA is presented in (d) –and (e)
being its Boolean complement for comparing with (b)—directly
converging via a bit inversion –symmetrical key #0069. Notice
that the first filter proposes the inside silhouette, and that the second one an outside silhouette. Figures 10(f) to (j) propose a more
complex contour transformation such that only horizontal, vertical, and diagonal patterns remain –symmetrical key #0446.
Another complex behavior can be observed in figure 11: surface convection detection –symmetrical key #1328. In this complex CA, we can observe that after filling the entire texture of
1 These figures being composed of very fine blank and white dots, behaviors should be observed at very high resolution using electronic version or on our web site [1].

Identifying symmetrical rules

As previously explained, although symmetrical rules could be
particularly interesting in many research fields, identifying the
CA-key codes can be difficult. In nature, symmetrical pattern
can easily be found, for instance snowflakes as shown figure 8.
Thus we have developed a method to identify central symmetry. We identify the 12 non-redundant change of states (S1 ..S12 )

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

(Tb1
(Tb2
(Tb3
(Tb4

:)
:)
:)
:)

[S1
S2
S2
S3

S2
S3
S7
S8

S2
S7
S3
S8

S3
S8
S8
S11

S4
S5
S5
S6

S5
S6
S9
S10

S5
S9
S6
S10

S6
S10
S10
S12 ]

Table 4: Analyzing symmetrical properties of truth table 3
with patterns proposed figure 9.

S1
a8

S2
a7
a6
b8
c8

S3
a5
b7
c6
d8

S4
a4

S5
a3
a2
b4
c4

S6
a1
b3
c2
d4

S7
b6
c7

S8
b5
c5
d7
d6

S9
b2
c3

S10
b1
c1
d3
d2

S11
d5

S12
d1

Table 5: Associating symmetrical keys to bits of the bytebased CA-key code.

Ta
Tb
Tc
Td

20
S6
S10
S10
S12

21
S5
S9
S6
S10

22
S5
S6
S9
S10

23
S4
S5
S5
S6

24
S3
S8
S8
S11

25
S2
S7
S3
S8

26
S2
S3
S7
S8

27
S1
S2
S2
S3

Table 6: Final four bytes CA-key code T reconstructed from
symmetrical a S key of 12 bits .

random-like cellular states, only few unstable strings-like region
remain, always converging to minimize their respective length.
As the CG-texture used here is not limited in dimension (i.e.
max(x, y) + 1 = 0 and min(x, y) − 1 = max(x, y)), depending of the root, the pattern will converge to x or y perfectly
straight lines –as shown figure 11(l). However quite useless in
two-dimension, we believe that this CA could be extremely useful in three-dimension. The front page figure 1 and figure 12
present a CA that can memorize and repeat patterns with a cycle
of 16 steps. This behavior is quite spectacular as shapes seem to
disappear and become random noise. Nevertheless, the enlarged
region of screen shot 12(f) shows the cells are not ordered randomly but rather in a maze-like pattern. An animation of this
phenomena as well as other CG-pictures can be seen at the U RL
referred in footnote 1.

Figure 10: Example of symmetrical 2D-CA contour behavior: (a) initial figure; (b) first step of 2DCA-contour rule (simkey #0069) converging at step four in (c); (d) 2DCA-contour
rule (sim-key #2254) converging at first step with a color inversion –(e) being its boolean complement; (f) to (j) 2DCAcontour (sim-key #0446) where only the four direction lines
remain.

for as long as this issue remains unresolved, there is no point in
designing a GPU-CA model for such dimension or higher.
5.2

5

Higher Dimensions and non-Boolean CA

We have mainly explored first and direct neighborhood second
dimension CA and found many examples of interesting behavior.
In this section we present issues and propose some solutions to
extend our models to higher dimensions and non-Boolean CA.
5.1

Hexagonal grid and third dimension

Even if their respective graphical geometric structures are different, hexagonal and 3rd dimension direct neighborhood CA
(see figure 4(c and d) generate an equivalent number of key rule
7
(i.e.: ρ2DHbCA = ρ3DvNbCA = 22 ) which is around 18 billion billion. Following from what has been shown in this paper,
to identify interesting behaviors, we have to decrease the number of key rules by considering symmetrical rules of those CA.
For hexagonal grid based CA, we believe that a more natural cellular structure will lead to promising studies. Concerning direct
neighborhood 3D-CA, nowadays maximum graphical card memory is typically 768M b and therefore as 3D-textures can directly
be instantiated a 900 cells side cube can be generated –which
can produce sufficient renderings. For 2D Moore neighborhood
and 3D CA, even Boolean cells produce a real challenge as a the
number of key rule code is: 3DMb CA: 2 pow( 2 pow( 19 ) ) = 2
pow( 524288 ), round e9215 which is hard to conceive. Therefore

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

Non-Boolean CA

Indeed, non-Boolean CA is not really an issue as cellular values
can be interpreted as thresholds. Of course, key-rule code numbers will increase exponentially but we can imagine encoding the
four texture RGBα parameters in a more efficient way to simulate cellular thresholds.

6

Conclusion and future work

We have presented an original method to visualize CA of different
dimensions to identify their emerging behavior. After explaining
the use of CA and the need for such a tool, we summarize the
technique of GPU programming and detail how to encode 1D
and 2D von Neumann CA. In particular, we have presented an
original way of sorting symmetrical 2D CA. To show the capabilities of our model, we have presented a non restricted set of
convenient rules simulating fractals, drop and string like sets, and
contour identification. We then discussed ways and issues to implement non Boolean and higher order CA. Based on the ideas
developed in this paper, we are hoping to identify other emerging
behaviors and we are also currently developing a general method
for real-time information visualization of 3D-CA. In the field of
computer graphics (CG) this research can help model an accelerated and generalized 3D-surface CA [8] –i.e. where any symmetrical or asymmetrical CA could be directly encoded without
developing specific code. Furthermore, virtual reality (VR) being

Figure 11: 2D-CA Strings-like behavior (sym-key #1328):
(a) to (d) initial steps; (e) merging of stable regions; (f) to
(g) stable region becomes dominant as ”strings” appears; (h)
to (l) all strings decreases as remains only unlimited string
regions.

one of the major topics of our research team, we are currently designing CA models interacting with scenes and end-users as well.
For instance, sceneries based on real-time weathering textures or
interactive intuitive CA-based menu for helping parametrization.

Acknowledgment
We would like to thanks Mr Herv´e Bonafos, Mr Jean-Marie Pergandi, and Mr C´edric Goulon, for their technical support, daily
services, and being part of our great CS team! Special thanks
are also due to Mrs Thelma Coyle for her kindness and the proofreading of the text.
References
[1] CNRS-Univ.Aix-Marseille II IFR Marey Additionnal pictures, S. Gobron.
http://www.laps.univ-mrs.fr/~gobron/, 2007.
[2] B. Chopard and D. Lagrava. A cellular automata model for species competition and evolution. In The International Conference on Cellular Automata for
Research and Industry (ACRI06), Springer, pages 94–103, Perpignan, France,
september 20-23 2006.
[3] S. Druon, A. Crosnier, and L. Brigandat. Efficient cellular automaton for 2d /
3d free-form modeling. Journal of WSCG, 11(1, ISSN 1213-6972), 2003.
[4] R. Durikovic and R. Kimura. Gpu rendering of the thin film on paints with
full spectrum. In Tenth International Conference on Information Visualisation
(IV’06), IEEE Computer Society, pages 751–756, London, UK, 5-7 July 2006.
[5] O. Fialka and M. Cadik. Fft and convolution performance in image filtering on
gpu. In Tenth International Conference on Information Visualisation (IV’06),
IEEE Computer Society, pages 609–614, London, UK, 5-7 July 2006.
[6] J.D. Foley, A.F. van Dam, K. Stephen, J.F. Hughes, and R. Phillips. Introduction to Computer Graphics, principles and practice. Addison-Wesley, 2nd
edition, 1993. 1175 pages.
[7] S. Gobron, F. Devillard, and B. Heit. Retina simulation using cellular automaton and GPU programming. Machine Vision and Applications Journal,
Springer Berlin-Heidelberg, pages 1432–1769, 2007.
[8] S. Gobron and D. Finck. Generating surface textures based on cellular networks. In The Geometric Modeling and Imaging international conference
(GMAI06), IEEE Computer Society, pages 113–120, Londres, UK, july 5-7
2006.
[9] M. Harris. Implementation of a cml boiling simulation using graphics hardware. In CS. Dept, UNCCH, Tech. Report, volume 02-016, 2003.

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

Figure 12: 2D-CA (sym-key #1370) for the following steps:
(a) initial figure; (b,c,d) first, second, and fifth steps; (e) step
255 mature growth (d); (f,g) respectively step 511 and 512
–also shown figure 1.

[10] S. Lefebvre, S. Hornus, , and F. Neyret. All-purpose texture sprites. In INRIA
Research Report 5209, INRIA, Grenoble, France, 2004.
[11] Jesper Mosegaard, Peder Herborg, and T.S. Sorensen. A gpu accelerated
spring mass system for surgical simulation. Studies in Health Technology and
Informatics, (978-1-58603-498-6):342–348, 2005.
[12] H. Nishio. How does the neighborhood affect the global behavior of cellular
automata? In The International Conference on Cellular Automata for Research and Industry (ACRI06), Springer, pages 94–103, Perpignan, France,
september 20-23 2006.
[13] R.J. Rost. OpenGL Shading Language. Addison Wesley Professional, 2nd
edition, 2006. 800 pages.
[14] C. Shaw, S. Das, and B.K. Sikdar. Cellular automata based encoding technique for wavelet transformed data targeting still image compression. In The
International Conference on Cellular Automata for Research and Industry
(ACRI06), Springer, pages 94–103, Perpignan, France, september 20-23 2006.
[15] D. Shreiner, M. Woo, J. Neider, and T. Davis. OpenGL Programming Guide:
the official Guide to learning OpenGL v2.0. Addison Wesley Professional, 1st
edition, 2005.
[16] R. Slimi and S.El Yacoubi. Spreadable probabilistic cellular automata. In
The International Conference on Cellular Automata for Research and Industry
(ACRI06), Springer, pages 94–103, Perpignan, France, september 20-23 2006.
[17] Cyril Soler, Marie-Paule Cani, and Alexis Angelidis. Hierarchical pattern
mapping. In ACM, SIGGRAPH’02 Conf. Proc., July 2002.
[18] P. Topa. Towards a two-scale cellular automata model of tumour-induced angiogenesis. In The International Conference on Cellular Automata for Research and Industry (ACRI06), Springer, pages 94–103, Perpignan, France,
september 20-23 2006.
[19] J. Tran, D. Jordan, and D. Luebke. New challenges for cellular automata
simulation on the gpu. www.cs.virginia.edu, 2003.
[20] Shaders tutorials. http://www.3dshaders.com/joomla/, 2007.
[21] L. Wang, X. Wang, X Tong, S. Lin, S. Hu, B. Guo, , and H-Y. Shum. Viewdependent displacement mapping. In SIGGRAPH’03 Conf. Proc., volume 22,
pages 334–339, 2003.
[22] J. Was, B. Gudowski, and P.J. Matuszyk. Social distances model of pedestrian dynamics. In The International Conference on Cellular Automata for
Research and Industry (ACRI06), Springer, pages 94–103, Perpignan, France,
september 20-23 2006.
[23] S. Wolfram. A new kind of science. Wolfram Media Inc., 1st edition, 2002.
1197 pages.
[24] Y. Wu, N. Chen, M. Rissler, Y. Jiang, D. Kaiser, and M. Alber. Ca models of myxobacteria swarming. In The International Conference on Cellular
Automata for Research and Industry (ACRI06), Springer, pages 94–103, Perpignan, France, september 20-23 2006.
[25] Y. Xiao and J. Yicheng. Gpu based real-time shadow research in large shiphandling simulator. In Tenth International Conference on Information Visualisation (IV’06), IEEE Computer Society, pages 585–590, London, UK, 5-7
July 2006.


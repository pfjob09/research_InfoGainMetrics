Maintaining a Random Binary Search Tree Dynamically
Prasad Vinod
Dept. of Technology, Majan
University, Sultanate of Oman.
vinod136@msn.com
vinod@majancollege.edu.om

Suri Pushpa
Dept. of Computer Science and
Applications, Kurukshetra
University, Haryana, India.
pksuri@kuk.ernet.in

Abstract
Binary tree is a graph, without cycle, that is frequently
used in computer science for fast data access and
retrieval. To ensure faster insertion and deletion, the tree
height has to be kept to a minimum. A random tree starts
loosing its randomness after a series of insertions and
deletions and, in the worst case, a tree with n nodes,
could grow up to the height of n-1. In this paper, we
present modified insertion and deletion algorithms to
maintain the tree in better shape dynamically. Without
applying any complex rebalancing technique, or using
considerable amount of space, both algorithms maintain
the tree in such a way that even a series of insertions and
asymmetric deletions do not cause the tree to grow
beyond n/2. A comparative study of traditional and
modified insert algorithms shows that for random input,
the modified insert algorithm produces a tree with 20% to
30% reduction in height, forcing the average number of
comparisons required for a successful search to go down
by 15% to 20%.

Carsten Maple
Dept. of Computing and
Information Systems, University
of Luton, United Kingdom.
carsten.maple@luton.ac.uk

situations optimal shape may not be a primary concern,
particularly where rebalancing cost overtakes all the
benefits. In such situations a random tree could be
preferred over its balanced version. A random tree, on
average, requires approximately 39% more comparisons
than the balanced tree [6]. However, in most cases a
random tree behaves much better than this. These facts
clearly show that a random tree could be a better
alternative where optimality is not a big issue, and treerestructuring cost is high. This option could become more
attractive when insert-delete algorithms are capable of
maintaining the tree in better shape without considerable
effort. To create a random binary tree conventional insertdelete algorithms [7] are mostly used. For the delete
algorithm, two variations asymmetric and symmetric
deletion exist. In asymmetric deletion, a node having both
sons is replaced by its successor, while in symmetric
deletion either successor or predecessor replaces a node
alternatively. For a random binary search tree, the
expected internal path length is θ(n lg(n)). Eppinger [8]
has shown that performing a large number of insertions
and asymmetric deletions increases the expected internal
3

1. Introduction
Binary search tree is a best-suited data structure for
data storage and retrieval when entire tree could be
accommodated in the primary memory. However, this is
true only when the tree is height-balanced or nearly
optimal in shape. The lesser the height, faster the search
will be. Despite of the wide popularity of Binary search
trees there has been a major concern to maintain the tree
in proper shape as the tree may become unbalanced after a
series of insertions and deletions. To maintain the tree in
optimal shape many algorithms have been presented over
the years. For more details please refer to [1] - [5]. Most
of the algorithms are static in nature as they take whole
tree as input to create a balanced tree in two phases. Most
of the static algorithms developed so far run in time linear
to the size of input, and in some cases require a
considerable amount of additional space. In many

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

path length up to θ(n lg (n)), resulting the tree no longer
being random. This is because while performing insertion
or deletion, conventional insert-delete algorithms do not
take care of the shape of the tree. However, if symmetric
deletion algorithm is used, the expected internal path
length remains better. Algorithms proposed in this paper
maintain a random tree in better shape dynamically.

2. Modified insert algorithm
A tree would be more efficient than a random tree
provided that most of the nodes in the tree have their both
sub-trees non-empty. In the proposed algorithms we have
exploited this fact by not allowing too many nodes to
have their sub-trees empty. The essence of both insert
and delete algorithms is “Don’t allow any grandfather in
the tree to have empty sub-tree”. In such a case, even for
the worst input, the insert-delete pair will not allow the
tree to grow beyond n/2 instead of n-1 as conventional

algorithms do. During each insertion, prospective
grandfather of the new node is examined to check
whether it has any of its sub-tree empty. If not, insertion
of new node is done as usual, otherwise, following
insertion; sub-tree rooted at the grandfather is rotated in
an appropriate direction. Fig. 1 shows the worst case,
when a double rotation is required. Following the
insertion of node ‘38’, father node ‘40’ is rotated to the
right followed by left rotation of the grandfather node
‘35’. The insert algorithm makes use of two additional
pointers, ‘grandfather’ and ‘fgrandfather’ (the father of
the grandfather). Use of the grandfather in the algorithm
is straightforward (to check whether grandfather is having

.

20

15

any of its sub-tree empty) while fgrandfather is
maintained to keep track of the modified sub-tree
following the rotation. Procedure ‘insert’ takes one
additional parameter *temp_root to accelerate the deletion
process that is explained in the deletion algorithm. In the
insert algorithm *temp_root can be assumed as a pointer
to the root but in the deletion algorithm it has a different
meaning. During the process of deletion, a call to insert
algorithm may be required to reinsert a grandfather whose
one sub-tree has been deleted (dangling grandfather).
During reinsertion, *temp_root is a node from where
traversal of the tree begins. The whole process is
explained
in
the
deletion
algorithm.

20

Fgrandfather

30

15

20

30

15

30

Grandfather
25

35

25

40

(a)

38

35

Father

38

(b)
Newnode

38

25

35

40

40

(c)

Figure 1. (a): New node is inserted. (b): Father is rotated to right. (c) Grandfather is rotated to left.

Algorithms are implemented in C language where, we
have assumed that each node in the tree has three fields:
pointer to the left sub-tree, pointer to the right sub-tree
and a ‘key’. We have used conventional approach to write
procedures and to declare pointer variables, where, node
*ptr means ‘ptr’ is a pointer to a node type structure, ptr>key means the key value of the node pointed by ‘ptr’.
struct node
{
struct node *left;
struct node *right;
int key;
};
node *root=null;
//tree is empty
/* Procedure ‘insert’ takes two parameters to accelerate
the deletion process. For each insertion, the root of the
tree is passed along the newnode. Initially, root is null so,
temp_root is passed a null value */
procedure insert(node *newnode, node *temp_root)
{
node *ptr,*fgrandfather,*grandfather,*father;

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

ptr=fgrandfather=grandfather=father=temp_root;
if(temp_root==NULL) //tree is empty
{
root=newnode;
return;
}
/* Search a node to which a newnode has to be inserted.
When the ‘while loop’ terminates, father points to a node
to which the newnode has to be added. Grandfather points
to the grandfather of the newnode, and fgrandfather is the
father of the grandfather */
while(ptr!=NULL)
{
fgrandfather=grandfather;
grandfather=father;
father=ptr;
if(newnode->key==ptr->key) //Duplicate
return;
else if(newnode->key<ptr->key)
ptr=ptr->left;
else
ptr=ptr->right;
}// end while

/* Insert newnode as ususal */
if(newnode->key>father->key)
father->right=newnode;
else
father->left=newnode;
/* There is only one node (root) in the tree. Grandfather,
fgrandfather do not exist; normal insertion */
if(father==temp_root)
return;
/* Grandfather does not have the left sub-tree rotate the
sub-tree rooted at grandfather to the left. In a double
rotation father is rotated to right, followed by left rotation
of the grandfather and vice versa*/
else if(grandfather->left==NULL)
{
if(newnode->key>father->key)
ptr=rotate_left(grandfather);
else
ptr=rotate_right_left(grandfather);
//double rotation
}
/* Grandfather does not have the right sub-tree. */
else if(grandfather->right==NULL)
{
if(newnode->key<father->key)
ptr=rotate_right(grandfather);
else
ptr=rotate_left_right(grandfather);
//double rotation
}
/* Grandfather has both sub-trees full; normal insertion*/
else
return;
/* ‘ptr’ is not null; implies that tree is rotated. Following
the rotation tree needs to be adjusted accordingly. If root
is rotated, adjust root */
if(ptr!=NULL)
{
if(grandfather==root)
root=ptr;
else if(ptr->key<fgrandfather->key)
fgrandfather->left=ptr;
else
fgrandfather->right=ptr;
}
}//end insert

3. Modified delete algorithm
Deletion of a node from a binary tree has always been

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

a complex task. A series of asymmetric deletions results
in a tree to loose its randomness, and the tree becomes
worse in shape. However, algorithm presented here is also
asymmetric, but could be modified slightly so that on half
of the occasions, a node having both sub-trees is replaced
by its successor and half of the occasions by its
predecessor. To maintain the initial assumption that all
the grandfathers in the tree should have two sons, deletion
becomes slightly more complex. Let us assume that the
node to be deleted is being pointed by ‘ptr’; following
three cases are possibleCase 1: ‘ptr’ has both sub-trees full.
Replace ‘ptr’ by the smallest node (temp) in its right
sub-tree and make ‘ptr’ point to the ‘temp’ reducing, case
1 to case 2 or case 3. It must be noted that ‘temp’ can’t be
a grandfather; it could be either a leaf or may have only
one right son.
Case 2: ‘ptr’ has only one son.
Replace ‘ptr’ by son.
Case 3: ‘ptr’ is a leaf.
This is the most complex phase of the algorithm. The
father of the leaf node could have a grandson in the
opposite direction, and therefore merely deleting the leaf
node would leave the father (who is a grandfather of some
node) having only one sub-tree; violating the initial
assumption (a dangling grandfather). If the father of the
leaf node does not have any grandson, then the leaf node
‘ptr’ is deleted simply, otherwise, along the deletion of
the node ‘ptr’, father of the node ‘ptr’ (dangling
grandfather) is also removed and reinserted into the tree.
Insert algorithm takes care of where this node has to be
reinserted, and whether during the reinsertion any rotation
is required. One might assume that to reinsert a node, the
tree has to be traversed from the root again; but this is not
the case here. Instead, traversal begins from the point
where father was removed, making the deletion process
faster. This is why insertion algorithm takes two
parameters, making it possible to insert a node from any
location and not necessarily from the root. In fig. 2b, the
leaf node ‘25’ is deleted, leaving father node ‘20’ with
just one sub-tree. Since node ‘20’ is a grandfather of some
node in the left sub-tree, it has also to be removed (fig.
2c) and reinserted into the tree (fig. 2d). Fig. 2e shows the
final structure of the tree after rotation. During
reinsertion, a call to the insert algorithm can be avoided
by simply replacing father as a right most son in the left
sub-tree of itself and vice versa followed by a single
rotation if required fig. 2d and 2e (note that double
rotation will not be required during reinsertion). This
strategy will eliminate the need for two parameters in the
insert algorithm.

/* For the sake of simplicity procedure ‘delete’ is written
asymmetrically, and hence will provide better results
when modified slightly. ‘Key’ is the key field of the node
to be deleted. When the ‘while loop’ terminates ‘ptr’
points to the node to be deleted, father and grandfather
point to the father and the grandfather of the ‘ptr’. */
procedure delete(int key)
{
node *temp,*father,*grandfather,*ptr;
grandfather=father=ptr=root;
if(root==NULL) //empty tree
return;
while(ptr!=NULL)
{
if(ptr->key==key)
break;
grandfather=father;
father=ptr;
if(key<ptr->key)
ptr=ptr->left;
else
ptr=ptr->right;
}
if(ptr==NULL) //Key not found
{
return;
}
/* ‘ptr’ has both sub-trees. Replace ‘ptr’ from smallest
node ‘temp’ in the right sub-tree of ‘ptr’. Father and
grandfather points to the father and the grandfather of
‘temp’. Following the replacement, ‘ptr’ is modified to
point to the ‘temp’. */
if((ptr->left!=NULL)&&(ptr->right!=NULL))
{
temp=ptr->right;// prepare for the replacement
grandfather=father;
father=ptr;
while(temp->left!=NULL)
{
grandfather=father;
father=temp;
temp=temp->left;
}
ptr->key=temp->key; // replace
ptr=temp; // modify ‘ptr’ to delete temp now
}
/* ‘ptr’ has only one sub-tree implies, ‘ptr’ can’t be a
grandfather, hence, son of the ‘ptr’ will be a leaf node.
Simply replace the key of ‘ptr’ by the key of the son */
if(ptr->right!=NULL)
{
father=ptr;

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

ptr=ptr->right;
father->key=ptr->key; //replace
father->right=NULL;
}
else if(ptr->left!=NULL)
{
father=ptr;
ptr=ptr->left;
father->key=ptr->key;
father->left=NULL;
}
/* Else ‘ptr’ is a leaf. Check whether the father of ‘ptr’
has any right grandson. If yes, disconnect entire sub-tree
rooted at father from the original tree. Skipping father,
make grandfather point to the right son of father. Reinsert
father into the tree. If father itself is the root of the tree
then grandfather of ‘ptr’ does not exist, modify root to be
the right son of the father. */
else if(father_has_right_grandson(father))
{
temp=father->right;
father->left=father->right=NULL;
if(father==root)
root=temp;
else if(father->key<grandfather->key)
grandfather->left=temp;//Remove father
else
grandfather->right=temp;
insert(father,temp);
//reinsert father
}
else if(father_has_left_grandson(father))
{
temp=father->left;
father->left=father->right=NULL;
if(father==root)
root=temp;
else if(father->key<grandfather->key)
grandfather->left=temp;
else
grandfather->right=temp;
insert(father,temp);
}
/* else ‘ptr’ is a leaf without father */
else if(ptr==root)
root=NULL;
/* else ‘ptr’ is a leaf whose father is not having any
grandson. Simply disconnect ‘ptr’ */
else if(ptr->key<father->key)
father->left=NULL;
else
father->right=NULL;
delete ptr;
}//end delete

30

30

20

15

20

40

25

35

(a)

18

30

15

50

45

55

40

40

15

35

(b)

18

30

35

50

45

50

18

55

(c)

45

55

30

15

40

18

18

35

20

50

45

15

40

20

35

55

(d)

50

45

55

(e)

Figure 2. (b): Leaf node 25 deleted. (c): Father of 25 is removed. (d):Father is reinserted. (e): Single left rotation
When compared to the conventional insert algorithm
proposed algorithms take little extra constant space in the
form of few additional pointers fgrandfather, grandfather
and temp_root. Few extra calculations are required to
check whether a node is a grandfather (note that not every
node is examined). For random input, rotation would not
be a requirement every now and then. Therefore,
additional time taken by algorithm will not grow up
considerably. Comparing the worst-case behavior of both
algorithms, benefits of the modified algorithms are selfexplanatory. In the worst-case, the conventional insertdelete pair lets the tree grow up to n-1, reducing the
search to be sequential, where for the same case, modified
algorithms maintain the tree within the height <=n/2. Fig.
3a, 3b shows a comparison between traditional and
modified insert algorithms to create an initial binary
search tree (with no deletion). Both the algorithms were
made to run under Borland C++ Compiler 5.5. In fig. 3a,
1000 random numbers were generated and same input
was fed to both the algorithms. The result of 10 sample
runs shows that in most of the cases, percentage reduction
in height could be more than 25%. Fig. 3b shows same
results for 2000 random numbers. The maximum number
that the system could have generated was 32767. These

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

results clearly suggest that maintaining two sons all the
time for each grandfather in the tree results in an
improved shape. Though, these results have nothing to do
with the deletion process, still there wouldn’t be a
considerable variation when deletion is applied along with
insertions, since each deletion ensures the balance of the
grandfather as insertion does. Therefore, we can expect
even better results. Note that maximum height of AVL
tree is approximately 1.44 lg(n) [1]. In the worst case, for
n=1000 and n=2000 corresponding height of AVL tree
would have been 14.4 and 15.8 respectively.

4. Conclusion
Dynamic maintenance of a binary search tree in
optimal shape has always been a big concern. Proposed
algorithms are a compromise between tree rebalancing
cost and optimality. Compared to a balanced tree, in a
random tree, on average, the number of comparisons
increases by a factor of 1.39. Using the modified
algorithms this factor could be brought down further,
making random tree a better choice most of the time.

Figure 3: A Comparison between Traditional and Modified Algorithms
Sample
run

Traditional algorithm
Height of
the tree

1
2
3
4
5
6
7
8
9
10

22
20
20
26
21
22
21
20
20
20

Sample
run

Average number of
comparisons (for a
successful search)
12.19
12.06
11.57
12.35
11.67
12.01
12.17
11.50
11.21
11.16

Traditional algorithm
Height of
the tree

1
2
3
4
5
6
7
8
9
10

22
22
23
23
23
23
23
24
23
25

Average number of
comparisons for a
successful search
13.05
13.52
14.55
13.62
12.49
13.39
13.02
13.25
14.07
15.17

Modified algorithm
Height of
the tree

Average number of
comparisons (for a
successful search)
15
9.94
16
10.16
16
10.26
17
10.39
15
9.86
17
10.29
15
10.12
16
10.37
14
9.87
15
9.73
(a): For 1000 nodes

Height of
the tree

Authors wish to thank Prof. Pramod Kishan Suri
(Kurukshetra University), Prof. Sadiq Hussain, and John
Bramwell (Majan University) for many helpful
discussions. Thanks are also due for Syed Rehman and
Dr. Zain E.A. Tahboub (Dean of Majan College) for their
kind support.

[3]

References

[4]
[5]
[6]

G. M. Adel’son-Vel’skii, and E. M. Landis, “An
Algorithm for the Organization of Information,”
Soviet Mathematics Doklady, Vol. 3, 1962, pp. 1259–
1263.

[7]
[8]

0-7695-2602-0/06 $20.00 © 2006

IEEE

% Reduction in average
number of comparisons.
18.4
15.7
11.4
15.8
15.5
14.3
16.8
9.8
11.9
12.3

% Reduction

Average number of
comparisons for a
successful search
16
11.19
16
11.23
16
11.70
17
11.15
17
11.08
18
11.60
17
11.34
19
11.61
17
11.16
18
12.09
(b): For 2000 nodes
[2]

Proceedings of the Information Visualization (IV’06)

%
Reduction
in height
31
20
20
34
28
22
28
20
30
25

Modified algorithm

5. Acknowledgement

[1]

% Reduction

%
Reduction
in height
27
27
30
26
26
21
26
20
26
28

% Reduction in average
number of comparisons.
14.3
16.9
19.6
18.2
11.3
13.4
12.9
12.4
20.7
20.3

W. A. Martin, and D. N. Ness, “Optimal Binary Trees
Grown with a Sorting Algorithm,” Commun. of the
ACM, 15, 1972, pp. 88-93.
A. C. Day, “Balancing a Binary Tree,” Computer
Journal, 19, 1976, pp. 360-361.
H. Chang, and S. S. Iyengar, “Efficient Algorithms To
Globally Balance a Binary Search Tree,” Commun. of
the ACM, 27, 1984, pp. 695-702.
F. Stout, and L.W. Bette, “Tree Rebalancing in
Optimal Time and Space,” Commun. of the ACM, 29,
1986, pp. 902-908.
D.E. Knuth, “The Art of Computer Programming,”
Vol. 3, Searching and Sorting, Pearson Education
Asia, 1999.
Y. Langsam, J. Moshe, and M. Tenenbaum, “Data
Structures Using C and C++, Printice-Hall, Second
Edition, 1998.
J.L. Eppinger, “An Empirical Study of Insertion and
Deletion in Binary Search Trees,” Commun. ACM, 26,
1983, pp. 663-669.


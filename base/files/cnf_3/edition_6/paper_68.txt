Uniﬁcation and Evaluation of Graph Drawing Algorithms for Different
Application Domains
Bastian Florentz and Tilo Muecke
Institute for Programming and Reactive Systems
Technical University of Braunschweig
Muehlenpfordtstr. 23, 38106 Braunschweig, Germany
ﬂorentz,tmuecke @ips.cs.tu-bs.de

Abstract
Today formalisms with graphical representations are
used to model structure, behaviour, and other views on software and systems. The UML is just one example for modelling languages with graphical representation of its models. Although most models are executable without explicit
graphical information of the model’s elements, the appearance of a model is of particular importance for its readability. To improve the so called embedding of a graph
representing a model or to create a initial embedding, an
algorithmic support for arranging the elements is useful.
We provide a software environment in which layout algorithms can be developed and evaluated. By deﬁning proper
interfaces for graph elements, we provide easy access to our
library of layout algorithms for external use.

1. Introduction
Nowadays, software and systems are designed using formalisms based on graphical models. Many different views
on the software and systems (e.g. structure, behaviour, etc.)
can be modelled with these formalisms. While the graphical representation can be omitted for computation or simulation of most models, their representation is essential for
readability and reusability of the models by a designer. To
create, change, or improve a graph embedding, so called
layout algorithms are available [1] or need to be developed.
Although many formalisms, models, and domains require
different layout algorithms, most of them can be reused.
In our approach, we build a Java graph drawing library
based on interfaces. Graph features regarding the embedding are deﬁned by them. Therefore, the access for application and development of layout algorithms is directly based
on the graph interfaces.
We want to support two main user groups with our approach:

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

An application developer uses the layout algorithms to
get well-readable embeddings in his/her modelling domain. Therefore, support for suitable graph features is
needed to be capable to express and layout the (possibly very special) graphical representation of a model.
A layout algorithm developer does not need to deal
with all graph features right from the beginning. An incremental development of new algorithms is needed to
ensure efﬁciency for implementing and testing the new
algorithm or parts of it. Additional, it can be very useful to combine algorithms dealing with different graph
features. Thus, an efﬁcient construction of new algorithms is possible.
The interface based design of our approach meets the requirements in both cases. Suitable algorithms can be identiﬁed or rather developed with a selection of graph features
(i.e. a selection of interfaces) to be handled. Therefore, the
interface to our graph drawing library is very ﬂexible. In
addition to the selection of graph interfaces, the ﬂexibility
is increased by the extendibility of the interfaces. The hierarchical structure of interfaces and their extension ensures
applicability of algorithms capable of a proper extension on
a graph without this extension and vice versa. Thus, the algorithms have to be implemented downwardly compatible.
Section 2 contains some examples for extended interfaces,
because the deﬁned interfaces are based on extensions already.
Now that we have a very ﬂexible and powerful interface
to the graph drawing library, we need to handle all the different layout algorithms. While their technical applicability is ensured and an algorithm preselection based on graph
interfaces is possible, we need to take the layout results,
the embeddings, into account. Different formalisms with a
look-alike graphical representation may need to be laid out
differently. The graph interfaces only deﬁne the graphical
representation of a model but no graph independent properties of an embedding. For example, the arrangement of

In the last decades, a lot of different graph drawing libraries have been designed. A short comparison of the best
established libraries is given in Tabular 1. Our main focus
in this comparison is:
Which graph features are supported by these libraries?
How can the libraries be included in projects?
Is there a development environment available for a layout algorithm developer?
We did not

see Page

aiSee
GDS
GDToolkit
AGD
Pigale
yFiles

Graph features
Hierarchy
Multiple hierarchy
Node ordering
Special shapes
Nodes on borders
Labelled nodes
Arrows
Edge emission bounds
Edge emission sorted
Labelled edges
Nails
Spline edges
Edge directions
Constrained ranks
3D representation
Provided interface to applications
Description language
Lib data structure
Lib interface structure
Description extendable
Layout developer support
Editor
Additional algorithms
Empirical evaluation
supported,

partially supported,

3
3
3
4
4
5
4
4
4
5
4
4
4

6
3
3
6
6
6

not supported

Table 1: Features of Graph Drawing Libraries

mention features related with the graph’s visualisation
(like the colour of a node) or the control of a layout
algorithm (like the strength of the springs in a spring
embedder), because this information should be separated from the graph description,
compare the variety, efﬁciency, and quality of the integrated layout algorithms.
The Graphviz tool [5] transforms a textual description
of a graph, given in the dot language, into a picture of the
graph. Therefore, information about the representation of
the graph, like the colours of the nodes, has to be included
in the graph description language. The contents of the graph
description language can be extended by user deﬁned attributes, but it is not possible to add new elements into the
language keeping backward compatibility. Communication
with the library can take place via the dot description language or by copying the graph description into a class structure which is given within the library. The Graphviz library
comes with a lot of graph features.

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

GLAD
Graphviz

model elements based on the semantics of the formalisms
is not expressible with the means of the graph interfaces.
But, we need a possibility to classify the layout algorithms
with respect to these graph interface independent and domain speciﬁc requirements. We designed a development environment which is content of Section 3. This environment
supports the evaluation of layout algorithms. On the one
hand, an algorithmic evaluation of the embeddings is supported that is capable of checking for certain properties, like
overlapping nodes, crossing edges, covered elements, etc.
On the other hand, the ’look and feel’ of an embedding for
human users is hardly expressible in terms of a computer.
Moreover, the correlation between graph aesthetics criteria
and the human ability to solve problems on a graph is rather
weak [12]. To classify the layout algorithms with respect to
such readability properties, a game based on solving certain
tasks on laid out graphs leads to information about the suitability of layout algorithms for proper application domains.

IEEE

AGD [6], a Library of Algorithms for Graph Drawing,
originates from the DFG-funded project ”Design, Analysis,
Implementation, and Evaluation of Graph Drawing Algorithms”. It supports only very few graph features but allows for the reuse of the layout algorithms within other data
structures by using interfaces for describing a graph. Besides, it has a very nicely structured wide variety of layout
algorithms.
Our tool, General Layout Algorithm Designer (GLAD),
is not only a graph drawing library. GLAD is a development environment for layout algorithms. It comes with a
lot of graph features but allows for the development of layout algorithms which only use a subset of these features.
At the same time, it offers tool support for evaluating the
implemented layout algorithms. The layout algorithms can
easily be adapted to already existing data structures by an
extendible graph description interface structure.
The other graph drawing libraries mentioned in this
paper are: aiSee (originally VCG [11]), Graph Drawing

Server (GDS) [2], GDToolkit [3], Pigale [4], and yFiles
[13]. For brevity, their features are shown in Tabular 1.
The right column contains references on pages of this paper dealing with the column’s topic.

the space available for internal blobs is deﬁned. Figure 2
shows an example compound blob with its insets.

2. Extendable Graph Interface
A graph which can be layouted by an algorithm of
GLAD has to implement some interfaces. These interfaces
allow for information gathering and manipulation of the
graph. Every graph is based on the three basic interfaces
Blob, Edge, and Label (see Figure 1). Extensions of
these interfaces allow for more speciﬁc embeddings. Algorithms that do not support extended interfaces will layout
the graph ignoring the extensions but respecting the basic
interfaces of the elements to layout.
These basic interfaces are explained in the following
subsections. Examples how to apply the interfaces for different purposes can be found in Subsection 2.4.

Figure 2: Compound Blobs Introduce Hierarchy
Sorted Compound Blob: An order of the internal blobs
may have a semantic meaning (e.g. in Stateﬂow Charts [7]).
This order can be expressed using sorted compound blobs.
The internal blobs can be arranged in several ways, e.g.
from left to right, from top to bottom, or from left to right,
and from top to bottom (see Figure 3) .

Figure 1: Basic Graph Components

Figure 3: Order in Compound Blobs

A blob represents a node of a graph. It has a width, a
height, and a border radius. Therefore, it can be shaped in
between a circle and a rectangle. It also has a maximum
and minimum size as restriction for the layout algorithm.
The layout algorithm may change the location of the blob
if it is not ﬁxed in location. Every blob has a name and
knows about its parent (i.e. its container). Additionally, a
blob may have several incoming and outgoing edges (see
Subsection 2.2). Due to the fact that an edge knows about its
source and goal, this information is redundant. The redundancy ensures higher performance of a layout algorithm.
For a fairly easy implementation, the interfaces are built
with respect to the realisation as Java GUI Components (e.g.
blob extends JComponent).
The following subsections deal with hierarchy of blobs
and special kinds of blobs regarding their positioning and
shape.
A compound blob extends a blob by adding a list of internal blobs which have to be graphically located inside of
the compound blob. Furthermore, the size of the compound
blob’s border has to be speciﬁed in terms of insets. Thus,

Gap Free Compound Blob: There may be no gaps
needed or allowed in between the inner blobs of a compound blob (e.g. AND states of statecharts). This information is represented by this interface. As a result, the inner
blobs of a gap free compound blob will completely ﬁll its
area.
Multiple Hierarchy is realised by multiple parented
blobs, which extend blobs by the possibility of having several parents. Therefore, it is possible to describe multiple
hierarchy with multiple parented blobs. A multiple parented
blob has to be located in each of its parents (see Figure 4).

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

Figure 4: Multiple Parented Blobs Introduce Multiple Hierarchy

Blob On Border: In some graphical description languages, a blob is allowed to be located on the border of
another blob (see Figure 5). An extension of blob provides
to describe this construct by containing a set of blobs to be
located on a blob’s border.

Figure 8: Range for Edge Emission

Figure 5: Describing Blobs on Blob Borders
A Special Shape Blob does not have the standard blob
shape. The point of contact of an edge and a blobs border
can easily be calculated if the width, the height, and the
border’s radius of a blob are given. Because of the irregular
shape of a special shape blob, these inputs are not available
or not useful at least. The calculation of the point of contact
needs to be redeﬁned for every type of special shape blob.
Figure 6 shows a special shape blob example in which the
point of contact is not determined by the height of the blob.

Figure 6: Adding Blobs with Other Shapes
Edges Sorted Blob: The edges adjacent to a blob are already sorted in a list, but the leftmost possible position of
the ﬁrst edge has to be determined on the blob’s borderline.
The edges sorted blob extends blob by containing a start
angle as a position for the ﬁrst edge. The graphical representation of sorted edges is shown in Figure 7.

A special case of a emission range is a port. To realise ports
on a blob’s border, an emission range with size zero can be
deﬁned.

An edge has a source and a goal blob. These blobs are
connected by the edge. In addition, an edge may be directed
from its source to its goal blob. To control the embedding
of an edge, a list of nails determines its course. The actual course (e.g. spline-like) has to be handled by the graph
implementation.
Arrow: It is possible to decorate edges with arrowheads.
While arrowheads should not overlap with other graph elements, their size is an important input for layout algorithms.
The size of an arrowhead is represented by a bounding box.
Direction Preselect: Edges can have additional information about the direction in which they should run. Edges
may have to go straight up, down, left, or right or approximately in a direction (see Figure 9). In the latter case, edges
are not allowed to run in the opposite direction (with any
section). Therefore, up to two neighboured approximate directions can be selected for an edge.

Figure 7: Sorted Edges
Emission Range Blob: The emission range blob extends
the blob by additional functions returning the emission angle range for every adjacent edge. With this interface, edges
can be bound to emit in certain areas of the blob border (see
Figure 8).

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

Figure 9: Edge Directions
Hyper Edges can be described by connecting edges to a
blob with zero size. Therefore, additional interfaces are not
needed to realise hyper edges.

Labels have a special meaning in graphical design languages or other uses of graph-like structures. On the one
hand, labels are used to name design elements and to clarify the design. On the other hand, labels may contain textual model elements like action language code of e.g. statecharts. At least in the latter case, the positioning of a label can have a special meaning, too, although labels can be
moved independently from their associated modelling element.
Labels can contain text fragments, small graphics, or
both. Therefore, labels have no predeﬁned size, and additionally, they can have several possible sizes depending on
the inner embedding of label (e.g. the word wrapping).
Labelled blobs extend blobs by having several labels,
each of which has to be placed at certain positions. The positions are based on a horizontal and a vertical component
(left, middle, right and top, middle, down). In addition, the
locations outside and anywhere are deﬁned. Several labels
with the same location will be laid out in the order of their
declaration on the blob. Therefore, they will be arranged
vertically.
Labelled edges extend edges by having several labels,
each of which has to be placed at certain positions. The
positions are combinations of left of, on the middle, right of,
over, or under the edge and near the source, at the middle,
or near the goal. The indeﬁnite location anywhere is the
sixteenth location. Several labels with the same location
will be laid out in the order of their declaration on the edge.

To guarantee the reusability of the layout algorithms developed with GLAD, we added the possibility to extend the
graph description with new features. Nevertheless, the already included features are sufﬁcient to layout all UML diagrams as well as many other diagram types. In this subsection, some examples are given to show the capabilities
of the developed graph description interfaces.
2.4.1 UML State Machines
UML State Machines [10] are a widely used behavioural
formalism. It is automaton based and supports input and
output via queues as well as hierarchy.
The initial pseudo state on the left of Figure 11 is a blob
with a circular shape. The states are blobs. Transitions are
directed edges with an arrowhead and a label. Composite
states are represented by compound blobs. The top insets of
this blob have to include the name label of the compound
blob. If internal actions, like entry or exit actions and internal or do-activities, are part of a blob, they will be added as

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

labels inside the blob. Final and history states are handled
as circular blobs.
State machines can have orthogonal regions. The covering state is called an AND state. It is represented by a
gap-free compound blob. If the AND state shows its name
on a tab, a special shape blob will be used. Fork and join
pseudo states are rectangular blobs. The sync state is a circular blob on the border of the two substates (regions) which
are synchronised by it.
Entry and exit points are circular blobs on the border
with a label outside. Junction pseudo states are connectors
to combine several transitions possibly with several sources
and goals. They are displayed as circular blobs. Decision
states are special shape blobs. In addition to the special
shape to be displayed, the special shape blob allows for restrictions on the emission positions of edges (i.e. the corners
of the decision state). Termination states are special shape
blobs, too. Their basic shape is quadratic, but their appearance and their borderline are not. Edges have to enter this
special shape blob at its centre.
2.4.2 Basic Message Sequence Charts
The formalism of Message Sequence Charts (MSCs) is used
to describe interaction examples dealing with several components or instances. For example, UML Sequence Diagrams are a derivative of Basic Message Sequence Charts
[8] (see Figure 10). We take them as an example to show
that our interfaces deal with diagrams which are usually laid
out by specialised programs, too.

Figure 10: Basic Message Sequence Chart Example
Instances in an MSC are represented by two rectangular blobs each, one at the top and one at the bottom of the
diagram. These blobs are connected via a lifeline. The lifeline is represented by an edge which direction preselection
is ’straight down’. The connections to the instance blobs
is restricted to the middle of the blobs by using emission
ranges (reduced to ports).
Actions on a lifeline are rectangular blobs (actually separating the lifeline in sections). Like from the instance blobs,
the lifelines are only allowed to emerge in the middle of the
lower and upper borderline.
Messages are represented by edges with an arrow head.
Their direction select is ’downwards’. They are labelled

Figure 11: UML State Machine
with the message text. The connection with the lifelines
is realised like connections in hyper edges.

We designed an environment for the evaluation of embeddings for different purposes. Therefore, a concrete
implementation of our graph interfaces (see Section 2) is
needed to represent graphs. Furthermore, we designed an
editor for building graph instances (see Figure 12), controlling layout algorithms, and the evaluation environment.
While the evaluation is based on the interfaces and not
on a concrete implementation, we omit further information
about the implementation of the graph in the current paper.
We support two different possibilities for evaluating
graph embeddings. The ﬁrst one is based on algorithms
checking for measurable properties of embeddings to discover bad parts like overlapping blobs, crossing edges, etc.
It is content of Subsection 3.1. In Subsection 3.2 we describe how to evaluate non-measurable graph properties,
like the readability, by playing games.

For example, labels are allowed for crossing their associated edge. Transitions are allowed to cross borders of blobs
to reach inner or outer components in hierarchy. Elements
included in other elements (i.e. hierarchy) need to be completely covered by their parent (i.e. a composite state).
The general embedding of edges is another property of a
graph that can be checked by algorithms. In addition to the
general course of an edge (horizontal, vertical, or diagonal),
the number of nails is a signiﬁcant criterion of the embedding. Less nails means a clearly arranged embedding. If
there are some edges crossing each other, the angle between
the edges should be as large as possible .
Keeping the order or the position of blobs and edges may
be important to avoid changes of the graph’s meaning for
certain formalisms. Therefore, the location and order of
edges on blobs, the positioning of inner blobs, and the positioning of labels should be kept by the layout algorithms in
some cases. Layout properties based on the ordering of elements cannot be checked by taking a single embeddings into
account. At least two embeddings are necessary to check if
there are no/some changes in the ordering.

We implemented a number of algorithms to evaluate layout algorithms by checking the resulting embeddings. Only
measurable properties can be regarded hands-off. Therefore, the number of useful evaluation algorithms is limited.
Following, we give an overview of some of these algorithms.
The correct embedding of graph elements, especially in
relation to each other, is one of the main graph properties
observable by evaluation algorithms. We need to check if
graph elements cross any other elements. This is not allowed in most cases. Some exceptions are deﬁned, too.

Readability properties of an embedding are not easy to
evaluate using an algorithm, because readability is mainly
based on the ’look and feel’ of a graph. Thus, the automated evaluation of an embedding is very difﬁcult for this
properties. To evaluate layout algorithms regarding such
properties, we designed an evaluation game. Actually, the
evaluation has to be done by the player of the game. The
player is not asked to evaluate an embedding directly but
gets a number of tasks to solve on a graph laid out by a
layout algorithm. The correctness of the players answers
and the needed time are indicators for the layout algorithms

3. Layout Algorithm Framework

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

Figure 12: Screenshot of the Editor
quality. The evaluation game is an online game played by
human beings.
Several tasks are available to as basis for the evaluation
in the game. While the evaluation aims to be suitable for
different purposes, these tasks can be extended and completed with respect to these purposes. Some examples are:
1. Is there a path from blob A to blob B? Find the shortest
one!
2. Is there a cycle of length n contained in the graph?
3. Is the graph n-colourable?
4. Is there a strong component with n blobs contained in
the graph? Mark this blobs!
5. Is there a clique with n blobs contained in the graph?
Mark this blobs!
6. Is there a Hamilton circle contained in the graph?
The information gathered by several played games has to
be analysed for the correlation of time and correctness with

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

respect to player domains, graphs, tasks, and layout algorithms. This supports the application developer choosing
an appropriate layout algorithm for his application domain,
tasks, and graph features. E.g. task 1 (shortest path) is
solved faster on a graph laid out by a spring embedder, but
to solve task 2 (cycle of length n), a tree layouter should be
preferred.

4. Conclusion
In contrast to other graph drawing libraries, GLAD is a
graph drawing development environment. It is easy to use
and ﬂexible for both, the application and the layout algorithm developer. This goal is achieved mainly by deﬁning
extendable interfaces for the description of a graph. They
are used to provide the layout algorithm with the necessary information about the graph and allows the algorithm
to change the graph’s embedding.
An application developer, who wants to use GLAD, has
to integrate the graph description interfaces in the own

graph data structure. Afterwards, any layout algorithm can
be applied to a graph. To simplify the selection of a proper
layout algorithm, the application developer should at ﬁrst
choose only layout algorithms which support the used interface extensions. Afterwards, a ranking about the readability
of the laid out graphs can be derived automatically from the
already measured values of the evaluation game. This ranking depends on the tasks signiﬁcant for readability in the
application domain and the players qualiﬁcation.
On the one hand, this ﬂexible structure enables the layout
algorithm developer to build new layout algorithms from
scratch by using only the basic interfaces ﬁrst. This is done
very quickly, we needed about 1 hour to implement a sound
spring embedder. On the other hand, existing layout algorithms can be combined, conﬁgured, and manipulated in order to develop a new algorithm. The new algorithms can
be tested without any particular application on drawn-byhand as well as on randomly generated graphs in the editor.
Additionally, evaluation algorithms can be executed on the
laid out graph to gather information about the assets and
drawbacks of the layout algorithm. After ﬁnishing the development, the algorithm can be added to the library and
evaluated practically by using the evaluation game.
By now, we have implemented the complete basis for a
graph drawing development environment, including an editor, evaluation algorithms, an evaluation game, and several
layout algorithms [9]. But there is still a lot of future work:
If further extensions of the graph description interfaces
are necessary for special application domains, they
will have to be introduced into the existing interfaces
with care.
So far, only a few convenient layout algorithms, like
a spring embedder, a tree layouter, and a planarity
algorithm, have been developed. Their modular design ensures easy handling of new graph features (see
[5]). However, there are several promising algorithms
which should be integrated into the library.
More data has to be collected from people playing the
evaluation game for better prognosis of the readability
achieved with certain layout algorithms.

References
[1] G. D. Battista, P. Eades, R. Tamassia, and I. G. Tollis. Graph
Drawing: Algorithms for the Visualization of Graphs. Prentice Hall PTR, Upper Saddle River, NJ, USA, 1998.
[2] S. S. Bridgeman, A. Garg, and R. Tamassia. A graph drawing and translation service on the WWW. In Proceedings of
the Symposium on Graph Drawing, pages 45–52. Springer
LNCS, 1997.
[3] L. Buti, G. D. Battista, G. Liotta, E. Tassinari, F. Vargiu, and
L. Vismara. Gd-workbench: a system for prototyping and

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

[4]

[5]

[6]

[7]

[8]

[9]
[10]
[11]
[12]

[13]

testing graph drawing algorithms. In Proceedings of Graph
Drawing 95, volume 1027, pages 111–122. Springer LNCS,
1996.
H. de Fraysseix and P. O. de Mendez. An algorithm to
ﬁnd a Kuratowski subdivision in DFS cotree critical graphs
2000. In Proceedings of the Twelfth Australasian Workshop on Combinatorial Algorithms, pages 98–105, Institut
Teknologi Bandung, Indonesia, 2001.
E. R. Gansner and S. C. North. An open graph visualization
system and its applications to software engineering. Software – Practice and Experience, 30(11):1203–1233, 2000.
C. Gutwenger, M. J¨unger, G. Klau, S. Leipert, and P. Mutzel.
Graph drawing algorithm engineering with agd. In Software
Visualization, International Dagstuhl Seminar on Software
Visualization 2001, volume 2269, pages 307–323. Springer
LNCS, 2002.
G. Hamon and J. Rushby. An operational semantics for
Stateﬂow. In M. Wermelinger and T. Margaria-Steffen, editors, Fundamental Approaches to Software Engineering: 7th
International Conference (FASE), volume 2984 of LNCS,
pages 229–243, Barcelona, Spain, April 2004. Springer
LNCS.
S. Mauw and M. A. Reniers. An algebraic semantics of basic
message sequence charts. The Computer Journal, 11(4):1–
9, 1994.
T. M¨ucke and B. Florentz. Homepage of GLAD Project
(LaHiG): http://www.ips.cs.tu-bs.de/tmuecke/sep/layout/.
OMG. Uniﬁed modeling language 1.5 speciﬁcation, 2003.
G. Sander. VCG: Visualization of Compiler Graphs. PhD
thesis, Universit¨at des Saarlandes, 1995.
C. Ware, H. Purchase, L. Colpoys, and M. McGill. Cognitive
Measurements of Graph Aesthetics. Information Visualization, 1(2):103–110, 2002.
R. Wiese, M. Eiglsperger, and M. Kaufmann. yﬁles: Visualization and automatic layout of graphs. In Proceedings of
the 9th international symposium of graph drawing, volume
2265, page 453 ff., Vienna, Austria, 2001. Springer LNCS.


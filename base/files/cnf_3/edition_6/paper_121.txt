A Real-time Monitoring System for Programming Education
using Program Animation Systems and Compile-Errors Records
Youzou Miyadera1
Kunimi Kurasawa2
Shoichi Nakamura3
Setsuo Yokoyama5
Nobuyoshi Yonezawa4
1,2,5) Tokyo Gakugei University 3) Fukushima University 4) Kogakuin University
1) miyadera@u-gakugei.ac.jp 2) kunimi923@hotmail.com 3) nakamura@sss.fukushima-u.ac.jp
4) ct72058@ns.kogakuin.ac.jp 5) yokoyama@u-gakugei.ac.jp

Abstract
We have developed a system that informs lecturers
regarding real-time learning situations in the
classroom and helps them provide support for students
(novice programmers) experiencing common problems.
This system has two functions. The first is a program
animation function which keeps a historical record of
the students’ operations, and analyses this record to
provide the information about difficulty of program
actions to lecturers. The second is a compile-error
support function which keeps a historical record of the
students' errors, and then analyses this record and
informs the lecturer about the correspondence between
compile-error causes and particular lines of source
code. This system should provide lecturers with full
support and real-time solutions to common problems
faced by students.
KEYWORDs: Program Animation, Programming
Education, Learning Situation, Real-time Monitoring,
Compile-error cause

1. Introduction
In the early stage of a programming language
course, the lecturer typically provides a sample
program to students and explains the program actions.
The tracing work to execute the source code of the
program step by step and to manually change the
memory on the computer is indispensable study for
novice students. However, it can be difficult for novice
students to follow the execution process while tracing
a sample program (Problem 1). Understanding how
such programs operate is the foundation of a
programming language education, so this problem
cannot be taken lightly.
In addition, novice students often fail to understand
the compile-error messages they receive during

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

programming exercises and cannot find the causes of
errors (Problem 2).
A lecturer has to help students cope with both types
of problem, but usually has to instruct a large number
of students within a limited amount of time, so it is
difficult for him to adequately deal with each problem
a student faces (Problem 3). This problem can be
alleviated, though, if the lecturer can communicate at
the same time to several students struggling with the
same problem.
Our goal is to solve these three types of problem.
Our approach is based on a belief that a lecturer who
can see in real-time where students are having
problems understanding a program phase will be able
to simultaneously help all students experiencing the
same problem. However, it is difficult to know in realtime which problems students are experiencing, and a
lecturer needs some means of support to do this.
Research has been done on ways to help lecturers
monitor the general level of student understanding
during programming exercises [1-6]. For example,
methods have been developed to help lecturers
understand the tendency of students to make particular
errors, monitor the degree of student understanding
during lectures, and predict questions likely to be
asked during exercises. In these researches, though,
real-time study records were not collected. In contrast,
another method enables lecturers to instruct students
while reproducing the practice process for them. One
other system allows lecturers to monitor whether the
program of a student can operate, the progress of each
student doing a practice problem, and the status of
reports students to submit [11]. However, these
methods do not immediately show the lecturer which
problems students tend to encounter. Thus, these five
methods do not provide an understanding of real-time
learning situations that enables simultaneous
instruction (problem 3). Other research has aimed at
program animation to enhance the understanding of

program operation [7-9]. While these studies have led
to methods that provide effective support for students,
they do not help lecturers monitor the students'
learning situations in real-time.
Therefore, we have developed a real-time support
system that allows lecturers to monitor the learning
situation of novice students so that they can see which
problems students are having during the process of
program understanding and the programming exercise.
To achieve this, we have developed a function to
add to a program animation system. This function
enables the acquisition of a historical record of each
student's control operations and information on where
the student has encountered understanding difficulties;
this helps to solve problems 1 and 3. From the
acquired information, the system can estimate the
points at which students have trouble understanding
the actions of a program and will notify the lecturer.
Moreover, the causes of compile-errors made by
students are estimated from the trend of past compileerrors and provided to the lecturer. This helps to solve
problems 2 and 3.
Thus, our system makes it possible for a lecturer to
see in real-time the problem tendencies of the entire
class, and then provide instructions for students facing
a common problem.
In this paper, we describe the method that allows
lecturers to monitor learning situations in real-time and
the system incorporating this method. Section 2
describes the current condition and problems that arise
in programming exercises. Section 3 proposes a
learning situation comprehension method based on
program animation systems to deal with problems 1
and 3. Section 4 proposes a learning situation
comprehension method that uses a historical record of
the students' compile-errors. Section 5 describes the
development of a system that incorporates the methods
of Sections 3 and 4.

2. The current condition and problems in
programming exercises
Programming exercises in our university are based
on the following learning cycle (Figure 1):
1. Lecture by a lecturer
2. Students understanding the action of sample
programs
3. Students developing programs for exercise
problems
4. Students writing and submitting reports

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

Figure 1. Learning Cycle
When trying to understand the action of a sample
program, novice students often find it difficult to
imagine the action as an instructor explains a program
by tracing it step by step (Problem 1). This difficulty is
mainly because novice students are unable to anticipate
the change of variable values in each command and the
change of controls caused by junction with conditions
and repetition with loops. Moreover, when developing
programs for exercise problems, it is difficult for
novice students to determine why compile-errors occur
and how to solve them (Problem 2). This is mainly
because beginners are unable to grasp the detailed
causes of errors and syntax problems from only the
outputted error messages.
To solve these problems, our research is aimed at
helping lecturers understand the tendencies of
problems which cause novice students to stumble and
provide simultaneous guidance to students with
common problems. Specifically, we have designed
systems that support programming exercises from
multiple perspectives.

3. A support method for monitoring
learning situations based on analysis of
the operation history in program
animation systems
3.1. Outline of the method
For a lecturer to provide simultaneous guidance, to
deal with problems 1 and 3, he has to recognize which
parts of the sample program novice students do not
understand and why they fail to understand these parts.
To enable the lecturer to grasp the learning situation,
the system performs the following procedures.

Procedure 1: To recognize which points are difficult
to understand and the causes of the difficulties, a
historical learning record is collected in real-time.
Procedure 2: The trend of the problems novice
students encounter is provided to the lecturer so
that he can help the students with regard to these
problems.
We will focus on program animation to solve the
problems.

3.2. Program animation system
A program animation system is an effective way to
enhance the understanding of program action [7-9].
This system can display the changes in the memory
corresponding to the execution of a program while
tracing the program line by line through animation to
make it more comprehensible. Furthermore, students
can use the control button to enter commands, such as
[execute the program], [stop], [back], [step execute],
and [change the speed], so that they can go through the
operation at a pace matching the progress of their own
understanding.
In this work, we started with a hypothesis that
“students tend to use certain system operations when
they encounter a program part that is difficult to
understand.” It seems probable that a system can
identify which parts were difficult for each student
based on a history of the student’s use of the program
animation system’s control operations. We then
compared situations where there were various degrees
of understanding of a program’s actions and the
corresponding historical operation records of the
students who studied the program, and tested whether
points where the program actions were difficult to
understand could be estimated from the operation
records.

3.3. Verification of historical operation records
3.3. 1. Outline
The verification of the hypothesis provided in
Section 3.2 was followed by four steps:
Step 1: Students attempted to understand the action of
sample programs by using the program animation
system. During this, a historical record of the
program animation system’s control operations was
accumulated.
Step 2: The students completed a questionnaire asking
at which points the program actions were difficult
to understand.

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

Step 3: The questionnaire also asked the students
about what kind of situation each operation was
used in.
Step 4: Student tendencies regarding points at which
the program action was difficult to understand and
the correspondence between these points and the
animation system operation records was analyzed
using the questionnaire results.
For this analysis, we developed an experimental
system which was capable of, at least, the necessary
support specified in [7, 8] with regard to program
action understanding (Figure 2). The experimental
system could be applied to the sample programs used
by the verification, and displayed as animation how the
value of the variable changed depending on the source
code. Furthermore, the system had several operation
control functions (i.e., [execute the program], [stop],
[back], [step execute], and [change the speed]), and
enabled acquisition of a historical record of student
operations to control the animation.

Figure 2. Experimental system interface
3.3.2. Verification
The operation of the experimental program
animation system was explained to 30 novice students
in a programming class. After the students had become
accustomed to operating the system, we tested our
hypothesis given in Section 3.2 through the procedures
stated above. The sample programs were programs to
obtain the maximum number, to obtain the greatest
common divisor, and to sort data.
First, we analyzed the relation between the student
operations at a line where the program action was
difficult to understand (determined from the
questionnaire results) and the historical operation
record. We found the following tendencies:
- Stopping near a difficult to understand line until the
action was understood
- Going back to a difficult to understand line until the
action was understood

- Step executing at a difficult to understand line until
the action was understood
- Repeating the above operations at a difficult to
understand line until the line was understood
- Increasing the execution speed of the program at a
line where the action was easy to understand
Thus, the students tended to use the [stop], [back],
and [step execution] functions at lines where the
program action was difficult to understand. Neither the
usual execution nor the speed adjustment functions
were used at lines where the program action was
difficult to understand.
We next analyzed whether the lines where the
program action was difficult to understand coincided
with the lines where the three operations ([stop],
[back], and [step execution]) were most often used.
The agreement rates (number of operations
corresponding to difficult to understand lines / total
number of operations) are shown in Table 1.
[stop]

[back]

[step execution]

Number of
operations
corresponding to
difficult to
understand lines

235

245

403

Total number of
operations

312

346

513

Agreement rate

0.753

0.708

0.786

Table 1. Agreement rate between difficult to
understand lines and operations
The high agreement rate for [step execution],
indicating that the students used [step execution] to
gain a better understanding of the program action,
suggests a high probability that this operation will be
used at a line where a student finds it difficult to
understand the program action.

3.4. Degree of difficulty understanding the
program action
Students tended to repeat the same line when the
program action was difficult to understand. Thus, we
tried to tell which lines were difficult to understand
based on the agreement rate for each operation. Our
estimation method uses the following expression,
where the difficulty of understanding the action is
calculated for each line to identify difficult to
understand lines. The difficulty of understanding the
program action of line j of sample program i for
student S is defined as follows.

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

[Definition] Difficulty of understanding program
action
The difficulty of understanding the program action
of line j in sample program i for student S (DSij) is
defined as
DSij = aXSij + bYSij + cZSij ,
where a, b, and c are the agreement rates (from Table
1) for the [stop], [back], and [step execution]
operations, respectively, and XSij, YSij, and ZSij are the
respective numbers of times each operation was used
by student S.
//
Because each student operated the system to repeat
lines where understanding was difficult, we defined
that the difficulty of understanding was related to the
repetition of the operations for the same line.
Next, we calculated the difficulty of understanding
for each line using the historical operation record of 10
students who did not take part in the previous
verification but were in the same year of study, and
compared the previous difficult to understand lines
with the difficulty of understanding expressed by this
group of students. We found that the difficulty of
understanding tended to rise for the lines earlier
classified as difficult to understand.
A difficult to understand line may be in a group of
two or more lines that a student repeats with the
system to aid understanding. Even so, this is useful
information for the lecturer. In addition, an
experienced lecturer will probably be able to estimate
which line of two or more lines is the source of
difficulty.

3.5. Monitoring the difficulty of understanding
program actions
Based on the above verification, we will use the
historical operation record of the program animation
system to predict which lines are difficult to
understand. However, the cause of the student’s
difficulty in understanding the action cannot be found
from only the historical operation record. In such cases,
the lecturer can determine the cause by having the
student input a cause (the difficulty information) for
the part (the instruction line) that is difficult to
understand.
We therefore collect the following information for
inclusion in a real-time historical operation record
during procedure 1 (Section 2.3.1):
- Student ID
- Sample program ID
- Line-number
- Kind of operation
([stop], [back], or [step execution])

- Causes of difficulties
From this information, lines where the action of the
sample program is difficult to understand can be
identified for each student in real-time and the cause of
the difficulty determined.
Next, the difficulty of understanding the program
action of each line for each student is obtained from
the collected historical study records. A table is made
that shows the problems all students tend to encounter
and this is presented to the lecturer. The sample
program is shown in one column of the table, and the
difficulty of understanding the program for all students
is shown on each row through a color classification
code. In addition, the lecturer can obtain the cause of a
difficulty from information shown for each line of the
sample program. As a result, the lecturer can see which
lines are difficult for students to understand, and can
directly instruct all students suffering from the
difficulty at the same time, thus solving problems 1
and 3.

4. A method for monitoring the learning
situation using the compile-error history
4.1. Outline of the method
To deal with problems 2 and 3 by enabling a
lecturer to provide simultaneous guidance, the lecturer
must be able to grasp in real-time what kind of syntax
compile-errors are occurring and what is making it
difficult to remove those errors. Our research has led to
a system which allows the lecturer to monitor the
learning situations in this respect based on the
following procedures.
Procedure 1: Collect learning histories in real-time to
specify the cause of errors and syntax that are
difficult to correct.
Procedure 2: Indicate visually the overall tendencies
regarding problems that students experience.
A system to estimate the cause of compile-errors
and provide the result has been reported [10]. This
system uses past error messages and their appearance
ratio to estimate the cause of compile-errors. Our
method also uses past error messages to find the causes
of compile-errors. Specifically, in procedure 1,
tendencies regarding the cause of errors and the
corresponding syntax for each error message are
analyzed from error messages collected in the past.
The overall problem tendencies for all students are
then calculated.

4.2. Analysis of the compile-error history

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

Compile-error messages have been collected over a
two-year period in programming exercise classes at our
university. At present, 13181 error messages have been
collected and stocked. The compile-error message,
learner ID, compile data, source code and subject No.
are collected automatically as the compile-error history.
The collected messages have been classified into 257
error types and a type ID has been assigned to each
message [10]. Moreover, the cause of the compileerror, the error syntax, and the subject area has been
classified manually and IDs have been assigned.
Specifically, the causes of compile-errors have been
classified into 80 types, which have been categorized
into 11 upper level types. Syntax in which compileerrors occur has been classified into 42 types. These
classifications and assignments have been applied to
every error message and an error message table was
created (Table 2).
ID

Error message

Error
type

Subjectiv
e area

Error
cause

Error
syntax

8560

kadai2703.c:8: parse
error before “for”

153

3

5-1

23

8561

kadai2703.c:8:
initializer element is
not constant

106

3

5-1

23

8526

kadai2703.c:8: parse
error before ‘)’ token

238

3

5-1

23

8563

kadai2703.c:11:
redefinition of ‘s’

171

3

9-16

19

10

3

9-16

19

106

3

9-16

19

73

3

9-16

19

68

3

9-16

19

164

3

9-16

19

14

3

9-16

19

73

3

9-16

19

8564

8565

8566

8567

8568

8569

8570

kadai2703.c.7:
‘s’
previously
defined
here
kadai2703.c.11:
initializer element is
not constant
kadai2703.c:11:
warning:
data
definition has no
type or storage class
kadai2703.c.12:
conflicting types for
‘t’
kadai2703.c:12:
conflicting types for
‘t’
kadai2703.c:12: ‘n’
undeclared here (not
in a function)
kadai2703.c:12:
warning:
data
definition has no
type or storage class

Table 2. Error message table (partial extract)
Using this error message table, a list of error causes
for each subject area corresponding to each error type
is created with ordering by appearance frequency. An
error syntax list is also created with ordering by
appearance frequency. Finally, when a compile-error
occurs during a student’s compiling, the cause and
syntax of that error is automatically estimated based on
the cause and error syntax lists, respectively. Thus, our
system provides real-time estimation of the error cause
and syntax for each compile-error. To apply in practice
the estimation described above, the following

compiling histories are collected in real-time as
learning histories during procedure 1:
- Learner ID
- Subject No.
- Source code
-Compile date
- Compile-error message
After that, the estimated error cause and the
corresponding syntax for all learners are provided
visually to an instructor. Specifically, each error
message is indicated as one column. The cause of an
error and the related syntax are each displayed in one
row and placed next to the corresponding error
message. This visual indication enables an instructor
to easily monitor in real-time the learning situation of
all students, such as what kinds of error messages are
occurring and their cause and related syntax. As a
result, a lecturer can simultaneously guide the students
who find it difficult to correct the same compile-errors
(Solution of problems 2 and 3).

5. System Development
5.1. Generation of a support system for
understanding program action

The programming languages and database
management system used to implement this system are
as follows:
- Parser: GNU Bison, flex, and C
- Program animation generation part: Java
- Program animation system: Java Swing
- Learning situation monitoring part: PHP
- Databases to manage animation system and
operation histories: MySQL
(1) Program animation generation
To prepare for a class, a lecturer initially uploads
the C source code of a sample program to the server.
Receiving the source code, our system performs lexical
analysis, syntax analysis, construction of a parse tree,
and generation of intermediate code. Then the system
generates the Java source code of the program
animation system including the operation history
collection and registers this into the animation system
database. Figure 4 is a screen shot of the start window.
Lecturers can select the sample source code using this
window. For example, if a lecturer inputs the sample
source code shown in Figure 5, the system generates
the intermediate code shown in Figure 6, and then
generates the JAVA source code shown in Figure 7.

Figure 3 shows the outline of our developed
prototype system, including the method proposed in
Section 3, which consists of three main parts:
(1) Program animation generation
(2) Program animation system with operation
history collection
(3) Learning situation monitoring

Figure 4. Start Window
main(){
int x , y , z;
scanf( "%d" , &x );
scanf( "%d" , &y );
z = gcd( x , y );
printf( "%d" , z );

Figure 3. Configuration of the system to
monitor students’ understanding of
program action

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

}
int gcd( int a , int b ){
int d;
if ( b == 0 ){
d = a;
}else{
d = gcd( b , a%b );
}
return d;
}

Figure 5. Input Source Code

(1@(3@(2@(4@(6@(52@(60@(54@(-304,,,main@))(-274,,,(@)(275,,,)@)))(108@(-276,,,{@)(109@(11@(14@(23@(259,,,int@)))(19@(19@(18@(20@(52@(54@(-304,,,x@)))))(280,,,,@)(20@(52@(54@(304,,,y@)))))(280,,,,@)(20@(52@(54@(304,,,z@)))))(281,,,;@)))
(112@(112@(112@(111@(98@(114@(180@(176@(174@(172@(170@(168@(1
66@(164@(162@(160@(158@(156@(153@(151@(141@(135@(132@(128@(304,,,scanf@)))(274,,,(@)(140@(139@(176@(174@(172@(170@(168@(166@(164@(162@(1
60@(158@(156@(153@(151@(141@(132@(130@(306,,,%d@))))))))))))))))))(280,,,,@)(176@(174@(172@(170@(168@(166@(164@(162@(160@(158@(1
56@(153@(151@(143@(146@(-296,,,&@))(151@(141@(132@(128@(304,,,x@))))))))))))))))))))(-275,,,)@)))))))))))))))))(281,,,;@))))

As each student tries to understand the program
action using the program animation system (Figure 8),
the operation history collection part records the
operation history and registers it in the operation
history database every time the student pushes an
operation button.

Figure 6. Example of Intermediate Code
public void main ( ) {
  showLine(0);
addFunction("main");
showLine(1);
VariableNode x = new VariableNode("x",2);
addVariable(x);
VariableNode y = new VariableNode("y",2);
addVariable(y);
VariableNode z = new VariableNode("z",2);
addVariable(z);
showLine(2);
inputVariable( x );
showLine(3);
inputVariable( y );
showLine(4);
move( z , gcd ( x.getValueInt() , y.getValueInt() ) );
showLine(5);
showLine(6);
}
int gcd ( int tmp_a , int tmp_b ) {
addFunction("gcd");
showLine(7);
VariableNode a = new VariableNode("a",2);
addVariable(a);
move( a , tmp_a );
VariableNode b = new VariableNode("b",2);
addVariable(b);
move( b , tmp_b );

Figure 8. Program Animation System
Moreover, a student inputs information regarding
each difficult line in the program through the form that
appears when the student clicks the “Quest” button
(Figure 9).

showLine(8);
VariableNode d = new VariableNode("d",2);
addVariable(d);
showLine(9);
if ( judge( b.getValueInt() == 0 ) ) {
showLine(10);
move( d , a.getValueInt() );
}
else {
showLine(11);
showLine(12);
move( d, gcd ( b.getValueInt(),
a.getValueInt() , b.getValueInt() ) );
showLine(13);
}
showLine(14);
int tmp_d = d.getValueInt();
removeFunction();
return tmp_d ;
}

Figure 7. Generated JAVA Code
(2) Program animation system with operation
history collection

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

Figure 9. Problem information input form
(3) Learning situation monitoring
The difficult line estimation part calculates the
difficulty of understanding the program action based
on the operation histories as explained in Section 3. To
help the lecturer monitor the learning state, the
understanding situation presentation part totals the
information concerning each difficult line and the
causes of difficulty and provides a summary to the
lecturer.

Figure 10 shows the user interface of the
understanding situation presentation part. Each row of
the table displays a line of the source code. A column
indicates which lines each student is likely to find
difficult, estimated from the total degree of difficulty
for all students. The lines, which show the top seven or
eight difficulty values, are color coded. Therefore, a
lecturer can immediately see which lines the students
find most difficult and provide supplementary
instruction regarding those lines. Furthermore,
information on the cause of difficulty, which is input
by the students, can be displayed in the right side of
the window by clicking a link on each line.

of the source code. In this case, we extended the gcc
command to collect the history.

Figure 11. System Organization of Compileerror Situation Monitoring System
Intermediate Code

Figure 10. User interface of the understanding
situation presentation part
This support lets a lecturer identify the difficult
lines of the program and see the cause of the difficulty.
Consequently, the lecturer can provide simultaneous
guidance to many students regarding the lines they find
problematic, basing the priority on the appearance
frequency. Thus, problems 1 and 2 can be solved.

5.2. Compile-error
System

Situation

Monitoring

The system organization of the compile-error
situation monitoring system, including the method
proposed in Section 4, is shown in Figure 11. The
programming languages and database management
system used to implement this system are as follows:
- Compile-error correction: Perl
- Compile-error acquisition, error-cause
estimation, error situation presentation: PHP
- Compile-error record DB: MySQL
- Error-causes DB: MySQL
When the students execute the C-compiler, this
system collects the compile-error history (described in
Section 4.2) shown in Figure 12 and also registers it to
the compile-error history DB. The subject ID can be
collected by having the students write the ID at the top

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

Learner’s ID

username=m031110g&
hostname=157%2e105%2e54%2e141&
Computer name
subject_number=kadai04010011&
Subject ID
date=2005%2d02%2d16%2013%3a25%3a59&
䉮䊮䊌䉟䊦䉣䊤䊷෼㓸ㇱ
error=gcd%2ec%3a%20In%20function%20%60main%27%3a%0agcd
䉮䊮䊌䉟
Date & Time
%2ec%3a7%3a%20%60z%27%20undeclared%20%28first%20use%20
in%20this%20function%29%0agcd%2ec%3a7%3a%20%28Each%20
Error Message
undeclared%20identifier%20is%20reported%20only%20once%0agcd
䉮䊮䊌䉟䊦䉣䊤䊷ขᓧㇱ
%2ec%3a7%3a%20for%20each%20function%20it%20appears%20in
ቇ⠌⠪
%2e%29%0a&
source=%2f%2a%20%23kadai04010011%23%20%2a%2f%0a%23
include%3cstdio%2eh%3e%0amain%28%29%7b%0a%09int%20x
䉮䊮䊌䉟䊦䉣䊤䊷
%20%2c%20y%20%3b%0a%09scanf%28%20%22%25d%22%20
%2c%20%26x%20%29%3b%0a%09scanf%28%20%22%25d%22
ጁᱧDB
Ყセ
%20%2c%20%26y%20%29%3b%0a%09z%20%3d%20gcd%28
%20x%20%2c%20y%20%29%3b%0a%09printf%28%20%22%25d
Source Code
%22%20%2c%20z%20%29%3b%0a%7d%0a%0aint%20gcd%28
䉣䊤䊷ⷐ࿃䊶᭴ᢥ᳿ቯㇱ
%20int%20a%20%2c%20int%20b%20%29%7b%0a%09int%20d
%3b%0a%09if%20%28%20b%20%3d%3d%200%20%29%7b
%0a%09%09d%20%3d%20a%3b%0a%09%7delse%7b%0a%09
䉣䊤䊷⁁ᴫឭ␜ㇱ
%09d%20%3d%20gcd%28%20b%20%2c%20a%25b%20%29
ቇ⠌⁁ᴫᛠ
%3b%0a%09%7d%0a%09return%20d%3b%0a%7d%0a%0a

Figure 12. Intermediate code of Error
Compile History
To enable the lecturer to monitor the compile-error
situation, the error-cause estimation part acquires the
latest compile-errors of all students from the compileerror record DB, and estimates the error causes from
the error-cause DB. The error situation presentation
part then provides the estimated results to the lecturer.
The interface of the error situation presentation part
is shown in Figure 13. The compile-errors that have
occurred up to the line of the table in Figure 13 are
displayed
in
occurrence
frequency
order.
Corresponding to each error message, the number of
occurrences, the three most frequent kinds of error
cause, and the three most frequent kinds of error
structure are presented. The lecturer can thus see the
cause of frequently appearing error messages that
students are finding difficult to understand.
Furthermore, he can see what kinds of structure an
error can have. This lets the lecturer simultaneously
explain the type of correction needed for a particular
error message, while referring to the error causes and
the structure from the table provided as shown in

Figure 13. The lecturer can also see the error situation
for each student (Figure 14).
Through this system, lecturers can simultaneously
instruct many students regarding their particular
problems. Thus, problems 2 and 3 are solved.

These functions enable a lecturer to monitor the
progress of all students in real-time, identify
tendencies regarding programming lines that the
students are having trouble understanding, and provide
simultaneous guidance to many students concerning
the points they find difficult. Consequently, this system
promises to make programming education for
beginners more effective.
Our next step will be to evaluate the system through
practical trials.
This work was supported in part by the Ministry of
Education, Culture, Sports, Science and Technology,
Japan under Grant-in-Aid for Young Scientists (B)
(No.17700599) and by Japan Society for the Promotion
of Science under Grant-in-Aid for Scientific Research
(B) (No.17300262).

References

Figure 13. Interface of error situation
presentation for the error frequency

Figure 14. Interface of error situation
presentation for each student

4. Summary
This paper has described a support system, and its
implementation, for real-time monitoring of students’
understanding of program actions. This system is
aimed at helping lecturers provide simultaneous
guidance to programming beginners during classroom
exercises. The prototype system generates a program
animation system and functions for real-time collection
and analysis of information on student difficulties.

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

[1] Stasko, J. T., “A framework and system for algorithm
animation”, J. IEEE Computer, Vol.23, No.9, pp. 27-39,
1990.
[2] Miyadera, Y., Yaku, T. and Konya, H., “Network-Based
Programming Language Education Environment Based
on AModular Program Diagram”, Proc. Int. Conf. Multi
Media in Education, IEEE, pp.425-434, 1996.
[3] R. Martinez-Unanue, M. Paredes-Velasco, “Electronic
Books for Programming Education: A Review and
Future Prospects”, Proc. ITiCSE'02, pp. 34-38, ACM,
2002.
[4] Pillay, N., “Developing Intelligent Programming Tutors
for Novice Programmers”, The SIGCSE Bulletin, Vol.35,
No.2, pp. 78-82, 2003.
[5] Kelleher, C., Pausch, R., “Lowering the barriers to
programming:
A
taxonomy
of
programming
environments and languages for novice programmers”,
ACM Computing Surveys, Vol.37, No. 2, pp. 83-137,
2005.
[6] Chiken,K., Hazeyama, A., Miyadera, Y., “A
Programming Learning Environment Focusing on Failure
Knowledge”, J. IEICE in Japan, Vol.J88-D1, No.1,
pp.66-75, 2005.
[7] Ben-Ari, M., Myller, N., Sutinen, E., Tarhio, J.,
“Perspective on Program Animation with Jeliot”,
Software Visualization, LNCS2269, pp.31-45, 2002.
[8] Miyadera, Y., Huang, N. and Yokoyama, S., “A
Programming Language Education System Based on
Program Animation”, Proc. Education Uses of
Information and Communication Technologies, in IFIP
16th World Computer Congress, pp.258-261, 2000.
[9] Sanders, D., Dom, B., “Classroom experience with
Jeroo”, The Journal of Computing in Small Colleges,
Vol.8, pp. 308-316, 2003.
[10] Takamoto, A., Fujii, M., Izumi, N. and Tanaka, M, “A
Support System Based on a Bug Factor for Programming
and its Effectiveness”, Trans. JSiSE, in Japan, Vol.17,
No.4, pp.533-540, 2000.


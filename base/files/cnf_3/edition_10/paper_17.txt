Numerical Solving of Geometric Constraints
Samy Ait-Aoudia
INI - Institut National de formation en Informatique
BP 68M - Oued Smar 16270 Algiers ALGERIA
Tel : + 213 21 51 63 91 - + 213 21 50 87 29
Fax : + 213 21 51 61 56
E-mail : s_ait_aoudia@ini.dz

Abstract
In computer-aided design, geometric modeling by
constraints enables users to describe shapes by
relationships called constraints between geometric
elements. The problem is to derive automatically these
geometric elements. Many resolution methods have been
proposed for solving systems of geometric constraints.
Geometric methods can be very efficient but are only
applicable to particular kinds of problems (typically rule
and compass constructive problems). Some schemes can't
be solved by any geometric method. A numerical method
is then necessary. We use the bisection method to solve
these "difficult" cases. The bisection method enables users
to reliably find all solutions to a system of non-linear
equations within a region defined by bounds on each
individual co-ordinate of the geometric objects.
Key Words: geometric modeling, constraints, bisection
method.

find symbolic expressions for the solutions. These
methods are "extremely" time consuming.
Rule-based solvers rely on the predicates formulation
(see [2,3,4]). Although they provide a qualitative study of
geometric constraints, the "huge" amount of computations
needed (exhaustive searching and matching) make them
inappropriate for real world applications.
Geometric methods can be very efficient but are only
applicable to particular kinds of problems, typically rule
and compass constructive problems (see [5,6,7,8]). The
geometric designs (these schemes are well constrained)
shown in figure 1 can't be solved by any geometric
method. The nodes of theses graphs represent points and
the edges represent distance constraints.

(a)

1. Introduction
In computer aided design, geometric modeling by
constraints enables users to describe shapes by specifying
a rough sketch and adding to it geometric constraints i.e. a
set of required relations between geometric elements. For
example, the set of elements might be three points, with
three constraints that specify the distance between each
pair of points. The constraint solver must derive
automatically the correct shape needed.
Many programming styles or languages have been
investigated: imperative, object oriented, rules driven.
Many resolution methods have been proposed for solving
systems of geometric constraints. We classify the
resolution methods in four broad categories: geometric,
symbolic, rule-oriented and numerical.
In symbolic methods (see [1]), the constraints are
translated into a system of equations. Methods such as
Gröbner bases or elimination with resultants are applied to

(b)
Figure 1. Ruler and compass non constructible
configurations.

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

Thus, numerical methods are very useful to solve
"difficult" configurations. Geometric constraints are, as in
symbolic methods, translated into a system of equations
and then solved with a numerical method. The most
popular numerical method is Newton-Raphson’s iteration.
It was used, among many others, by Serrano [9] and Perez
et al [10]. This method needs an initial guess, typically
given by the sketch of the desired geometric scheme.
However, there is a well-known problem. If NewtonRaphson’s method often works well, sometimes it does
not converge or it converges to an unwanted solution. In
this last case, the user changes his initial guess until
Newton-Raphson’s method works if it does.
In this paper, we describe our constraint-based
modeler that uses a bisection method instead of NewtonRaphson’s iteration to solve the geometric constraints
when there is no possibility to solve them by a geometric
method. The bisection method avoids the drawbacks of
the Newton iteration. It enables users to reliably find all
solutions to a system of non-linear equations within a
region defined by bounds on each individual co-ordinate
of the geometric objects.
This paper is organized as follows. Correspondence
between geometric constraints and equations is explained
in section 2. In section 3, we briefly describe the
mathematical framework of the bisection method. The
decomposition method, of the system of equations into
well-, under- and over constrained parts, is given in
section 4. We describe in section 5, our constraint-based
modeler. Section 6 gives conclusions.

Example 1:
A constrained scheme is shown in figure 3. It consist of
three points and three distance constraints.The point P1
lies at the origin and P3 on the positive x-axis. The
corresponding set of equations is given below :
eq1 : x1 = 0.
eq2 : y1 = 0.
eq3 : y3 = 0.
eq4 : y2 – y1 – d1 = 0.

2. Constraints and equations

3.2. Terminology and definitions

In a numerical constraint solver, the geometric
constraints are first translated into a system of algebraic
equations (linear or not). This system is then solved by
applying a numerical method. For each constraint
correspond an algebraic equation. As an example of this
correspondence, the equation corresponding to "internal"
and "external" tangency between two circles (see figure
2), one centred at A with radius r1, the other centred at B
with radius r2 is the following :
2
2
2
(xB - xA) + (yB - yA) - (r1 ± r2) = 0.

An interval, X=[a,b] is a subset of R defined as:
[a,b] = {x | a ≤ x ≤ b, x,a,b ∈ R}
The numbers a and b are called the bounds of the
interval; a is called the lower bound, written lb[a,b], and b,
the upper bound, written ub[a,b] (see [11]).
An interval vector X is an ordered n-tuple of intervals:
X = (X1, X2, … , Xn) where Xi = [ai,bi]. Geometrically this
is an n-dimensional box. Note that the real line is
embedded in the collection of real intervals. For instance
0=[0,0] and 5=[5,5].
Let X1 = [a1,b1] and X2 = [a2,b2] be two intervals. The
binary operations +, -, ., / are defined as:

C2

C2
C1

C1
r2

r1
A

B

r2

r1
A

B

Figure 2. tangency between two circles.

2

2

2

eq5 : (x3 – x2) + (y3 – y1) – d3 = 0.
eq6 : x3 – x1 – d2 = 0.

y
P2(x2,y2)
d3
d1
x
P1(x1,y1)

P3(x3,y3)
d2

Figure 3. A constraint problem.

3. Bisection method

X1 + X2 = [a1 + b1 , a2 + b2]
X1 - X2 = [a1 - b2 , b1 - a2]
X1 . X2 = [min(a1.a2 , a1.b2 , b1.a2 , b1.b2), max(a1.a2 ,
a1.b2 , b1.a2 , b1.b2)]
1 / X1 = [1/b1 , 1/a1] if 0 ∉ X1
if 0 ∈ X1
1 / X1 = [-∞ , 1/a1] if b1 = 0
1 / X1 = [-∞ , 1/a1] ∪ [1/b1 , +∞] if a1< 0 and b1>0
1 / X1 = [1/b1 , +∞] if a1 = 0

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

Now, suppose X=[a,b], we define the midpoint of X as
m(X)=(a+b)/2 and the width of X as w(X)=b-a. Similarly,
for interval vector X=(X1, X2, … , Xn), we define the
midpoint m(X)=(m(X1),m(X2), … ,m(Xn)) and the width
w(X)=(w(X1),w(X2), …,w(Xn)).
If f is a vector valued function of the n real variables
x1,x2, …,xn, then we define the interval extension of f as
an interval vector valued function F with interval
arguments, for which F(x1,x2, …,xn)=f(x1,x2, …,xn) for
real arguments. That is, as the interval arguments decrease
in width, F converges to f.
Suppose that the interval vector X=(X1, X2, … , Xn)
where Xi=[ai, bi]. We define |Xi|=max(|ai|,|bi|) and the
interval vector norm as ||X||= maxi(|Xi|). For interval
matrix A (a matrix with interval entries) we define the
matrix norm ||A|| = maxi(∑j|Aij|).

3.2. The Krawczyk-Moore test
In this section, we consider the following general
problem:
Find, with certainty, approximations to all solutions of
the non-linear system S:
fi(x1,x2, … ,xn) = 0 ; 1 ≤ i ≤ n
where bounds ai and bi are known such that :
ai ≤ xi ≤ bi for 1 ≤ i ≤ n
The generalized bisection algorithm used here consists
of a geometrical bisection process, a root inclusion test
and a search algorithm. The geometrical bisection process
is similar to that given in [12]. To each box
B = (X1, X2, … , Xn) where Xi = [ ai, bi]
we find k such that
w(Xk) = max (w(Xi)) ; 1 ≤ i ≤ n
then we form two boxes B1 and B2 such that :
B1 = ([a1,b1],[a2,b2], … ,[ak,m(Xk)], … ,[an,bn])
B2 = ([a1,b1],[a2,b2], … ,[m(Xk),bk], … ,[an,bn])
That is, we cut the box B into two boxes B1 and B2 by
cutting B in the co-ordinate direction in which B is
longest.
The root inclusion test is a function TF that associates
to each box the values "true", "false" or "unknown".
Defined formally in [13], it has the following properties:
i) TF(B) = "true" implies that there is a unique solution
of the system S within B, and Newton’s method or
one of its variants will converge to that solution from
any starting point in B.
ii) TF(B) = "false" implies that there are no solutions of
the system S within B.
iii) TF(B) = "unknown" ; the box B must be bisected
further.

3.3. Bisection process
The bisection process and the root inclusion test define
a binary search algorithm naturally. Our constrained-based

modeler uses the Krawczyk-Moore algorithm which is
given below (see [12, 14, 15, 16]). The initial box X is
defined by bounds on each individual co-ordinate of the
geometric objects. The equations f=(f1,f2, … ,fn) of the
system correspond to the geometric constraints. Finding
the solutions of the system of equations is summarized by
the algorithm given below.
Algorithm :
TEST (X)
Begin
Compute K(X); /* interval computation */
if (K(X) ∩ X) = ∅
then there are no solutions of the system within X
else /* (K(X) ∩ X) ≠ ∅ */
r =||I - M.J(X)||;/* I is the identity matrix */
if (K(X) ⊂ X)
then if r < 1
then the simple Newton sequence xn+1=p(xn)
will converge to a unique solution x* in X
from any starting point x0 in X
else begin BISECT (K(X), X1, X2);
TEST(X1); TEST(X2);
end
else
a=min(w(X))/2;
if r < 1 and ||m(X) -p(m(X))||< (1-r).a
then the simple Newton sequence xn+1=p(xn)
will converge to a unique solution x* in X
from any starting point x0 in B(m(X),a).
else begin BISECT ((K(X) ∩ X), X1, X2 );
TEST(X1); TEST(X2);
end
End.
where
K(X) = m(X) - M.f(m(X)) + [I - M.J(X)].[X - m(X)];
J(X) is the jacobian interval matrix;
M = J(m(X))-1;
B(m(X),a) = {x ∈ X : || x - m(X) || ≤ a };
p(x) = x - M.f(x).
A box X is said to be "safe" if the root inclusion test is
true. Newton’s iteration is performed and a solution is
computed. A box X is excluded if there are no solutions in
it. Otherwise the box (K(X) ∩ X) is subdivided to yield
two new boxes X1 and X2. The "safety" of these two boxes
is then tested.

4. Constraints decomposition
Before applying the bisection process, we must isolate
the well-constrained part of the system of equations. For
this purpose, we consider the natural bipartite graph
associated with systems of equations. This bipartite graph

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

has one vertex per equation, one vertex per unknown, and
an edge between an unknown x and an equation f if and
only if x appears in equation f. This type of graphs has
been already used, for example by Serrano in [9]. Let
G=(V, E) be this bipartite graph with edges E and with
vertices V. Then V = F ∪ X and F ∩ X= ∅. F is the set of
equations; X is the set of unknowns.

This general bipartite graph decomposition is shown in
figure 5 (equation vertices are drawn above unknown
vertices). G1 corresponds to the well-constrained part, G2
to the over-constrained part and G3 to the underconstrained part. Note that G1, G2 or G3 can be empty.
The sub-graphs G1, G2 and G3 can be obtained by the
following algorithm (see [19]).

Example 2:
The bipartite graph corresponding to the system of
equations {F1: x1 + x2 – 1 = 0, F2: x1 + 2x2 –3 = 0} is
shown in figure 4.

Algorithm :
i. Find a maximum matching M of G.
ii. Build the directed graph G' from G by replacing each
edge xf in M by two arcs xf and fx, and by orienting
all other edges of the bipartite graph from F to X.
iii. The graph G2 is the set of all descendants of source of
G'.
iv. The graph G3 is the set of all ancestors of sinks of G'.
v. G1 = G – G2 – G3.
The steps 2, 3, 4 and 5 can be computed in O(n+m),
and the whole algorithm runs in O(mn1/2) where n=|V| and
m=|E|.

F1

F2

x1

x2

Figure 4. Bipartite graph.
Any bipartite graph can be canonically decomposed in
three parts (see [17]): well-constrained, over-constrained
and under-constrained. The following theorem (see [18]
for the proof) describes this structure.
Theorem.
Let G = (V={F,X},E) be any bipartite graph. V can be
partitioned into three sets : D, A, C where :
D is the set of all vertices in G not covered by at least
one maximum matching,
A is the set of all vertices in V - D adjacent to at least
one vertex in D,
C = V - A – D.
These subsets are unique and yield a unique
decomposition of G into three sub-graphs G1, G2 and G3
defined by :
G1 =({C1,C2}, E1) where C1 = C ∩ F, C2 = C ∩ X
and E1 is the set of induced edges of G1,
G2 =({D1,A2}, E2) where D1 = D ∩ F, A2 = A ∩ X
and E2 is the set of induced edges of G2,
G3 =({A1,D2}, E2) where A1 = A ∩ F, D2 = D ∩ X
and E3 is the set of induced edges of G3.

C1

D1

5. A 2D constraint-based modeler
We have implemented an experimental 2D constrained
based modeler in C++ on an IBM PC compatible machine
(CPU Pentium III, 700MHz and 128 MO of RAM).
The user creates points, lines, and circles and specifies
constraints in an interactive way. Predefined constraints
are: distance between two points or between a point and a
line, angle between two lines, tangency between a line and
a circle or between two circles, incidence between a point
and a line or a circle. He can specify (with an algebraic
formula) any algebraic equation. He can also fix coordinates or declare them ‘moveable’.
After constructing and decomposing the bipartite
graph, the bisection method is applied for the wellconstrained part of the system of equations. For the underconstrained part the user must add constraints. For the
over-constrained part the user must remove constraints.
A screen dump of a scheme solved by our solver is
given in figure 6. The three circles rc0, rc1 and rc2 are
initially fixed. The problem is the following: find the
circle with unknown radius tangent to these three circles
(it’s known as Apollonius’s problem). The eight solutions
(eight circles ci, 1≤i≤8) are shown in figure 6.

A1
6. Conclusion

C2
G1

A2
G2

D2
G3

Figure 5. Bipartite graph decomposition.

We have implemented a 2D constraint-based modeler,
but bisection also applies for 3D geometric constraints.
We have noticed that the resolution time grows
consequently for large irreducible well-constrained
systems. Our current interest is to distribute the computing
task among several computers so as to speed up the
resolution process.

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

Figure 6. Solutions of Apollonius’s problem

References
[1] X.S. Gao and S.C. Chou. Solving geometric constraint
systems : a symbolic approach and decision of Rcconstructibility. Computer Aided Design, pp. 115-122. vol.
30, n°. 3, 1998.
[2] G. Sunde. Specification of shape by dimensions and other
geometric constraints. Geometric modeling for CAD
applications, pp. 199-213. North-Holland, IFIP, 1988.
[3] H. Suzuki, H. Ando and F. Kimura. Variation of geometries
based on a geometric-reasoning method. Computer and
Graphics, 14(2), pp. 211-224. 1990.
[4] A. Verroust, F. Schonek and D. Roller. Rule-oriented method
for parametrized computer-aided design. Computer Aided
Design, 24 (3), pp. 531-540, Oct. 1992.
[5] I. Fudos, C.M. Hoffman. A Graph-Constructive approach to
Solving Systems of Geometric Constraints. ACM Trans. on
Graphics, Vol. 16, No. 2, April 1997, 179-216.
[6] C. Hoffman, A. Lomonosov, M. Sitharam. Geometric
constraint decomposotion. In B. Bruderlin and D. Roller,
editors, Geometric constraint solving and applications.
pages 170-195, Springer 1998.
[7] S. Ait-Aoudia, H. Brahim, A. Moussaoui , T. Saadi. Solving
Geometric Constraints by a Graph-Constructive Approach.
IEEE International Conf. on Information Visualization ,
(London, England), pp. 250-255, July 99.
[8] C. Jermann, G. Trombettoni, B. Neveu, M. Rueher. A
constraint programming approach for solving rigid
geometric systems. 6th Conf. on Principles and Practice of
constraint programming pp 233-248, Singapore sep. 2000.

[9] Serrano, D. Automatic Dimensioning in Design for
Manufacturing, Symp. on Solid Modeling Foundations and
CAD/CAM Applications, 379-386, 1991.
[10] A. Perez et D. Serrano. Constraint base analysis tools for
design. 2nd Symp. on Solid Modeling Foundations and
CAD/CAM Applications, Montreal Canada, pp. 281-290,
Mai 1993.
[11] Snyder,J.M. Interval Analysis For Computer Graphics,
Computer Graphics, Vol. 26, No. 2, 121-130, 1992.
[12] R.E. Moore et S.T. Jones. Safe starting regions for iterative
methods. SIAM J. Numerical Analysis, vol. 14, num. 6, pp
1051-1065, Dec. 1977.
[13] Kearfott, R.B. Some tests of Generalized Bisection. ACM
Transactions on Mathematical Software, Vol. 13, No. 3,
197-220, 1987.
[14] Moore, R.E., QI, L. A Successive Interval for Nonlinear
Systems, SIAM J. Numerical Analysis, Vol. 19, No. 4, 845850, 1982.
[15] R. Krawczyk. Newton algorithmen zur bestimmung von
nullstellen mit fehlerschranken. Computing, 4. pp 187-201,
1969.
[16] R.E. Moore. Interval Analysis. Prentice Hall, Englewood
Cliffs, N.J, 1966.
[17] K. Murota. Systems Analysis by Graphs and Matroids,
Solvability and Controllability. Springer Verlag 1987.
[18] L. Lovasz and M.D. Plummer. Matching Theory. NorthHolland, 1986.
[19] S. Ait-Aoudia, R. Jegou and D. Michelucci. Reduction of
constraint systems. In Proceedings of Compugraphics,
(Alvor, Portugal), 83-92, 1993.

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE


The Suitability of the Java Language for Computer-Graphics and Visualisation
Research
Frank D´evai
South Bank University
103 Borough Rd, London SE1 0AA, UK
fl.devai@sbu.ac.uk

Abstract
The potential and the limitations of the Java language
for graphics and visualisation research are evaluated. Evidence is offered that Java is adequate for high-performance
computing, and still has the added benefit of the portability
of its compiled byte code over a wide range of platforms.
It is demonstrated that, contrary to popular belief, there
is an efficient way for reading and writing individual pixels. It is also demonstrated that graphics primitives can be
drawn in one memory access per pixel even without pointer
arithmetics. Just-in-time and hot-spot compiler technologies considerably improve the speed of the executable code,
though some penalty remains for dynamic binding. Some inconsistencies and flaws in the design and implementations
of the Java class libraries are noted. In general, however,
Java offers both portability and adequate performance of
the executable code, and also increased productivity due to
its extensive class libraries, therefore it should be a serious
consideration for researchers, developers and educators in
graphics and visualisation.

1 Introduction
Though Java has been designed as a graphics language,
few researchers in graphics and visualisation seem to use it.
By June 2001 over five million developers had downloaded
the Java 2 Software Development Kit (SDK) still few papers in academic journals refer to it, and few people at conferences talk about it. On 9 January 2002 a search for the
word ‘Java’ matched only four out of 739,310 documents in
the IEEE Xplore on-line database.
Some flaws and inconsistencies in the design and implementation of graphics classes and class libraries offer further evidence that these classes and libraries are
not widely used. For example, the addPoint(...)
method of the java.awt.Polygon class can take x-

Md Mizanur Rahman
South Bank University
103 Borough Rd, London SE1 0AA, UK
mizanur@ukonline.co.uk

and y -coordinates, but not actually a Point, which
is, however, a legitimate type in the same class library.
Also the drawRectangle(...) method
in the java.awt.Graphics class does not take a
Rectangle object as a parameter, which is though a legitimate type as well. The prefix java.awt. refers to the
Abstract Window Toolkit (AWT) package, the basic Java
application programmer’s interface (API) for graphics.
A general reason for Java not being used in certain
branches of high-performance computing could be that it
is perceived as slow. A particular reason for graphics and
visualisation could be that the only primitive researchers
eventually need is an efficient access to pixels in a frame
buffer — and Java seems to fail to provide such a primitive.
In Section 2 an efficient way is proposed for reading and
writing individual pixels. A prototype class for frame-buffer
operations is provided, together with a fragment of an example program. Section 3 demonstrates the possibility of
a more efficient way for reading and writing a sequence of
pixels. The proposed method takes one memory access per
pixel, without the need for pointer arithmetics. In Section 4
other performance issues, such as inline code, just-in-time
and hot-spot compiler technologies and the problem of the
lack of macros are discussed. Section 5 is a brief overview
of the APIs within the Java Foundation Classes, in particular
the Java 2D graphics API. In Section 6 the Java support for
animation and some problems with random-number generation are discussed. Section 7 provides an overview of Java’s
two programming models: applications and applets, and a
practical method for testing applets. Finally in Section 8
conclusions are offered.

2 Reading and writing pixels
It is widely assumed [1, 8] that the only way to write
a pixel in Java is to draw a zero-length line segment with
identical endpoints, such as

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

g.drawLine(x, y, x, y);

where x and y are the co-ordinates of the pixel, and g is
a graphics object. Writing pixels in this way is extremely
inefficient as we pass four parameters, rather than two, and
the set-up time for the line-drawing algorithm is also an extra overhead.
Actually each pixel in Java can be represented by an integer, such that the first byte is the alpha parameter used for
image composition, and the remaining three bytes are the
red, green and blue colour components. If we keep the first
byte filled with 1s, the pixel value in hexadecimal notation
is ffrrggbb, where rr, gg and bb are hexadecimal numbers representing the red, green and blue colour components
respectively.
In Figure 1 a simplified prototype of a class for pixel
operations is given. The class uses an integer array a
as a frame buffer. A constructor is provided to create
the array of the appropriate size, and to set the background to the specified colour. The methods setPixel
and getPixel provide access to any individual pixel,
and the method getImage can be used to retrieve the
content of the full frame buffer. Catching the exception
thrown when the index is out of the bounds of the array with an empty code block provides a natural (though
not complete) way of clipping pixels to the frame-buffer
image. Adding a setColor method together with an
overloaded version setPixel(int x, int y) to the
FrameBuffer class provides a more efficient way of writing a sequence of pixels.
In Figure 2 a fragment of a demonstration program is
given. Note that one endpoint of the diagonal line is outside
the frame-buffer image, but it is clipped to the boundary of
the image. (This is not the case with every line segment:
a segment leaving the image on the right-hand side, would
come back on the left-hand side.) We can add methods for
drawing graphics primitives, such as line segment, polygon
etc, to our frame-buffer class, but also the AWT methods
can seamlessly be combined with its image, as shown in
Figure 2.
Future versions of the SDK are expected to provide
methods like the ones proposed here for accessing pixels.
Newer Java versions, however, are not immediately supported by web browsers. The FrameBuffer class provided here can be used with any version of Java.

3 Pointers
Every Java object access means a pointer dereference.
Other object-oriented languages, such as C++, also have the
option of placing one object inside the other, eliminating a
level of indirection. The lack of pointer arithmetics in Java
seems to be a further loss of performance when accessing a
sequence of pixels.

import java.awt.*;
import java.awt.image.*;
public class FrameBuffer {
public int [] a;
public int w, h;
public FrameBuffer(
int w, int h, Color c) {
this.w = w; this.h = h;
a = new int[w*h];
int pixVal = c.getRGB();
for (int i = 0; i < a.length; i++)
a[i] = pixVal;
}
public void setPixel(int x,
int y, Color c) {
try {
a[x + w*y] = c.getRGB();
} catch
(IndexOutOfBoundsException e) {}
}
public int getPixel(int x, int y) {
try {
return a[x + w*y];
} catch (IndexOutOfBoundsException e) {
return 0;
}
}
public MemoryImageSource getImage() {
return
new MemoryImageSource(w,h,a,0,w);
}
}

Figure 1. A class for accessing pixels

FrameBuffer fb;
Image img;
public void init() {
fb = new FrameBuffer(
150, 100, Color.pink);
for (int i = 0; i < 300; i++)
fb.setPixel(i, i, Color.red);
img = createImage(fb.getImage());
}
public void paint(Graphics g) {
g.drawImage(img, 0, 0, null);
g.drawString("writing on " +
"a pixel image...", 10, 50);
g.setColor(Color.blue);
g.drawString("and outside " +
a pixel image", 10, 120);
}

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

Figure 2. Pixel and AWT operations

public void
drawLine(int x1, int y1, int x2, int y2) {
int dx = x2 - x1, dy = y2 - y1;
int d = 2*dy - dx;
int dE = 2*dy, dNE = 2*(dy - dx);
int i = x1 + w*y1, j = x2 + w*y2;
for ( ; ; ) {
a[i] = fgPixel;
if (i == j) return;
if (d > 0) {
d += dNE; i += w + 1;
} else {
d += dE; i++;
}
}
}

Figure 3. Line segment generation
Let p(x y ) be the address of the memory word representing the pixel at point (x y ). Then the memory address
for the pixel at point (x 1 y ) is simply p(x y ) 1. Similarly p(x y 1) = p(x y ) w and p(x 1 y 1) =
p(x y )
w
1, where w is the width of the frame buffer.
Obviously these observations can be exploited by pointer
arithmetics. We demonstrate, however, that they can as
well be exploited by using indices: The Java code given
in Figure 3 is the modification of the C code for the
Bresenham-Pitteway line-segment generation algorithm on
page 78 of Foley et al [4], and is written as a method of
the FrameBuffer class developed in Section 2. We assume that, as in Foley et al [4], all parameters are nony2 ; y1
x2 ; x1 . The exisnegative, and that 0
tence of a private instance variable fgPixel containing
the value for the pixel in the foreground colour is also assumed. The foreground colour can be changed by a further
method setColor(Color c) that consists of a single
statement fgPixel = c.getRGB().
The reader might get an impression of the overhead incurred by using a line-drawing algorithm for setting pixels.
On the other hand, it is easy to that the method in Figure 3
takes only one memory access per pixel after the setup.

4 More performance issues
From version 1.1.8 of the Java Development Kit (JDK) a
Just-In-Time (JIT) compiler is provided with the Windows
version. The JIT compiler converts bytecodes to native instructions during loading time, which causes some delay in
program startup, but also reduces overall program execution time, according to the documentation, by a factor of
ten. Some tests were performed on a 166 MHz core, 66
MHz bus Pentium MMX processor (family = 5, model = 4,
stepping = 3) that returned the hexadecimal value 8001bf

instruction calculated
time
FADD
6–42
FSUB
6–42
FMUL
6–42
FDIV
235–253

JIT -nojit

60
55
55
240

400
420
395
560

Table 1. Microbenchmark results [ns]
as processor identification (CPUID) feature flags. The JDK
version 1.1.8 was used.
The execution times of floating-point addition, subtraction, multiplication and division (FADD, FSUB, FMUL and
FDIV respectively) were calculated from the number of
clock cycles and the processor clock frequency. FADD,
FSUB and FMUL take 1–7, and FDIV 39–42 cycles [2].
The actual time required by an individual instruction on a
superscalar architecture with branch prediction depends on
several factors (cache hit or miss, instruction pairing etc).
As the Pentium can execute a co-processor instruction and
two integer instructions simultaneously [2], simple expressions dominated by floating-point operations can be measured relatively accurately in a timing loop. The results
with JIT compiler and without it (-nojit option of the
virtual machine) are summarised in Table 1 in nanoseconds.
Though the results should only be taken as indicative, they
confirm that the JIT compiler introduces a significant performance improvement.
The macro facilities provided by the preprocessor in
C/C++ are no longer available in Java. This is unfortunate,
as many graphics and geometric algorithms can be implemented more efficiently by handling symmetric cases by inline code [3, 7]. Though the Java compiler can also make
inline substitutions, it is no longer under the direct control
of the programmer. Let’s consider the class definition:
class Segment {
private float x1, y1, x2, y2;
public final float getX1()
{ return x1; }
// more method definitions ...
}

Any call to method getX1() can be replaced with the variable x1 itself, because the keyword final explicitly forbids any subclass to override getX1(). Inserting final
only for this reason, however, defeats the purpose of objectoriented programming.
The HotSpot performance engine, introduced in April
1999 with the SDK v1.3.0 [6], can inline a method such
as getX1() even without the keyword final. There is
no problem as long as there are no subclasses overriding
getX1(). If such a subclass is loaded dynamically, however, any code that inlined any call to getX1() has to be

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

recompiled.
The HotSpot engine initially runs the program using an
interpreter. When it discovers that some method is executed
a lot, either because it is called a lot or because it contains
a loop, it compiles the method. The next time the method
is called, the compiled method will be invoked, or even the
currently running loop will be replaced with the compiled
version. This adaptive compilation technology can be better than the JIT compilation technology, because programs
can start faster, consume less memory and can inline more
methods.

5 More graphics APIs
The Java Foundation Classes (JFC) comprise five APIs:
AWT, Java 2D, Accessibility, Drag and Drop and Swing.
The Accessibility, Drag and Drop and Swing packages offer higher level graphics primitives for developing graphical
user interfaces.
Java 2D is a graphics API, and only available on the
Java 2 platform (from SDK v1.2). Java 2D provides deviceindependent rendering of three main types of graphical objects: shapes, images and text, to three types of output:
monitor screens, printers and off-screen buffers. Graphics
in the AWT is produced by the paint(Graphics g)
method, which is invoked whenever the repaint()
method is called, or the system decides that the window
needs updating. In Java 2D extra features are added by the
Graphics2D class, which is also in the java.awt package, and extends the Graphics class. A Graphics2D
object can be obtained by a cast within the paint(...)
method:
public void paint(Graphics g) {
Graphics2D gg = (Graphics2D)g;
// statements generating
// graphics using gg
}

The Java 3D API aims to provide a flexible platform
for a broad range of 3D applications including mechanical CAD, scientific visualisation, business and educational
graphics and virtual reality applications [9]. Though the
only way of representing three-dimensional objects in Java
3D is the polygon mesh, no polygon-based algorithms for
visibility computations are supported, but only the z-buffer
algorithm.

s

= mod 5
0
1
2
3
4
r

r

05
16
27
3
4

probability

1
1
1
1
1

4
4
4
8
8

=

=

=
=
=

Table 2. Probability of random integers
updating) or whenever the repaint() method is called.
Java provides multithreading, and also timers, therefore
animation can be produced by calling repaint() from
a thread after a delay, or by using a timer. There is a
more straightforward way, however: repaint() has an
overloaded variant that takes a long integer as parameter, which is interpreted as a delay in milliseconds, and
repaint(long d) calls itself again after the specified
delay d.
To delete the previous frame, Java provides a convenience method, called update(), to ‘clear the slate’. The
update() method cannot provide a selective erase—it
only clears the image with the background colour. To
avoid flicker, update() is often overridden, and a selective erase is provided by the programmer.
Generating random integers with the same probability
in a given range has always been a concern in graphics [5]. The documentation of the java.util.Random
class (SDK v1.4.0) implicitly claims that the usual way of
generating random integers in the range 0–n by r mod n,
where r is a random source, can be biased. To illustrate the
point, let r be a variable that takes the values 0, 1, 2, . . . ,
7 uniformly, independently at random, and suppose that we
need a random variable r that takes the values 0, 1, . . . , 4
also uniformly, independently at random. Table 2 gives the
values of s = r mod 5 together with the values of r and the
respective probabilities. Indeed, the probability of each of
0, 1 and 2 is twice as high as the probability of 3 and 4.
Unfortunately, the method in the Random class
public int nextInt(int n)
that is supposed to correct the bias is hopelessly flawed.
First, if our random source, r, is in the range of 231 , the
bias is negligible for a small n. Even if n is in the order of
a million, the bias in relative frequencies is less then a thousandth. Second, the published code for nextInt(n) does
not make any effect on removing the bias, just imposes an
extra overhead.

6 Animation and simulation
7 Applications and applets
As we have already seen, graphics is produced by the
paint(...) method, which is invoked either by the operating system (when the window is first displayed or needs

Java offers two programming models: the application and the so-called applet model. A Java appli-

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

cation is similar to a C/C++ program: one (and only
one) class in the program must define a public, static
method main(String [] args) that takes zero or
more command-line arguments, which are available from
the string array called args here (though it could have been
called by any legitimate Java name).
A Java applet is not a stand-alone program, but one embedded in a world-wide-web document. It must contain
a class that extends either the Applet or the JApplet
class from the java.applet or javax.swing packages respectively, or any class derived from these. An
applet does not need to define a main(...) method,
though it can, as we will see later. The application (e.g.,
a web browser or applet viewer) working with an applet
may call four methods of the applet: init(), start(),
stop() and destroy(). These methods are inherited
from Applet (JApplet is a derived class of Applet)
and can be overridden by the programmer as needed. For
example, an applet doing some animation can start the animation with its start() method, which is called when
the relevant window is opened up, and stop the animation
with its stop() method, which is called when the window
is iconified. Applets, like any other graphics components,
also have update() and paint() methods.
For testing an applet we need a web browser or an applet
viewer, together with a small .html file. It is probably a
better solution to add a main(...) method to the applet,
providing its own applet viewer in this way. Figure 4 is an
environment for the demonstration program given in Figure 2 that can be run either as an applet or an application.
First a window, called f, is created, and its location and
size are set in pixels (8 and 27 pixels are left for the leftright and top-bottom margins respectively.) The line starting with f.addWindowListener... is the beginning
of the definition of an anonymous inner class for handling
the event of closing window f. Then an instance, called
apt, of the class is created and added to window f, the
init() method of apt is called, and f is set visible. This
short program illustrates that Windows programming is relatively simple and straightforward in Java.
Some missing features and inconsistencies are relatively
easy to fix in an object-oriented language. For example, the missing addPoint(Point p) method of the
java.awt.Polygon class mentioned in Section 1, can
easily be provided, together with a constructor that creates
a polygon from a Vector of Points, as shown in Figure 5.
Other inconsistencies are not so easy to fix,
e.g., we cannot provide the overloaded version
drawRectangle(Rectangle r) as we cannot provide our own Graphics class, because the paint(...)
method is called by the system, therefore its signature

import java.awt.*;
import java.awt.event.*;
public class
FBdemo extends java.applet.Applet {
//
// insert the code of Figure 2 here
//
public static void main(String [] args) {
Frame f = new Frame("Frame buffer demo");
f.setLocation(200, 150);
f.setSize(258, 157);
f.addWindowListener(
new WindowAdapter() {
public void windowClosing(
WindowEvent e)
{ System.exit(0); }
});
FBdemo apt = new FBdemo();
f.add(apt);
apt.init();
f.show();
}
}

Figure 4. Running an applet as an application

import java.awt.*;
public class MyPolygon extends Polygon {
public MyPolygon(java.util.Vector v) {
super();
for (int i = 0; i < v.size(); i++)
addPoint((Point)v.elementAt(i));
}
public void addPoint(Point p) {
addPoint(p.x, p.y);
}
}

Figure 5. An extension of the Polygon class

public void paint(Graphics g)

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

cannot be changed.

8 Concluding remarks
We argued that one reason why Java is not widely
used for graphics and visualisation research could well
be—in addition to performance concerns—that Java does
not directly provide primitives like setPixel(...) and
getPixel(). The obvious reason for not supporting such
operations is that reading and writing individual pixels is inherently inefficient. Unfortunately, the lack of these primitives forces some programmers to use even more inefficient
workarounds.
We have demonstrated that, with the help of a
FrameBuffer class, the cost of reading and writing a sequence of pixels approaches one memory access per pixel.
Custom rendering can be used together with standard rendering operations on the same image.
We also argued that just-in-time and hot-spot compiler
technologies significantly improve the speed of the executable code. We provided some experimental results indicating that the performance of the code is adequate.
The portability of the executable code is a major advantage of Java. C++ development environments are also
supported by class libraries that can do graphics, but using one of these libraries usually make the applications
non-portable. Note that in case of C++ we are talking about source-level portability—and even that can be
problematic—while in case of Java the portability of the executable code is granted.
Java offers increased productivity due to its extensive
class libraries. Some inconsistencies or mistakes in such
a vast amount of software are inevitable. All the inconsistencies and flaws in the design and implementations of Java
class libraries found in the course of this research have been
submitted as bug reports to the developers of Java. We are
convinced that Java should be a serious consideration for
researchers, developers and educators in graphics and visualisation.

[5] A. S. Glassner. Generating random integers. In A. S. Glassner, editor, Graphics Gems, pages 438–439. Academic Press,
1990.
[6] S. Meloan.
The Java HotSpot performance engine:
An in-depth look. Sun Microsystems, Inc, June 1999.
http://developer.java.sun.com.
[7] T. M. Nicholl, D. T. Lee, and R. A. Nicholl. An efficient new
algorithm for 2-D line clipping: its development and analysis.
Computer Graphics, 21(4):253–262, 1987.
[8] G. W. Rowe. Computer Graphics with Java. Palgrave, Basingstoke, UK, 2001.
[9] H. A. Sowizral and M. F. Deering. The Java 3D API and
virtual reality. IEEE Computer Graphics & Applications,
19(3):12–15, May 1999.

References
[1] L. Ammeraal. Computer Graphics for Java Programmers.
John Wiley & Sons, 1998.
[2] B. B. Brey. Programming the 80286, 80386, 80486, and
Pentium-based Personal Computer. Prentice Hall, 1996.
[3] F. D´evai. An asymptotic model for clipping line segments. In
International Conference on Computer Graphics and Imaging, pages 229–233, Las Vegas, Nevada, USA, Nov. 2000.
[4] J. D. Foley, A. van Dam, S. K. Feiner, and J. F. Hughes. Computer Graphics: Principles and Practice. Addison-Wesley,
1996. (2nd ed in C).

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE


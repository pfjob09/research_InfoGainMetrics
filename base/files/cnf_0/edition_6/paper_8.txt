Dynamic Hierarchy Specification and Visualization
Richard M. Wilson1, R. Daniel Bergeron2
Computer Science Department
Kingsbury Hall (33 College Road)
University of New Hampshire
Durham, NH 03824

Abstract
This paper describes concepts that underlie the design and
implementation of an information exploration system that allows
users to impose arbitrary hierarchical organizations on their data.
Such hierarchies allow a user to embed important semantic
information into the hierarchy definition. Our goal is to
recognize the significance of this implicit information and to
utilize it in the hierarchy visualization. The innovative features
of our system include the dynamic modification of the hierarchy
definitions and the definition and implementation of a set of
layout algorithms that utilize semantic information implicit in
the tree construction.

1

Introduction

As data set sizes continue to increase dramatically, it is
becoming increasingly difficult to visualize them effectively. It
is essential to be able to extract subsets and define appropriate
high-level abstractions of portions of the data set in order to
reduce the active data size to manageable levels. One valuable
mechanism for reducing the effective size of a data set is to
organize it into a hierarchy. It is possible to create a hierarchy
where the leaf nodes contain data and the internal nodes contain
conditions that determine the position of the data. Using this
structure, the data within a leaf inherits all the properties of its
ancestors. Furthermore, visualizing the constructed hierarchy
may reveal structure, patterns, and relationships in the data.
Recent advances in hierarchy visualization such as cone trees
[13], disc trees [7], and 3d hyperbolic trees [12] have
dramatically increased the size of trees that can be effectively
rendered. The implementations of these techniques, however,
assume that the data set is a “natural” hierarchy that includes no
inherent metric interpretation of its structure. In other words, all
nodes are created equal. If the hierarchy is, in fact, created by
imposing semantic interpretations on data values in the data set,
the “default” visualization may lead to incorrect interpretations.
In particular, the relative visual appearance of two nodes may
not reflect their relative importance for the current task. We
describe a visualization system that facilitates the exploration of
data organized in hierarchies that are designed interactively by
the user. User-defined hierarchical structures may help to reduce
large data collections into smaller and more manageable subsets.
1

Current address: Lotus Development, Portsmouth, NH
Richard_Wilson@lotus.com
2
rdb@cs.unh.edu

In order to avoid creating meaningless hierarchies, the user
should bring domain-specific and task-specific knowledge to the
hierarchy specification. By organizing complex data sets into a
semantically meaningful hierarchy, we hope to reveal patterns
and relationships among the data, both of which support the
process of turning raw data into usable information. It is very
often the case that there is considerable semantic knowledge
about the expected values for variates in a data set. For example,
although a salary field may have legal values from 0 to many
millions, it is probably not useful to partition this range into
equal sized subranges. Once we use world knowledge to define
partition ranges, it is important that the visualizations of the
resulting trees reflect (in some manner) the way in which the
hierarchy has been defined, or else the visualizations may show
patterns that don't really exist and may fail to show significant
patterns that are present in the data. To address this problem we
have developed a set of layout algorithms that can be tailored to
the semantics of the hierarchy specification.
In some circumstances the definition of partitions that define
a hierarchy may be very sensitive to minor changes in the
partition boundary definition. In order to explore such a
possibility, we have developed a tool for dynamically modifying
the partition ranges of any part of the hierarchy specification. As
the ranges are modified, the user can view the effect on the
visualization—if minor boundary changes cause major display
changes, the user will have to do additional exploration to
validate the results of the visualization.
The remainder of this paper presents a brief overview of
related work, describes a system that supports interactive user
definition of hierarchies, highlights the layout algorithms that
support alternative visualizations of user-defined hierarchies, and
describes the facilities for dynamic modifications to hierarchy
partition boundaries.

2

Related Work

Conventional hierarchy visualizations include the indented list,
the 2D node-link diagram [9], the horizontal family tree diagram
[9] and the radial tree diagram [10]. Within the last decade,
novel visualization methods have been developed for displaying
large hierarchies, including the Treemap [8], cone tree [2, 13, 14,
3], disc tree [7], hyperbolic tree [10], and 3D hyperbolic tree [12]
visualizations. The Treemap display [8, 15] consists of a
hierarchy mapped onto the full screen, which is accomplished by
subdividing the screen space into smaller rectangles, resulting in
a node size and location that is a function of both node weight
and depth. The cone tree [13, 14, 3], which is a variation of the
traditional two-dimensional link-node display, consists of a
radial tree layout mapped into a three-dimensional environment.

Variations on cone trees include cam trees [13] and
reconfigurable disc trees [7]. Cam trees are cones trees that use a
horizontal rather that a vertical layout. Reconfigurable disc trees
are cone trees modified to use discs rather than cones, resulting
in an increase of the number of nodes that can be displayed
within a single visualization.
Although the ideas we present in this paper are applicable to
any tree visualization technique, our initial prototype system is
based primarily on the hyperbolic tree. This visualization
technique is a unique solution for displaying thousands of nodes
without the large amount of resources required by the cone tree.
It was developed in 1994 by Lamping and Rao [11] and uses a
focus+context technique for displaying hierarchies. The
hyperbolic tree display consists of a radial tree layout mapped
onto a hyperbolic plane, which is then mapped onto a 2D disc
with nodes decreasing in size as the radius increases. There is an
area of interest located at the center of the disc where
magnification of the nodes within this region occurs. The entire
hierarchy is always visible. Nodes outside of this area are still
visible, although significantly reduced in size. Like the cone tree,
structure in the hyperbolic visualization is immediately apparent.
There are three limiting factors with the existing hierarchical
visualization techniques. First, they are limited to data which
have an intrinsically hierarchical structure, such as organization
charts, taxonomies, and computer file systems. Second, these
techniques provide an essentially fixed pre-defined hierarchy not
allowing the user to see the data in different organizations.
Finally, with the exception of Treemaps, current techniques do
not attempt to utilize semantic information about how the
hierarchy is defined.

3
3.1

The User-Defined Hierarchy Approach
Overview

The user-defined hierarchy (UDH) approach provides a method
for creating a hierarchical structure from various types of user
data for the purpose of information visualization and exploration.
Data structured into a UDH may already have intrinsic
hierarchical form, in which case the natural hierarchy may be
used or a user-defined one may be imposed. Non-hierarchical
data, such as temporal, multivariate, and spatial data types, can
also be mapped into hierarchical structures.
User data record descriptions are required to identify field
names and types that may be used in constructing hierarchies.
From these descriptions, the user can interactively specify fields
and conditions on field data to form UDHs. Conditions for levels
and nodes within a UDH might include relational and equality
operators, string pattern matching operators, and logical
operators. The user can specify a variety of conditions for a
single data set thereby creating an assortment of UDH
descriptions. Each unique description provides a distinctive view
of the data. Forming various hierarchies creates multiple data
views that could aid in highlighting patterns and relationships
among the data.

3.2

UDH Functionality

We have implemented the UDH concept in a prototype system
we call UNHIDES (User-Navigated Hierarchical Interactive
Data Exploration System). UNHIDES enables the user to create
hierarchy descriptions and render data visually. Prior to defining
hierarchy descriptions, a user data record description must be

created that registers the name and type for each field with the
system. For user convenience, the system allows the interactive
entry of field names and field types for the user data record
description. Field names identify each field in the data record
and are implemented as text strings. Field types determine how
the user data is to be represented in memory and what operators
are applicable for the field. Various data types are supported by
the system, including integer, float, and string.
Once the user data record description has been created, a
hierarchy description can be defined. The hierarchy description
builder provides an interactive user interface for defining and
editing hierarchy descriptions. Defining a UDH begins by
selecting a data field from the user data record description and
establishing conditions on it for structuring user data into the
hierarchy. This process is iterative and fields may be used more
than once.
Following the process of defining a hierarchy description, the
system constructs an internal hierarchy incorporating the user
data into it. Subsequently, the system creates and renders one or
more simultaneous UDH visualizations that are internally linked.
Visualizations could include cone trees, disc trees, hyperbolic
trees, 3D hyperbolic trees, tree maps, as well as conventional
tree displays. Our initial implementation focuses primarily on
hyperbolic tree visualization.
Navigating and exploring UDHs may be achieved through
the use of interactive controls. Navigation controls depend on the
particular visualization technique and could include interactions
such as rotating, translating, and scaling the view of the
hierarchy, as well as providing context between the region of
interest and the entire visualization. Exploration interactions
could include functionality for data inspection, data filters, and
dynamic queries. Other exploratory interactions might include
data overviews, multiple visualizations for comparison and
contrast, as well as iterative, goal-oriented reconstruction of
UDH descriptions.

3.3

System Overview

The UNHIDES system enables users to explore data through
multiple user-defined hierarchical views. There are three main
stages to the UDH creation and exploration process which
include input, hierarchy processing, and user interaction. Figure
1 shows an overview of this process. Stage one, the input stage,
reads data, record definitions, and UDH definitions and produces
three components used as input for the next stage. Data can be
supplied to the system either as a text file or as a database query
result. Text file input contains a data set with one data record per
line. A record definition must also be supplied in the form of
another text file, which contains field name, type, and delimiter
definitions. Database input is supported through the use of the
JDBC API, which provides an SQL interface from the system to
a database. Record definitions are provided automatically by the
DBMS as a result of an SQL statement execution. A UDH can
be supplied to the system by using the system’s UDH editor or
by reading a previously defined one that is stored in a text file.
Stage two is where the hierarchy processing occurs.
Hierarchy processing is supported through a software subsystem
that supports hierarchy creation, data integration, and
visualization production. A hierarchy is created as specified by
the UDH description from the input stage, which contains level
descriptions. Once created, data is then populated into the
hierarchy according to conditions at each level. Upon completion

Data from
File

Record
Definition
Build UDH
Definition

Data from
Database

Create
Hierarchy

Populate
with Data

Create
Visualization

Explore
Visualization

Automatic
Record
Definition

Input

Modify
Hiearchy

Refine
Partitions

Process Hierarchy

User
Interaction

Figure 1. Overview of the UDH creation and exploration process.
of hierarchy creation and data integration, a visualization is
produced and presented to the user.
It is in stage three that the user can interact with the system
and explore the data by changing hierarchy layouts, refining
partitions, and modifying hierarchy levels.

3.4

Visualization Features

Visualization features include dynamic hierarchy layout,
graphical data distributions, edge and node coloring, and node
labeling. Hierarchy layout and data distributions are discussed in
subsequent sections. Edge coloring provides a method for
coloring edges based on the proportion of nodes within a subtree.
Subtrees with a large number of data nodes are assigned a higher
color intensity than those of a lower number of data nodes.
Coloring can be based on both local and global node
information.
A data node contains a data record and can display any field
within that record according to a user-defined active field. The
active field is used for node labeling, coloring, sorting, and UDH
statistics. Labels can be toggled on and off. Nodes can be
colored according to their active field value with respect to the
local or global data range; they can also be sorted into ascending
and descending order. By default, UDH nodes display their
partition information, but can also display a variety of statistics
relative to the active field, such as mean, median, standard
deviation, and range.

4
4.1

Hierarchy Layout Algorithms
Overview

Once a UDH has been created and populated with data, a spatial
layout algorithm must then process it to create a layout that can
be used in the course of creating a hierarchy visualization.
UNHIDES uses a hyperbolic tree [11] for its main display,
which requires that all locations be calculated in a radial fashion
along an arc with respect to depth in the tree and to an interior
point where the root node resides. Given a UDH, a spatial layout
algorithm traverses the tree and calculates an x, y location for
each node, resulting in a layout coordinate set consisting of
coordinates paired with nodes. When calculating each nodecoordinate pair, consideration is given to the distance a node is
from its parent, siblings, and other neighbors. Pairs within the
layout coordinate set are used by the visualization algorithm to

generate an output hierarchy visualization. There is no
distinction between calculating locations for data nodes and
internal nodes. Using different spatial layout algorithms can have
a dramatic effect on how the hierarchy appears in the final
visualization. This effect is clearly evident using the Treemap
algorithm [8, 1] which uses weights derived from node content to
determine the visual size of the node's representation. We call
this an attribute-based layout and apply it to the hyperbolic tree
display in UNHIDES.
In addition to an attribute-based layout, UNHIDES supports
four other layout algorithms: leaf-based, subnode-based, rangebased, and density-based that are described in detail in this
section. In all four layout algorithms, positions are calculated for
each node based on radius and on arc center. A node’s radius
value is obtained via a lookup table according to its depth within
the hierarchy. This table contains increasing values from 0.3 to
1.0 and has the effect of positioning nodes closer together at
upper levels within the hierarchy. Radius values at depth d,
denoted as rd, are calculated as follows:
d

rd =

∑ radiustable[i ]
i =1

A node’s arc center is calculated using metric and region
variables. The metric variable defines a value corresponding to
the proportion of space that a node can occupy. The region
variable defines a value calculated using the metric and indicates
a node’s arc definition, at the center of which the node is located.

4.2

Layout Algorithm Selection

In this section, we explore and illustrate the use of each layout
algorithm with a focus on its merits and on how it can contribute
toward achieving data exploration goals. One key goal involves
finding data clusters, which can reveal relationships among
variates within a UDH. Data within a UDH might be part of a
data group or part of a data cluster. A data group is set of data
nodes with a common parent, while a data cluster is a data group
that embodies some semantic cohesiveness. Throughout the data
exploration process, user goals could include any of the
following objectives:
• Find data clusters
• Observe data distribution within the hierarchy
• Differentiate data groups from data clusters

• Detect outliers
• Observe conditions matching no data records
The four layout algorithms typically provide different layout
configurations that can then be used to produce different
visualizations for a given data set. Each distinct visualization
presents an opportunity for the user to gain further insight into
the data set.
In order to illustrate the effect a layout algorithm has on the
hierarchy visualization, a real-world data set is used throughout
the examples within this section. The data set used here consists
of 40 data records retrieved from a stock market quote service
[4] and contains information relating stock quote requests for a
single day (see www.cs.unh.edu/~rdb/unhides/sdata98.html for a
copy of this data). A three level UDH is constructed from this
data set based on the stock requests, price change, and trading
volume fields. The detailed UDH description is shown in Figure
2, where levels are described using a name and data type, along
with one or more partitions. Partitions are described using a 3tuple format with minimum, maximum, and partition count
parameters, respectively. From the description in Figure 2, R
represents
stock
level = R type = integer
requests, C represents
partition = (0, 8, 1)
// R1
price change, and V
partition = (8, 21, 1)
// R2
represents
trading
partition = (21, 51, 1)
// R3
volume. The first level is
level = C type = float
defined using the stock
partition = (-20.0, 20.0, 2.0)
requests field, which
level = V type = integer
ranges in value from 6 to
partition = (1600, 2285200, 1)
partition = (2285200, 2988200, 1)
51. Level two is based
partition = (2988200, 10101300, 1)
on price change, which
ranges in value from
−11.25 to 2.94. The last Figure 2. UDH description for
level is based on trading stock market data set.
volume, which ranges in
value from 1,600 to
10,101,300.

4.3

Leaf-Based Layout

The first layout algorithm is called the leaf-based layout
algorithm and was provided as the default layout in the
hyperbolic tree library [5] used in this research. With this
algorithm, each leaf node is given an equal amount of space on
the circumference of the visualization. Construction of this
layout is accomplished from the bottom up starting with leaf
nodes. Thus, a requirement of this algorithm is that all internal
UDH nodes must contain at least one child. To satisfy this
condition, any terminal UDH node without a child leaf is
allocated space for an invisible child for use in the layout
algorithm.
All visible and invisible leaves are located uniformly along
the circumference of the layout. The calculation for the radius, r,
of each leaf arc is:
r = 2π / (count(data nodes) + count(childless UDH nodes)).
The calculation of an internal node’s arc center is based on
the center arc of its children. For terminal UDH nodes without
children, the arc center is based on a single invisible child along
the circumference. The resulting layout is such that groups with
a large number of data nodes occupy large regions, whereas

groups with a small
number of data nodes
occupy small regions.
Both of these properties
hold, regardless of the
range conditions that
define the partitions.
The leaf-based layout
has the property that each
leaf node is given an equal
amount of space on the
circumference of the
visualization.
This Figure 3. Visualization created
property has the visual using leaf-based layout for stock
effect of giving all market data.
individual data nodes
equal weight. This can
help the user to perceive how data is distributed within the
hierarchy; subhierarchies containing many data nodes occupy
more space than subhierarchies with few nodes.
Figure 3 shows the stock market data set using the leaf-based
layout, where the distribution of data nodes can be seen. From
this visualization, it is immediately apparent that subtree R1 has
many more nodes than subtrees R2 or R3. Notice that
terminating UDH nodes without children are allocated space for
an invisible data node.

4.4

Subnode -Based Layout

The subnode-based layout algorithm divides space evenly among
nodes at each internal level within a subhierarchy. Terminal
UDH nodes containing no children are allocated the same
amount of space as each of their siblings. Construction of this
layout, as well as the next two layout types, is accomplished
from the top down starting at the root node. A node’s arc is
calculated based on its parent arc divided evenly among its
children. That is, if a node has four children, the arc allocated to
the parent is divided into four equal-sized subranges, one for
each child. This calculation can be broken down into two parts,
the proportion metric and the node region:
metric = 1 / count(parent’s subnodes)
region = parent region * metric
As a result of the subnode-based layout, the hierarchy
branches at regular intervals and its structure is natural and easy
to see. Figure 4 shows a stock market data visualization
produced using this layout algorithm. Notice how the uniform
division of space among subnodes within the visualization
provides a clear and natural way to see the hierarchy structure.
Subhierarchies R1, R2, and R3 are all allocated the same amount
of space; each of the data node groups are also allocated the
same amount of space. The latter property has the effect of
conspicuously isolating outliers within the visualization enabling
them to be easily noticed by the user. Regions containing no data
whatsoever are also manifest. Another benefit of the subnodebased layout algorithm is that layout uniformity provides for an
ideal hierarchy layout to compare different data sets under the
same conditions. This is also true of the range-based layout.
Both of these layout algorithms have the property that the
numbers of leaves within a subhierarchy do not affect how the
basic hierarchy is shown.

Although there are
many benefits to the subnode-based layout algorithm,
finding
data
clustering can sometimes
be problematic because all
nodes on a particular level
within a branch are uniform and equally spaced.
This is often appropriate if
the partitions cover equal
sized ranges and the fundamental semantics asso- Figure 4. Visualization created
ciated with the data using subnode-based layout for
supports the equal range stock market data.
partitioning.
However,
consider the case where one node has a large range condition and
another has a small range condition, yet they both have the same
large number of data nodes. Here, they both have a similar appearance in the visualization, such as the two potential clusters at
the right in Figure 4, and a cluster might go unnoticed without
careful scrutiny by the user. Partition changes can also go unnoticed within the visualization due to the uniform layout.

4.5

Range-Based Layout

The range-based layout algorithm divides space proportional to
the size of the range value associated with each node. Nodes
with a large range value occupy a greater amount of space than
those with a small range value. Clusters appear as dense groups
of data nodes that occupy a small region within the visualization.
The metric and region values are calculated for each node as
follows:
metric = range / sum(sibling range)
region = parent region * metric
As a result of the range-based layout, the hierarchy branches
containing a large range value are given a large amount of space.
Consider that a cluster can be identified by a large number of
nodes that lie within a small range. The issue of identifying
clusters can be overcome now that space is being used in the
layout to conform to a node’s range condition. Clusters appear as
dense groups of data nodes that occupy a small region within the
visualization.
This algorithm works particularly well with hierarchies in
which the range among sibling nodes varies significantly; it does
not provide a substantially
different layout than the
subnode-based layout in
the case where the range of
nodes are approximately
the same size. Dynamic
partition changes made by
the user are noticeable
within the visualization by
the reallocation of space
for the hierarchy.
Figure 5 shows a
range-based stock market
data visualization. Notice Figure 5. Visualization created
the data clusters in the left using range-based layout for
branches of subtrees R1 stock market data.

and R2 and how they appear tightly grouped together. Also
notice how much space is allocated to R3 due to its large range.
A primary user goal involves finding data clusters. Using the
range-based layout algorithm with a data set containing data
clusters, those clusters can be made visible as a set of densely
grouped data nodes within a small region. However, because
data clusters are given less space within the visualization than
larger-range nodes, it might become difficult to easily separate
adjoining clusters.

4.6

Density-Based Layout

The density-based layout algorithm divides space using a density
metric. Nodes with a high density occupy a greater amount of
space than those with a low density. Density is computed as the
number of data nodes within a subtree divided by the range of
that subtree. Clusters appear as groups of data nodes that occupy
a large region within the visualization. The density, metric, and
region values are calculated for each node as follows:
density = count(subtree data nodes) / range
metric = density / sum(level(density))
region = parent region * metric
In the resulting layout, subtrees with a high density occupy
more space than those with a low density. Another property of
this layout is that neighboring UDH terminal nodes containing
no children converge to a single location. By applying the
density metric to the layout, denser subtrees, which are likely to
contain clusters, are given a larger proportion of space within the
visualization. A potential cluster is now identified as a single
group of leaf nodes that occupies a large arc space. The resulting
visualization also helps to separate neighboring clusters.
Figure 6 shows a density-based stock market data visualization. The two potential clusters that are quite evident in the four
and five o’clock positions of the range-based visualization
shown in Figure 5 and in the two and four o’clock positions of
the subnode-based visualization shown in Figure 4 have moved
in Figure 6 to the ten and twelve o’clock positions and are now
distinguished as one data group and one data cluster. The fivenode group at the twelve o’clock position is, in fact, a cluster
since it spreads out over a relatively wide range. In contrast, the
six-node group at the ten o’clock position occupies relatively
little space, so it is not likely to be a significant cluster. Furthermore, a two-node cluster, which up to this point remained hidden, is now made evident within subhierarchy R1 on the right
side of the visualization. Because of subhierarchy R1’s considerable density, it is allocated
the most space within the
visualization, about twothirds of the total space.
Also notice that because of
subhierarchy R3’s low
density, it is allocated the
least amount of space.
Contrast this visualization
with the one in Figure 5.
The dense packing of
potential clusters in Figure
5 is immediately visually
apparent, but it is not Figure 6. Visualization created
necessarily clear that these using density-based layout for
“obvious” visual patterns stock market data.

(a)
(b)
(c)
(d)
Figure 7. The dynamic algorithm blending was used to create this sequence of stock market visualizations
are true clusters. The layout of Figure 6 requires more careful
inspection, but also yields more conclusive results. These observations suggest that a series of visualizations may be the most
effective exploration tool.

4.7

Dynamic Blending Metric

As shown in the previous section, user goals for data exploration
can be achieved by using different layout algorithms to create
visualizations targeted to achieve goal-related objectives.
However, each algorithm produces a fixed layout according to a
given data set and UDH description. Furthermore, it is possible
for the user to create partitions where the range values or density
values are significantly skewed. Under such conditions, it may
be best to use either the subnode-based or the density-based
layout algorithm or some combination of the two. A blending
algorithm can be used to calculate a metric that reflects
percentages of both the subnode and density metrics. Both layout
algorithms can then be used proportionately according to the
blending metric. For example, the density-based and subnodebased layout algorithms could be combined as follows:
Let blend = 0.5
metric = blend * density + (1 – blend) * subnode
region = parent region * metric
After applying a blending metric of 0.5 to the density and
subnode metrics, the region metric is weighted with a 50%
contribution from each algorithm. As the blending parameter
increases, more weight is given to the density metric; as it
decreases, more is given to the subnode metric. The region
metric can be applied to a node subsequent to the even division
among siblings that initializes each layout algorithm. Figure 7
shows a visualization sequence using algorithm blending with
the subnode-based and density-based algorithms. There are five
different visualizations at various stages of a blending
progression. Figure 7a was created using 100% of the subnodebased layout algorithm and 0% of the density-based layout
algorithm, while Figure 7e was created using the 100% of the
density layout algorithm and 0% of the subnode-based layout
algorithm. Figures 7b, 7c, and 7d show blending of the subnodebased and density-based algorithms at ratios of 75:25, 50:50, and
25:75. Notice how it becomes increasingly apparent through the
visualization sequence that the group of data nodes at the nine
o’clock position in Figure 7a is a significant cluster as shown in
Figure 7e. There are two more clusters that are revealed at the
right and at the top of Figure 7e. Also note the potential cluster at
the three o’clock position in Figure 7a is revealed to be a data
group (not a cluster) at the 10 o’clock position in Figure 7e.

(e)

This blending factor allows a user to create a layout family
composed from any two existing algorithms. Each member of
the family represents a different relative influence of the two
contributing algorithms. Moreover, by providing support for the
blending factor at runtime through a continuously-variable, usercontrolled slider, the dynamic layout algorithm allows the user to
effect dramatic changes in the hierarchy appearance in a smooth
progression of layout changes. Thus, the user can search for
clusters or search for other patterns by using the subnode-based,
range-based, or density-based algorithms or by using a dynamic
layout created by combining any two algorithms together.

5
5.1

Partition Definition
Dynamic Partitions

A convenient method for defining and editing partitions is
through the use of graphical dynamic partition sliders (GDPS). A
GDPS display is similar in form to Eick’s data visualization
slider [6]; it contains information for each data value within a
field paired with its index into the unordered data set. GDPSs
support dynamic revision for partitions using direct manipulation
of boundaries represented in a graphical data distribution chart
that depicts the distribution. Results from partition revisions are
immediately reflected in the hierarchy visualization.

5.2

Partition Definition with GDPSs

There are two different types of GDPSs: ordered and unordered.
An ordered GDPS is created by using a set of data values sorted
into ascending order and partition descriptions as input to create
a data chart visualization like the ones shown in Figures 8a, 8b,
and 8d. Data is depicted as connected points in a chart where the
horizontal axis indicates data indexes on a counting scale and the
vertical axis indicates the full range of data values on a value
scale.
Partitions are depicted in the graphs as vertical lines within
the ordered displays and as horizontal lines in the unordered
displays. A partitioning scheme can be either complete or
partial. In the complete range scheme, the full data range is
broken into a contiguous set of partitions. Partial range partitions
provide support for creating non-contiguous partitions. By using
non-contiguous partitions, the user can filter data by excluding it
from the set of defined partitions.
Figure 8a shows a GDPS using the complete range partition
scheme, where there is a user-defined partition boundary in the
center at data index 8, which contains the value 5.28. When
using the complete range partitioning scheme, fixed partition
boundaries are always defined at the left and right chart
extremes. Figure 8b shows partitions defined using the partial

6
8

6

(a)

9

12

(b)

The layouts we’ve described so far have all used the same
layout algorithm at every level of the hierarchy and have based
the layout decisions on the same variates used to define the
hierarchy. It is both easy and useful to relax these constraints.

6.1
12

(c)

8

(d)

Figure 8. A data set of 16 values displayed using four
different graphical dynamic partition sliders.
range partition scheme with two partitions defined on indexes 6
through 9 and 12 through 15. The disjoint partitions are shown
as shaded region within the graph.
An unordered GDPS is created by using an unordered set of
data values and partition descriptions as input to create a data
chart visualization like the one shown in Figure 8c. In this
figure, data values are displayed according to their associated
index values, which are in a sequentially increasing order. Also
note that the partition boundary is shown as a horizontal line
across the unordered data graph.
Graph coloring associates a color for each value according to
its index value and is colored from dark to light as indexes
increase in value. Data indexes in the unordered display are in
increasing order from 0 to n, where n is the total number of data
elements minus one. Figure 8c shows the unordered data set
with index coloring, where dark color values have low indexes
and light color values have high indexes. Data index coloring is
also shown in figure 8d, which shows a graph of the ordered
data set.

5.3

Interactive Partition Modification

User interactions supported by a GDPS include revising,
adding, and removing partition boundaries. Revising a boundary
is accomplished by “dragging” the boundary to a new location
using a mouse. Throughout the boundary revision process, the
visualization is updated immediately with each new position.
New boundaries can be added and old boundaries deleted by
simple interactions. Upon completion of any of these tasks, the
hierarchy is modified to correspond to the structural change,
repopulated with data, and redisplayed in the hierarchy
visualizations. Additionally, the index coloring can be turned on
and off.
The GDPS has several advantages over the UDH editor in
terms of partition definition. The visual aspect of a GDPS allows
the user to see the data distribution for hierarchy levels in both
ordered and unordered forms. This can facilitate definitions of
effective partitions. For example, in the ordered GDPSs,
partitions defined over flatter sections of a distribution, in which
values lie within a small range, are more likely to yield data
clustering than other partitions. The dynamic nature of the
graphical slider provides a method for the user to use direct
manipulation to modify the hierarchy through partition changes.
Moreover, the GDPS supports immediate visualization updates
for revisions that provide timely feedback to the user.

Layout Algorithm Extensions

Weighted Partition Layout

When carrying out an exploration, some data sets may have
certain ranges that are more interesting than others for a
particular task. For example, when exploring file system data,
the user may determine that smaller files are more interesting
than medium or large size files. Weighted mappings allow the
user to adjust the “normal” spatial distribution as computed by
each of the layout algorithms. This approach is most easily seen
when applied to the node-based layout. Consider, for example,
the file system data with three partitions based on file size. Using
the node-based layout, each of these partitions would occupy the
same amount of space. If, however, the user assigns weight of
(3,2,1) to the three partitions, respectively, the first partition
(representing small files), would be allocated 50% of the space
(3/6), partition 2 would get 33.3% of the space (2/6) and
partition 3 would get 16.7% (1/6).
Weights could also be used to affect the other layouts,
although the implementation and interpretation of the results is a
bit more subtle. We compute new spatial percentages by
multiplying the original percentages by the weights and then
dividing by the sum of the new products to get new percentages.
For example, consider the file size example using the rangebased layout algorithm. Suppose that partition 1 includes files
whose size is less than 1000, partition 2 includes files between
1000 and 100,000, and partition 3 includes files from 100,000 to
1MB. With no weighting these partitions would occupy
approximately 0.001%, 10% and 90% of the space, respectively.
By assigning the weights, (10000,10,1) to the three partitions, we
get a new set of spatial ratios, (10,100,90) which are then
mapped to the percentages, (5,50,45). This approach is likely to
be most useful when selecting a single partition to emphasize
and changing its weight relative to the others. This could even be
done dynamically by mapping a slider to this weight. A similar
effect can be achieved by dynamically blending two different
layouts as described below in section 6.4.

6.2

Data-driven Layout Variations

Up to this point, we have described output visualizations that
are principally a function of the user-defined hierarchy
specification. An alternative is to let the data drive the
visualization using a data derived value. Especially useful values
include statistical summaries such as the data’s actual range,
standard deviation, average, and median.
Actual data ranges are calculated as the difference between
the minimum and maximum values for a data group. Although
the hierarchy may be specified using a large range, the range of
the data values within a data group might be small in a specific
data set. By using the data’s actual range, the hierarchy could
more accurately reflect the data rather than the specification. A
data group having a small actual range, but a large range
specification, would be shown using a smaller amount of area in
the range-based layout and a larger amount of area in the
density-based layout.

Similarly, standard deviation could be used to show the
amount of deviation from the mean within a data group. Groups
having a larger amount of deviation would be shown using a
larger amount of space in the range-based layout and a smaller
amount in the density-based layout. Likewise, groups having a
smaller amount of deviation would be shown using a smaller
amount of space in the range-based layout and a larger amount in
the density-based layout.
It is also possible to use one data attribute to specify
conditions for defining a level and use another attribute’s derived
summary values as a parameter to a layout algorithm to drive the
output; one attribute serves to organize, whereas the other
determines the visual effect.

hierarchies for some given data sets. Statistical clustering results
could provide a starting point from which to define hierarchies,
whereupon the user could refine the hierarchy in accordance
with world knowledge of the data. We would also like to adapt
our ideas to other tree visualization algorithms, such as cone
trees, disc trees, and 3d hyperbolic trees. Other possible
refinements to the UNHIDES system include support for a usercontrollable filtering mechanism used for pruning branches with
few data nodes, coloring nodes that incurred a parent change
during a partition refinement, and providing a preview of data
movement prior to an actual partition change.

6.3

[1]

Level-based Layout Specification

Attributes within a data set typically have differing
characteristics, and each may best be shown using a particular
layout algorithm. Level-based layout specification provides a
flexible way to combine multiple layout algorithms to produce a
single hierarchy visualization. Each level can use a particular
layout or combination of layouts as specified by the user.
Consider again the file system data where each file has a
specific type, size, and age. A hierarchy can be defined using
descending levels as follows: type using the node-based layout,
followed by size using the range-based layout, and then age
using the density-based layout. Partitions in the type level are
evenly divided among the included types; partitions in the size
level are divided such that larger file sizes correspond to larger
partitions; and partitions in the age level are divided evenly into
several groups.
It is possible to bring additional flexibility to this example by
using the data-driven and weighted layouts. For instance, in the
file level, the data driven layout could be used to provide a
visualization by using the actual file size ranges within each
partition, and the weighted layout could be used to give smaller
files more precedence in the output visualization.

6.4

References

[2]

[3]

[4]
[5]

[6]

[7]

[8]

[9]

Extended Dynamic Blending
[10]

When switching from one layout algorithm to another, it is
possible for the user to lose context with the visualization. The
notion of dynamic blending of layouts as discussed in section 4.7
can be extended to include all of the layout variations described
in this section. Automatic animation could be used to provide a
smooth series of incremental changes from one visualization to
the next when switching layout algorithms. This would allow the
user to track individual nodes as they are repositioned.

[11]
[12]

[13]

7

Conclusion

Our user-defined hierarchies help to reduce a data set into
smaller subsets that are more manageable and to reveal patterns
within a data set such as clustering. The semantic interpretation
that underlies a user defined hierarchy can lead to inappropriate
visualization using existing hierarchy visualization techniques.
Our implementation of user-defined hierarchies, called
UNHIDES, addresses this problem by providing multiple
hierarchy layouts, layout blending, and dynamic partition
adjustment, all of which help the user to find patterns within
data.
In future research, we would like to compare the results from
statistical clustering techniques to results from user-defined

[14]

[15]

[16]

Asahi, T., Turo, D., Shneiderman, B. Using Treemaps to Visualize
the Analytic Hierarchy Process. Information Systems, vol. 6, no. 4
(December 1995), pp. 357-375.
Card, S. K., Robertson, G. G., Mackinlay, J. D. The Information
Visualizer, An Information Workspace. In Proceedings of the ACM
SIGCHI’91 Conference on Human Factors in Computing Systems,
(New Orleans, LA, April 1991), pp. 181-188.
Carriere, J. and Kazman, R. Research Report Interacting with Huge
Hierarchies: Beyond Cone Trees. In Proceedings of Information
Visualization’95, (Atlanta, GA, October 1995), pp. 74-81.
Top Stocks [On-line]. StockMaster, 1998. Available HTTP:
http://www.stockmaster.com/wc/form/P1?template=sm/topstocks.
Robinson, A. EBI Hyperbolic Viewer [On-line]. European
Bioinformatics Institute, Cambridge, UK, 1998. Available HTTP:
http://industry.ebi.ac.uk/~alan/components.
Eick, S. G. Data Visualization Sliders. In Proceeding of UIST’94,
ACM Symposium on User Interface Software and Technology,
Marina del Rey, CA., 1994, pp. 119-120.
Jeong, C., and Pang, A. Reconfigurable disc trees for visualizing
large hierarchical information space. In Proceedings of Information
Visualization, 1998, pp. 19 -25, 149.
Johnson, B., and Shneiderman, B. Tree-maps: A Space Filling
Approach to the Visualization of Hierarchical Information
Structures. Proceedings of IEEE Visualization'91 Conference, (San
Diego, CA 1991), pp. 284-291.
Knuth, D., The Art of Computer Programming: Fundamental
Algorithms,
Third
Edition.
Addison-Wesley,
Reading,
Massachusetts, 1997, pp. 308-316.
Lamping, J., Rao, R. and Pirolli, P. A Focus+Context Technique
Based on Hyperbolic Geometry for Visualizing Large Hierarchies.
In Proceedings of CHI ’95 ACM Conference on Human Factors in
Computing Systems, (Denver, CO May 1995). ACM press, New
York, pp. 401-408.
Lamping, J. and Rao, R., Laying Out and Visualizing Large Trees
Using a Hyperbolic Space, UIST'94 Proceedings, pp. 13-14, 1994.
Munzner, T. Exploring Large Graphs in 3D Hyperbolic Space.
IEEE Computer Graphics and Applications, July/August 1998, pp.
18-23.
Robertson, G. G., Mackinlay J. D., and Card, S. K. Cone Trees:
Animated 3D Visualizations of Hierarchical Information. In
Proceedings of ACM SIGCHI’91 Conference on Human Factors in
Computing Systems, ACM press, New York, 1991, pp. 189-194.
Robertson, G. G., Card, S. K., and Mackinlay J. D. Information
Visualization Using 3D Interactive Animation. Communications of
the ACM 36, (4 April), 1993. pp. 57-71.
Shneiderman, B. Designing the User Interface: Strategies for
Effective Human-Computer Interaction, third edition, AddisonWesley, Reading, MA, 1998, pp. 510-544.
Shneiderman, B. The Eyes Have It: A task by Data Type
Taxonomy for Information Visualization. Proc. 1996 IEEE, Visual
Languages, (Boulder, CO, Sept.3-6,1996), pp. 336-343.


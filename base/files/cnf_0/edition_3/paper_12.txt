A Space-Optimized Tree Visualization
Quang Vinh Nguyen
Faculty of Information Technology
University of Technology, Sydney
NSW 2000, Australia
quvnguye@it.uts.edu.au
Abstract
This paper describes a new method for the visualization
of tree structured relational data. It can be used
especially for the display of very large hierarchies in a 2dimensional space. We discuss the advantages and
limitations of current techniques of tree visualization. Our
strategy is to optimize the drawing of trees in a
geometrical plane and maximize the utilization of display
space by allowing more nodes and links to be displayed at
a limit screen resolution. We use the concept of enclosure
to partition the entire display space into a collection of
local regions that are assigned to all nodes in tree T for
the display of their sub-trees and themselves. To enable
the exploration of large hierarchies, we use a modified
semantic zooming technique to view the detail of a
particular part of the hierarchy at a time based on user’s
interest. Layout animation is also provided to preserve the
mental map while the user is exploring the hierarchy by
changing zoomed views.

1. Introduction
As the amount of information available for access has
grown rapidly in the last few decades, researches on
finding new tools and techniques for navigating and
analyzing information have become more and more
important. One of these research areas is Information
Visualization, the technique to generate visual
presentations of information structure. These visual
representations can help human with a better
understanding of the information and the relationships
among data items. A large quantity of the information is
structured hierarchically, such as product catalogs, HTML
documents, computer file systems, organization chats, etc.
In graph theory, we usually call these hierarchical trees.
Early researches in tree visualization can be classified
into two main streams:

Proceedings of the IEEE Symposium on Information Visualization 2002 (InfoVis’02)
1522-404X/02 $17.00 © 2002 IEEE

Mao Lin Huang
Faculty of Information Technology
University of Technology, Sydney
NSW 2000, Australia
maolin@it.uts.edu.au
•

Connection: It is a natural way to draw tree
structures in a node-link diagram. A set of
visible graphical edges are drawn in the diagram
to link nodes from the parents to their children.
These edges are used to present relationships
among data items. There are many researches in
this direction have been done, such as cone-tree
[1, 14, 15], hyperbolic-tree [1, 10], balloon
view[1, 9], radial view[1, 8], disk tree[17] etc …
The advantage of using a node-link diagram to
present tree structures is that the human can
direct see these relationships that are drawn as a
set of graphical edges appearing in the diagram.
This makes easier for the process of human
perception in understanding the relational
structures of the information.

•

Enclosure: Another way to visualize trees is to
use enclosure. Unlike connection, enclosure is
the method of using enclosure to represent the
tree structures. Figure 6 shows that each node is
mapped to a rectangular area, then that area is
subdivided in horizontal or vertical direction to
show the relative size of the children of the node.
The process is recursively applied to the children
nodes with the subdivisions on the X- or Y-axis.
There are also some researches in this direction
that have been well done. A typical example of
this type of visualization techniques is tree-maps
[1, 2, 12].

Node-link diagrams and tree-maps are both effective
methods for visualizing trees of moderate size. Which one
we use depends primarily on the properties of the data.
Node-link diagrams are effective for trees that have an
uneven shape while tree-maps are effective for trees
where the nodes include quantitative variables,
particularly when large values are important. Now we
would like to briefly review some of the tree visualization
techniques and the limitations of these techniques.

Figure 1. Tree layout for a moderately large graph

Figure 4. Balloon view

Figure 2. H-tree layout

Figure 5. Hyperbolic browser

Figure 3. Radial view

Figure 6. Tree-maps

Proceedings of the IEEE Symposium on Information Visualization 2002 (InfoVis’02)
1522-404X/02 $17.00 © 2002 IEEE

1.1. Current tree visualizations
We now discuss some typical tree visualization
techniques including the classical hierarchical view [1,
6], the h-tree layout [1, 7], the radial view [1, 8], the
balloon view [1, 9], hyperbolic browser [1, 10], and treemaps [1, 2, 12].
The classical hierarchical view - The classical
hierarchical view is based on the algorithms developed by
Reingold and Tilford [6]. This technique positions
children nodes “below” their common ancestor. The
layout can vary as top-down, left-to-right tree and gridlike positioning. The algorithm is simple, fast and
predictable, but there is a lot of unused space between
nodes (see Figure 1). Because the utilization of
geometrical space is not optimized and there are many
unused holes produced on the drawing, this technique is
not a space-optimized drawing method and it is not
adequate for visualizing large size hierarchies.

rectangular space to display information but only the area
within the internal disc (see Figure 5). It also produces a
large portion of the unused display space
Tree-Maps - Unlike other traditional layout techniques,
tree-maps [1, 2, 12] represent hierarchical structures using
enclosure. Figure 6 shows that each node is mapped to a
rectangular area, then that area is subdivided in X or Y to
show the relative size of the children of the node. The
process is recursively applied to the children nodes with
the subdivisions on the X- or Y- axis.
This technique, as was claimed by Brian 1991,
optimizes the use of all available space (see Figure 6).
However, the lack of edges linking between nodes might
prevent viewers from understanding the relationship of
information. The viewers cannot direct see relationships.
This makes it much hard for viewers in percept and
understanding of the relational structures.

1.2. Space-optimized tree visualization
The H-Tree Layout - The h-tree layout [1, 7] is a
classical drawing technique for representing binary trees
(see Figure 2). This layout, however, only performs well
on balance trees and it is not suitable for general tree
visualization that we are concerning in this paper.

Although many visualization techniques have been
proposed for dealing with tree visualization, there are only
few are good candidates considering the issue of
optimizing display space in the layouts design.

The Radial View - The radial view is based on an
algorithm described in Eades [8] – recursively positions
children of a sub-tree into circular wedges. The angles of
these wedges are proportional to the number of leaves of
the sub-tree. The algorithm is simple and it behaves well
in general. This technique, however, is also not optimized
in the use of available space. In Figure 3, we see that there
are many unused holes in the geometrical plane that waste
a large portion of the display space.

The Connection approach, such as hyperbolic tree [1,
10], uses a node-link diagram to present relationships
among data, allowing viewers to directly see the
relationships that are usually drawn as a set of graphical
edges appearing in the diagram. However, layouts
produced by connection approach are usually containing
many unused spaces that waste the display space and
reduce the number of displayed nodes and edges on the
screen.

The Balloon View - This layout is formed where siblings
of sub-trees are included in circles attached to the father
node. The balloon view can also be obtained by projecting
a cone tree [14] onto a plane. The algorithm behaves well
on balance trees. Similarly to the radial view, it wastes a
large portion of the display space (see Figure 4).

On the other hand, Tree-maps [1, 2, 12] claims 100%
efficiency of space utilization. However, they do not show
directly the relational structures of information by
providing links to connect nodes. This costs extra
cognitive effort of viewers in understanding the relational
structures that are presented in an enclosure manner.

The Hyperbolic Browser - Hyperbolic layout is a new
technique developed by Lamping and Rao [10]. This
layout technique constructs trees in hyperbolic plane and
then maps that structure into ordinary Euclidean plane.
The algorithm produces nice tree visualization in side a
disc and it is quite capable for visualizing large
hierarchies. There are several implementations are
available at Inxight-Xerox1. In spite of being a good
layout technique, hyperbolic browser does not use entirely

Noticeably, Cheswick and Burch have presented a nice
technique for Internet mapping [5]. The technique yields
very large tree-like structure (100,000 nodes or more) by
using a node-spring approach and a number of heuristics.
However, the running cost of this technique is high and a
typical layout run requires 20 CPU hours on a 400 MHz
Pentium. [5]

1

http://www.inxight.com/

Proceedings of the IEEE Symposium on Information Visualization 2002 (InfoVis’02)
1522-404X/02 $17.00 © 2002 IEEE

This paper presents a new simple and fast technique for
tree visualization in 2D planes. Similar to tree-maps, we
also use area division to define the layout of sub-trees.

This ensures the 100% efficiency of space utilization. On
the other hand, we still use a node-link diagram (as
traditional display techniques do) to show the hierarchy
relationships of information. This improves dramatically
the clarity of the data structure.
Our strategy is to optimize the drawing of trees in a
geometrical plane and maximize the utilization of display
space by allowing more nodes and links to be displayed at
a limit screen resolution. We use the enclosure to partition
the display space into a collection of geometrical areas,
then these areas are assigned to all nodes of the tree. We
also use node-link diagrams to show the relational
structure. Our technique is similar to the radial drawing
that uses a term wedge for positioning sub-trees.
However, in radial drawing the layout of a sub-tree is not
restricted in a particular of geometrical area, but only a
clock-wise angle α and a direction for tree extension. In
contrast, out technique uses two terms, wedge and local
region, for the positioning of sub-trees. The layout of a
sub-tree in our technique is restricted in a particular local
region.
We take both advantages of two approaches, the
enclosure and the connections. To enable the exploration
of large hierarchies, we use a modified semantic zooming
technique to move a detailed view of a particular area of
hierarchy around based on user’s interest. Layout
animation is also provided to preserve the mental map
while the user is exploring the hierarchy by changing
zoomed views.
Section 2 describes technical specifications of our
technique including the detail of space-optimized tree
layout, navigation and interaction, and animation. Section
3 discusses the implementation of our technique on
various data sets. Finial session is our future work and
conclusion.

2. Technical Specification
Our space-optimizing technique can only be applied to
rooted trees. We now review the terminologies that are
used in our technique.

2.1. Terminology
A tree is a connected acyclic graph. A rooted tree
consists of a tree T and a distinguished vertex r of T. The
vertex r is called the root of T. In other words, T can be
viewed as a directed acyclic graph with all edges oriented
away from the root. If (µ,ν) is a directed edge in T, we
then say µ is the father of ν and ν is a child of µ. A leaf is
a vertex with no children. If T contains a vertex ν, then

Proceedings of the IEEE Symposium on Information Visualization 2002 (InfoVis’02)
1522-404X/02 $17.00 © 2002 IEEE

the sub-tree T(ν) rooted at ν is the sub-graph induced by
all vertices on paths originating from ν. We also use a
node to represent a vertex ν with its displaying properties.
This terminology is mainly mentioned in display session.
A geometrical local region of the vertex ν in T is
defined as a convex polygon P(ν), that contains the
drawing of a sub-tree T(ν) and a directed edge (µ,ν)
where µ is the father of ν. A wedge wg(ν), in our
implementation, is defined by a vertex µ, a line l goes
through that µ, and a clock-wise angle α(ν); where µ is
the father of ν (see Figure 7). Thus we have
wg(ν) = {µ, l, α(ν)}.
A weight w(ν) is a integer value that associated with a
vertex ν in T.

Figure 7. A wedge wg(ν)

2.2. Geometrical Layout
The geometrical drawing D(T) of a tree T is responsible
for the positioning of a set of vertexes {r,ν1,ν2, …,νn} and
the computation of local regions P(ν1), P(ν2), …, P(νn)
for the drawing of sub-trees T(ν1), T(ν2), …, T(νn) in a 2D
plane.
Each vertex νi is bounded by a polygon P(νi). The area
of P(νi) is equal to the total areas of local regions of its
children. The drawing of a sub-tree T(νi) is restricted
within the area of P(νi). See an example in Figure 8.
A drawing of sub-tree T(νi) rooted at νi is calculated
based on the properties of νi and its boundary P(νi). We
firstly define the local region P(r) for root r as the entire
display area, and the position of root r is at the center of
P(r). Then, all local regions P(ν1), P(ν2), …, P(νn) are
calculated recursively as described below:
Suppose that we want to calculate the region P(νi) of
the sub-tree T(νi) rooted at νi which has k children {νl,
νl+1, …,νl+k-1 }.

• We firstly calculate local regions P(νl), P(νl+1), …,
P(νl+k-1) for the children {νl,νl+1, …,νl+k-1}.
• We then calculate positions of {νl,νl+1, …,νl+k-1} that
are inside their local regions P(νl), P(νl+1), …, P(νl+k1).
• We repeat the above calculation to all sub-trees from
the top to the bottom of the tree hierarchy and it stops
when all leaves of the tree are reached.
• We technically ignore the layout calculations for
those sub-trees when local regions of these sub-trees
are too small to be displayed by the current screen
resolution.
• We eventually get P(νi) = P(νl) ∪ P(νl+1), …, ∪
P(νl+k-1)
Weight calculation - we assign a weight w(νi) to each
vertex νi for the calculation of the local region P(νi) in
relatively to its father. A weight is a integer value that is
associated with a vertex in T. We have a set of weights
{w(ν1), w(ν2), …, w(νn)} associated with the vertex set
{ν1,ν2, …,νn} in T. This set can be calculated recursively
from leaves in the following rules:
• If νi is a leaf, its weight is w(νi) = 1
• If νi has k children {νl,νl+1, …,νl+k-1}, its weight is
w(νi) = 1 + C

k −1

∑ w(vl + j )
j =0

Where C is a constant (0 < C < 1), and w(vl+i) is the
weight assigned to lth child of νi.
Constant C is a scalar that determines the difference
between the weight of a vertex and their children. In other
words, the larger the C’s value is, the bigger the
difference of local regions between vertexes with more
descendants and vertexes with fewer descendants. We
apply a constant C = 0.6 in our prototype system.
Wedge calculation - we use wedges to find positions of
vertexes and calculate the local regions for these vertexes.
Suppose that a vertex νi has k children {νl,νl+1, …,νl+k-1}
located in a local region P(νi). We want to divide P(νi)
into sub-regions P(νl), P(νl+1), …, P(νl+k-1) for the
drawings of sub-trees T(νl), T(νl+1), …, T(νl+k-1).
A sub-region P(νl+m) of the mth child of νi consists of a
wedge wg(νl+m) and one (or more) cutting edges
(boundaries) cut by other higher level local regions in the
drawing.

Proceedings of the IEEE Symposium on Information Visualization 2002 (InfoVis’02)
1522-404X/02 $17.00 © 2002 IEEE

A wedge is defined as wg(νl+m) = {νi, l, α(νl+m)}, where νi
is the father of νl+m and l is a straight line going through νi
that determines two boundaries of P(νl+m).
The angle α(νl+m) of the wedge wg(νl+m) of the mth child
is calculated by the formula below:

α(νl+m) =

A

w(vl + m )
k

∑ w(v
j =0

l+ j

)

Where A is a constant (A = 360o) and w(νl+j) is the
weight associated with vertex νl+j.
We repeat the above calculation to get a set of wedges
{wg(ν1), w(ν2), …, w(νn)} associated with every vertex in
tree T. These wedges determine the area division of local
regions.
Figure 8 shows an example of dividing vi’s local region
into 4 sub-regions for its children {νl+1, νl+2, νl+3, νl+4}.
Local region P(vi) of vi is a pentagon and {α(νl+1), α(νl+2),
α(νl+3), α(νl+4)} are respectively the angles of wedges
{wg(νl+1), wg(νl+2), wg(νl+3), wg(νl+4)}. Figure 9 shows an
example of area division of a data set.
Vertex position - the position of a vertex vl+m is
computed after the calculation of local region P(vl+m). We
need to find out a point P in the boundary of P(vl+m) that
the straight line connecting P and the father vertex νi
divides P(vl+m) into two areas of the same size. We then
choose the position of the vl+m in the midpoint of the line.
See an example in Figure 10.

2.2 Navigation and Interaction
To be able to explore large hierarchies with detailed
viewing, we use a modified semantic zooming technique
[1, 16] to display the detail of a particular part of the
hierarchy based on user’s interest at a time. When being
selected by a mouse-click, the selected node moves
forward to the position of the root. All its ancestors and
siblings are ignored except a few ancestors are kept as a
history path for the tracking of navigation. The local
region of the selected node now expands to the entire
display area. In other words, during the navigation, we
only visualize the sub-tree of selected node and a history
path (including the root). This viewing technique requires
the recalculation of positions of all vertexes in a sub-tree
at a time in corresponding to a mouse click (see Figure
11).

As same as the area division where a child’s area is
always smaller than its father, we also apply this rule to
our viewing technique. The size of nodes and the width of
edges we choose are proportional to their levels in the
hierarchy. In order words, the closer to the root, the larger
of nodes and the wider of edges are. This rule improves
the clarity of the presentation of tree hierarchies.
As mentioning above, the history path is created for
backward navigating purpose. The path displays orderly
all direct-ancestors of the selected node. We assign
different graphic properties to these ancestors to
distinguish them from the normal nodes for the
enhancement of clarity.
Figure 10. Example of positioning a vertex

Figure 8. An example of dividing νI’ s local region
into children ‘s local regions of 4.

Figure 9. Example of area division

Proceedings of the IEEE Symposium on Information Visualization 2002 (InfoVis’02)
1522-404X/02 $17.00 © 2002 IEEE

Figure 11. Example when a node is selected

2.3 Animation
Animation is used preserve mental map when the view
is changing. This is a real challenge because our
technique focuses on visualizing very large hierarchies.
The expensive computation of big data set (more than
10000 nodes) might disrupt smooth animation.
Therefore, we only apply animation to those nodes that
are visible in the screen resolution. As a result, the
number of nodes need to be involved in animation is
reduced dramatically to from a few tens up to a few
hundreds. In addition, during the animation period, edges
are drawn and calculated with a minimal width. This also
decreases remarkably the animation cost.
When a node is selected, all siblings and ancestors of
this node are blurring away gradually while the selected
node moves to its father’s position. During that
movement, all descendants of the selected node will
smoothly move to and occupy the space of selected
node’s father. The animation stops when the selected node
reaches the root position (the center of the display area).

3. Examples
Figures 12 through 15 are examples of applying our
new technique on 4 data sets. These pictures are screen
dumps collected from our computers with a standard
screen resolution (1024x768). Figure 12 shows the
visualization of a medium size data set with 150 nodes
where viewers can easily see all data items and relations
among nodes. Figures 13 and 14 show the layout of two
large and very large relational data sets. Figure 15 shows
an example of applying our technique for visualizing a
uniform data structure. Overall, the amount of data does
not affect significantly in the display of overall tree
structures by using our layout technique. These examples
illustrate the high capability of our technique for
visualizing large hierarchical structures for various data
sets.

4. Conclusion and future work
Space-optimized tree visualization is an effective and
efficient technique for visualizing large tree structures.
Our algorithm can draw the entire tree of large data sets at
the screen resolution. This allows viewers to navigate and
view any part of the large tree structures with the assistant
of our modified semantic zooming technique.
We are currently investigating on new animation
algorithms to find out the one that is most suitable for the
space-optimized tree visualization. Another improvement
over the original layout is also being implemented. This

Proceedings of the IEEE Symposium on Information Visualization 2002 (InfoVis’02)
1522-404X/02 $17.00 © 2002 IEEE

algorithm uses area approach to define a node boundary
based on its weight instead of wedge angle. We also
investigate on new viewing techniques that can keep the
global view of the entire tree structures while a detailed
view of a part of the tree can be displayed during the
navigation. In addition, we are working on usability test to
demonstrate the benefits of our technique.
We have presented our space-optimized tree technique
for visualizing and manipulating large hierarchies.
Although our work is not completed yet, we believe that
this technique will become a valuable tool for visualizing
a variety of the large real tree-structural data sets.

References:
[1] Herman, G. Melançon, M.S. Marshall, “Graph Visualization
in Information Visualization: a Survey” In: IEEE Transactions
on Visualization and Computer Graphics, 2000, pp. 24-44.
[2] Johnson, Brian, and Shneiderman, Ben, “Tree-maps: A
space-filling approach to the visualization of hierarchical
information structures”, In Proceedings of the 1991 IEEE
Visualization, IEEE, Piscataway, NJ, 1991, pp. 284-291.
[3] Quingwen Feng, “Algorithms for Drawing Clustered
Graphs”, Thesis of Doctor of Philosophy, The Department of
Computer Science and Software Engineering, The University of
Newcastle, Australia, April 1997.
[4] Hideki Koike, Hirotaka Yoshihara, “Fractal Approaches for
Visualizing Huge Hierarchies”, In Proceedings of the 1993
IEEE Symposium on Visual Languages, IEEE/CS, 1993, pp. 5560.
[5] Hal Burch, Bill Cheswick, “Internet Mapping Project”, Bell
Labs, http://www.cs.bell-labs.com/who/ches/map/index.html
[6] E. M. Reingold and J. S. Tilford, “Tidier Drawing of Trees”,
IEEE Transactions on Software Engineering, SE-7(2), 1981, pp.
223-228.
[7]. Y. Shiloach, “Arrangements of Planar Graphs on the Planar
Lattices”, PhD Thesis, Weizmann Institute of Science, Rehovot,
Israel, 1976.
[8]. P. Eades, “Drawing Free Trees”, Bulleting of the Institute
fro Combinatorics and its Applications, 1992, pp. 10-36.
[9]. C. S Jeong and A. Pang, “Reconfigurable Disc Trees for
Visualizing Large Hierarchical Information Space”, In
Proceedings of the IEEE Symposium on Information
Visualization (InfoVis ’98), IEEE CS Press, 1998.
[10] J. Lamping and R. Rao, “The Hyperbolic Browser: A Focus
+ Context Technique for Visualizing Large Hierarchies”,
Journal of Visual Languages and Computing, vol. 7, no. 1,
1995, pp. 33-55.
[11] G. di Battista, P. Eades, R. Tamassia, and I. G. Tollis,
“Graph Drawing”, IEEE Transactions on Visualization and
Computer Graphics, 1(1), 1995, pp. 16-28.
[12] Ben Shneiderman, “Treemaps for Space-Constrained
Visualization of Hierachies”, December 26, 1998, updated
November 30, 2001. http://www.cs.umd.edu/hcil/treemaps.
[13] Graham J Wills, “NichesWorks – Interactive Visualization
of Very Large Graphs”, Lucent Technologies (Bell
Laboratories), USA. http://www.belllabs.com/user/gwills/NICHEguide/nichepaper.html.

[14] G. G. Robertson, J. D. Mackinlay, and S. K. Card, “Cone
Trees: Animated 3D Visualizations of Hierarchical
Information”, Human Factors in Computing Systems, CHI ’91
Conference Proceedings, ACM Press, 1991, pp. 189-194.
[15] G.G. Robertson, S.K. Card, and J.D. Mackinlay,
“Information Visualization Using 3D Interactive Animation”,
Communication of the ACM, 36(4), 1993, pp. 57-71.

Figure 12. Example with a medium large data set of
approximately 150 nodes

Figure 13. Example with the data set of
approximately 9000 nodes

Proceedings of the IEEE Symposium on Information Visualization 2002 (InfoVis’02)
1522-404X/02 $17.00 © 2002 IEEE

[16] G. W. Furnas, X. Zhang, “MuSE: A Multi-Scale Editor”, In
Proceeding of the UIST’98 Symposium, ACE Press, 1998.
[17] Huai-hsin Chi, James Pitkow, Jock Mackinlay, Oeter
Pirolli, Rich Gossweiler, Stuart K. Card, “Visualizing the
Evolution of Web Ecologies”, In Proceeding of ACM CHI 98
Conference on Human Factors in Computing Systems, ACM
Press, 1998. Los Angeles, California, pp. 400-407, 644-645.

Figure 14. Example with the data set of
approximately 55000 nodes

(A run of the above layout takes approximately 5 CPU minutes on
a 1000 Mhz Pentium III PC, using Java Applet)

Figure 15. Example with the 11 levels uniform binary
tree (approximately 4000 nodes)


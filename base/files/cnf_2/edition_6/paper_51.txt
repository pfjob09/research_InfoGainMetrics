DOI: 10.1111/j.1467-8659.2009.01624.x
EUROGRAPHICS 2010 / T. Akenine-Möller and M. Zwicker
(Guest Editors)

Volume 29 (2010), Number 2

Human Motion Synthesis with Optimization-based Graphs
Cheng Ren1,2 , Liming Zhao2 and Alla Safonova2
1 Beihang University 2 University of

Pennsylvania

Abstract
Continuous constrained optimization is a powerful tool for synthesizing novel human motion segments that are
short. Graph-based motion synthesis methods such as motion graphs and move trees are popular ways to synthesize long motions by playing back a sequence of existing motion segments. However, motion graphs only support
transitions between similar frames, and move trees only support transitions between the end of one motion segment and the start of another. In this paper, we introduce an optimization-based graph that combines continuous
constrained optimization with graph-based motion synthesis. The constrained optimization is used to create a
vast number of complex realistic-looking transitions in the graph. The graph can then be used to synthesize long
motions with non-trivial transitions that for example allow the character to switch its behavior abruptly while retaining motion naturalness. We also propose to build this graph semi-autonomously by requiring a user to classify
generated transitions as acceptable or not and explicitly minimizing the amount of required classifications. This
process guarantees the quality consistency of the optimization-based graph at the cost of limited user involvement.
Categories and Subject Descriptors (according to ACM CCS): I.3.7 [Computer Graphics]: Animation—
Keywords: Character Animation, Motion Synthesis, Continuous Optimization, Motion Graphs

Sit

1. Introduction
A number of researchers have shown that continuous constrained optimization (also called spacetime constraints or
simply optimization) can often be used to synthesize a
human motion [WK88, Coh92, NM93, LGC94, RGBC96,
Gle97, LP02, FP03, SHP04]. The appeal of these methods
is that they can generate motions that are very different
from the existing example motions. The success of the
optimization-based methods however, depends strongly on
the presence of a good initial guess, on how short the desired
motion is and how well the objective function such as energy
minimization or smoothness correlates with the naturalness
of the desired motion. These conditions make optimization
quite restrictive as well as not robust enough for generating
a wide variety of motions.

Pick

Throw

Duck

Jump

Figure 1: A motion generated with optimization-based graph: transitions between behaviors are direct (without walks in between) and
at the same time are realistic-looking.

tween start and end frames of the behaviors (in case of move
trees). Since it is difficult if not impossible to capture data
that would contain all possible transitions between behaviors, these methods have limited freedom in transitioning
from one behavior to another without introducing noticeable
discontinuities in the motion.

In contrast, the discrete optimization-based motion synthesis, such as motion graph-based [AF02,LCR∗ 02,KGP02,
AFO03] and move trees-based [Men99,MMC01,LK05] motion synthesis, can be used to generate natural long motions
quite reliably. Unlike the continuous constrained optimization approaches however, these methods are limited to playing back existing motion segments. In particular, they can
smoothly switch in between behaviors only when similar
frames are encountered (in case of motion graphs) or in be-

In this paper we describe a motion synthesis using an optimization-based graph. Motion synthesis with
optimization-based graphs combines the power of continuous constrained optimization in computing complex non-

c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.
Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and
350 Main Street, Malden, MA 02148, USA.

545

546

C. Ren & L. Zhao & A. Safonova / Human Motion Synthesis with Optimization-based Graphs

existent motions required to connect dissimilar frames with
the power of discrete optimization in synthesizing long motions. To build the optimization-based graph we use constrained optimization to find short natural motion segments
between frames in a motion database. These motions are
used as transitions in the graph. Once an optimization-based
graph is built, the motion synthesis itself is a discrete optimization for the motion that satisfies user constraints.
The technical challenge in constructing an optimizationbased graph lies in the fact that each optimization takes time,
may fail, and even when successful, the motion segment
it returns may be unnatural. To this end, we formulate the
construction of an optimization-based graph as a stochastic process and perform finite-horizon policy computation to
decide what optimizations to run in order to achieve a good
quality optimization-based graph with the least number of
optimizations. This speeds up the process of generating the
graph, improves the quality of the graph, and minimizes the
amount of user involvement, whom we use to confirm the
naturalness of the motions found by the optimization. Our
experimental results show that motion synthesis using an
optimization-based graph can generate good quality motions
that were not present in the original set of motions, for example, motions that involve direct transitions in between sitting,
picking, throwing, ducking and jumping motions (Figure 1)
or sudden but realistic-looking transitions in between sitting
down and walking (Figure 9).

2. Related Work
Continuous constrained optimization (optimization for
short) was introduced to the graphics community by Witkin
and Kass in 1988 [WK88]. In 1996 Rose and his colleagues [RGBC96] showed how to use optimization to create transitions between different motion segments. The system allowed a user to manually break existing motions into
pieces and then manually reassemble them back into the desired (new) motions by adding transitions using optimization. In our work we also use optimization to create transitions. However, the main contribution of our work is in developing an algorithm that automatically schedules the minimal number of optimizations required to achieve a good
quality optimization-based graph. Optimization allows us
to construct graphs that contain transitions which are not
present in motion database but are required by current user
applications. This graph can then be used to synthesize and
re-synthesize a variety of desired motions.
To compute transitions using optimization we need to
know the length of the transition. Wang and Bodenheimer [WB08] presented "geodesic distance" method and
"joint velocities" method for determining the length of a motion transition before doing interpolation. Li and his colleagues [LMFP08] computed the transition length by the
process of minimizing the effort needed to perform a tran-

sition. In our work, we used the idea of Wang and Bodenheimer [WB08] to compute transition length.
One popular alternative to continuous constrained optimization is motion blending. Motion blending techniques [WP95,RCB98,PSS02,PSKS04] are frequently used
to produce smooth transitions between two different behaviors, for example transitions from walking to running. However, these techniques usually concentrate on creating a single transition between two motion segments rather than constructing a graph as we do. In addition, while slower, constrained optimization is typically more powerful in generating motions that connect dissimilar frames. It therefore enables us to create graphs containing many transitions that
would not have been present at all or would be highly unnatural if using motion blending (See examples in Section 4).
In the context of motion graphs, several research papers
have recently appeared that address the problem of creating graphs with fast transitions. For example, Ikemoto and
her colleagues [IAF07] create quick (1 second long) transitions between all frames in the motion capture database by
interpolating existing motion segments. As another example, Zhao and Safonova [ZS08] use interpolation of motion
segments of the same contact to add additional data to the
database. The augmented database will contain many more
similar poses and therefore will allow for better connectivity
between behaviors. These papers use interpolation of existing motion segments to improve connectivity and/or flexibility of the graph and therefore are constrained by the limited
power of interpolation as compared to optimization.
A number of approaches have also been introduced that
combine motion graphs and interpolation [SH07, PSS02,
PSKS04, KS05, SO06, HG07, TLP07]. These approaches interpolate motion segments of similar behavior to create variations of motions of that behavior. For example, interpolating walks with different turn angles allows for the synthesis
of walking motion along paths of different curvature. These
techniques are orthogonal to our work which concentrates
on building novel transitions which were not captured by the
motion capture data.
Finally, move trees [Men99, MMC01, LK05] are different kind of graphs that are commonly used in games to control characters. These graphs are constructed manually by
carefully capturing motion segments that represent different
behaviors (such as walk cycle, jump, picking, sitting, etc).
Each behavior is represented by a node in the graph. In such
structured, behavior-based graphs, behaviors can only connect at the end of the motion clips. Our goal is to simplify
the process of graph creation (making it much less laborious). At the same time we aim to achieve the abundance
of transitions from within one behavior to another by introducing complex realistic-looking transitions that continuous
constrained optimization is often capable of producing.
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

C. Ren & L. Zhao & A. Safonova / Human Motion Synthesis with Optimization-based Graphs

3. Optimization-based Graph
An optimization-based graph is constructed semiautonomously: the user is only involved in deciding
whether the motion segments generated by optimization
should be accepted or rejected. In the following, we first
explain a simple but inefficient way to construct the graph
(Section 3.1). This method introduces many redundant
transitions. Not only does it result in long computation
times, but it also requires the user to decide on the quality of
many more generated transitions than necessary.
In Section 3.3, we show how to achieve a good quality
optimization-based graph with much smaller number of optimizations. The described algorithm minimizes explicitly
the number of times the constrained optimization is invoked.
This reduces drastically both the computation time and the
user involvement, making the algorithm practical.
3.1. Construction of Optimization-based Graph
Let G stand for the optimization-based graph we are constructing. Suppose we are given m motions that will be used
to construct graph G. The construction process consists of
three basic steps. Figure 2 demonstrates the process on an
artificial example for m = 2 motions.
In the first step, graph G is initialized using the provided
m motions: each vertex v in G corresponds to a frame in
one of the motions, and vertex v is a successor of vertex v
if and only if the frame corresponding to vertex v follows
the frame corresponding to vertex v in one of the motions. In
other words, at this point, graph G has m disconnected paths,
each corresponding to one of the motions (Figure 2(a)).
In the second step, the algorithm automatically picks
uniformly-spaced frames within each motion. In our running example, the algorithm picked every third frame (Figure 2(b)) resulting in a total number of n = 4 selected frames
across all the motions. Based on these frames, the algorithm
constructs matrix A of size n by n whose each entry, Ai, j ,
represents the length of the shortest path in between the corresponding vertices i and j. Thus, initially, if these frames
do not come from the same motion or if frame j precedes
frame i in the same motion, then Ai, j = ∞. Otherwise, Ai, j
gives the number of frames in between these two frames.
Figure 2(b) shows the matrix A for our simple example.
In its final (and main) step, the algorithm introduces additional transitions between some of the selected frames using
optimization (the details of the optimization process itself
will be given in Section 3.2). The objective of this step is to
ensure that in between every pair of the selected frames there
is a transition of at most length T (other objectives such as
the bound on the average transition time can also be used).
To achieve this, for every pair of the selected frames i, j for
which Ai, j > T , the algorithm tries to run optimization to
compute a motion segment connecting them. Thus, in our
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

547

example, the first pair selected for optimization was frames
1 and 3 (Figure 2(c)). After each invocation of the optimization, a user is prompted to confirm that the generated motion
segment appears to be natural. If the user confirms it, then
the motion segment is added to graph G as a transition between frames i and j and matrix A is re-computed (note that
multiple entries of A can be affected by the new transition). If
the user classifies motion segment as unnatural on the other
hand, then Ai, j remains the same. The algorithm repeats this
process until it has attempted to optimize for all the pairs of
frames whose Ai, j > T (Figure 2(d)).
3.2. Continuous Constrained Optimization
In this section we explain how we compute transitions using
optimization. We found that our approach computes good
quality, physically realistic transitions. However, our approach for creating an optimization-based graph can also be
used with other existing methods for computing transitions
using optimization (such as [RGBC96]).
Given two frames i and j, we use a two-phase optimization process to generate a transition between them. Twophase optimization is a common approach to solving hard
optimization problems. In the first phase, we solve an easier
optimization problem: we compute a motion that connects
frames i and j with C1 continuity. In the second phase, we
use the result from the first phase as an initial guess to solve a
more complex optimization problem with added constraints
on the physical correctness of the motion.
Each transition M consists of a sequence of frames M(t),
for t = 0..T . The duration T of each transition, is firstly computed using a simplified version of the time-warped "geodesic distance" method of Wang and Bodenheimer [WB08].
Given a start frame i and an end frame j, we first find such
frame i + b1 that it: (a) belongs to the sequence of frames
that follow frame i and remains in the same foot contact
as frame i; and (b) minimizes the difference, d(i + b1 , j) to
frame j. We then find such frame j − b2 that it: (a)belongs
to the sequence of frames that precede frame j and remains in the same foot contact as frame j; and (b) minimizes the difference, d( j − b2 ,i), to frame i. We choose
d(i+b1, j)
T = b1 / f ramerate as the transition duration if
≤
b1
d(i, j−b2 )
b2

d(i+b , j)

1
and
< Θ, where Θ = 1.5 is a threshold
b1
parameter. We choose T = b2 / f ramerate as the transition
d(i, j−b2)
d(i+b1, j)
d(i, j−b2 )
duration if
≤
and
< Θ. We have
b2
b1
b2
found that when the minimal difference is below Θ (two
cases above), it represents a very good estimate for the transition length. For situations when the minimal difference is
above Θ, we compute the transition length using a variation of the “joint velocities” method in [WB08]: the transi-

max log(q−1 qi,k)

j,k
tion duration is
, where the numerator is the
v
maximum joint difference between frames i and j. We use
a constant 0.9 for the denominator. We found that using this
constant works better than using the joint velocity, especially

548

C. Ren & L. Zhao & A. Safonova / Human Motion Synthesis with Optimization-based Graphs

(a)

(b)

(c)

(d)

Figure 2: Naive Construction Process

when those two dissimilar postures have small velocities or
even are static. In few cases where it does not work well, our
user assessment will remove the transition by labeling it as
unnatural. We use the method of [KGP02] to compute difference (d) between any two frames. The difference can also
be computed by other methods, such as that in [WB08].
The transition M(t) = (p(t),q1(t),...,qn (t)), where p(t)
and q1 (t) are the position and rotation of the root joint,
and q2 (t),...,qn (t) are rotations of other joints of the character. We represent M(t) = M0 (t) + D(t), where M0 (t) =
(p0 (t),q10(t),...,qn0 (t)) is an initial motion and D(t) =
(pd (t),q1d (t),...,qnd (t)) is the unknown displacement motion.
In the first phase, we use interpolated motion as the initial
motion, and in the second phase, we use the result motion
of the first phase as the initial motion. We follow a standard
approach for representing each element in D(t) using cubic
B-splines. We only allow optimization between frames i and
j if they have the same contact information. Therefore, our
transitions span only one 0.2 to 1 second long contact phase
and can be represented with 4 B-spline control points. We
now explain the two optimization phases in more details.
Optimization Phase 1: In this phase, we compute the
motion that connects frames i and j with C1 continuity. Because this optimization does not involve physics constraints,
it is easy and fast to solve. First, we compute the initial motion M0 (t) by interpolating joint angles (q20 (t),...,qn0 (t)) of
frames i and j (we use slerp operation between joint quaternions for interpolation). Note, that this interpolation does
not include root. We compute root position and orientation
(p0 (t) and q10 (t)) for each frame by rotating and translating
it to have the same contact foot orientation and position as
the first frame i.
The unknowns of the optimization are the components of
the displacement D(t), for t = 0..T . The objective function,
G(M), that we minimize ensures the smoothness of joint angle trajectories and root position over time by minimizing
the sum of weighted squared joint accelerations and root position accelerations:
n
2
G(M) = ((w p(t))
¨
+ (w q¨k (t))2)dt
(1)
1

∑

k

k=1

where weight wk is aggregate mass subtended at each joint
with respect to the effective root(see details in [FP03]).
We add posture constraints and velocity constraints to the
optimization. The posture constraints (Equation 2) ensure
that the transition starts from the joint angles of posture i

and ends with the joint angles of posture j . The velocity
constraints (Equation 3) ensure that velocities at the beginning and ending points of the transition are consistent with
the velocities at frames i and j correspondingly. In order to
avoid foot skate, we also add contact foot position constraint
(Equation 4). We treat constraints in Equation 2 and 4 as
hard constraints and constraints in Equation 3 as soft constraints (we add them as additional terms to the optimization
function).
q(0) = qi ; q(T) = q j
(2)
( p(0)
˙ − p˙ i)2 = 0 ; ( p(T
˙ ) − p˙ j )2 = 0;
n

∑ (q˙k (0) − q˙ki)2 = 0

k=1

(3)

n

;

∑ (q˙k(T ) − q˙kj )2 = 0

k=1

, t ∈ 0..T
pcontacts(t) = pcontacts
i

(4)

where pi , qi and p j , q j represent the root position and joint
angles of postures i and j in the original motion. p(0), q(0)
and p(T), q(T ) represent those of the first and last postures
of the synthesized transition.
Optimization Phase 2: In the second phase, we minimize
the same objective function and keep the same constraints as
in the first phase. In addition, we add physics to ensure physical validity of the motion. We use the same set of physics
constraints as in [FP03], and we refer the reader to this paper for additional details. The solution from the first phase is
used as the initial motion M0 (t) for the second phase. This
initial guess makes the optimization problem for the second
phase much easier to solve.
To solve our optimization problem, we use a sequential
quadratic programming package, SNOPT [GMMS97], and a
modeling language, AMPL [FGK89], that allows the user to
easily formulate linear and nonlinear optimization problems
in mathematical terms and automatically generates code appropriate for various solvers. The fist optimization phase
usually converges within 2 seconds, and the second phase
converges within at most 20 seconds. We declare the optimization as failure, when either the solver returns a failure
or the optimization time exceeds two minutes (in the latter
case, we stop the optimization process). In our experiments,
only 2% of optimizations failed to find a transition (for example, it sometimes failed to find a transition between two
double-support poses that are of different foot seperation).
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

C. Ren & L. Zhao & A. Safonova / Human Motion Synthesis with Optimization-based Graphs
1

1

2

3

4

A1
0 3 ∞∞
∞ 0 ∞∞
∞∞0 3
∞ ∞∞ 0

P1

(a) Potential Transitions

0 0.9 0.9 0.7
0.6 0
0.1
0.1 0.2 0 0.9
0.2 0.1 0.8 0

0

2

3

4

A0
∞∞
∞ ∞∞
∞∞0 3
∞ ∞∞ 0

0 0.9 0.9 0.7
0.6 0 0.8 0.1
0.1 0.2 0 0.9
0.2 0.1 0.8 0

0

3
0

O ptim izing
P air (2,3)
fails

549

P0

O ptim izing
P air (2,3)
succeeds

1

0

2

3

4

A2

P2

3 7 10

∞ 0 4 7
∞∞ 0 3
∞ ∞∞ 0

(b) First Optimization

0 0.9 0.9 0.7
0.6 0
0.1
0.1 0.2 0 0.9
0.2 0.1 0.8 0

0

(c) Policy Tree

Figure 3: Optimized Algorithm.

3.3. Speeding up the Construction Process
Clearly, the last step of the algorithm, namely generating
new transitions in graph G using optimization, is computationally the most expensive step. There are at least two
reasons why the invocation of optimization should be minimized if possible. First, each optimization takes time. For example, if we have m = 10 motions, and within each motion
the algorithm selects 5 frames, then there are total n = 50
frames. Thus, the number of pairs (or, in other words, elements in A) will be 2450, and if each optimization takes
20 seconds, then the method described in Section 3.1 will
take over 13 hours to run. Perhaps, even more important is
that it will prompt a user to evaluate 2450 generated motion
segments. In this section, we therefore explain how to decide what pairs of frames to perform optimization for and
in which order so as to reach the desired objective (e.g.,
maxi, j (Ai, j ) ≤ T ) with the smallest number of optimizations.
Every time the optimization is invoked, there is a chance
that it fails because either the optimizer itself fails to find the
solution or it produces an unnatural motion which user will
reject. The basic assumption we make is that we can estimate the likelihood of optimizer finding a natural transition
in between any pair of frames i and j. We will use P(i, j)
to represent this probability (and matrix P to represent all of
them). Section 3.4 provides the details on how we compute
these probabilities.
Figure 3 demonstrates our Optimized Algorithm for a very
simple scenario with m = 2 motions and only n = 4 selected
frames. In Figure 3(a) all the dashed lines between selected
frames represent the potential transitions. Each such transition has a corresponding probability (shown next to it) of being generated successfully by optimization. Thus, the group
on the top in Figure 3(b) gives the corresponding matrices
A and P for graph G before any optimization is invoked.
Figure 3(b) also shows that the attempt to generate a transition between frames 2 and 3 using optimization results in
two possible outcomes. The first outcome, shown as bottom
group on the right, corresponds to success. Graph G now has
the transition between these frames, matrix A is re-computed
to reflect the new lengths of shortest paths. The second outcome, shown as bottom group on the left, corresponds to
failure. So G and A remains the same as initially. In both
outcomes, P(2,3) is set to zero in order to prevent future
invocations of the optimizer on the same pair of frames.
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

Thus, the whole construction process of graph G can be
modeled as a Markov Decision Process (MDP) [Put94]. An
MDP can be thought of as a graph in which edges correspond
to some actions, and one or more of these actions (edges)
result in more than one outcome with the associated probability. MDP is a common representation of planning under
uncertainty problems and provide a way to compute plans
that minimize the expected cost of reaching the goal state.
Mathematically, an MDP is a 4-tuple (S,Λ(·),P· (·,·),C(·)),
where S is a set of states, Λ(s) is a set of actions available at
any state s ∈ S, Pa (s,s ) is the probability of action a leading
to state s when executed at state s, C(a) is cost of executing action a. Note, we use a cost-based version of MDP, in
which each action is associated with cost rather than reward.
We also assume that cost is associated with action rather than
state-action tuple.
In our problem, each state s in this MDP corresponds to
a particular matrix A and a particular matrix P. Each action
a corresponds to picking a pair of frames to optimize for.
Thus, for each state, there are n ∗ (n − 1) possible actions.
And for each action that tries to optimize for frames i, j,
there are two outcome states, say s1 and s2 . s1 corresponds
to the optimization being successful, and s2 corresponds to
failed optimization (the optimization solver fails to find a
solution or user rejects the solution). Probability of the first
outcome is given by P(i, j), and the probability of the second
outcome is 1 − P(i, j). In both states, s1 and s2 , P(i, j) is
set to 0. In addition, in state s1 , matrix A is re-computed,
whereas in state s2 it remains the same. The cost of each
action in this MDP is set to 1. The example in Figure 3(b) is
in fact the start of this MDP for our simple example.
Given this MDP, our goal is to find the policy that minimizes the expected number of actions (optimizations) before
we reach any state sgoal at which matrix A satisfies our objective such as maxi, j (Ai, j ) ≤ T or avei, j (Ai, j ) ≤ T , or any
other elementwise norm of A. A policy dictates what action
to execute at any state we may possibly encounter while executing the prescribed actions. Figure 3(c) shows an example
of a policy. In our domain, it is always a binary tree. At its
first level, the policy specifies which constrained optimization to run first. At the second level,the policy specifies what
pair of frames should the optimizer try to connect next if the
first optimization succeeds and what pair of frames should
be chosen if the optimizer fails.

550

C. Ren & L. Zhao & A. Safonova / Human Motion Synthesis with Optimization-based Graphs

Since the size of the resulting MDP is very large, finding
an optimal policy becomes infeasible. A common solution to
this is to settle for a finite-horizon optimal policy. A finitehorizon policy of horizon h considers only at most h actions
into the future. Thus, the policy in Figure 3(c) has horizon
equal to 2 if it is not grown any further.
For our problem, we also use a finite-horizon policy, and
after every optimization execution, we re-compute it using
Dynamic Programming [Put94]. The value of any state slea f
at the leaf of the tree generated by the policy is computed according to max( f (A(slea f )) − T,0), where A(slea f ) is matrix
A associated with the state slea f and function f is the objective function we use such as max or ave. For example, if
the horizon is equal to one, then this computation of optimal
policy reduces to picking a single pair of frames i∗ , j∗ . This
pair is such that optimization for it minimizes the expected
value of function f (A). Mathematically:
{i∗ , j∗ } = min{1 + P(i, j) · max( f (A(ssuccess)) − T,0)
i, j

+(1 − P(i, j)) · max( f (A(scurrent)) − T,0)}
where matrix A(ssuccess) corresponds to distances in between
pairs of frames assuming frames i and j are connected successfully, and matrix A(scurrent ) corresponds to the distances
if the optimization fails which are the same distances as before the optimization is run. In computing A(ssuccess) we
compute the length of the motion generated by the optimization using the technique presented in Section 3.2.
Theoretically, executing the policy requires the user to
verify the naturalness of the generated motions after every
optimization. In reality, however, it is much simpler for the
user to do this in batches. Thus, we run the construction
process fully autonomously for some period of time (e.g.,
20 minutes) and after every optimization re-compute A as if
the generated motion is natural. Afterwards, all the generated motions are presented to the user for evaluation. Based
on the user’s selection of the acceptable motions, we recompute matrix A and continue the process. We stop as soon
as matrix A satisfies our objective, that is, f (A) ≤ T .
3.4. Probability Estimation
Our graph construction algorithm relies on an estimation of
likelihood P(i, j) of optimizer finding a natural transition
between any pair of frames i and j. The higher the probability P(i, j), the more likely the optimizer will generate a
natural transition. We pre-compute probability P(i, j) for all
selected pairs of frames as a first step of the graph construction.
To estimate the probability we first generate a transition
using simple posture interpolation. We found that discontinuities in the trajectories of the center of mass (COM) and
end-effectors in such transition correlate well with the probability that optimization succeeds. The lower the discontinuity the more likely that optimization produces a natural

transition (Section 4 provides more detailed analysis of effectiveness of our probability computation). To compute interpolated transition we interpolate start frame i and target
frame j with weight equal to 0.5 to get a center frame C (we
use slerp operation between joint quaternions for interpolation). We only interpolate joint angles. Root position and orientation for frames C and j are computed by aligning contact
foot position and orientation for frames C and j with contact
foot position and orientation for frame i. This ensures that
frames i , C, j all have the same contact. We can then compute position of the center of mass (COM) and positions of
end-effectors for all 3 frames: i , C, j. In this paper we used
head, hands, and feet as end-effectors. Let posi,k, pos j,k ,
posC,k represent the position of kth end-effector in frames
i, j, C, respectively. The probability of transition from frame
i to frame j is then given by:
m
1 + VC j,k · V j,k
1 + VCi,k · Vi,k
) · ( ∑ wed,k ·
) (5)
2
2
k=1
k=1
posC,k − posi,k
pos j,k − posC,k
VCi,k =
; VC j,k =
(6)
T /2
T /2
m

p = ( ∑ wst,k ·

where, T is the duration between frame i and j, m is
the number of trajectories (including COM trajectory and
all end-effectors) and Vi,k ,V j,k are calculated by averaging
the kth end-effector velocities in the original 6 neighbor
postures. wst,k and wed,k are the weights for different endeffectors. Usually feet have larger weights since feet discontinuities in human motion are more obvious than others. Also, in order to produce abrupt yet natural transitions,
we usually make wst,k smaller than wed,k. For example, consider a situation in which a character is stretching an arm to
pick something, but before he picks it, the character is commanded to stop picking and walk away. This abrupt behavior
change happens often in computer games. Smaller wst,k allows for such transitions (Figure 9(c)).
We show two estimated probabilities in Figure 4. Note
that frame i(walking posture) and frame j(jumping posture)
do not have to be very similar for probability of transition
to be high. As long as the interpolated motion has close velocity trends with the original motions, the probability score
will have a higher value. If the probability score is above
an assigned threshold, the corresponding posture pair(i, j)
will be a candidate pair for generating transitions. Different
behaviors could have different threshold.
4. Experimental Results
In this section we analyze the performance of our algorithm. We used a motion database consisting of various behaviors such as walking, turning, sitting, picking, jumping,
ducking, throwing, standing and transitions in between them.
The database contained 14 motions with 1390 frames, which
were sampled at 30 frames per second. It was a subset from
the publicly available CMU mocap database [CMU]. Even
though our dataset contained captured transitions in between
different behaviors, these transitions were sparse and happened mostly at the ends of behaviors. For example, if the
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

551

C. Ren & L. Zhao & A. Safonova / Human Motion Synthesis with Optimization-based Graphs
100%

Acceptance RaƟo

Percentage of pairs

40%
30%
20%
10%
0%
0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0

Probability

(a) High Probability=0.886

(b) Low Probability=0.001

Figure 4: Probability estimation between a walking posture and a
jumping posture. The three red frames are the start frame, interpolated frame and target frame respectively. (a) shows a high probability estimation with relatively consistent velocities, indicated by the
smooth center of mass and right foot trajectories. (b) shows a low
probability estimation, indicated by the strong discontinuity in the
trajectories. The discontinuities are highlighted by the red circles.

character entered a sitting motion, then there was no way for
it to rapidly transition back to walking (if the user changed
his/her mind). Also, most of the transitions in between different behaviors required the character to make few walking steps. For example, it was impossible to transition from
ducking to throwing behavior directly, the character needed
to take few walking steps in between. This problem happened because it is practically impossible to capture all possible transitions in between different behaviors. We used our
algorithm to create an optimization-based graph based on
this dataset, and generate more direct yet natural transitions.
Probability Estimation: In order to test the effectiveness
of our probability computation, we performed a user study
on 10 subjects. First, 700 pairs of frames were chosen randomly and motion segment between each pair was generated
using optimization as described in Section 3.2. Each generated motion was then concatenated with motion segments
from mocap database. That is, for pair (i, j), motion segment
right before frame i was added at the beginning of generated
transition and motion segment right after frame j was added
at the end of the transition. This allowed the user to evaluate
the generated transition as part of a longer motion. Finally
these concatenated motions were presented to each subject.
Without knowing any probability scores, each subject was
asked to rank each motion as either acceptable or unacceptable. Acceptable meant the motion looked natural to the user
and he/she would be fine with having this motion as part of
his/her motion controller.
We discretized the probability range [0, 1) into 10 even
intervals, and computed for each interval the ratio of motions users marked as acceptable over the number of motions in this interval. We call this ratio - user acceptance ratio. For example, we had 96 motion segments in range [0.9,
1), and, on average, out of these 96 segments, the subjects
marked 92 segments as acceptable. Thus, the acceptance ratio was 93/96=95.83%. From the Figure 5(b), we can see
that there is a correlation between our probability estimation
and the user acceptance ratio. The higher the probability, the
larger the acceptance ratio. Thus, our probability estimates
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

80%
60%
40%
20%
0%
0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0

Probability

(a) Distribution of Probabilities
(b) User Study
Figure 5: Effectiveness of Probability Estimation

are good indicators of the likelihood of acceptance of the
generated motions. In our work, we usually chose the probability threshold 0.9 for generating transitions between walking frames, and threshold 0.5 for all other pairs of frames.
Figure 5(a) shows that our probability estimates are well distributed. It shows the percentage of pairs of frames that fall
into different probability categories.
Graph Construction: We tested our algorithm by constructing an optimization-based graph for use in interactive
control applications. As such, the graph had a requirement of
fast response to user commands. In these experiments, the
goal of the graph construction process was set to compute
a graph with an average transition length between selected
frames less than T frames. Our construction process tried to
achieve this goal while minimizing the number of optimizations invoked. First our algorithm selected 105 frames from
motion database. Thus, the size of the matrix A was 105 by
105. The frames were picked by sampling walking motions
uniformly with interval of 20 frames and sampling all other
motions with interval of 10 frames.
Since our graph construction process allows a user to classify transition as acceptable or not, we performed a user
study to determine the amount of effort required by the user.
Ten subjects participated in the study. To familiarize subjects with our system, we first explained to them the purpose of the user assessment and then let them practice classifying motions. We then asked each subject to create an
optimization-based graph using our system. Figure 6 shows
the workflow that users followed. First, the process of computing an optimization policy interleaved with the optimizations themselves ran for about 30 minutes with no user involvement. On average 100 optimized transitions were computed during a 30 minutes window. Users then had an opportunity to get back to the computer and label the generated transitions as acceptable or not. On average each subject
used 5.5 minutes in total to label approximately 100 transitions. Therefore, on average it took the users 3.3 seconds to
label each transition. Subtracting 2 seconds used for displaying the motion, the decision time for each transition took
only 1.3 seconds. After finishing classifying the generated
transitions, the user could then start the policy computation
and optimization process again. This process was repeated
until the graph satisfied the required objectives or there was
no more improvement possible.

552

C. Ren & L. Zhao & A. Safonova / Human Motion Synthesis with Optimization-based Graphs

Figure 6: User Work Flow

Table 1 shows a more detailed analysis of our graph construction process. For different goals(first column) it shows
an average number of optimizations marked as acceptable
by users (second column), the number of optimizations invoked (third column), the time spent by the user(fourth column), and the total construction time required (fifth column). Note, that compared to the original number of pairs
in Matrix A (105*104=10920), optimization was invoked for
only a small portion or pairs (131 to 369). This significantly
sped up the graph construction process in addition to significantly decreasing required user time. According to our experiments, we could achieve fast response to user commands
from our graph when an average transition length T was set
to an empirical value 50 frames. For T = 50, we had 303
transitions marked as acceptable by the user. These transitions were then added to our original graph (without adding
any new nodes to the graph). The final graph therefore contained 1390 nodes and 1792 transitions.
average transition
length limit (T)
60
55
50
48

# of accepted
optimizations
131
172
303
369

# of invoked
optimizations
151
202
343
415

user time
(min)
7
8.5
15
20

construction
time(min)
60.5
64
94
111

Table 1: Graph Construction Statistics.

Optimization vs Interpolation: We used optimization to
compute transitions because optimization can produce complex realistic-looking and physically correct motions. One
popular alternative to optimization for generating transitions
is motion blending. Two methods for motion blending exist: transition blending (blending between two motion windows) and posture blending (blending between two postures). Transition blending produces natural looking motion
only if two blended motion windows are similar enough. It
fails in connecting poses in two dissimilar segments. For example, it cannot be used to blend a sitting down segment
with a walking segment(Figure 7(c-d)). Posture blending can
be used to blend any two poses. However, it can not guarantee that there will be no discontinuities in velocity (Figure 7(b)). This guarantee can be easily achieved with optimization by adding velocity continuity constraints into optimization process(Figure 7(a)). Moreover, posture blending
might generate physically incorrect transitions. For example, when generating a transition from sitting at the bottom
to walking, posture blending produces an obviously incorrect motion: the center mass is outside of the support polygon(Figure 7(d)). In contrast, our optimization process generates natural, physically realistic motions(Figure 7(c)).
Application to Interactive Control: The accompanying
movie shows the results of using our optimization-based
graph in an interactive control context. The user controls

(a) Optimized Motion

(b) Interpolated Motion

(c) Optimized Motion

(d) Interpolated Motion

Figure 7: Comparison of interpolated and optimized transitions.
Generated postures are shown in red. Original motion captured postures are shown in blue. Blue curves are right hand trajectories and
red ones are for the center of mass. (a) shows that our optimization
preserves the velocity continuity during a transition from throwing
to walking. In contrast, (b) shows the motion discontinuity (highlighted by the red circle) using interpolation. (c) shows that our optimization preserves correct physics during a transition from sitting
to walking, while (d) shows a physically implausible interpolation,
where the center of mass is out of the support polygon.

the orientation and the behavior of the character. We allowed 7 types of behavior and discretized ordination into
720 intervals (0.5 degrees per interval). We used value iteration, a common technique used in interactive control applications [LL04, MP07, TLP07, ZS08], to learn a good control policy. The policy table took 28MB to store. Note, that
since we didn’t add new nodes to the initial graph (only
transitions), the policy table size is the same as that of a
basic motion graph. The control policy learned from our
optimization-based graph allows the character to switch between different behaviors abruptly yet naturally in response
to user inputs. Many of these transitions between the user
specified behaviors were not initially present. For example,
our optimization-based graph allows direct transitions from
picking to ducking to throwing behaviors (Figure 8(a)).
In the movie, we also show the comparison of the performance of our optimization-based graph with the performance of motion-graph based approaches [AF02, LCR∗ 02,
AFO03, LP02]. We constructed motion graph at three different similarity thresholds: low threshold to allow for only
good quality transitions, high threshold to allow for good
connectivity between behaviors, and a threshold in the middle between high and low to provide a compromise between
quality and connectivity. The motion graph constructed at
low threshold generated smooth motions but provided very
bad responsiveness. For example, it was often impossible
to transition into ducking behavior. The motion graph constructed at middle threshold allowed transitions into ducking and throwing behaviors, but did not contain direct transitions (see Figure 8(b)). The motion graph constructed at
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

C. Ren & L. Zhao & A. Safonova / Human Motion Synthesis with Optimization-based Graphs
Pick

Duck

Throw

(a) Optimization-based Graph

Pick Walk Duck Walk Throw

(b) Motion Graph

Figure 8: Transition comparison of our optimization-based graph
(a) and a motion graph (b). The optimization-based graph generates
responsive transitions according to a user command of pick, duck
and then throw. A motion graph inserts walking motions because it
lacks direct transitions between these behaviors.

high threshold allowed these direct transitions but the motions had noticeable discontinuities (even with blending enabled). In contrast, our graph had a large number of direct
yet natural transitions(See Figure 8(a)).
An important benefit of novel transitions generated by optimization is that they allow the user to change the current
behavior abruptly while still maintaining smoothness. The
example in Figure 9(a-b) illustrates this.
5. Conclusions and Discussion
In this paper, we have presented an approach to motion
synthesis based on combining continuous constrained optimization useful for generating short motions with graphbased motion synthesis useful for generating long motions.
We have deliberately chosen a semi-autonomous way of
constructing the optimization-based graph - the core data
structure used in our approach - in order to provide consistency in its quality. While not fully autonomous, the user
is only asked to classify motions as acceptable or not and
our method explicitly reasons about the minimization of user
involvement. Our experimental results show that user involvement is indeed quite limited and motion synthesis with
optimization-based graphs can synthesize long motions with
non-trivial realistic-looking transitions that allow the character to switch behaviors abruptly while retaining naturalness.
In our experiments, we have compared our approach
to motion graphs. In the future, we would like to compare it against other graphs such as well-connected motion
graphs [ZS08] and fat graphs [SO06]. However, because
these graphs use interpolation of existing motion segments,
they lack the power of constrained optimization as we have
shown in the optimization vs interpolation experiment. An
interesting future work would be to merge interpolationbased motion graph construction techniques with our work.
During policy construction step in Section 3.3 we minimized “average” transition time between selected frames.
Other objectives might be used as a better heuristic or as an
additional heuristic. For example, instead of minimizing average transition time between frames, minimize the average
direct transition time between behaviors (without passing
through a third behavior) could enable the resulting graph
to transition between all behaviors faster. More interestingly,
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

553

if we add objectives that include environmental constraints,
we hope to construct a graph which would allow character
to interact with an environment filled with objects. As for
the termination of the construction process, we used an empirical threshold of 50 frames. The stopping criteria here is
actually a tradeoff between graph connectivity and both, final graph size and construction time. An automatic stopping
criteria could be explored in the future.
One shortcoming of our approach is the limited scalability to large motion databases. Currently the bottleneck
is the computation of the lengths of the shortest paths between all pairs of selected frames (matrix A) as discussed
in Section 3.1. This computation is invoked O(n2) times for
each new transition added to the graph, where n is the number of selected frames. We used Floyd-Warshall method to
compute these paths (which has complexity O(n3)). For the
database we used in this paper, this computation takes less
than 3.5 seconds. If the database size is doubled it takes 112
seconds. We found, as the database grows, this update takes
long time and dominates transition optimization time (which
is less that 20 sec). Not all entries in matrix A need to be
updated, however. A smarter update, which will only update necessary entries (such as [Dem04]), should be investigated to improve performance. Also, as the graph grows the
number of required optimizations and the size of the MDP
tree grow. To scale to much larger databases we need to
combine our approach with approach of Zhao and his colleagues [ZNKS09]. Given a particular application, we could
run their algorithm to select a “good” set of motions from
the large database as a first step. Then, our algorithm can be
used as a second step to add additional transitions.
References
[AF02] A RIKAN O., F ORSYTH D. A.: Interactive motion generation from examples. ACM Trans. on Graphics 21, 3 (2002),
483–490.
[AFO03] A RIKAN O., F ORSYTH D. A., O’B RIEN J. F.: Motion
synthesis from annotations. ACM Trans. Graph. 22, 3 (2003),
402–408.
[CMU]

Motion capture database at carnegie mellon university.

[Coh92] C OHEN M. F.: Interactive spacetime control for animation. In Computer Graphics (Proc. of SIGGRAPH 92) (July
1992), vol. 26, pp. 293–302.
[Dem04] D EMETRESCU C.: Experimental analysis of dynamic
all pairs shortest path algorithms. In In Proceedings of the fifteenth annual ACM-SIAM symposium on Discrete algorithms
(2004), pp. 369–378.
[FGK89] F OURER R., G AY D. M., K ERNIGHAN B. W.: AMPL:
A Mathematical Programming Language. Tech. rep., MANAGEMENT SCIENCE, 1989.
[FP03] FANG A. C., P OLLARD N. S.: Efficient synthesis of
physically valid human motion. ACM Trans. on Graphics 22,
3 (2003), 417–426.
[Gle97] G LEICHER M.: Motion editing with spacetime constraints. In ACM Symposium on Interactive 3D Graphics (Providence, RI, Apr. 1997), pp. 139–148.

554

C. Ren & L. Zhao & A. Safonova / Human Motion Synthesis with Optimization-based Graphs

(a) Optimization-based Graph

(b) Motion Graph

(c) Optimization-based Graph

(d) Motion Graph

Figure 9: This figure illustrates the power of optimization based graph. It allows the user to stop current behavior abruptly and to transition to
another behavior. Red poses represent behavior changing points generated by optimization. Frames originally present in the motion capture data
are shown in blue. Trajectories for center of mass and right hand are shown as curves. (a) Shows a motion generated with optimization-based
graph that corresponds to user commanding the character to sit down, and then, before it sits fully down, commanding the character to walk
again (e.g., user changes his/her mind about sitting down). Our graph allows to stop sitting down behavior immediately and transition into
walking behavior, all very naturally. (b) shows a motion generated for the same commands but using motion graph - because of the lack of
abrupt transitions, the character sits down fully before getting up. (c-d) shows the similar situation with stopping picking command.
[GMMS97] G ILL P. E., M URRAY W., M ICHAEL , S AUNDERS
M. A.: Snopt: An sqp algorithm for large-scale constrained optimization. SIAM Journal on Optimization 12 (1997), 979–1006.

[PSKS04] PARK S. I., S HIN H. J., K IM T. H., S HIN S. Y.: Online motion blending for real-time locomotion generation. Computer Animation and Virtual Worlds 15, 3-4 (2004).

[HG07] H ECK R., G LEICHER M.: Parametric motion graphs. In
ACM Symposium on Interactive 3D Graphics (2007), pp. 129–
136.

[PSS02] PARK S. I., S HIN H. J., S HIN S. Y.: On-line locomotion generation based on motion blending. In ACM SIGGRAPH/Eurographics Symp. on Comp. Animation (July 2002).

[IAF07] I KEMOTO L., A RIKAN O., F ORSYTH D.: Quick transitions with cached multi-way blends. In ACM Symposium on
Interactive 3D Graphics (2007), pp. 145–151.

[Put94] P UTERMAN M. L.: Markov Decision Processes: Discrete
Stochastic Dynamic Programming. John Wiley and Sons, New
York, NY, USA, 1994.

[KGP02] KOVAR L., G LEICHER M., P IGHIN F.: Motion graphs.
ACM Trans. Graph. 21, 3 (2002), 473–482.

[RCB98] ROSE C. F., C OHEN M. F., B ODENHEIMER B.: Verbs
and adverbs: Multidimensional motion interpolation. IEEE Computer Graphics and Applications September/October (1998).

[KS05] K WON T., S HIN S. Y.: Motion modeling for on-line locomotion synthesis. In ACM SIGGRAPH/EurographicsSymp. on
Comp. Animation (July 2005), pp. 29–38.

[RGBC96] ROSE C. F., G UENTER B., B ODENHEIMER B., C O HEN M. F.: Efficient generation of motion transitions using
spacetime constraints. In Proc. of SIGGRAPH 96 (Aug. 1996).

[LCR∗ 02] L EE J., C HAI J., R EITSMA P. S. A., H ODGINS J. K.,
P OLLARD N. S.: Interactive control of avatars animated with
human motion data. ACM Trans. on Graphics 21, 3 (2002), 491–
500.

[SH07] S AFONOVA A., H ODGINS J. K.: Construction and optimal search of interpolated motion graphs. In ACM Trans. Graph.
(2007), p. 106.

[LGC94] L IU Z., G ORTLER S. J., C OHEN M. F.: Hierarchical spacetime control. In Proc. of SIGGRAPH 94 (July 1994),
pp. 35–42.

[SHP04] S AFONOVA A., H ODGINS J. K., P OLLARD N. S.: Synthesizing physically realistic human motion in low-dimensional,
behavior-specific spaces. ACM Trans. on Graphics 23, 3 (2004).

[LK05] L AU M., K UFFNER J. J.: Behavior planning for character
animation. In 2005 ACM SIGGRAPH / Eurographics Symposium
on Computer Animation (Aug. 2005), pp. 271–280.

[SO06] S HIN H. J., O H H. S.: Fat graphs: Constructing an
interactive character with continuous controls. In ACM SIGGRAPH/Eurographics Symp. on Comp. Animation (Sept. 2006),
pp. 291–298.

[LL04] L EE J., L EE K. H.: Precomputing avatar behavior from
human motion data. In ACM SIGGRAPH/Eurographics Symp.
on Comp. Animation (2004), pp. 79–87.
[LMFP08] L I L., M C C ANN J., FALOUTSOS C., P OLLARD N.:
Laziness is a virtue: Motion stitching using effort minimization.
In Short Papers Proceedings of EUROGRAPHICS (2008).
[LP02] L IU C. K., P OPOVI C´ Z.: Synthesis of complex dynamic
character motion from simple animations. ACM Trans. on Graphics 21, 3 (2002), 408–416.
[Men99] M ENACHE A.: Understanding Motion Capture for
Computer Animation and Video Games. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1999.
[MMC01] M ARK M IZUGUCHI J. B., C ALVERT T.: Data driven
motion transitions for interactive games. In Eurographics 2001
Short Presentations (2001).
[MP07] M C C ANN J., P OLLARD N. S.: Responsive characters
from motion fragments. ACM Transactions on Graphics (SIGGRAPH 2007) 26, 3 (Aug. 2007).
[NM93] N GO J. T., M ARKS J.: Spacetime constraints revisited. In Computer Graphics (SIGGRAPH 93 Proceedings) (Aug.
1993), Kajiya J. T., (Ed.), vol. 27, pp. 343–350.

[TLP07] T REUILLE A., L EE Y., P OPOVI C´ Z.: Near-optimal
character animation with continuous control. ACM Trans. Graph.
(2007), 7.
[WB08] WANG J., B ODENHEIMER B.: Synthesis and evaluation
of linear motion transitions. ACM Trans. Graph. 27, 1 (2008),
1–15.
[WK88] W ITKIN A., K ASS M.: Spacetime constraints. Computer Graphics (Proceedings of SIGGRAPH 88) 22, 4 (1988).
[WP95] W ITKIN A., P OPOVI C´ Z.: Motion warping. In SIGGRAPH 95 Proceedings (Aug. 1995), Annual Conference Series,
ACM SIGGRAPH, Addison Wesley, pp. 105–108.
[ZNKS09] Z HAO L., N ORMOYLE A., K HANNA S., S AFONOVA
A.: Automatic construction of a minimum size motion graph. In
Proceedings of the 2009 ACM SIGGRAPH/Eurographics Symposium on Computer Animation (2009), pp. 27–35.
[ZS08] Z HAO L., S AFONOVA A.: Achieving good connectivity in motion graphs. In Proceedings of the 2008 ACM
SIGGRAPH/Eurographics Symposium on Computer Animation
(2008), pp. 127–136.

c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.


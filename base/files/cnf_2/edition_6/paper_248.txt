DOI: 10.1111/j.1467-8659.2010.01825.x

COMPUTER GRAPHICS

forum

Volume 29 (2010), number 8 pp. 2569–2578

Efficient and Quality Contouring Algorithms on the GPU
L. Schmitz, L. F. Scheidegger, D. K. Osmari, C. A. Dietrich and J. L. D. Comba
Instituto de Inform´atica - UFRGS, Brazil
{laschmitz, lfscheidegger, dkosmari, cadietrich, comba}@inf.ufrgs.br

Abstract
Interactive isosurface extraction has recently become possible through successful efforts to map algorithms such as
Marching Cubes (MC) and Marching Tetrahedra (MT) to modern Graphics Processing Unit (GPU) architectures.
Other isosurfacing algorithms, however, are not so easily portable to GPUs, either because they involve more
complex operations or because they are not based on discrete case tables, as is the case with most marching
techniques. In this paper, we revisit the Dual Contouring (MC) and Macet isosurface extraction algorithms and
propose, respectively: (i) a novel, efficient and parallelizable version of Dual Contouring and (ii) a set of GPU
modules which extend the original Marching Cubes algorithm. Similar to marching methods, our novel technique
is based on a case table, which allows for a very efficient GPU implementation. In addition, we enumerate and
evaluate several alternatives to implement efficient contouring algorithms on the GPU, and present trade-offs
among all approaches. Finally, we validate the efficiency and quality of the tessellations produced in all these
alternatives.
Keywords: isosurfacing, marching cubes, GPU
ACM CCS: I.3.3. [Computer Graphics]: Picture/Image Generation—Line and curve generation; I.3.5. [Computer
Graphics]: Computational Geometry and Object Modeling—Geometric algorithms, languages, and systems

1. Introduction
Isosurface extraction is a scientific computing problem that
has well-established algorithms and techniques widely available in the literature. Given a scalar field f : R3 → R and
an isovalue f0 , the goal of isosurface extraction is to approximate the surface S defined by the set of all points s
for which f (s) = f0 , where f is usually obtained through
three-dimensional (3D) scanners or simulations. However,
constant improvements in scanner technology and simulation techniques generate increasingly larger data sets that
bring existing isosurfacing algorithms to their practical limits. Moreover, the growing need for faster and more accurate
methods motivates constant improvements on existing algorithms or even the development of entirely new techniques.
Finally, the ability to interactively modify the isovalue of interest and observe the computed results in real time is very
desirable, allowing users to better understand their data during visualization.
c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics
Association and Blackwell Publishing Ltd. Published by
Blackwell Publishing, 9600 Garsington Road, Oxford OX4
2DQ, UK and 350 Main Street, Malden, MA 02148, USA.

The intrinsic parallel nature of most common isosurfacing
algorithms, such as Marching Cubes [LC87], makes them
ideal candidates for highly parallelizable implementations.
Although recent CPUs offer an increasingly larger number
of cores, the most promising approach for massively parallelizable algorithms today lies in exploiting modern GPU
architectures. Throughout the evolution of GPUs, many approaches for isosurface extraction were described in the literature. The introduction of GPU programmability via Vertex
and Fragment Shaders drove many advances in this field, but
the recent introduction of Geometry Shaders made the first
complete implementations of the Marching Cubes pipeline
possible entirely on the GPU [Tar06, Cra07, Gei07]. Experimental results show that GPU-based Marching Cubes
implementations offer a clear performance advantage compared to traditional CPU code. However, several performance
issues regarding the use of Geometry Shaders suggest that
current state-of-the-art performance can still be further improved. In this paper, we summarize several alternatives for

2569

2570

L. Schmitz et al. / Efficient and Quality Contouring Algorithms on the GPU

Figure 1: Three different snapshots showing different isosurfaces of the Stent data set. Interactive application allows the user
to change the isovalue incrementally and inspect how the isosurface changes.
GPU-based isosurface extraction algorithms and propose
suitable modifications which allow more advanced algorithms to be efficiently implemented on GPUs.
Popular methods for improving the performance of
Marching Cubes typically include the use of acceleration
structures. For instance, the Span Space [SHLJ96] data
structure can be combined with a Geometry Shader-based
implementation of Marching Cubes to drastically improve
performance. Another example is the use of HistoPyramids
(short for Histogram Pyramids) [DZTS08], structures that execute multiple Fragment Shader passes to efficiently identify
the set of active cells (cells that can possibly contain the desired isosurface) in a volume. Experimental results show that
the HistoPyramids technique performs better than Geometry
Shader implementations. However, their main limitation is
that the entire volume must fit inside GPU memory.
More refined contouring algorithms can also be mapped
to the GPU. For instance, the Macet algorithm [DSS∗ 09,
DSC∗ 08, DSC∗ 09] is a modification of Marching Cubes that
produces meshes with improved triangle quality. The mapping of Macet to the GPU is similar to the mapping of Marching Cubes, with modifications that implement the edge transformations described in Macet. The Dual Contouring method
[JLSW02] is an adaptive meshing technique better suited to
represent sharp edges on the isosurface, and operates on the
dual grid of the volume, thus generating quadrilaterals. However, mapping the Dual Contouring algorithm to the GPU is
not entirely straightforward. Because it uses an Octree data
structure to generate adaptively refined meshes, it requires a
more elaborate cell neighbouring analysis to stitch individual isosurface elements together. Also, vertices are placed
on the isosurface by minimizing a Quadric Error Function
(QEF). This can be memory expensive, because it requires
10 floating point numbers per QEF. Moreover, because this
minimization requires a QR or SVD decomposition of the
Error Function, its implementation is not as simple as the
interpolation strategy used by Marching Cubes.

In this paper, we propose a modified version of Dual Contouring that can be directly mapped to the GPU. We describe
two modifications of the original algorithm: first, we use
a regular grid instead of an indexed Octree. Secondly, we
position the vertices of the isosurface using a particle-based
minimizer which is simpler to compute than the original QEF
minimization approach. We believe that the introduction of
a regular grid is an acceptable trade-off, because the original adaptive Dual Contouring algorithm must also build a
complete Octree (equivalent to a regular grid), only to perform culling on its branches in a subsequent step. By using
a regular grid, our proposed algorithm can be easily implemented thorough a discrete case table similar to Marching
Cubes.
In order to evaluate performance results, we revisit existing GPU Marching Cubes implementations, and compare them against our GPU implementation of Macet and
our table-driven Dual Contouring algorithm, also implemented on the GPU. For each technique, we evaluate different implementations using Geometry Shaders as well
as the Span Space and HistoPyramids acceleration structures. We obtain results that are up to 1500 times faster
with our Macet and Dual Contouring implementations when
compared to Marching Cubes implementations, thus allowing interactive exploration of isosurfaces. Figure 1 illustrates the quality aspect of the meshes produced by our
GPU implementations of Macet and Dual Contouring as
compared to the reference Marching Cubes implementation.
In summary, our main contributions in this paper are: a
very fast GPU-based implementation of high-quality isosurface extraction algorithms, a modified formulation of Dual
Contouring using a discrete case table and particle-based
minimizer functions and a GPU implementation of the Macet
algorithm. We also provide validation for several combinations of acceleration structures, including Span Spaces and
HistoPyramids.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

L. Schmitz et al. / Efficient and Quality Contouring Algorithms on the GPU

2. Related Work
Isosurface extraction is a very active topic in the visualization and scientific computing community. Since the
pioneering work of Udupa [HU82], several significantly different approaches for meshing implicit surfaces were proposed. Our work advances methods based on domain subdivision, whose underlying approach leads to parallelizable,
high performance algorithms. These methods follow the divide and conquer approach, where the domain of f is subdivided into a set of cells that are processed independently.
These methods approximate the implicit surface inside each
cell by a set of triangles that, when combined, form a C 0 continuous manifold. The Marching Cubes [LC87] algorithm is
a well known example of these techniques. Marching Cubes
extracts the isosurface of interest through two fundamental
steps: active cell (cells that intersect the isosurface) detection and isosurface generation. There exists a wide variety of
previous work focused on improving the efficiency of active
cell detection [SHLJ96, BPS96, DZTS08], as well as methods to improve the quality and correctness of the triangles
generated during tessellation [THAG03, LB03, Nie03].
Early approaches to improve triangle quality involve
pseudo-physical smoothing algorithms such as SurfaceNets
[Gib98]. The SurfaceNets technique is based on Cuberille
sampling, which places vertices at the centre of each cell
and connects them to vertices in adjacent active cells. The
resulting mesh is dual to the Marching Cubes tessellation
(in the absence of self-intersections) and does not have as
many badly-shaped triangles. In the Kizamu system [PF01],
a method based on SurfaceNets is presented for tessellating
adaptive distance fields. In particular, they propose a tabledriven algorithm that shares some similarities to the one described in this paper. Triangle quality can be further improved
by a constrained Laplacian Smoothing pass over the vertices.
The Dual Contouring [JLSW02] algorithm combines Cuberille sampling with the sharp feature-sensitive approach of
Extended Marching Cubes [KBSS01], generating an accurate, high-quality triangulation. Instead of placing vertices
at cell centres, Dual Contouring finds sharp features in the
isosurface and places vertices accordingly, thus improving
sampling accuracy without sacrificing efficiency. The Macet
[DSC∗ 09] algorithm uses the notion of edge transformations
and edge groups to place Marching Cubes edges on more
convenient positions and create a modified case table, respectively. These modifications generate much better quality
triangles while requiring only minor modifications to the
original Marching Cubes code.
Cell detection performance, on the other hand, is typically
improved by adding a pre-processing step to the tessellation
pipeline. The Span Space [SHLJ96] structure maps each cell
i in the domain to a point (mini , maxi ) ∈ R2 , where mini
and maxi are the minimum and maximum values of f in
i, respectively. Given an isovalue f0 , the set of active cells
corresponds to all points where mini < f0 and maxi > f0 .

2571

These constraints define a rectangular subregion of the Span
Space, against which cells can be trivially culled using a
regular grid or kd-tree. GPU-based tessellation techniques
also exist where the cost of cell detection is amortized by
assigning each cell to a separate processor.
Early programmable GPUs allowed developers to customize the vertex and fragment shading pipeline stages, but
lacked the ability to generate triangles directly inside the
GPU. The Marching Tetrahedra algorithm, described by Pascucci [Pas04], is based on a tetrahedral decomposition of
the volume and performs a significant part of its extraction
pipeline in the graphics processor. It dispatches a quadrilateral to the GPU for every tetrahedron in the volume (quads
contain two triangles, which account for the maximum number of primitives possible in a tetrahedral cell). The algorithm
then collapses two of the quad’s vertices into one for cells
that generate only one triangle, or the entire quad into a single point for empty cells. In the case of a regular grid, each
cell must be subdivided into five or six tetrahedra, resulting
in up to 24 points being sent to the GPU per voxel. Reck et.
al [RDG∗ 04] use Span Spaces to reduce the amount of geometry sent to the GPU, whereas Klein [KSE04] uses vertex
arrays to shift computations to the faster Fragment Processor. Kipfer [KW05] further improves this implementation by
allowing different tetrahedra to share vertices. All of these
approaches, however, use a tetrahedral decomposition of the
domain, which generates a higher triangle count than the traditional Marching Cubes algorithm, and presents accuracy
problems [Sno06].
The Marching Cubes implementations described by Goetz
[GJD05] and Johansson [JC06] determine the number of
primitives generated by each voxel on the CPU and cull
empty cells using Span Spaces. Thus, too much work is
allocated to the CPU, resulting in a strict bottleneck. Interactive isosurface extraction algorithms have only recently been
made practical with the introduction of Geometry Shading
[Bly06] in modern graphics hardware.
The Geometry Shader allows developers to customize the
tessellation stage of the graphics pipeline by allowing shader
programs to explicitly create and delete primitives entirely
on the GPU. Thus, it renders most previous workarounds
to modifying tessellation on the GPU obsolete. With this
flexibility, it has become possible to implement Marching
Cubes and other subdivision-based algorithms entirely on
the GPU [TSD07]. Moreover, Dyken et al. [DZTS08] introduce HistoPyramids, a novel acceleration structure that performs compaction and expansion of primitives, minimizing
CPU–GPU communication. HistoPyramids employs multiple rendering passes to generate geometry from a set of
canonical indices (allocated as triangles in GPU memory).
In this paper, we evaluate how the use of Geometry Shaders
and HistoPyramids affects GPU implementations of Macet
and Dual Contouring. The GPU implementation of Macet

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

2572

L. Schmitz et al. / Efficient and Quality Contouring Algorithms on the GPU

Figure 2: Particle-based minimization procedure in 2D. (a) Isosurface (red line) and cut points p0 and p1 . (b) The vector
distances (green lines) from v0 , .. , v3 to the tangent planes at the cut points. (c) Resultant forces f0 , .. , f3 (blue lines) on
v0 , .. , v3 . (d) Initial position (mass point) of the particle inside the cell. (e), (f) Forces f0 , .. , f3 that act on the particle and the
particle trajectory in the cell.
uses edge transformations that improve the quality of the
generated mesh, whereas the GPU-based Dual Contouring algorithm can better approximate the isosurface. Both
implementations fully exploit GPU parallelism and, to the
best of our knowledge, represent the fastest high-quality isosurface extraction algorithms available.

3. Dual Contouring
Dual Contouring is an isosurface tessellation technique that
combines Extended Marching Cubes’ [KBSS01] ability to
represent sharp features with the quadrilateral mesh generation approach of SurfaceNets [Gib98]. With an Octreeaugmented extension of SurfaceNets, Dual Contouring is capable of representing sharp features in the isosurface as well
as varying surface sampling rate according to local isosurface
smoothness.

Although Dual Contouring’s adaptiveness and ability to
identify sharp features are advantages over similar methods,
the computation required to minimize Equation (1) is not entirely straightforward [SW02]. Moreover, a GPU implementation of Dual Contouring would require an efficient way to
generate and share connections and vertices among active
edges, in a way similar to the standard CPU implementation.
Therefore, we propose a new particle-based approach that
can minimize Equation (1) directly on the GPU. As will be
discussed in the next section, each vertex is iteratively moved
to a position minimizing Equation (1), while remaining constrained to the cell. We also propose a table-driven algorithm
to generate geometry entirely on the GPU, which we present
in more detail in Section 3.2.

3.1. Particle-based minimization
The algorithm starts by finding the set of active edges,
that is all edges that intersect the isosurface of interest. Each
active edge generates one vertex in each of its neighbouring
cells. Active cells contain only one vertex and connect this
vertex to all vertices contained in their edges. Finally, vertices are moved to a position that is simultaneously closest to
the isosurface tangent planes at the cell’s cut points. Vertex
positioning takes both cut points’ positions pi and normals
ni into account, similarly to Extended Marching Cubes, although not generating additional vertices inside cells. The
position x of the vertex can be found by minimizing E[x]
using QR or SVD decompositions as follows:
(ni (x − pi ))2 .

E[x] =
i

(1)

The Dual Contouring algorithm uses the Hermite data of
cut points to position a vertex inside its cell. The Hermite
data is used to form a QEF, which is minimized to find the
vertex position. This minimization has several steps which
involve costly matrix manipulations that must be recomputed
after every change of isovalue. As discussed by Schaefer and
Warren [SW02], however, much of the work done by the
minimizer can be reduced by positioning the vertex at the
average position of cut points. This position is called mass
point. We use this claim to derive a much simpler particlebased minimization technique that places vertices at cells’
mass points and iteratively moves them toward the isosurface
of interest. In what follows, we use the terms particles and
vertices interchangeably.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

L. Schmitz et al. / Efficient and Quality Contouring Algorithms on the GPU

2573

Particles are placed initially at the mass point of their cell.
We next calculate the force f that moves the particle from
c¯ to the implicit isosurface (Figure 2). f is given as the
trilinear interpolation of the forces f0 ..f7 located at the grid
points v0 ..v7 . Each fk , in turn, is calculated as the sum of
vector distances to the planes given by all pairs ni (defined
by ∇f (pi )) and pi (isosurface tangent planes at intersection
points)
n

fk =

(vk · Si )ni .

(2)

i=1

In Equation (2), Si stands for the plane defined by ∇f (pi )
and pi , in Hessian normal form. f is interpolated from f0 ..f7
at each iteration, for a fixed number of steps or until the
particle is closer to the isosurface than a given threshold. In
order for this procedure to adapt to local feature size, both
threshold and stepsize are calculated as a fraction of edge
length (for our experiments, we use 2% and 5% of the edge
length, respectively, for threshold and stepsize).
3.2. Table-driven geometry generation
In a complete Octree, we only need to consider three edges
per voxel while marching through the grid, because the remaining edges will be processed by subsequent cells. We use
a stencil composed of four vertices that share a corner vertex and define three edges. Similarly to Marching Cubes, we
use vertex polarity to address cell configurations (Figure 3).
Our complete table is even simpler than the one used by
Marching Tetrahedra, which requires a combination of five
vertices. The complete table used for GPU Dual Contouring
is described in Figure 3.
Our discrete case table contains neighbouring voxel labels
for the vertices of each quad, instead of Marching Cubes’
edge labels. As an example, if the index v3 v2 v1 v0 is 0001 for
voxel (i, j , k), the first vertex is located in the current voxel,
the second in voxel (i, j + 1, k), the third in (i, j + 1, k + 1)
and the fourth vertex is located in (i, j , k + 1) (see Figure 3,
for details).
4. GPU Isosurfacing using HistoPyramids
Triangle generation is one of the most important steps in the
implementation of any contouring algorithm on the GPU. As
we discussed previously, Geometry Shaders can be used to
implement the full Marching Cubes pipeline entirely on the
GPU [Tar06, Cra07, Gei07]. However, current graphics cards
cannot handle efficiently a large amount of computation on
the Geometry Shading pipeline stage, which can easily become a bottleneck in an interactive application. Therefore,
it is necessary to identify and shift as much computation
away from Geometry Shaders as possible. In this section, we
review the HistoPyramids approach to detecting the set of active cells in a volume. This technique drastically reduces the

Figure 3: Table-based Dual Contouring. The isosurface is
evaluated at the four vertices of the stencil (a). For each
code, quads are created using dual vertices v following the
ordering given in (b). (c) First eight entries and corresponding quads. (d) Complete table: input code (orange) followed
by a list of quad vertices (blue, red or magenta).
amount of computation done on Geometry Shaders, because
it allows Marching Cubes to only create geometry directly
inside active cells, at the expense of increased memory usage.
4.1. HistoPyramids Construction
HistoPyramids are hierarchical data structures implemented
on the GPU that are constructed for a given isovalue and
can efficiently determine the set of active cells. For a given

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

2574

L. Schmitz et al. / Efficient and Quality Contouring Algorithms on the GPU

where x = kmin + v(nw), y = x + v(ne), z = y + v(sw)
and w = kmax .

Figure 4: Histogram Pyramid with three levels: the lowest
level (left) contains the number of vertices generated within
each cell. Remaining levels contain the summation of levels
immediately below. At the top, we have the total number of
vertices of the isosurface (56 in this example).
isovalue f0 , the first step in constructing a HistoPyramid involves flattening the input volume by tiling adjacent xy-slices
side-by-side on a two-dimensional (2D) texture [HBSL03].
This assigns a unique (u, v) texture coordinate for each voxel
in the data set. However, instead of keeping f values, this 2D
texture keeps, for each voxel, the number of vertices required
to tessellate the isosurface inside that voxel. This number can
be easily determined by inspecting the Marching Cubes table
for each voxel. Once computed, this 2D texture represents
the lowest level of the final HistoPyramid.
Each subsequent level is constructed by adding the values
of 2 × 2 squares in the level directly below and storing this
result in a new, smaller texture. This process continues recursively until the highest pyramid level contains only one
element corresponding to isosurface’s total number of vertices. Figure 4 illustrates this construction. HistoPyramids
can be computed entirely on the GPU, using a Fragment
Shader that receives as input the original volume stored in a
3D texture and outputs all levels of the pyramid as a set of
2D textures. For convenience and efficiency, HistoPyramids
are often stored as a set of power-of-two textures.
To allow the proper traversal of the HistoPyramid, each
vertex in the isosurface must be associated with a unique
identifier k such that 0 ≤ k < n, and each node in the pyramid must store a range [kmin , kmax ) identifying all vertices
contained in this node’s children. For the top of the pyramid,
this range is defined as [0, n).
To compute the ranges of a node other than the top of
the pyramid, we fetch the vertex counts v(nw), v(ne), v(sw)
and v(se) for each of this node’s children. Observe that, by
construction,
kmax − kmin = v(nw) + v(ne) + v(sw) + v(se).

(3)

This observation allows us to easily compute the range of
each child thus
range(nw) = [0..x),

range(ne) = [x..y),

range(sw) = [y..z),

range(se) = [z..w).

Consider the example in Figure 4. We must compute the
range for a total of 56 vertices. Applying the equations above
to the top of the pyramid, we divide its range into four intervals, one for each child respectively: [0..16) (nw), [16..24)
(ne), [24..40) (sw) and [40..56) (se). Computation then proceeds to each child similarly. Consider the south-west child,
which has range equal to [24..40). This generates the following intervals for its children: [24..28) (nw), [28..28) (ne),
[28..32) (sw) and [32..40) (se). Observe that kmin = kmax for
all empty cells. Once the pyramid base is reached, the process
stops. To locate the cell to which a given vertex belongs, the
algorithm simply traverses this data structure executing a set
of range inclusion tests.

4.2. Histogram pyramid traversal
To locate vertices in their proper cells, the HistoPyramids
algorithm traverses the data structure in a top-down fashion.
Initially, the CPU issues a call to the graphics API to generate all n primitives contained at the top of the pyramid.
To determine the cell to which a vertex belongs, we traverse
the HistoPyramid from top to bottom and descend through a
specific child if and only if the vertex’s identifier is contained
in that child’s range. Once a vertex is located in its final cell,
its position in the isosurface can be easily computed using a
simple case-table. Because this recursive traversal employs
very few computations (only up to four range tests for each
pyramid level), it can be very efficiently implemented directly on the Geometry Shader, automatically culling empty
cells and placing vertices in their correct positions.

5. Discussion and Results
All isosurface extraction algorithms were implemented on
the GPU using GLSL, and performance results were obtained
with an Intel Core 2 Extreme CPU X9650 System equipped
with 8 GB of RAM, and an NVIDIA Quadro FX 5800 Graphics Card with 4 GB of memory. We validate our results using
the following data sets: Backpack, Stent, Bonsai, Engine,
Aneurysm and Stagbeetle. For each isosurfacing algorithm
presented in this paper (e.g., GPU-based Macet and Dual
Contouring), we present performance results and compare
them against the standard Marching Cubes implementation
available in the literature. We report performance results in
Figure 5 for three implementations of each algorithm: using
Geometry Shaders, Span Spaces and Histogram Pyramids.
We report times in milliseconds, which correspond to the
time taken to extract one isosurface. Larger data sets (such as
the Backpack and Aneurysm) impose an additional challenge
to the HistoPyramids implementation, since their dimensions
require a 2D texture whose size exceeds the current graphics card limit of 81922 . To circumvent this, we extend the

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

2575

L. Schmitz et al. / Efficient and Quality Contouring Algorithms on the GPU
Table 1: Volume and isosurface extraction information.

Data sets
Backpack
X×Y ×Z
λ (Isovalue)
No. of Tri. (MC)
No. of Tri. (DC)
Av.Qlty(MC)
Av.Qlty(DC)
Av.Qlty(Macet)
Min.Qlty(MC)
Min.Qlty(DC)
Min.Qlty(Macet)

5123
1000.5
2338896
2342608
0.700012
0.766
0.81369
1.525e-5
1.785e-5
0.44475

Bonsai

Engine

2563
2563
49.5
49.5
671296
599024
673048
598920
0.687802 0.70733
0.75725 0.77274
0.82694 0.81674
1.373e-3 4.232e-4
1.138e-4 6.55e-3
0.47395 0.51064

Stent
5122 × 256
500.5
2823756
2826208
0.71089
0.77473
0.80432
1.709e-5
1.502e-3
0.45069

Note: The isovalues and number of triangles are related to the extraction times in Figure 5. The average and minimum triangle quality is
given by the radii-ratio.

Figure 5: Extraction time (in milliseconds) for one isosurface using the GPU-based Dual Contouring, Macet and
Marching Cubes algorithms.

original HistoPyramids formulation to handle multiple pyramids (only two were necessary in our case).
The performance results confirm our previous conjecture
that using a Span Space acceleration structure is crucial to
improve the performance of the Geometry Shader implementation, which becomes unacceptable when the number
of cells to be processed increases beyond what the Geometry
Shader can handle efficiently. Another important comparison
can be made between the performance of the HistoPyramids
implementation and the Span Space-accelerated Geometry
Shader code. In previous experiments, using older CPU and
GPU hardware, we could observe that the HistoPyramids
code was the fastest approach. With our current hardware,
on the other hand, we observe that both Marching Cubes
and Macet using the Geometry Shader and Span Spaces are
faster than Histogram Pyramids, in particular if the data set
contains many non-active cells. This observation is not valid
for the Dual Contouring implementation, since this latter requires a more involved Geometry Shader, which makes the

Figure 6: Metro results: histogram shows the forward distance between meshes generated by DC and MC.

HistoPyramids solution more efficient. The performance improvement obtained using HistoPyramids, however, comes
with the cost of higher memory consumption. For large data
sets, storing both the entire volume and the HistoPyramid
data structure directly on GPU memory is a challenging task,
which becomes even worse because GPU hardware requires
power-of-two textures that most of the time need a lot of
padding.
In Table 1, we report statistics about the meshes generated
with our techniques, including triangle quality measurements

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

2576

L. Schmitz et al. / Efficient and Quality Contouring Algorithms on the GPU

Figure 7: Isosurface results and radii-ratio colouring, where green denotes well-shaped triangles and blue denotes slivers.
This figure shows the Stent (row 1), Aneurysm (row 2) and Engine (row 3) data sets, tessellated using Marching Cubes (column
1), Dual Contouring (column 2) and Macet (column 3).
using the radii-ratio metric. Interestingly, the bottleneck of
both the HistoPyramids and Span Space data structures is the
number of triangles in the isosurface, and not the size of the
volume. This happens mainly because both data structures
require an individual query or traversal for each triangle. This
does not imply, however, that we were unable to handle large
isosurfaces. Conversely, sparse isosurfaces result in a very
fast tessellation even for large volumes.

Another important quality metric involves estimating how
close the tessellated surface is to the actual isosurface of
interest. Because we are not given the actual isosurface, we
compare the meshes generated by our techniques with the
results obtained using Marching Cubes. For this purpose, we
use the Metro [CRS98] tool, which computes the Hausdorff
distance between surfaces and plots a histogram of forward
distances between meshes. Figure 6 shows the results Metro

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

L. Schmitz et al. / Efficient and Quality Contouring Algorithms on the GPU

reports when comparing Marching Cubes meshes with our
GPU-based implementation of Dual Contouring. Note that
the reported error is within a very small margin (less than
0.2% in all cases). The same results can be observed when
comparing meshes generated by Marching Cubes and Macet.
Figure 7 shows meshes collared in a post-processing step to
illustrate triangle quality based on a radii-ratio metric.
6. Conclusions and Future Work
This paper presents algorithms for contouring high-quality
isosurfaces interactively on graphics hardware. We present
GPU implementations of a modified version of Dual Contouring and Macet. We also discuss several acceleration structures
to implement these algorithms efficiently on the GPU, and
evaluate our results with experiments that test performance,
accuracy and triangle quality of all implementations.
One of the main aspects of the original Dual Contouring
algorithm, the mesh adaptivity generated by their use of an
Octree spatial subdivision, is not explored in our work. This
happens because our use of a table-driven formulation of
Dual Contouring requires fixed resolution, thus improving
algorithm performance. As future work, we plan to investigate ways to incorporate adaptive subdivision structures
while still preserving a case table-based implementation. We
also plan to extend our current approach to meshes of greater
sizes, possibly using heterogeneous systems or clusters of
GPUs, and we intend to keep evaluating how the performance of our current implementations change in the face of
improvements in modern graphics hardware.
Acknowledgments
The work of Leonardo A. Schmitz, Daniel K. Osmari.
Luiz Scheidegger and Jo˜ao L.D. Comba is sponsored by
CNPq-Brazil grants (136569/2008-0, 485853/2007-8 and
569239/2008-7) and CAPES.
References
[Bly06] BLYTHE D.: The direct3d 10 system. ACM Transactions on Graphics 25, 3 (2006), 724–734.
[BPS96] BAJAJ C. L., PASCUCCI V., SCHIKORE D. R.: Fast isocontouring for improved interactivity. In VVs’96: Proceedings of the 1996 Symposium on Volume Visualization
(San Francisco, CA, USA, 1996), pp. 39–ff.
[Cra07] CRASSIN C.: Opengl geometry shader marching
cubes. http://www.icare3d.org/blog_techno/gpu/opengl_
geometry_shader_marching_cubes.html, 2007, accessed
September 2, 2010.
[CRS98] CIGNONI P., ROCCHINI C., SCOPIGNO R.: Metro: Measuring error on simplified surfaces. Computer Graphics
Forum 17, 2 (1998), 167–174.

2577

[DSC*08] DIETRICH C., SCHEIDEGGER C., COMBA J. L. D.,
NEDEL L. P., SILVA C. T.: Edge groups: An approach to understanding the mesh quality of marching methods. IEEE
Transactions on Visualization and Computer Graphics 14,
6 (2008), 1651–1658.
[DSC*09] DIETRICH C. A., SCHEIDEGGER C. E., COMBA J.
L., NEDEL L. P., SILVA C. T.: Marching cubes without
skinny triangles. Computation in Science & Engineering
11, (2009), 82–87.
[DSS*09] DIETRICH C. A., SCHEIDEGGER C. E., SCHREINER J.,
COMBA J. L. D., NEDEL L. P., SILVA C. T.: Edge transformations for improving mesh quality of marching cubes. IEEE
Transactions on Visualization and Computer Graphics 15,
1 (2009), 150–159.
[DZTS08] DYKEN C., ZIEGLER G., THEOBALT C., SEIDEL H. P.:
High-speed marching cubes using histopyramids. Computer Graphics Forum 27 (September 2008), 2028–2039.
[Gei07] GEISS R.: Generating complex procedural terrains
using the gpu. In GPU Gems 3. H. Nguyen (Ed.). AddisonWesley Professional, Reading, MA, USA, 2007.
[Gib98] GIBSON S. F. F.: Constrained elastic surface nets:
Generating smooth surfaces from binary segmented data.
In MICCAI’98: Proceedings of the First International
Conference on Medical Image Computing and ComputerAssisted Intervention (London, UK, 1998), SpringerVerlag, pp. 888–898.
[GJD05] GOETZ F., JUNKLEWITZ T., DOMIK G.: Real-time
marching cubes on the vertex shader. In Proceedings of
Eurographics 2005 Short Presentations, Eurographics
Association. http://www.cs.uni-paderborn.de/fileadmin/
Informatik/AG-Domik/medicine/Real-Time_Marching_
Cubes_on_the_Vertex_Shader__EG_2005_.pdf, 2005,
accessed September 9, 2010.
[HBSL03] HARRIS M. J., BAXTER W. V., SCHEUERMANN T.,
LASTRA A.: Simulation of cloud dynamics on graphics hardware. In HWWS’03: Proceedings of the ACM
SIGGRAPH/EUROGRAPHICS Conference on Graphics
Hardware (Aire-la-Ville, Switzerland, 2003), Eurographics Association, pp. 92–101.
[HU82] HERMAN G. T., UDUPA J. K.: Display of 3d digital
images: Computational foundations and medical applications. In Proceedings of the Medcomp 82 (Philadelphia,
PA, USA, 1982), pp. 308–314.
[JC06] JOHANSSON G., CARR H.: Accelerating marching
cubes with graphics hardware. In CASCON’06: Proceedings of the 2006 Conference of the Center for Advanced
Studies on Collaborative Research (New York, NY, USA,
2006), ACM, p. 39.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

2578

L. Schmitz et al. / Efficient and Quality Contouring Algorithms on the GPU

[JLSW02] JU T., LOSASSO F., SCHAEFER S., WARREN J.: Dual
contouring of hermite data. ACM Transactions on Graphics 21, 3 (2002), 339–346.
[KBSS01] KOBBELT L. P., BOTSCH M., SCHWANECKE U., SEIDEL
H.-P.: Feature sensitive surface extraction from volume
data. In SIGGRAPH’01: Proceedings of the 28th Annual
Conference on Computer Graphics and Interactive Techniques (Los Angeles, CA, USA, 2001), ACM, pp. 57–66.
[KSE04] KLEIN T., STEGMAIER S., ERTL T.: Hardwareaccelerated reconstruction of polygonal isosurface
representations on unstructured grids. In PG’04: Proceedings of the Computer Graphics and Applications, 12th Pacific Conference (Washington, DC, USA, October 2004),
IEEE Computer Society, pp. 186–195.
[KW05] KIPFER P., WESTERMANN R.: GPU construction and
transparent rendering of iso-surfaces. In Proceedings
of the Vision, Modeling and Visualization. G. Greiner,
J. Hornegger, H. Niemann and M. Stamminger (Eds.).
(Erlangen, Germany, 2005), IOS Press, pp. 241–248.
[LB03] LOPES A., BRODLIE K.: Improving the robustness and
accuracy of the marching cubes algorithm for isosurfacing. IEEE Transactions on Visualization and Computer
Graphics 9, 1 (2003), 16–29.
[LC87] LORENSEN W. E., CLINE H. E.: Marching cubes: A
high resolution 3d surface construction algorithm. SIGGRAPH Computer Graphics 21, 4 (1987), 163–169.
[Nie03] NIELSON G. M.: On marching cubes. IEEE Transactions on Visualization and Computer Graphics 9, 3 (2003),
283–297.
[Pas04] PASCUCCI V.: Isosurface computation made simple:
Hardware acceleration, adaptive refinement and tetrahedral stripping. In Proceedings of the IEEE TVCG VisSym
(Konstanz, Germany, 2004), pp. 293–300.

[PF01] PERRY R. N., FRISKEN S. F.: Kizamu: A system for
sculpting digital characters. In SIGGRAPH 01: Proceedings of the 28th Annual Conference on Computer Graphics
and Interactive Techniques (New York, NY, USA, 2001),
ACM, pp. 47–56.
[RDG*04] RECK F., DACHSBACHER C., GROSSO R., GREINER
G., STAMMINGER M.: Realtime isosurface extraction with
graphics hardware. Eurographics Short Presentations,
2004.
[SHLJ96] SHEN H.-W., HANSEN C. D., LIVNAT Y., JOHNSON
C. R.: Isosurfacing in span space with utmost efficiency
(ISSUE). In VIS’96: Proceedings of the 7th Conference
on Visualization (Los Alamitos, CA, USA, 1996), IEEE
Computer Society Press, pp. 287–ff.
[Sno06] SNOEYINK J.: Artifacts caused by simplicial subdivision. IEEE Transactions on Visualization and Computer
Graphics 12, 2 (2006), 231–242.
[SW02] SCHAEFER S., WARREN J.: Dual contouring: The secret sauce. Technical Report 02-408, Department of Computer Science, Rice University, 2002.
[Tar06] TARIQ S.: Nvidia - directx 10 effects. http://
developer.download.nvidia.com/presentations/2006/
siggraph/dx10-effects-siggraph-06.pdf, 2006, accessed
September 2, 2010.
[THAG03] LEWINER T., LOPES H., VIEIRA A.W., TAVARES G.:
Efficient implementation of marching cubes’ cases with
topological guarantees. Journal of Graphics Tools 8, 2
(2003), 1–15.
[TSD07] TATARCHUK N., SHOPF J., DECORO C.: Real-time isosurface extraction using the GPU programmable geometry pipeline. In SIGGRAPH’07: ACM SIGGRAPH 2007
Courses (New York, NY, USA, 2007), ACM, pp. 122–
137.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.


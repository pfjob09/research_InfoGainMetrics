DOI: 10.1111/j.1467-8659.2009.01601.x
EUROGRAPHICS 2010 / T. Akenine-Möller and M. Zwicker
(Editors)

Volume 29 (2010), Number 2

Deformation Transfer to Multi-Component Objects
Kun Zhou†
†

Zhejiang University

Weiwei Xu‡
‡

Yiying Tong§

Microsoft Research Asia

§

Mathieu Desbrun¶

Michigan State University

¶

Caltech

Abstract
We present a simple and effective algorithm to transfer deformation between surface meshes with multiple components. The algorithm automatically computes spatial relationships between components of the target object, builds
correspondences between source and target, and finally transfers deformation of the source onto the target while
preserving cohesion between the target’s components. We demonstrate the versatility of our approach on various
complex models.
Categories and Subject Descriptors (according to ACM CCS): I.3.3 [Computer Graphics]: Geometry—Shape Deformation

wider range of applications, as we demonstrate through deformation transfer onto whimsical objects, and retargeting
captured motion data onto multi-component targets.

1. Introduction
Deformation transfer [SP04] has proven to be a valuable
technique for remapping rigid or non-rigid animation sequences from one geometry onto another. Despite its ability to transfer entire animation sequences from a surface
mesh to another with only little user interaction, its most
serious limitation lies in how similar (in shape and topology) the source and target meshes must be. This technique
will simply fail if the source and target objects have drastically different topologies, e.g., if the source is a single connected mesh while the target is an object containing multiple components (see Figure 1). However in real-life applications, characters or moving objects usually consist of multiple connected components, as pointed out in a recent paper
by Ben-Chen et al. concurrent to our work [BCWG09]. They
presented an efficient space deformation transfer technique
to handle multi-component objects equipped with polyhedral cages. However, automatic cage generation methods
often generate undesirable cages (e.g., fused feet of humanoid models). Moreover, cage-based techniques can also
run into numerical issues for thin-shell-like deformation as
in Figure 3, where the cage would exhibit significant selfintersection and degeneracy.

1.1. Related Work
Deformation transfer [SP04] provides a simple and efficient
way to remap animation sequences from one mesh onto another. This method first builds a correspondence map between the triangles of the source mesh and those of the target mesh by deforming the target into the reference pose
of the source through energy minimization. Then an affine
transformation matrix (or deformation gradient) is computed from each triangle in the source mesh to its counterpart in the deformed source mesh by appending an additional vertex to each triangle. Finally the transformation
matrices are applied to the corresponding triangles in the
target mesh, and a linear system (i.e., Poisson equation) is
solved to generate the deformed target mesh whose deformation gradients (with respect to the reference target mesh)
are as similar as possible to the deformation gradients of the
source. The final process is also known as gradient-domain
mesh deformation, which has gained a lot of attention in recent years [YZX∗ 04, SCOL∗ 04, BS08].
Since its introduction, the deformation transfer method has
been improved and extended by many researchers. Instead
of transferring all the gradients of the source deformation,
Zayer et al. [ZRKS05] proposed to transfer gradients only
at a few key points, and interpolate them to other points of
the target with a harmonic function. Botsch et al. [BSPG06]
proved that the same transfer results can be achieved without
adding an additional vertex to each triangle, speeding up the

In this paper, we remedy these issues by improving upon the
surface-based deformation transfer algorithm. Our contribution stems from simple solutions to two main challenges:
how to reliably establish correspondences between wildly
different source and target meshes without heavy user interaction, and how to maintain the spatial distribution of the
multiple components of the target throughout an animation
sequence. The versatility of our method allows for a much
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.
Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and
350 Main Street, Malden, MA 02148, USA.

319

320

K. Zhou, W. Xu, Y. Tong and M. Desbrun / Deformation Transfer to Multi-Component Objects

Target

Source

Reference

Figure 1: Deformations of a single-component horse are transferred to a pebble camel made of 750 separate stones. Only 47
correspondences are specified. (The pebble camel was inspired by The Thing, a fictional character made of stones in the movie
entitled “The Fantastic Four”.)
linear system solve. While the original deformation transfer
method requires similar reference poses between the source
and target meshes, Lee et al. [LWC06] developed a method
to remove this restriction. They segment the source and target into the same number of near-rigid components and adjust the orientation of the target components to be similar
to the corresponding source components through rigid transformation. More recently, Baran et al. [BVGP09] proposed
semantic deformation transfer to preserve the semantic characteristics of the motion instead of its literal deformation.
One serious limitation of Sumner and Popovi´c’s method
is that it is restricted to single-component meshes. To remove this restriction, Ben-Chen et al. [BCWG09] proposed
a spatial deformation transfer technique to handle multiplecomponent meshes and polygon soups. Their technique,
however, requires to construct polyhedral cages for the objects. Moreover, some high-frequency details of the source
deformation may be lost since the method projects the deformation into a low-dimensional linear subspace. Like Sumner and Popovi´c’s original approach, our method is surfacebased, and thus does not suffer from these issues.
1.2. Algorithm Overview
Our goal is to extend Sumner and Popovi´c’s method to multicomponent meshes. We adopt their approach for the computation of the per-triangle deformation. However, the original
method requires a manual specification of a global boundary
condition, i.e., an anchor point for each topological component of the mesh to assemble the deformations. Handling
objects with multiple parts could thus not be handled for a
series of reasons: (1) providing an anchor for each separate
component of the target object is difficult; (2) preservation of
spatial relationships between components is not addressed;
(3) establishing correspondence between the source mesh
and the target mesh requires tedious manual work to specify enough marker pairs on each component. To circumvent
these issues, we will show that one can employ simple graph
theoretical techniques, along with recent developments in
mesh deformation that locally preserve shape as best as possible [BS08].

Our algorithm first computes a set of closest vertex pairs to
build a graph that encodes the spatial relationship between
components. Then both the correspondence algorithm and
the deformation transfer algorithm in [SP04] are adapted
to take into account the graph connectivity. First, when establishing correspondences between the source and target,
we add an energy term to make the components without
any user-specified markers deform with the components that
have makers. This greatly reduce the manual work to specify markers for each separate component. Note that, unlike in
[SP04], where every triangle of the target has a corresponding triangle in the source, not all target triangles may have
correspondences in our case. Some components of the target may not have any corresponding triangles in the source.
Such components are called orphan components. Also note
that, while it is possible to adapt recent automatic algorithms
for non-rigid registration [WJH∗ 07,HAWG08,LSP08] to get
better correspondences, our current deformation-based approach is simple and easy to implement, and can compute
good enough correspondences for the deformation transfer
application.
Second, when deforming the target to match the source deformation gradient, we add two new energy terms as soft
constraints. The first term tries to preserve the lengths of the
graph edges so that the spatial relationship between components is maintained. It also removes the need to provide an
anchor for each separate component of the target object. The
second term is based on Laplacian coordinates [SCOL∗ 04]
and tries to preserve the surface details of the orphan components in the target. Since the two newly added terms are
not in quadratic form, the total energy cannot be minimized
using a linear solver. Instead, an iterative Gaussian-Newton
method is employed – we approximate the two terms as
quadratic functions and only need to solve a linear system
at each iteration. This optimization scheme works efficiently
for all of our experimental data.
One may think that the above two energy terms are unnecessary, and by interpolating the deformation of orphan components from nearby components, the desired deformation
can be computed using a linear solver. The assumption of
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

321

K. Zhou, W. Xu, Y. Tong and M. Desbrun / Deformation Transfer to Multi-Component Objects

this linear approach (i.e., the closest triangle pairs of nearby
components have similar deformations), however, is not true
in many cases. For example, when the mechanical-like horse
shown in Figure 7 is running, two components near to a
joint can have different rotations. Enforcing transformation
smoothness between the closest triangle pairs may introduce
undesirable deformation artifacts (see Figure 7).

2. Algorithm
˜ and a target obGiven a pair of source objects, S and S,
ject T consisting of multiple disconnected components (T =
{T1 , T2 , ...}), our goal is to generate a new object T˜ such that
the deformation between T and T˜ is analogous to the defor˜ Note that the source object may
mation between S and S.
also consist of multiple components. For clarity, we will denote by ui a vertex of S and by u˜ i its corresponding vertex
˜ while vi will refer to a vertex of T and v˜ i its associated
in S,
vertex in T˜ that we will solve for. We will also sometimes
indicate with a superscript that a vertex belongs to one of the
components of T; e.g., vai and vi will refer to the same vertex, but the superscript stresses the fact that vi belongs to the
component Ta .
Our approach starts by adding vertices to the source objects.
˜ with three
Following [SP04], for each triangle of S (resp., S)
vertices {u1 , u2 , u3 } (resp., {u˜ 1 , u˜ 2 , u˜ 3 }), we add a fourth vertex u4 (resp., u˜ 4 ) in the direction of the outward normal
of the triangle, at a distance from the triangle proportional
to the square root of the area. This procedure is designed
to make the stretch in the normal direction the geometric
average of the principal stretches in the plane. The affine
transformation of the source triangle, mapping ui to u˜ i for
i = 1 . . . 3, is computed as:
˜ −1 ,
F = GG

(1)

where
G = [u2 − u1 u3 − u1 u4 − u1 ]
˜ = [u˜ 2 − u˜ 1 u˜ 3 − u˜ 1 u˜ 4 − u˜ 1 ].
G
The algorithm then proceeds as follows:
1. Computation of Proximity Pairs between Components:
Since T consists of multiple disconnected components,
we start by encoding the spatial relationship between
components through a set of proximity pairs. For each
pair of components (Ta , Tb ), we will define as Pa,b a selected set of vertex index pairs that represent key spatial
adjacencies that subsequent processing will try to preserve during transfer. Note that Pa,b may be empty if the
associated components are too far away from each other.
The computation of Pa,b will be described in Section 2.1.
2. Establishment of Correspondences: We assume that the
user has provided a small set of markers that indicate point-to-point correspondences between the meshes
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

S and T. From these markers, we will deduce correspondences between source triangles and target triangles
through a set M:
M = {(s1 ,t1 ), (s2 ,t2 ), ..., (s|M| ,t|M| )},

(2)

where a pair (sm ,tm ) indicates that the target triangle
tm should deform like the source triangle sm . The computation of M will be explained in Section 2.2. Unlike
in [SP04], where every triangle of the target object has
a corresponding triangle in the source object, not all target triangles may have correspondences. If the source and
target objects have drastically different topologies, enforcing a correspondence to a triangle on the source for
each triangle of the target and transferring the deformation will generate unintuitive and unappealing results (see
Figure 7). We denote by H the set of “orphan” target triangles (i.e., the ones that do not have correspondences).
Note that some components in T may not contain any
corresponding triangles in M. We denote by TH the set of
these “orphan” components without corresponding triangles.
3. Deformation Transfer: Finally the deformation is transferred through an energy minimization that accounts for
the presence of multiple components. Section 2.3 reviews
this final process.
We now provide details on the successive steps of our deformation transfer approach.
2.1. Proximity of Components
The spatial relationship between the components of the target mesh, encoded as proximity pairs, can be established
through the following steps:
• For every pair of components (Ta , Tb ), find the shortest
distance da,b between them as well as the pair of vertices
(vai , vbj ) corresponding to this shortest distance:
da,b := vai − vbj =

min

vi ∈Ta ,v j ∈Tb

vi − v j .

• Build a complete graph G with the components as its
nodes, where edges are weighted by the shortest distances
computed above.
• Compute a minimal spanning tree K (i.e., the minimum
weight subgraph) of the graph.
• For each component Ta , compute its largest distance da
from each of its adjacent components in K:
da =

max

edge (a,b)∈K

da,b

• For every pair of components Ta and Tb not connected
by an edge in the subgraph K, if da,b ≤ da + εa and
da,b ≤ db + εb , connect Ta and Tb by adding an edge in
K between them. The user-specified thresholds εa and εb

322

K. Zhou, W. Xu, Y. Tong and M. Desbrun / Deformation Transfer to Multi-Component Objects

define a notion of “close” proximity, controlling how cohesive the target must remain. In our implementation, εa
(resp., εb ) is computed as the maximal edge length of the
component Ta (resp., Tb ) times 1.5.
The proximity pairs are then easily defined: for two components Ta and Tb , Pa,b is set to nil if these components are
not connected by an edge in the subgraph K. Otherwise, we
set Pa,b to be a set initialized with the closest vertex pair
(vai , vbj ); we further add to Pa,b any vertex pair (vak , vbl ) such
that vak − vbl < da,b + min{εa , εb }.
This simple choice of using a few distance-based vertex pairs
to encode proximity provides robustness to all sorts of targets while limiting undesirable relative rotations between
nearby components, as we will demonstrate in Section 3.
2.2. Establishing Correspondences
Finding correspondences between the source and target objects is achieved by deforming the target T into the static
pose of the source S in a fashion nearly identical to the original deformation transfer approach [SP04]. The deformed
vertices of T that we need to solve for will be called xi , and
are only temporarily used in this procedure to establish correspondences.
The user controls the deformation by specifying a set of pairs
of source and target vertex indices. Each pair indicates that
the target vertex, after deformation, should match the location of the source vertex. Then an iterated closest point algorithm is performed. At each iteration, the target is deformed
through an energy minimization, and the set of closest valid
vertex-point pairs is updated.
Correspondence Energy We compute the deformed vertices X = [xt1 xt2 . . . ]t by minimizing the following energy:
E = wS ES + wI EI + wC EC + ER
s.t. xmk = mk , k ∈ 1...m

(3)

where mk is the vertex index on the target mesh for marker
k, and mk is the corresponding position of marker k on the
source object. The deformation smoothness term ES , the deformation identity term EI , the closest valid point term EC
and the choice of weights are all identical to [SP04]: ES indicates that the transformations of adjacent triangles should be
equal, EI is minimized when all transformations are equal to
the identity matrix, and EC indicates that the position of each
vertex of the target mesh should be equal to the closest valid
point on the source mesh. Our only change to the correspondence process lie in the last energy term ER . The purpose of
this added term is to make the components without any userspecified markers deform along with the components that do
have markers, thereby minimizing the need for user-defined
correspondences. The ER energy is computed as follows:
• For each component pair (Ta , Tb ), we find a pair of triangles (tia ,t bj ) for each vertex pair (vai , vbj ) in Pa,b , such that

Figure 2: Finding correspondences through deforming the
target into the source. From left to right are the source,
the target, and the deformed target object. User-specified
marker points are shown in red.
tia ∈N(vai ),t bj ∈N(vbj ) (N(.) refers to the usual topological
one-ring), and that the triangles have the largest separation along the normal directions. More precisely, the pair
is defined as:
arg max|h · ntia | + |h · nt b |,
j

tia ,t bj

where nt is the normal of triangle t, and h is the vector
between the barycenters of the two triangles, tia and t bj .
• For each triangle tia we found above, we construct a tetrahedron by using one of the three vertices of t bj as the
fourth vertex. Similarly, we construct a tetrahedron for
triangle t bj . However, if triangles tia and t bj are approximately coplanar in the rest pose of the target object, the
two constructed tetrahedra will be degenerate. In this case
we simply use tia ’s fourth vertex (that was added in the direction perpendicular to the triangle, see Section 2) as the
fourth vertex of both tetrahedra.
• The energy ER is then defined as:
ER =∑
a,b

∑
(tia ,t bj )

wS Fˆ tia − Fˆ t b 2 +wI Fˆ tia − I 2 +wI Fˆ t b − I
j

2

j

(4)
where Fˆ tia indicates the transformation of the newly constructed tetrahedron based on tia .
Note that our goal is to deform the target into the source to
establish correspondences. After deformation, the shape of
every component as well as the edge length between components may have changed greatly. We thus cannot base our
energy on edge length constraint or on the Laplacian constraint, both of which are described in Section 2.3 (as E3
and E4 ). Our solution, implemented through ER , of adding
tetrahedra between two components allows for affine transformations of components, and is therefore more effective.
Solving for Correspondences The correspondence energy
minimization is achieved via the same two-phase method
described in [SP04], consisting in successive linear solves.
At each iteration, after the target object is deformed we also
need to update the set of the closest valid vertex-point pairs.
For each vertex of the deformed target object at the current
iteration, we find its closest point on the source object. If
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

,

323

K. Zhou, W. Xu, Y. Tong and M. Desbrun / Deformation Transfer to Multi-Component Objects
Reference

Target

Target

Source

Source

Reference

Figure 4: A 9-component bird running like a horse.
Figure 3: A mechanical-like horse collapsing.
the distance between vertex and point is less than a userspecified threshold and the difference between the vertex’s
normal and the point’s normal is less than 90 degree, we
add the vertex and point to the valid set. The whole process
converges fast and reaches a minimum after a few iterations
(see statistics in Section 3). We then compute the triangle
correspondences between the source and the deformed target triangles. For each deformed target triangle, if one or
more of its three vertices are among the markers or in the
set of the closest vertex-point pairs, it will not be assigned
any corresponding source triangle. Otherwise, we label its
corresponding source triangle as the one with the smallest
distance between the barycenters of the two triangles.
2.3. Deformation Transfer
˜ =
We finally solve for deformed vertex positions V
[˜vt1 v˜ t2 . . . ]t by minimizing the following energy:
E = w1 E1 + w 2 E2 + w 3 E3 + w 4 E4 .

(5)

Each term (explained next) serves a different purpose, while
the weights offer control on the overall deformation transfer
behavior. We use weights w1 = w2 = w4 = 1.0 and w3 = 0.1,
for all the examples in this paper.
The E1 term measures the difference between the source and
target transformations (defined in Eq. (1)) :
|M|

E1 =

∑

Fsi − Fti 2 .

(6)

i=1

For each triangles in H (i.e., with no corresponding triangle in the source object), E2 acts as a regularization, forcing
the transformation of this orphan triangle to be close to the
transformations of its adjacent triangles (where adjacency is,
again, defined as its topological one-ring):
E2 =

∑ ∑

Fti − Ft j 2 .

(7)

ti ∈H t j ∈N(ti )

The E3 term helps maintain the spatial relationship between
components by preserving the edge lengths of the vertex
pairs in each Pa,b :
E3 =

∑

∑

( v˜ ai − v˜ bj − vai − vbj )2 .

(8)

Ta ,Tb ∈T (vai ,vbj )∈Pa,b
a b

Note that vai − vbj is computed on the rest pose of the target object and remains constant. Finally, the components in
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

Model
Horse
Woman (source)
Car (source)
Mechanical Horse
Pebble Camel
Bird
Woman (target)
Car (target)

Components
1
1
261
21
750
9
4
40

Vertices
8,431
9,971
26,362
10,209
51,000
6,712
12,594
28,885

Triangles
16,843
19,938
47,315
20,334
99,000
13,388
25,704
57,332

Table 1: Number of components, vertices and triangles for
the models used in the paper.
TH do not have corresponding triangles in the source object.
Thus, we use Laplacian coordinates [SCOL∗ 04] to preserve
the surface details of these components by adding a fourth
energy:
E4 =

∑

ˆ V
˜ Ta ) 2 ,
˜ Ta − δ(
LTa V

(9)

Ta ∈TH

where LTa is the Laplacian operator matrix computed on the
˜ Ta is a sub-array of V
˜ containing only the vertex
mesh Ta , V
positions of component Ta , and the Laplacian coordinates
ˆ V
˜ Ta ) are defined as in [HSL∗ 06]:
δ(
˜
ˆ V
˜ Ta ) = LTa VTa
δ(
˜
LTa VTa

LTa VTa .

˜
The total energy E is therefore a nonlinear function of V,
but can be efficiently minimized using an iterative GaussNewton method as advocated in [SZT∗ 07]: while E1 and E2
˜ repeated quadratic approximaare quadratic functions of V,
tions of E3 and E4 lead to a linear solve for every GaussNewton iteration. Note that the optimization problem requires an additional boundary condition to determine the
global translation: this is easily fixed by setting the position
for a target vertex, or by specifying another positional constraint such as foot placement.
Note that all energy terms in Eq. (5) were carefully designed,
and proved to be necessary in our experiments. In particular,
the smoothness term E2 is used to propagate the transformations of the triangles with correspondences to those orphan
triangles without correspondences. The Laplacian term E4 is
used to preserve the surface details of orphan components.
Omitting E2 would leave the transformation matrices of the
orphan triangles discontinuous. Thus, the positions of these
vertices could not be determined and the orphan triangles
would not be deformed accordingly without E2 . Omitting E4

324

K. Zhou, W. Xu, Y. Tong and M. Desbrun / Deformation Transfer to Multi-Component Objects

Source

Reference

Target

Target

Source

Reference

Figure 5: A woman in a dress follows the moves of a dancer.
would leave orphan components under-constrained. The positions of orphan components could thus not be determined.
3. Results
We have implemented our deformation transfer algorithm on
an Intel Xeon 3.7GHz workstation. We selected a number of
examples to demonstrate the versatility of the resulting algorithm. We provide statistics for the models presented in this
paper in Table 1 and Table 2, including timings and number
of markers needed.
Whimsical Objects The first example shows a deformation
of a single-component horse transferred to a robot-looking
horse which has 21 components (see Figure 3). Both global
and local deformations are nicely reproduced on the new
model. Moreover, all components of the model deform consistently and their spatial relationship is well maintained.
Note that we constrained a marker vertex on one of the target’s feet components to match its correspondence marker
on the source. In Figure 4, we transfer the deformations of
the horse to a 9-component bird. Although every component
intersects with its adjacent components, our algorithm robustly handles the deformation transfer, producing very reasonable results.
Objects with Many Components To test the robustness of
our correspondence and transfer algorithm further, we try
to transfer the deformations of a horse onto a pebble camel
made of 750 separate stones (see Figure 1). In this case, only
47 correspondence markers are specified. Although most
components do not have markers, our correspondence algorithm handles them reliably via the extra tetrahedra (added in
the energy ER ), and nicely deforms the camel into the horse,
establishing satisfactory correspondences. The spatial relationships between components are very well preserved while
the deformations are faithfully transferred.
Human body & Clothes In [VBMP08], complex captured
data are encoded as a time-varying single-component mesh.
However, transferring deformation from such captured data
to other meshes will often involve multiple-component tar-

Figure 6: Deformation transfer of multi-component objects.
Example
Horse/Mec. Horse
Horse/Bird
Horse/Pebble Camel
Woman
Car

# Markers
43
19
47
78
70

Build Corresp.
8.15s
5.65s
54.56s
14.87s
32.86s

Transfer
0.424s
0.439s
14.72s
1.83s
8.09s

Table 2: The number of correspondence markers and the
timing results (in seconds) for building correspondence and
transferring a single frame.

gets: clothes and body meshes (as in Figure 5) are typically given as separate meshes. We show that our approach
can transfer animations from multiview silhouettes to multicomponent models created using commercial modeling softwares. Note that in some regions of the target model, the
body mesh is very close to the cloth mesh; they both are
deformed into the source mesh and find correct correspondences. As a result, these regions of the body are deformed
along with the cloth.
Our last example shows that our algorithm can easily handle deformation transfer from one multi-component object
to another. As shown in Figure 6, the deformation of a 261component sports car is transferred to a 40-component vintage car model. Note that the algorithm of Section 2 naturally
works for multi-component source objects as is.
4. Conclusion
We have generalized the deformation transfer technique
of [SP04] to handle complex models consisting of arbitrarily many components. We proposed simple methods to establish spatial relationship between components, build correspondences between models with different topologies, and
transfer deformation while preserving pairwise component
proximity. The resulting algorithm is straightforward to implement.
Although our algorithm works well even in the cloth examples, we cannot guarantee collision-free deformation transfer (see Figure 8). This may be, in certain applications, a
serious limitation. For future work, we believe that parts
of our algorithm can be easily adopted by as-rigid-aspossible shape interpolation algorithms [ACOL00] to handle
multi-component objects. We are also interested in definc 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

K. Zhou, W. Xu, Y. Tong and M. Desbrun / Deformation Transfer to Multi-Component Objects

325

Source

Reference

(b) our method

(c) full correspondence method

(d) linear method

Target

(a) rest pose

Figure 7: Comparison on the horse sequence. (a) Rest pose.
(b) Transfer result using our method. (c) Transfer result by
enforcing a correspondence between a triangle on the source
for each triangle of the target. Note the artifacts at the front
legs of the horse. (d) Transfer result using a linear method,
i.e., without the two terms E3 and E4 in Eq. (5) and by imposing smoothness constraints on paired tetrahedra found
as described in Section 2.2. As closest triangle pairs get different transformations from the source, this method introduces undesirable deformations. The relative distance between components are not well maintained either.
ing and preserving other kinds of spatial relationship between components during deformation transfer; currently we
only use edge lengths between vertex pairs, which is inappropriate if the relative distance between components in
the source model are supposed to change during deformation.Therefore, extensions could be proven useful.
Acknowledgements

Figure 8: A self-collision example. The samba deformation
sequence in [VBMP08] is transferred to the same woman
model in Figure 5. We only used 63 markers (compared to
the 78 markers used in Figure 5). Self-collisions occur in a
few frames of the transfer result.
[BSPG06] B OTSCH M., S UMNER R., PAULY M., G ROSS M.:
Deformation transfer for detail-preserving surface editing. In Vision, Modeling & Visualization (2006), pp. 357–364.
[BVGP09] BARAN I., V LASIC D., G RINSPUN E., P OPOVI C´ J.:
Semantic deformation transfer. ACM TOG 28, 3 (2009), 36.
[HAWG08] H UANG Q.-X., A DAMS B., W ICKE M., G UIBAS L.:
Non-rigid registration under isometric deformations. Computer
Graphics Forum 27, 5 (2008), 1449–1457.
[HSL∗ 06] H UANG J., S HI X., L IU X., Z HOU K., W EI L.-Y.,
T ENG S.-H., BAO H., G UO B., S HUM H.-Y.: Subspace gradient
domain mesh deformation. ACM TOG 25, 3 (2006), 1126–1134.
[LSP08] L I H., S UMNER R. W., PAULY M.: Global correspondence optimization for non-rigid registration of depth scans.
Computer Graphics Forum 27, 5 (2008), 1421–1430.
[LWC06] L EE T.-Y., WANG Y.-S., C HEN T.-G.: Segmenting a
deforming mesh into near-rigid components. The Visual Computer 22, 9 (2006), 729–739.
[SCOL∗ 04] S ORKINE O., C OHEN -O R D., L IPMAN Y., A LEXA
M., RÖSSL C., S EIDEL H.-P.: Laplacian surface editing. In
Proceedings of SGP’04 (2004), pp. 175–184.

We would like to thank the anonymous reviewers for their
helpful comments. Many thanks to Tianjia Shao and Zhenglong Zhou for their help in video production. This research
was partially funded by the NSFC (No. 60825201), the 973
program of China (No. 2009CB320801), the NSF (CCF0811313/0811373, and CMMI-0757106/0757123), and the
Open Project Program of the State Key Lab of CAD&CG,
Zhejiang University.

[SZT∗ 07] S HI X., Z HOU K., T ONG Y., D ESBRUN M., BAO H.,
G UO B.: Mesh puppetry: cascading optimization of mesh deformation with inverse kinematics. ACM TOG 26, 3 (2007), 81.

References

[WJH∗ 07] WAND M., J ENKE P., H UANG Q.-X., B OKELOH M.,
G UIBAS L., S CHILLING A.: Reconstruction of deforming geometry from time-varying point clouds. In Proceedings of SGP’07
(2007), pp. 49–58.

[ACOL00] A LEXA M., C OHEN -O R D., L EVIN D.: As-rigidas-possible shape interpolation. In ACM SIGGRAPH (2000),
pp. 157–164.
[BCWG09] B EN -C HEN M., W EBER O., G OTSMAN C.: Spatial
deformation transfer. In Proceedings of SCA’09 (2009).
[BS08] B OTSCH M., S ORKINE O.: On linear variational surface
deformation methods. IEEE TVCG 14, 1 (2008), 213–230.
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

[SP04] S UMNER R. W., P OPOVI C´ J.: Deformation transfer for
triangle meshes. ACM TOG 23, 3 (2004), 399–405.

[VBMP08] V LASIC D., BARAN I., M ATUSIK W., P OPOVI C´ J.:
Articulated mesh animation from multi-view silhouettes. ACM
TOG 27, 3 (2008), 97.

[YZX∗ 04] Y U Y., Z HOU K., X U D., S HI X., BAO H., G UO B.,
S HUM H.-Y.: Mesh editing with poisson-based gradient field
manipulation. ACM TOG 23, 3 (2004), 644–651.
[ZRKS05] Z AYER R., RR ÖSSL C., K ARNI Z., S EIDEL H.-P.:
Harmonic guidance for surface deformation. Computer Graphics
Forum 24, 3 (2005), 601–609.


Volume 27 (2008), Number 2

EUROGRAPHICS 2008 / G. Drettakis and R. Scopigno
(Guest Editors)

Hardware-Accelerated, High-Quality Rendering Based on
Trivariate Splines Approximating Volume Data
Thomas Kalbe1 and Frank Zeilfelder2
1 Technische
2 Universität

Universität Darmstadt 64 183 Darmstadt, Germany, thomas.kalbe@gris.informatik.tu-darmstadt.de
Mannheim, Institut für Mathematik, 68 131 Mannheim, Germany, zeilfelder@math.uni-mannheim.de

Abstract
We develop an approach for hardware-accelerated, high-quality rendering of volume data using trivariate splines.
The proposed quasi-interpolating schemes are realtime reconstructions. The low total degrees provide several
advantages for our GPU implementation. In particular, intersecting rays with spline isosurfaces for direct Phong
illumination is performed by simple root finding algorithms (analytic and iterative), while the necessary normals
result from blossoming. Since visualizations are on a fragment base, our renderer for isosurfaces includes an
automatic level of detail. While we use well-known spatial data structures in the CPU part of the algorithm
for hierarchical view frustum culling and memory reduction, our GPU implementations have to take the highly
complex structure of the splines into account. These include an appropriate organization of the data streams,
i.e. we develop an advanced encoding scheme for the spline coefficients, as well as an implicit scheme for bounding
geometry retrieval. In addition, we propose an elaborated clipping procedure to be performed in the fragment
shader. These features essentially reduce bus traffic, memory consumption, and data access on the GPU leading
to interactive frame rates for renderings of high visual quality. Compared with pure CPU implementations and
existing GPU implementations for trivariate polynomials frame rates increase by factors between 10 and 100.
Categories and Subject Descriptors (according to ACM CCS): I.3.1 [Computer Graphics]: Hardware Architecture–
Parallel Processing, I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling–Splines.

1. Introduction
Modern scanning devices such as CT and MRI allow to
measure huge volume datasets arising in many fields. Typical examples are given by medical applications and industrial quality control, where one is interested in efficient
methods leading to high-quality visualizations of the reconstructed objects, i.e. human organs or machinery parts,
for instance. Another source for volume data is to compute
signed distance functions (SDF) [JBS06] from given lowerdimensional objects in 3D space. Interactive volume rendering is devoted to efficient computational techniques for the
visualization of volume datasets [Baj99]. Basically one distinguishes between full volume rendering approaches, where
the integral equation of a physical emission-transport model
has to be numerically solved along rays and the less expensive isosurfacing [ML94,WS01], where surfaces of constant
scalar values are extracted from the volume model by applying ray-casting.
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.
Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and
350 Main Street, Malden, MA 02148, USA.

Figure 1: Environment mapped to varying isolevels of a
smooth cubic spline (approximating 643 voxels).
A basic problem in this area is to develop appropriate
volume models of the measured voxel data. Ideally, an approach involves realtime reconstruction, i.e. using a standard
PC the non-discrete model is immediately available from the
huge datasets, while a certain approximation order is guaranteed. In this connection, simultaneous approximation of
partial derivatives is an important issue, since it allows to
sample the gradients directly to render the smooth model. A
primary goal in the field is that the non-discrete models pro-

332

T. Kalbe & F. Zeilfelder / Hardware-Accelerated, High-Quality Rendering Based on Trivariate Splines

Figure 2: Smooth cubic spline renderings from the (SDF
generated) dragon dataset (200 × 158 × 121 voxels).
vide high-quality renderings, i.e. visualizations should appear natural and overall smooth, while artifacts (imperfect
silhouettes, oscillations, staircasing, . . .) are almost avoided
and standard techniques from Computer Graphics (texturing, shading, lighting, . . .) can be performed without too
much effort (see Fig. 1). A crucial issue for the visualization of sophisticated volume models is always interactivity,
since, in practice, the reconstructed objects should appear
on high-resolution displays without delays. High frame rates
can be achieved for volume models, where the locality allows to perform computations in parallel, while an automatic
level of detail is provided. In this connection, since recently,
shader programs running on the GPU can be used to render
non-discrete models built from general geometric primitives.
This establishes the development of interactive methods using sophisticated volume rendering models for high-quality
visualizations on standard PCs.
The purpose of this paper is to develop the first GPUbased rendering method for trivariate splines, i.e. piecewise polynomials on tetrahedral partitions connected via
smoothness conditions. Since we are interested in realtime
reconstructions, our models are based on quadratic and
cubic quasi-interpolating splines in Bernstein-Bézier form
(cf. [NRSZ05, SZ07] for the mathematical background),
where the coefficients are simply set as local averages of the
uniform data. This is done with care, such that approximation order two is guaranteed for the model and for its partial derivatives, while smoothness conditions are satisfied.
The computation of the spline model is a CPU-preprocessing
step, where we use spatial data structures in order to increase
efficiency, for instance to perform hierarchical view frustum
culling. The approximation nature of the spline algorithms
and the fact that we choose splines of low and lowest possible degree provide several advantages for our GPU implementation. Using blossoming, the restrictions of the splines
along viewing rays are easily determined in the fragment
shader by applying a few de Casteljau steps.

The low degrees support analytic and iterative root finding algorithms performed in parallel on the GPU with a low
number of fixed iterations in the latter case. Moreover, the
computation of the normals necessary for Phong illumination is done by applying Bernstein-Bézier techniques to the
polynomial pieces, and a separate model for the approximative derivatives is not needed, here. On the other hand, compared with standard models trivariate splines have a much
more complex structure. In order to keep bus traffic, memory
consumption, and data access on the GPU as low as possible, data streams have to be appropriately organized. To do
this, we develop an advanced encoding scheme for the spline
coefficients and an implicit scheme for bounding geometry
retrieval. The encoding scheme uses the splines structure
and allows us to send only a small number of coefficients
(associated with a so-called determining set) to the GPU,
while we recompute the remaining coefficients in the vertex
shader on-the-fly by means of a repeated averaging procedure. In addition, our implicit scheme for bounding geometry retrieval exploits the uniform structure of the underlying
tetrahedral partition to prevent explicit usage and storage of
the geometry. This is connected with an efficient clipping
procedure, which does not require explicit knowledge on the
vertices of the current tetrahedron and avoids clipping with
its four triangular planes. The results involving techniques
from Computer Graphics illustrate that our realtime reconstruction based on trivariate quasi-interpolating splines satisfies the various requirements of high-quality visualization
(see Fig. 2). As our main contribution, this is the first GPU
implementation for trivariate splines taking their structure
into account such that bus traffic, memory consumption, and
data access on the GPU is optimized. This results in an interactive renderer with frame rate improvements of factors
between 10 and 100 compared to previous approaches.

2. Related work
Nowadays, GPU implementations are used for general purpose computations [OLG∗ 07, gpg], which need not be related to Computer Graphics, e.g. high performance computing. The main reason lies in the highly parallel nature of
GPUs, applicable for large scale local problems.
Problems of this type arise in Computer Graphics,
e.g. subdivision surface displaying [SJP05] and interactive
volume visualization [KW03]. In the latter case, the underlying models are often classical trilinear splines, i.e. continuous, piecewise cubics obtained from successive univariate linear interpolation. The simplicity of this local spline
model let standard GPU implementations become straightforward being the main reason for its frequent usage. On the
other hand, high quality visualizations often require smoothness conditions to be involved (see Fig. 8). Hence, instead
of computing separate derivative models, triquadratic and
tricubic splines have been proposed to improve the visual
quality [BMDS02, ML94, VKG04]. However, the associated
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

333

T. Kalbe & F. Zeilfelder / Hardware-Accelerated, High-Quality Rendering Based on Trivariate Splines

operators sometimes require (approximate) derivatives. Additionally, the piecewise polynomials of degree six and nine
increase computational complexity when applying standard
techniques. GPU implementations were developed for the
visualization using higher-degree tensor products [HS05],
bivariate Bézier patches [Rei05], PN triangles [SSS06], and
NURBS patches [GBK05]. Different methods are based on
radial basis functions [JBL∗ 06].
Our approach is based on trivariate splines defined
w.r.t. tetrahedral partitions, which have been studied intensively in the approximation theory literature of the recent
years [Chu89, LS07] and rely on the Bernstein-Bézier form
(BB-form) [Far86, PBM02] of the polynomial pieces. Besides some insights on the complex structure [HNR∗ 04]
several operators have been suggested [NSZ05, SS04] Our
visualization is based on quasi-interpolation for quadratic
super splines [NRSZ05] and cubic C1 splines [SZ07] on
type-6 tetrahedral partitions. Note that our models do not
exceed the total degree of trilinear splines, while smoothness conditions are involved. The uniformity of the underlying partition, the regular structure and low total degrees
of our splines, and the availability of repeated averaging
type procedures for on-the-fly computation correspond with
the general requirements of GPU implementations in order to exploit its parallelism. Pure CPU implementations
for quadratic super splines have recently been developed
for isosurfacing [RZNS04a] and for direct volume rendering [SZH∗ 05]. Moreover, the GPU implementations on terrain rendering with bivariate splines [SW06], visualization
of algebraic surfaces from trivariate polynomials [LB06],
and rendering of piecewise quadratic polynomials in three
variables [SGS06, SWBG06] are most closely related. Using the BB-form of a polynomial, Loop & Blinn [LB06]
exploit the idea to perform the intersection test needed for
raycasting in screen space. Since, according to their method,
the projection step has to be performed on the CPU, only a
small number of tetrahedra can be processed this way. While
the approach by Sigg et al. [SWBG06] works well for a set
of (special) polynomials not being related by continuity and
smoothness conditions, Stoll et al. [SGS06] give a GPUimplementation for quadratic polynomials and particularly
apply their approach to quadratic super splines [NRSZ05].
However, still this is a pure polynomial GPU implementation, which requires full information, i.e. the explicit geometry of each relevant tetrahedron (for this notion see Sect. 5.1)
together with all the BB-coefficients is sent through the
GPU. Obviously, this leads to redundancies. In contrast to
this, our GPU implementations (involving the additional and
complex case of cubic C1 splines) show that more sophisticated algorithms are needed to deal with splines. More precisely, we have to take the complex structure of splines into
consideration and organize the data streams determining the
splines, as well as the relevant tetrahedra, appropriately. In
connection with our improved culling technique, this results
in an essential improvement of frame rates.
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

3. Trivariate Splines and BB-Form
We consider trivariate splines on type-6 tetrahedral partitions ∆. Given a cube partition ♦ = {Q : Q = Qi jk , i, j, k =
−1, . . . , n + 1} the partition ∆ is determined by subdividing
each Q into 24 congruent tetrahedra (see Fig. 3), where the
center point vQ = (2i + 1, 2 j + 1, 2k + 1)T h/2 with h = 1/n
is connected with the vertices of Q and each of the resulting
six pyramids is split into four tetrahedra.

R0

R1

R2

R3

q=2

q=3

Figure 3: A type-6 partition ∆ is obtained by subdividing
each cube Q into 6 pyramids (orange) and further split them
into 4 tetrahedra (grey). Domain points in Q are organized
in rings Rν , ν = 0, . . . , q, around vQ (top).
Trivariate splines s w.r.t. ∆ are piecewise polynomials in
three variables x, y, z of (total) degree q, which should be at
least continuous, i.e. for all T ∈ ∆, we have pT := s|T ∈
Pq := span{xi y j zk : i, j, k ≥ 0, i + j + k ≤ q}, and for any
tetrahedra T1 , T2 ∈ ∆ with F = T1 ∩ T2 = 0,
/ we always assume that pT1 |F = pT2 |F . We use the BB-form of s, i.e.
s|T =

∑

bi jk Bi jk , T ∈ ∆,

(1)

i+ j+k+ =q
j

where Bi jk = q!/(i! j!k! !) λ0i λ1 λ2k λ3 ∈ Pq , are the Bernstein polynomials w.r.t. T = [v0 , v1 , v2 , v3 ], and the barycentric coordinates λν ∈ P1 are determined by λν (vµ ) =
δν,µ . The BB-coefficients bi jk are associated with the domain points ξi jk = (iv0 + jv1 + kv2 + v3 )/q, and we set
Dq (∆) := {ξi jk : T ∈ ∆}. For each cube Q, the points
from Q ∩ Dq (∆) are organized in rings Rν , ν = 0, . . . , q,
around vQ as shown in Fig. 3. The local representation
of s in its piecewise BB-form provides several advantages
including the efficient and stable evaluation of s (and its
derivatives). In this connection, de Casteljau’s algorithm
[0]
is an important tool. Given z ∈ R3 and bi jk = bi jk , a de
[η]

Casteljau step is to compute bi jk , i + j + k + = q − η,
as the inner product of (λ0 (z), λ1 (z), λ2 (z), λ3 (z))T and
[η−1]
[η−1]
[η−1]
[η−1]
(bi+1 jk , bi j+1k , bi jk+1 , bi jk +1 )T ∈ R4 . It is well known
[q]

that s(z) = b0000 , and for later use, we also note that after the (q − 1)th step three (independent) directional derivatives of s in z are immediately available, since it yields
[q−1]
bi jk , i + j + k + = 1. Simple characterizing formulae describing smooth joins for neighboring polynomial pieces exist for the piecewise BB-form [Far86]. A basic step in the

334

T. Kalbe & F. Zeilfelder / Hardware-Accelerated, High-Quality Rendering Based on Trivariate Splines

structural analysis [HNR∗ 04] shows that the smoothness for
splines on ∆ requires simple formulae of the form
b0 = (b1 + b2 )/2 and b0 = (b1 + b2 ) − (b3 + b4 )/2

4. Quasi-Interpolating Spline Models
Given volume data, i.e. scalar values fi jk ∈ R associated
with grid positions xi jk = (−1, −1, −1)T + 2h (i, j, k)T ∈
R3 , i, j, k = 0, . . . , n, quasi-interpolating splines s on ∆ are
directly determined by simply setting their BB-coefficients
appropriately. More precisely, we consider the local representation (1) of s and set its coefficients bξ , ξ ∈ Dq (∆), as
certain weighted sums of some local portion of the data,

∑

ωi jk fi jk ,

1
8
1
8

(2)

to be satisfied, where bν = bξ are certain BB-coefficients
associated with domain points ξ on the common triangular
face F = T1 ∩ T2 and within distance 1 to F (i.e. ξ = ξi jk1 ).
Hence, (2) shows that the smoothness of splines on ∆ is easily described when considering only two neighboring polynomial pieces in BB-form by means of averaging the involved BB-coefficients. On the other hand, when modelling
huge volume datasets many polynomial pieces on complete
tetrahedral partitions ∆ have to be computed, and the conditions in (2) can not be considered independently, since they
have to be satisfied simultaneously across all the interior triangular faces of ∆. This is the main reason for the highly
complex structure of the spline spaces and has to be taken
into account for any reconstruction method and the related
visualization algorithms built on top of them.

bξ =

1
8
1
8

(3)

1
8
1
8

1
24
1
24

5
24

1
96

5
24

1
24
1
24

1
96

5
24
5
24

1
8
1
8

Hallo

7
48

1
32

1
96

7
48

1
96
13
48

1
32

fijk

fijk

Hallo

1
32

fijk
13
48

Hallo

1
32

Figure 4: Determining set D3 (top, left) and its masks (colored dots correspond to Fig. 3, black dots illustrate values).
below). The quadratic quasi-interpolant can be described
similarly. The two quasi-interpolating splines differ in their
smoothness properties: quadratic splines are smooth on all
the faces of the cubes Q in ♦ and certain BB-coefficients
associated with domain points in the interior of Q are determined by averaging smoothness conditions, while the construction in [SZ07] solves the problem of finding an overall
C1 cubic spline approximating data locally without tetrahedron subdivisions. Another difference is the number of BBcoefficients within one cube, which is 65 and 175, respectively. On the other hand, both schemes are based on a 27
data stencil, the models as well as their derivatives approximate with order two, and operator norms are both close to 1.

xi jk ∈Θξ

where Θξ is a subset of the data being close to ξ with small
support, and ωi jk are fixed fractions weighting the value fi jk
at xi jk ∈ Θξ . This approach leads to realtime reconstructions
(for timings, see Tab. 1) since the BB-coefficients of s are
immediately available from the (typically huge) data without
the need of any intermediate computations such as proper
derivative estimation, matrix inversions, or usage of certain
(locally supported) spanning splines.
A main challenge of the above approach is often to find
appropriate weights in (3) and choices of Θξ , such that
the quasi-interpolants of low degree automatically satisfy
smoothness conditions and some additional important properties (small data stencils, symmetry, guaranteed approximation order, automatic derivative approximation, stability of operator). In our GPU implementations, we consider
the symmetric quasi-interpolation schemes for quadratic
[NRSZ05, RZNS04a] and cubic [SZ07] splines s on ∆.
These methods are connected with certain determining
sets, i.e. subsets Dq ⊆ Dq (∆) such that the BB-coefficients
bξ , ξ ∈ Dq , determine the spline by using (2). The construction of the cubic quasi-interpolant is illustrated in Fig. 4,
where we show D3 as well as the masks determining its
associated BB-coefficients. The remaining BB-coefficients
are then obtained by applying the rules shown in Fig. 7 (see

Figure 5: A spline isosurface and its octree approximating
aneurism data. Colors indicate different node levels.
In our algorithm, we first perform some preprocessing
steps on the CPU. We organize the given data (xi jk , fi jk ) in a
min-max octree (see Fig. 5), i.e. every node is characterized
by its minimal and maximal data values fmin , fmax of its successors. Fixing an arbitrary isovalue ρ only branches of the
octree with the property ρ ∈ [ fmin , fmax ] have to be taken into
consideration. For the remaining data, we compute splines
according to the above approach, i.e. for each Q ∈ ♦ corresponding to such a data point xi jk , we determine the 24
polynomial pieces s|T , where T ⊆ Q. We proceed by exploiting the convex hull property of the BB-form (1) to indicate
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

335

T. Kalbe & F. Zeilfelder / Hardware-Accelerated, High-Quality Rendering Based on Trivariate Splines
0 1

2

3

4

5

6

4i . . . 4i + 3

7
...

0
−→

←− Q0
...

←− Q1

−→

...

j

←− Qi
...

..
.

...

0

1

= 12 (

+

= 12 (

)

+

)

...

1023

i
...

Q0 Q1 Q 2
...

...
Qi
...

...
Qj·210 . . .

Q1023
...
...

Qj·210 +i

..
.
σ−1

← Qj·210 +1023 →

← Q(σ−1)·210 +i →

2

j

←− Q1023 −→
..
.
...

← Qj·210 +i →

..
.

0

−→

...

←− Qj·210 −→

σ−1
← Q(σ−1)·210 →

. . . 4095
...

R G R G R G R G
B A B A B A B A

= 12 (

+

−

+

= 14 (

)

R G
B A

+

= 18 (

+

12

i=1

+

1
(
16

)−

)

8

)
i=1

..
.
...

Q(σ−1)·210 . . .

Q(σ−1)·210 +i

R G R G R G R G
B A B A B A B A
R G R G R G R G
B A B A B A B A

R G R G R G R G
B A B A B A B A
R G R G
B A B A

= 12 (

+

= 12 (

+

)

= 12 (

+

)

)

Figure 6: Layout of the textures representing D2 (top) and
D3 (bottom). Colors indicate the correspondence with Fig. 3.
all the remaining tetrahedra T ∈ ∆, where the polynomial
piece s|T potentially intersects the isosurface. Only the set
T of these relevant tetrahedra with cardinality κ, called the
bounding geometry, need to be considered for visualization.
In practice, we often observe that these preprocessing steps
essentially reduce the amount of data (i.e. BB-coefficients,
bounding geometry) to be sent to the GPU.
5. A Kernel for Hardware-Accelerated Visualization
We give the GPU specific details of our approach for
hardware-accelerated visualization. We give the details on
the organization of data streams determining the splines and
their associated bounding geometry. Then, we describe our
kernel involving vertex and fragment shaders and discuss the
usage of geometry shaders.
5.1. Organization of Data Streams
In contrast to the standard models (e.g. trilinear tensor
products), our splines possess a highly complex structure. Therefore, efficient GPU rendering is not straightforward and requires a sophisticated organization of the data
streams (i.e. the bounding geometry and its associated BBcoefficients). In what follows, we describe our encoding system for the splines and our implicit scheme for bounding geometry retrieval. These parts of the algorithm build the basis
for efficient data processing along the graphics pipeline.
We employ the uniform structure of the underlying tetrahedral partition ∆, use the symmetry of the determining sets
Dq (see Sect. 4), and distinguish quadratic and cubic splines.
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

= 12 (

+

+

−

)

=

=

−

+

1
(
32

8
i=1

1
(
2

+

) + 18 (

)

24
i=1

)−

3
(
32

24

)
i=1

Figure 7: Repeated averaging for on-the-fly computation.
Top: scheme for q = 2. Bottom: additional rules for q = 3.
Note that, refering to Fig. 3 & 4, D2 ⊆ R2 consists of the
domain points on the edges of ♦ (red and blue dots), while
D3 ⊆ R3 contains the domain points from the interior of
the triangular faces of the cube’s boundary (brown dots), in
addition. In order to encode the quasi-interpolating splines,
e.g. its determining sets, we use two-dimensional floating
point RGBA-textures. Fig. 6, top, illustrates our encoding
system for quadratic splines. Since 20 BB-coefficients have
to be stored for each cube Q, in this case we use two textures. We choose the first texture to consist of the 12 "blue"
and 4 "red" BB-coefficients associated with points from
D2 in four successive RGBA quadruplets, while the second texture contains the 4 remaining "red" coefficients of
D2 . In the case of cubic splines, 56 BB-coefficients have
to be encoded for each cube Q. To do this, we use four
textures, where the correspondence of their entries with the
BB-coefficients associated with points from D3 follow from
the colors used in Fig. 3 and 6 (bottom). We emphasize
that each row of the textures consists of 1024 entries cor-

336

T. Kalbe & F. Zeilfelder / Hardware-Accelerated, High-Quality Rendering Based on Trivariate Splines

responding with current hardware architectures, where 4096
is the usual upper bound for the maximum width of 2Dtextures. Although we only use 2 and 4 textures, respectively,
this encoding allows to store huge spline models consisting
of up to 3 · 225 ≈ 108 polynomial patches. For any T contained in Q, we apply repeated averaging successively to the
rings Rν with decreasing ν (see Fig. 7) to compute the remaining BB-coefficients bi jk of s|T on-the-fly. Our encoding
schemes involving spline structure significantly reduces the
amount of data to be processed by the GPU. Theoretically,
compared to direct approaches [SGS06, LB06] sending BBcoefficients of all the polynomial pieces of s, we only need
about 8% (q = 2) and 12% (q = 3) of the data, respectively.
On the other hand, our tests (cf. Tab. 1) indicate that for realworld data about half of the tetrahedra per cube are relevant.
Hence, in practice memory requirements decrease by about
a factor of 5 to 6 leading to an improved texture cache utilization. Thus, for large realworld datasets (see Sect. 6), we
observe an essential speed-up.
In order to minimize data traffic between CPU and GPU
as well as data access on the GPU, in addition we develop
an implicit scheme for the bounding geometry retrieval. This
scheme uses display lists and is applied to both spline methods, but heavily exploits the uniformity of ∆. First, we encode the vertices of each (object space) tetrahedron in the
cube [−1, 1]3 by creating 24 fixed display lists DT0 , . . . , DT23
using triangle strips. However, for rendering the world space
coordinates of the vertices of T ∈ T (see Sect. 4) need to
be known. We use a major display list, where each cube Q
is treated by first referencing the coordinates of vQ . For later
determination of the texture coordinates in the vertex shader
(see Sect. 5.2) we also store a unique cube index α, in addition (where we use the fourth coordinate of vQ ). Then we
store an additional pointer to each of the display lists DTµ
with Tµ ⊆ Q. This way explicit vertex encoding for T ∈ T
is avoided, and the bounding geometry is completely determined with low memory demand. If δ ∈ {1, . . . , 24} is the
average number of relevant tetrahedra T per cube, then we
need κ + 4/δ · κ ∈ [7/6 · κ, 5κ] (κ as in Sect. 4) memory
units (i.e. WORDS) to completely describe the geometry, because κ pointers, the coordinates of vQ and α are stored in
the major display list. In practice, we often have δ = 12, and
thus, 4/3 · κ memory units are needed for our geometry retrieval. This can be compared with the method in [SGS06],
where the (world space) geometry of T ∈ T is directly encoded by means of the vertex coordinates which, by using
triangle strips, results into ≥ 18κ memory units.
In addition, the octree enables us to use hierarchical view
frustum culling ( [AMH02], pp. 363), which significantly
speeds up the rendering, in particular, for closeup views (see
Fig. 8). Octree nodes are recursively tested against the viewing frustum during the rendering: if a node is identified as
being outside, the corresponding branch of the tree is truncated. To apply this technique, instead of using a single major display list, we create a set of display lists each corre-

Figure 8: Comparison of cubics: trilinear (left) and smooth
trivariate C1 spline (right). Closeup of bonsai (2563 voxels).
sponding to a non-empty node on a fixed (octree) level θ ,
where we typically choose θ ∈ {4, 5, 6}.
5.2. Vertex Shader Calculations
While visible fragments of the splines are finally determined
in the fragment stage, vertex shaders provide the necessary
data for the rasterization. In what follows, we describe our
vertex shader calculations. First, for every tetrahedron T ∈
T , the vertex v = vµ is provided by our implicit scheme.
Then, BB-coefficients of s|T are identified (using Dq ), and
some additional data is calculated. Finally, vQ is added to
the vertex followed by a transformation in screen space using
concatenated modelview and projection matrices.
In order to determine the BB-coefficients of s|T , we first
have to read the values associated with the points Dq ∩ Qα ,
where α is such that T ⊆ Qα . The corresponding (centered and normalized) texture coordinates (u, v), where u =
(u0 , u1 , u2 , u3 )T ∈ R4 and v ∈ R, of the four consecutive
RGBA texels (i.e. width is 4096 in Fig. 6) are given as uτ =
(1/8192)(8i + 2τ + 1), τ = 0, . . . , 3, v = (1/2σ )(2 j + 1),
where i = α mod 1024, j = α div 1024 (σ as in Fig. 6).
The formulae for the texture coordinates of the remaining
textures are similar. Fig. 6 indicates that 5 (q = 2) and 14
(q = 3), respectively, texture fetch operations have to be performed. Then, the remaining BB-coefficients of s|T are calculated with the rules shown in Fig. 7. Note that by symmetry of Dq , we do not have different cases for differing
tetrahedra in Qα , here.
In order to compute polynomial pieces s|T along viewing rays in the fragment shader (see below) some additional data is necessary. First, we need barycentric coordinates w.r.t. T of two different points on the ray through v.
A natural choice is to use v and its companion point v¯ =
v + (v − (e − vQ ))/||v − (e − vQ )|| (see Fig. 9), where e is the
vector associated with the eye point in world space coordinates. Obviously, the barycentric coordinates of v are given
as λν (v) = λν (vµ ) = δν,µ (see Sect. 3). On the other hand,
we determine λ (¯v) = (λ0 (¯v), λ1 (¯v), λ2 (¯v), λ3 (¯v))T ∈ R4 by
using a 4 × 4 matrix appearing in the following equation:
λ (¯v) =

v0
1

v1
1

v2
1

v3
1

−1

v¯
.
1

There are 24 such matrices (depending on the choice of T )
which we precompute once and forever. For efficient access
on the GPU a fixed array of uniform variables ( [Ros06],
p. 79) is used for their storage. The barycentric coordinates
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

337

T. Kalbe & F. Zeilfelder / Hardware-Accelerated, High-Quality Rendering Based on Trivariate Splines
[1]

−(e − vQ )

(0, 0, 0)

vQ

[1]

¯ For q ∈ {2, 3}, the computation of p
bi jk (w) and bi jk (w).
[1]

via blossoming is illustrated in Fig. 10. If q = 3, bi jk (w)
[1]

v

(v − (e − vQ ))/||v − (e − vQ )||
v
¯

Figure 9: Companion point v¯ for v and center point vQ .
)
(w

λ
w
λ(

)

b30 , b20
w)
λ(
λ(
w
¯)

b21 , b11

λ(
w
¯)
λ(
w
¯)

λ(
w
¯)
λ(
w
¯)

λ(
w
¯)

b12 , b02

b03

Figure 10: Trivariate blossoming in Pq , q = 2, 3.
of v and v¯ are then assigned to varying slots for linear interpolation in the rasterization, in order to obtain the barycentric coordinates λ (w) of points w on triangular faces of T
¯ in the fragment shader (see below).
and its companions w
Note that these calculations hide texture access latencies.
For optimizing the computation of s|T along rays applying
[1]

blossoming, we precalculate the BB-coefficients bi jk (v) and
[1]

bi jk (¯v) (see Sect. 3), and assign them to varying slots so that
[1]

[1]

¯ by linear interpolation.
we obtain bi jk (w) and bi jk (w)
5.3. Fragment Shader Calculations
The main purpose of our fragment programs is to determine
for each fragment f a point wρ ∈ R3 such that s(wρ ) = ρ,
where wρ is the closest point (to the eye) on the viewing
ray r corresponding to f . If wρ is a valid intersection with
the isosurface, then we compute the surface normal nρ at
wρ and perform the lighting calculations for f . Alternatively,
the normal can be saved to a buffer for a deferred shading
pass. As usual, the visibility, i.e. the determination of the
final color of the fragment, is solved by the z-buffer.
For every T ∈ T , we consider each front-facing triangle D of T , and its projection to screen space. For each
of the resulting fragments, the rasterization gives us the
barycentric coordinates of the corresponding point w ∈ D,
and hence the corresponding viewing ray r is determined by
¯ − w), t ∈ R. In order to compute the smallest
r(t) = w +t(w
tρ ≥ 0 such that s(r(tρ )) = ρ (if it exists), we need an appropriate representation of the univariate polynomial p defined by p(t) = s(r(t)), t ≥ 0. In order to minimize the necessary (bivariate and trivariate) de Casteljau steps, we apply blossoming [Sei93] to compute the univariate BB-form
of p, p(t) = ∑ bi j Bi j (t), t ∈ [0, 1]. Roughly speaking, the
i+ j=q

blossom approach includes and generalizes the de Casteljau algorithm in that the arguments may vary on the different levels. The rasterization provides the barycentric coordi¯ (w.r.t. T ) as well as the BB-coefficients
nates λ (w) and λ (w)
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

¯ are associated with points shown as green dots,
and bi jk (w)
and 16 elementary de Casteljau operations (linear interpolations) are performed to determine p: 3 de Casteljau steps on
level 2 (red dots) and 4 de Casteljau steps on level 3 (black
[1]
[1]
¯ correspond with the red
dots). If q = 2, bi jk (w) and bi jk (w)
dots (on top of Fig. 10), and only 3 elementary de Casteljau
operations are needed to determine p.
The computation of tρ requires a root finding algorithm.
Since p is a univariate quadratic or cubic polynomial, well
known formulae [HE95] can be applied to its monomial
form to determine the zeros of p − ρ in an analytical and
stable way. However, for cubic equations, Cardano’s formulae are relatively complicated and involve conditional
( )
branches. Alternatively, we apply Newton’s method tn+1 =
( )

( )

( )

tn + p(tn )/p (tn ), n ∈ N0 , to find all potential zeros in
[0, 1]. Here, we exploit the parallelism of the GPU by us(0)
(1)
(2)
ing three starting values t0 := 0, t0 , and t0 := 1. If no
(1)

inflection point exists in [0, 1], we chose t0 := 1/2. Note
that we use a fixed number I of iterations, where in practice
we observed that I = 5 is sufficient to eliminate visual artifacts (i.e. missed intersections, especially in regions with
( )
high curvature). The barycentric coordinates λ (wρ ) w.r.t.
( )

[ ]

( )

¯ − w), where tρ is an approximative
T of wρ = w + tρ (w
¯
zero, are given by linear interpolation of λ (w) and λ (w).
( )
(0) (1) (2)
The smallest, non-negative value tρ in {tρ ,tρ ,tρ } de( )

termines the closest point wρ = wρ , with s(wρ ) = ρ, if, in
( )

addition λν (wρ ) ≥ 0, ν = 0, . . . , 3. If no such point exists,
we discard the fragment. Observe that the usage of barycentric coordinates is the base of our simple, but efficient clipping procedure. In contrast to this, different approaches such
as [SGS06] require explicit knowledge of the vertices of T
to clip against its four triangular faces.
For performing the lighting calculations (e.g. Phong
shading), we need the surface normal nρ = ∇s(wρ ) =
( ∂∂ xs (wρ ), ∂∂ ys (wρ ), ∂∂ sz (wρ ))T of s|T in wρ . To compute nρ ,
we therefore use the connection of the BB-coefficients
[q−1]
bi jk (wρ ), i + j + k + = 1, with directional derivatives in
wρ discussed in Sect. 3 in conjunction with some general
relations of derivatives in direction of the edges of T with
the standard derivatives ∂ /∂ x, ∂ /∂ y and ∂ /∂ z, discussed
[q−1]
in [RZNS04a]. For q = 2 the bi jk are immediately avail[q−1]

[q−1]

¯ usable from linear interpolation of bi jk (w) and bi jk (w)
ing the ray parameter tρ . For q = 3 we can proceed accordingly. Now, for instance ∂∂ xs (wρ ) is given as the inner prod[q−1]

uct of the vectors bi jk (wρ ) and λν (x), ν = 0, . . . , 3, where
λν (x) are the barycentric coordinates of x = (1, 0, 0)T . We
calculate the values λ (x), λ (y), λ (z) for each of the 24 cases
once and forever and store them in a small 1D-texture for efficient access in the fragment shader.

338

T. Kalbe & F. Zeilfelder / Hardware-Accelerated, High-Quality Rendering Based on Trivariate Splines

Figure 11: Left: texture mapped QSS visualization of the
Marschner-Lobb test function (643 voxels). Right: QSS visualizations of SDF generated data neptune, (128 × 256 × 128
voxels), and gargoyle, (1283 voxels).
5.4. Discussion: Usage of Geometry Shader
We extended our implementation by using geometry shaders
[NVI07], where each T ∈ T is processed with a single call
to the graphics API (i.e. glVertex). The geometry shader
receives the BB-coefficients from the vertex program and
then emits the tetrahedron geometry. Surprisingly, we observe better performance without geometry shaders. One of
the reasons is the fixed number of shader units utilizable
in the three stages of the programmable graphics pipeline.
Units assigned for execution of geometry programs are simply unavailable for the vertex and fragment shaders. While
using geometry shaders reduces redundancies in the vertex
shader calculations, in practice no better performance has
been observed. This suggests that the redundancies have already been well hidden by the vertex and texture caches. We
conclude that at this time, our approach using only vertex
and fragment shaders is advantageous.
6. Results
We intensively tested our methods by using synthetic and
realworld datasets with a focus on the visualization issues.
Therefore, without discussing the details, we simply note
here that tests with smooth functions (as the Franke type exponential shown in Fig. 1 and Marschner-Lobb in Fig. 11)
confirmed that the quadratic and cubic quasi-interpolating
splines as well as their first derivatives yield approximation
order 2, where, somewhat surprisingly, we observe that the
constants are slightly better for cubics.
Our results on realworld datasets are summarized in
Tab. 1. We use two sources of datasets: measured data from
VolVis, University of Tübingen, and SDF generated datasets,
where we developed our own tools for computing the signed
distances from polygonal meshes. For each dataset, we give
information on the data and splines, memory requirements,
preprocessing times, and visualization performance. The table contains the cardinality of T , the amount of memory
needed to encode Dq , and for the bounding geometry (see
Subsect. 5.1). Although memory requirements seem to be
relatively high at first glance, our implicit isosurfacing approach bears comparison with standard methods like Marching Cubes (MC) (see [DZTS06] for a GPU implementation of MC. For the dataset aneurism, the authors report
frame rates of about 54 fps). Moreover, the preprocessing

Figure 12: Visual comparisons of QSS (left) and S31 (right).
Top: closeup of aneurism (2563 voxels). Bottom: reflection
lines on neghip (643 voxels).
includes creation times for the min-max octrees. Timings
for the spline reconstruction (i.e. computation of Dq , T ,
including data transfer between CPU and GPU) are shown
in the next two columns for quadratic super splines (QSS)
and cubic C1 splines (S31), respectively. Note that even for
huge datasets these realtime spline reconstructions are available in a few seconds on a standard PC. In addition, Tab. 1
shows the frame rates on a 1280 × 1024 viewport, where
we use two different GPUs (NVIDIA 8800 Ultra (G80) and
NVIDIA 7600 Go Mobile Graphics Chip (G70)). In contrast to the G80, the G70’s performance of texture reads in
the vertex shader is limited. Therefore, on this architecture
we store Dq in the (major) display lists. For large datasets,
the lower frame rates correspond to a viewing position from
a far distance, when all spline patches of the models are
potentially visible and need to be processed. Comparisons
with triangular meshes and tests using a performance monitoring tool (ShaderPerf [NVI07]) show that in these cases
performance is limited by geometry setup. Using hierarchical view frustum culling (see Subsect. 5.1), frame rates significantly increase for closeups (see Fig. 8 and 12), i.e. we
observe factors upto 4, and the fragment shader complexity becomes the limiting factor. Two further examples are
shown in Fig. 11, right, where the data is generated with
our SDF tools and numbers are similar to those shown in
Tab. 1. These numbers can be compared with the direct approach discussed in Subsect. 5.1 treating spline patches as
unconnected polynomials and using a more straightforward
method to deal with the bounding geometry. Our approach
provides a far better use of GPU memory and therefore
significantly higher frame rates. With the direct approach,
for example bonsai needs 235.9 MB for D2 and 566.1 MB
for the bounding geometry. Compared with pure CPU implementations [RZNS04a, SZH∗ 05], in our GPU approach
frame rates usually increase by factors between 10 and 100.
Depending on the data, even higher speedups were observed
(for example, for aneurism we have a factor of 180).
We proceed with a visual comparison of cubic splines,
namely the standard trilinear and our trivariate C1 spline.
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

T. Kalbe & F. Zeilfelder / Hardware-Accelerated, High-Quality Rendering Based on Trivariate Splines

dataset
neghip
dragon
aneurism
lobbster
foot
bonsai

ρ
0.40
0.50
0.40
0.14
0.40
0.14

data & splines
#cubes
#patches
1.0E4
1.17E5
5.0E4
5.84E5
7.6E4
8.53E5
1.5E5
1.70E6
3.5E5
4.17E6
5.1E5
6.18E6

memory requirements [MB]
D2
D3
geometry
0.77
2.16
0.48
3.84
10.77
2.41
5.79
16.20
2.95
11.20
31.35
7.00
27.03
75.70
16.83
38.90
108.93
25.27

preprocessing time (sec.)
octree QSS
S31
0.05
0.2
0.4
0.17
1.2
1.5
0.60
2.0
2.5
1.00
3.3
4.1
1.30
6.6
8.0
1.30
13.8
16.0

339

frames per second
QSS(G80) QSS(G70)
S31(G80)
40-60 (15-35)
20-34
20-40 (8-12)
14-30
15-22 (5-12)
10-18
7-15 (3-5)
4-9
4-12 (1-4)
2.7-8
2.5-12 (0.5-2)
1.5-8

Table 1: Memory requirements, preprocessing, and frame rates on selected boards (G80: 128 scalar shader units. G70: 5 vertex
and 8 fragment vector shader units) for quadratic super splines (QSS) and cubic C1 splines (S31) using different datasets.

Figure 13: Left: transparency (dataset foot, 2563 voxels).
Right: non-photorealistic shading of neghip.
While it is known that visualizations with trilinear splines
are very fast [KW03] (for aneurism, we achieved frame rates
≥ 60 fps), we observe that splines on ∆ appear smoother and
much more natural having an overall higher visual quality.
For instance, using our approach the leaves of the realworld
example in Fig. 8 possess improved boundaries with almost perfect silhouettes, while the trilinear approach smears
out the edges and fails to reproduce the fine structures. In
Fig. 1, we visually compare QSS with the more recent approach denoted by S31. Because of their approximating nature, both methods are quite insensitive concerning noise,
and automatically avoid undesired oscillation and staircasing. While memory consumption to encode the splines is
about three times higher for S31, this approach significantly
reduces the undesired visibility of the underlying partition
in areas of high curvature. The closeup on top of Fig. 12
showing the thin dentrites of the aneurism demonstrates this.
Moreover, Fig. 12, bottom, illustrates that for S31 reflection
lines have an improved appearance. In addition, standard
techniques from Computer Graphics are straightforward to
apply, see Fig. 1, 11, and 13, where we illustrate reflection mapping, texturing, transparency (using depth peeling),
and non-photorealistic shading, respectively. Moreover, our
splines have an inherent level of detail, i.e. we can zoom far
in without the need to refine the spline model, and visualizations remain smooth (see Fig. 8, right).

particular, we give the first visualizations of cubic C1 quasiinterpolating splines. Since we deal with splines of low and
lowest possible degree, our algorithms are efficient and stable. We propose to store only a subset of spline coefficients
on the GPU and calculate the remaining BB-coefficients onthe-fly in the vertex shader, which leads to a far better utilization of GPU memory and results in higher frame rates.
In connection with our implicit scheme for bounding geometry retrieval, resulting in significant memory reduction, it is
now possible to render from large datasets and with acceptable frame rates, which has not been possible prior to our
work. Besides, we show that spatial data structures (e.g. octrees) can be utilized to speed up the preprocessing calculations and rendering times for closeup views significantly.
We emphasize that the idea of storing splines as determining sets in textures is very flexible and bears high potential for further extensions. In this connection, we point
out that BB-coefficients can be easily modified on the GPU,
leading to numerous additional interactive applications in
CAGD, Solid Modeling, and Volume Animation. Moreover, current developments in GPU hardware and APIs
(e.g. CUDA, [NVI07]) give rise to shift our preprocessing
calculations (spline, octree) from CPU to GPU, allowing realtime visualization of varying surfaces, for instance. The
main challenges here are the dynamic process of constructing the sets of relevant tetrahedra as well as to find appropriate means to deal with the bounding geometry. NVidia’s
CUDA MC implementation [NVI07] and Lefohn et al.’s
GPU octrees [LKS∗ 06] can serve as good starting points.
Another extension could involve hierarchies in order to reduce data even further, improving the performance in cases
where we are limited by geometry setup (see Sect. 6). In
addition, designing realtime reconstructions based on discrete data (uniform and scattered [RZNS04b]) for splines
with higher smoothness and approximation order is an interesting but complex topic for future research.

7. Conclusion and Future Work
We develop the first GPU based, high quality rendering from
measured volume data, functional data, and distance fields
using trivariate splines, where we exploit the spline structure and uniformity of the underlying tetrahedral partition. In
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

Acknowledgements
The research was supported by grant GZ ZE 443/7-1, AOBJ: 526229, from the Deutsche
Forschungsgemeinschaft (DFG) in the project “Interaktive 3D Visualisierung mit glatten
Splines auf Tetraederpartitionen”. In addition, the authors thank the anonymous reviewers
for their important comments improving the manuscript essentially.

340

T. Kalbe & F. Zeilfelder / Hardware-Accelerated, High-Quality Rendering Based on Trivariate Splines

References
[AMH02] A KENINE -M ÖLLER T., H AINES E.: Real-Time Rendering, 2nd Edition. A.K. Peters Ltd., 2002.
[Baj99] BAJAJ C.: Data Visualization Techniques. John Wiley &
Sons, 1999.
[BMDS02] BARTHE L., M ORA B., D ODGSON N., S ABIN M.:
Triquadratic reconstruction for interactive modelling of potential fields. In Proc. Shape Modeling International 2002 (2002),
pp. 145–153.

Two Lagrange interpolation methods based on C1 splines on
tetrahedral partitions. In C. K. Chui et.al. (Eds.), Approximation
Theory XI: Gatlinburg 2004 (2005), pp. 101–118.
[NVI07] NVIDIA C ORPORATION: Developer documentation.
http://developer.nvidia.com, 2007.
[OLG∗ 07] OWENS J., L UEBKE D., G OVINDARAJU N., H ARRIS
M., K RÜGER J., L EFOHN A., P URCELL T.: A survey of generalpurpose computation on graphics hardware. Computer Graphics
Forum 26, 1 (2007), 80–113.

C HUI C.: Multivariate Splines. CBMS 54, SIAM, 1989.

[PBM02] P RAUTZSCH H., B OEHM W., M.PALUSZNY: Bézier
and B-Spline techniques. Springer, 2002.

[DZTS06] DYKEN C., Z IEGLER G., T HEOBALT C., S EIDEL H.P.: HistoPyramids in iso-surface extraction. Tech. rep., MPI
Saarbrücken, 2006.

[Rei05] R EIS G.: Hardware based Bézier patch renderer. In Proceedings of IASTED Visualization, Imaging, and Image Processing (VIIP) 2005 (2005), pp. 622–627.

[Far86] FARIN G.: Triangular Bernstein-Bézier patches. CAGD
3, 2 (1986), 83–127.

[Ros06] ROST R.: OpenGL Shading Language, 2nd Edition.
Addison-Wesley, 2006.

[GBK05] G UTHE M., BALAZS A., K LEIN R.: GPU-based trimming and tessellation of NURBS and T-Spline Surfaces. In Proceedings of Siggraph 2005 (2005).

[RZNS04a] RÖSSL C., Z EILFELDER F., N ÜRNBERGER G., S EI DEL H.-P.: Reconstruction of volume data with quadratic super
splines. IEEE Trans. Vis. & CG 4, 10 (2004), 397–409.

[gpg] General-purpose comp. using graphics hardware. http:
//gpgpu.org.

[RZNS04b] R ÖSSL C., Z EILFELDER F., N ÜRNBERGER G., S EI DEL H.-P.: Spline approximation of general volumetric data.
ACM Sym. on Solid and Phys. Mod. (2004), 74–82.

[Chu89]

[HE95] H ERBISON -E VANS D.: Solving quartics and cubics for
graphics. In Graphics Gems V, Paeth A., (Ed.). 1995, pp. 3–15.
[HNR∗ 04]

H ANGELBROEK T., N ÜRNBERGER G., RÖSSL C.,
S EIDEL H.-P., Z EILFELDER F.: Dimension of C1 splines on
type-6 tetrahedral partitions. J. Approx. Theory (2004).

[HS05] H ADWIGER M., S IGG C.: Fast third-order texture filtering. In GPU Gems II, Pharr M., (Ed.). Addison-Wesley, 2005,
pp. 313–329.
[JBL∗ 06] JANG Y., B OTCHEN R., L AUSER A., E BERT D.,
G AITHER K., E RTL T.: Enhancing the interactive visualization of procedurally encoded multifield data by Ellipsoidal Basis
Functions. Computer Graphics Forum 25, 3 (2006), 587–596.
[JBS06] J ONES M., BAERENTZEN A., S RAMEK M.: 3D distance
fields: a survey on techniques and applications. In IEEE Trans.
Vis. & CG (2006), pp. 581–599.
[KW03] K RÜGER J., W ESTERMANN R.: Acceleration techniques for GPU-based volume rendering. In IEEE Vis. (2003),
pp. 287–292.
[LB06] L OOP C., B LINN J.: Real-time GPU rendering of piecewise algebraic surfaces. ACM Trans. on Graphics 25, 3 (July
2006), 664–670.
[LKS∗ 06] L EFOHN A., K NISS J., S TRZODKA R., S ENGUPTA
S., OWENS J.: Glift: Generic, efficient, random-acces GPU data
structures. ACM Trans. on Graphics 25, 1 (2006), 60–99.
[LS07] L AI M.-J., S CHUMAKER L.: Spline functions on Triangulations. Cambridge Universiy Press, 2007.
[ML94] M ARSCHNER S., L OBB R.: An evaluation of reconstruction filters for volume rendering. In Proc. IEEE Vis. (1994),
pp. 100–107.
[NRSZ05]

N ÜRNBERGER G., R ÖSSL C., S EIDEL H.-P., Z EIL FELDER F.: Quasi-interpolation by quadratic piecewise polynomials in three variables. CAGD, Vol. 22 (2005), 221–249.

[NSZ05]

N ÜRNBERGER G., S CHUMAKER L., Z EILFELDER F.:

[Sei93] S EIDEL H.-P.: An introduction to polar forms. IEEE CG
& Appl. 13, 1 (1993), 38–46.
[SGS06] S TOLL C., G UMHOLD S., S EIDEL H.-P.: Incremental
raycasting of piecewise quadratic surfaces on the GPU. In Proc.
IEEE Symp. Inter. Raytr. (2006), pp. 141–150.
[SJP05] S HIUE L.-J., J ONES I., P ETERS J.: A Realtime GPU
Subdivision Kernel. In Proceedings of Siggraph 2005 (2005).
[SS04] S CHUMAKER L., S OROKINA T.: Quintic spline interpolation on type-4 tetrahedral partitions. Adv. Comput. Math. 21
(2004), 412–444.
[SSS06] S CHWARZ M., S TAGINSKI M., S TAMMINGER M.:
GPU-based rendering of PN triangle meshes with adaptive tesselation. In Proc. Vision, Modeling, and Visualization 2006 (2006),
pp. 161 – 168.
[SW06] S CHNEIDER J., W ESTERMANN R.: GPU-friendly highquality terrain rendering. Journal of WSCG 14, 1-3 (2006), 49–
56.
[SWBG06] S IGG C., W EYRICH T., B OTSCH M., G ROSS M.:
GPU-based ray-casting of quadratic surfaces. In Proceedings Eurographics (2006), pp. 59–65.
[SZ07] S OROKINA T., Z EILFELDER F.:
Local QuasiInterpolation by cubic C1 splines on type-6 tetrahedral partitions.
IMJ Numerical Analysis 27 (2007), 74–101.
[SZH∗ 05] S CHLOSSER G., Z EILFELDER F., H ESSER J., RÖSSL
C., N ÜRNBERGER G., M ÄNNER R., S EIDEL H.-P.: Fast visualization by shear-warp on quadratic super-spline models using
wavelet data decompositions. Proc. IEEE Vis. 2005 (2005), 45–
55.
[VKG04] V IOLA I., K ANITSAR A., G RÖLLER M.: GPU-based
frequency domain volume rendering. In Proc. of SCCG 2004
(2004), pp. 49–58.
[WS01] WALD I., S LUSALLEK P.: State of the art in interactive
ray tracing. In STAR, EUROGRAPHICS 2001. 2001, pp. 21–42.

c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.


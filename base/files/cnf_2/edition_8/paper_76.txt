Eurographics/IEEE-VGTC Symposium on Visualization 2008
A. Vilanova, A. Telea, G. Scheuermann, and T. Möller
(Guest Editors)

Volume 27 (2008), Number 3

Visual Comparison of Hierarchically Organized Data
Danny Holten1 and Jarke J. van Wijk2
1 d.h.r.holten@tue.nl, Eindhoven University of Technology
1 vanwijk@win.tue.nl, Eindhoven University of Technology

Abstract
We provide a novel visualization method for the comparison of hierarchically organized data. Our technique
visualizes a pair of hierarchies that are to be compared and simultaneously depicts how these hierarchies are
related by explicitly visualizing the relations between matching subhierarchies. Elements that are unique to each
hierarchy are shown, as well as the way in which hierarchy elements are relocated, split or joined. The relations
between hierarchy elements are visualized using Hierarchical Edge Bundles (HEBs). HEBs reduce visual clutter,
they visually emphasize the aforementioned splits, joins, and relocations of subhierarchies, and they provide an
intuitive way in which users can interact with the relations. The focus throughout this paper is on the comparison
of different versions of hierarchically organized software systems, but the technique is applicable to other kinds of
hierarchical data as well. Various data sets of actual software systems are used to show how our technique can
be employed to easily spot splits, joins, and relocations of elements, how sorting both hierarchies with respect to
each other facilitates comparison tasks, and how user interaction is supported.
Categories and Subject Descriptors (according to ACM CCS): I.3.3 [Computer Graphics]: Viewing Algorithms I.3

1

Introduction

Comparison of hierarchical information is of importance
within various areas; examples are evolutionary biology, human resources & personnel, and software development. We
focus here on this latter category.
For software engineers (SEs) it is important to be able
to quickly gain insight in the software architecture and the
actual source code of a software system. This knowledge
is needed for maintenance tasks, i.e., to address change requests, to fix bugs, or to implement new functionality.
It is often hard for an SE to quickly get up to speed with
the current version of a software system. This is especially
true for SEs that have previously been involved in the creation or maintenance of a software system, but who have not
worked on said system for a longer period of time. This is
due to the fact that the source code (and possibly the highlevel architecture) of the software system may have evolved
considerably in the meantime.
Because of the emphasis of our research on software visualization, the focus throughout this paper is on the comparison of different versions of hierarchically organized software
systems. However, the visual tree comparison technique presented in this paper could be applied to other kinds of hierarchical data as well. Examples are phylogenies within evolutionary biology and organograms within the context of human resources & personnel.
Based on what SEs generally find important, the main rec 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.
Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and
350 Main Street, Malden, MA 02148, USA.

quirements of our visual tree comparison technique and relevant assumptions are described below.
It is important for SEs to be able to quickly see what
has been modified between two versions of a hierarchically
organized software system. The visualization should therefore be able to provide a global overview of the differences
and similarities between two hierarchies in a single picture. The depicted splits, joins, and relocations of subsystems should entice a user to further explore these in more
detail using the provided interaction techniques.
Our proposed technique works well when the hierarchy
encodes a classi cation; the context that we consider provides a semantic for nodes at higher levels in the hierarchy, i.e., internal nodes can generally be interpreted in terms
of their child nodes. We therefore perform the hierarchyto-hierarchy mapping by matching the respective leaf sets.
This assumption is based on the following. In case of software systems, a possible, source code-centric perspective is
to view the actual functionality of a system as residing in the
leaf nodes of its hierarchy; the internal nodes are generally
structuring / classification elements that create groupings of
lower-level elements. An example is the decomposition of a
Java program into packages, classes, and methods. The actual functionality can be viewed as residing in the methods,
whereas classes and especially packages are used as container objects for these functional elements.
The rest of the paper is organized as follows. Section 2
describes related work in the areas of tree visualization and

760

Danny Holten & Jarke J. van Wijk / Visual Comparison of Hierarchically Organized Data

visual comparison of trees. Section 3 gives an in-depth description of the design choices for our visualization. This
section also explains how input data is obtained, how hierarchies are sorted with respect to each other to facilitate
comparison, and how user interaction is addressed. Section
4 shows the results of applying our technique to different
data sets, followed by Section 5, in which advantages and
limitations are discussed. Finally, Section 6 provides possible directions for future work.

2

Related Work

Since the objects to be compared are trees, we first give an
overview of tree visualization techniques. This is followed
by a survey of methods for the visual comparison of trees.
2.1

Tree Visualization

Tree visualization techniques are mostly based on nodelink- or enclosure-based representations. Node-link representations depict relations between parent and child nodes
by lines that connect the nodes. Enclosure-based techniques
use the convention that parent nodes visually enclose their
respective child nodes. Enclosure-based tree visualizations
are normally more space-efficient, but perceiving the hierarchical relationship is generally easier and more intuitive
when using a node-link representation.
A frequently used node-link representation is the simple
rooted tree [BETT99, HMM00, RT81]. The top-down layout positions child nodes below their respective parent nodes
and is the most common rooted tree layout. The left-to-right
layout is a variation on this. Another example of a nodelink representation is the radial tree, in which nodes are
placed on concentric circles according to their depth in the
tree [BETT99, Ead92, HMM00].
A well-known example of an enclosure-based representation is the treemap layout. Its space-filling nature makes
it an ideal technique for displaying large trees [Shn92]. A
radial variation on treemaps are balloon layouts, in which
sibling subtrees are represented as circles enclosed by the
parent node [HMM00].
Combinations of node-link- and enclosure-based techniques exist as well; examples are SHriMP views [SM95],
space-optimized tree visualizations [NH02], and elastic hierarchies [ZMC05].
Another class of tree visualizations that are somewhat
less-used are those based on abutment. Abutment-based visualizations (sometimes referred to as icicle plots) position
child nodes to be adjacent to parent nodes, often using rectangles to represent nodes [GK05, Sif06]. Our approach uses
this representation for the hierarchies as well.
It is furthermore possible to enhance most tree visualizations through focus+context techniques to make them more
space-efficient. An example is the layout of a tree in hyperbolic space [LR96]. The use of 3D provides another way to
achieve a more efficient use of space, but this quickly leads
to occlusion problems, requiring additional interaction tech-

niques, i.e., 3D rotation, to overcome these problems. Examples of 3D techniques are cone trees [RMC91] and H3, a 3D
hyperbolic visualization [Mun97].
2.2

Visual Comparison of Trees

TreeJuxtaposer (TJ) is a system for the structural comparison
of large trees [MGT∗ 03]. Of the approaches mentioned in
this section, TJ has the most in common with our approach.
Therefore, we first give a more in-depth description of the
similarities and differences between both approaches.
The aim of both approaches is the visual comparison of
generic hierarchies. However, in case of TJ, the design decisions were based on the need to compare phylogenies; in
our case, these decisions were based on the need to compare
different versions of hierarchically organized software. Furthermore, since phylogenies have nodes at continuous depths
rather than discrete levels, our approach would need an additional level-discretization step to enable the comparison of
phylogenies. This is because discrete levels are required by
the technique that we use to sort the hierarchies (Section 3).
TJ visualizes structural differences between trees by using a visual clue on top of a node to indicate whether or
not it matches well with the best corresponding node in the
other tree. To determine how well nodes match, TJ first uses
a similarity measure to compute the best corresponding node
for each internal node and each leaf node. Specific selection
of (multiple) nodes is still necessary to see how exactly the
selected nodes and their child nodes are reorganized.
Our approach only matches between the respective leaf
sets and does not require a best match to be calculated for
the internal nodes. We then use Hierarchical Edge Bundles (HEBs) in conjunction with the hierarchical structure
to show how nodes are redistributed in terms of splits,
joins, and relocations [Hol06]. Thus we explicitly visualize
inter-hierarchy relations between both hierarchies to show
structural reorganizations. This gives users a direct global
overview of the differences between hierarchies without requiring the (pre)selection of nodes (Section 3.2).
TC furthermore uses a guaranteed visibility approach to
make sure that selected nodes remain visible in both trees,
which is realized using custom rendering and focus+context
techniques. In our case, a more detailed view of the correspondence between the hierarchies is obtained by having
a user select nodes and/or inter-hierarchy relations between
both trees. Our tool then uses animated zooming to provide a
more detailed view of the inter-hierarchy relations and parts
of the hierarchies that are involved (Section 4.3).
Another technique for multiple hierarchy visualization of
large taxonomies is presented by Graham et al. [GK05].
Techniques that aid navigation for discovering structural
changes between hierarchies are provided. Changes are furthermore emphasized by glyphs that are superimposed on
selected nodes. Isenberg et al. propose a tree comparison
technique for co-located collaborative information visualization [IC07]. Tree comparison is not the main focus, but it is
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

Danny Holten & Jarke J. van Wijk / Visual Comparison of Hierarchically Organized Data

used as an illustrative example of collaborative information
visualization. The same node similarity measure as in TJ is
used. As is the case with TJ, these two techniques require
selection (or brushing) of one or more nodes to show the
correspondence between them. This makes these techniques
less suitable for generating a global overview of the correspondence between hierarchies.
MultiTrees provide a way to merge multiple hierarchies
into a single directed acyclic graph by reusing hierarchical
substructures [FZ94]. Although this technique can be used
to visualize multiple hierarchies, it is harder to perceive the
structure of each individual hierarchy. Another problem is
the fact that the internal structure can change considerably
between two versions of a software system, since internal
nodes are generally used as grouping elements. This can result in a large number of hierarchical substructures that are
unique to each version, which makes actual reuse of common hierarchical substructures more difficult.
A way to show uncertainty in similar hierarchies by interpreting the differences between trees as uncertainty is proposed by Lee et al. [LRCP07]. Their method merges two
trees into one and visualizes structural uncertainty. Although
it is developed to show uncertainty, it could also be used to
visualize the differences between two hierarchies.
Sifer presents a more general approach for exploring
multi-dimensional data by using different clusterings on the
data to produce multiple hierarchies [Sif06]. The hierarchies are visualized simultaneously and data elements can
be queried by selecting filtering nodes in each hierarchy.
Strategies for visualizing changes of hierarchical data using treemaps are presented by Tu et al. [TS07]. They propose
a new layout algorithm to reduce abrupt layout changes between treemaps. Additional cues to emphasize the difference
between treemaps are provided as well.
Finally, Sheth et al. present a visual tree comparison
technique that explicitly visualizes inter-hierarchy relations
(as does our method) [SBB∗ 03]. Their approach draws
two node-link representations facing each other with interhierarchy relations drawn between nodes. However, they do
not use HEBs to show structural reorganization at higher hierarchy levels or sort hierarchies to facilitate comparison.

3

Visualization Design

This section gives a detailed description of the design of our
visual tree comparison technique. It is described how input
data is obtained (Section 3.1), how the actual visualization
is designed (Section 3.2), how hierarchies are sorted with
respect to each other to facilitate comparison (Section 3.3),
and how user interaction is addressed (Section 3.4).
3.1

Input Data

The input data comprises two (partially) overlapping hierarchies and a matching list. Each hierarchy contains nodes
with unique full-names as identifiers. A full-name node
identifier consists of the full path from root to node, i.e.,
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

761

Root.L1.L2.Node. The matching list contains the fullname leaf-to-leaf mapping for both hierarchies. If desired, a
possible matching for leafs that could not be matched using
the provided matching list can automatically be provided by
using string-based matching instead. Leafs that still remain
unmatched are treated as unique to each hierarchy.
The data that we used was control software for a medical
scanner (provided by Philips Medical Systems Eindhoven),
control software for an electron tunneling microscope (provided by FEI Company Eindhoven), and five versions of
Azureus, a popular Java-based BitTorrent client.
The Philips and FEI data was processed using Bunch, a
software clustering tool that is capable of automatically generating one or more alternative, multi-level decompositions
of a software system using the system's leaf set (e.g., methods) and the adjacency relations (e.g., method calls) between
the leafs [MMCG99]. The multi-level decompositions generated by Bunch can be compared to the original data.
To compare the different versions of Azureus, we made
use of the abstracted FAMIX models of versions 2.1 to 2.5
that were part of the data set for the VISSOFT 2007 tool
demo challenge [vis]. We wrote a tool that enabled us to
perform semi-automatic matching between two versions.
Our similarity measure takes as much information as possible into account to determine whether or not two methods
should be considered a match. User intervention is only necessary when the matching score is inconclusive and this was
rarely the case while matching the Azureus data. The similarity measure takes the following information into account
(provided by the FAMIX models): method name, ancestor
name(s), calling methods, called methods, local variables,
method signature, and a set of software metrics that is provided for each method. Similarity is calculated by using a
weighted average of these attributes; this makes the automatic matching less susceptible to situations in which methods have only been renamed, for instance; these will still be
considered a match.
Obtaining a matching between the leaf sets of a pair of hierarchies can generally be done in various ways, all of which
are independent of our visual tree comparison approach. We
therefore focus on the actual visualization itself from this
point on and assume the matching list as given.
3.2

Visualization Layout

Since one of our requirements is to give a global overview of
the correspondence between hierarchies in a single picture,
we want to explicitly show the inter-hierarchy relations, i.e.,
the relations between matching leaf nodes. It is therefore desirable to have a reasonably compact visualization of both
hierarchies, leaving enough room for the visualization of the
inter-hierarchy relations. We also want to show certain attributes for each node (e.g., number of selected children) and
provide users with the ability to interactively select both leaf
as well as internal nodes. We have therefore chosen an icicle
plot representation for the hierarchies and placed both hier-

762

Danny Holten & Jarke J. van Wijk / Visual Comparison of Hierarchically Organized Data

(a)

(b)

a

b

L0
L1
L2
L3

L0
L1
L2
L3

L2
Bundling L1
active

L2
L1

Bundling L1
inactive
L2

L1
L2

L3
L2
L1
L0

L3
L2
L1
L0

(a)

(c)

(d)
(b)

Figure 2: (a) Bundling enabled at all levels; (b) deactivation of bundling at L1 re(c)
sults in shifting of the control polygon points corresponding to that level (shown in
Figure 1: (a) Icicle plot construction; blue). This effectively disables bundling at L1; (c) and (d) show how (de)activation of
(b) Trees are stretched and mirrored to bundling at certain levels can be used to specify whether splits / joins (as encircled in
create the HEB guiding structure; the (c)) should be shown at these levels.
centered horizontal line depicts both tree
roots; (c) inter-hierarchy relation (and
its control polygon) between matching
leafs at various bundling strengths.
archies along opposite edges of the screen. Figures 1a and
1b show the construction process.
To decrease clutter that would result from simply drawing
straight lines between matched leafs and to facilitate selection of inter-hierarchy relations, we chose to use HEBs to visualize the relations [Hol06]. Figure 1a shows the construction of the guiding structure (control polygons) to guide the
inter-hierarchy relations. Figure 1b shows the visualization
of a single inter-hierarchy relation.
Suppose that an SE wants to see if the software hierarchy
has been modified at a certain level. Figure 2b shows how
this can be accomplished by (de)activating the bundling at
certain levels (in this case deactivation at L1). If we view
this example as the comparison of two Java systems consisting of packages at L1, classes at L2, and methods at L3,
then we can see in Figure 2c that modifications took place at
the package level. Classes were indeed redistributed among
packages, as is shown by the splits / joins at the L1 level
within the encircled regions. But as can be readily seen in
Figure 2d, the class level did not change; no methods were
redistributed among classes.
3.3

Hierarchy Sorting

Since the internal structure of the hierarchies can differ considerably and since their leaf sets do not need to be completely identical, the ordering of the leaf nodes within both
hierarchies can differ substantially as well (Figure 3a).
To facilitate the visual comparison task, it is desirable to
depict both hierarchies with respect to each other in such
a way that matching nodes are positioned opposite of each
other as well as possible. This also reduces the number of
crossings between inter-hierarchy relations (Figure 3f).
To achieve this, we employ a Sugiyama-style crossing reduction (CR) technique [STT81]. The actual CR steps that

are performed by the Sugiyama technique are instances of
two-level CR problems, in which the reduction of crossings
within a bipartite graph is addressed. A bipartite graph is a
graph whose vertices can be divided into two disjoint sets
V1 and V2 such that every edge connects a vertex in V1 and
one in V2 . There is no edge between two vertices of the same
set. Figure 3c illustrates an instance of a two-level CR problem between the leaf levels of both trees. Here, the bipartite
graph is formed by two disjoint sets of leaf nodes – those of
S(M(T0 )) and those of S(M(T1 )) – and the inter-hierarchy
relations between the leafs.
Figures 3a through 3f now illustrate our complete CR
technique. To prepare both hierarchies for CR, we first remove non-matching nodes from both hierarchies. Since we
want to perform the actual CR on corresponding levels in
both hierarchies, we also need to equalize the number of hierarchy levels by copying (stretching) nodes down.
CR can now be performed per level by employing twolevel CR steps on corresponding levels while taking the
aforementioned constraint into account. After having completed the CR at the current level, we move up one level. To
do this, it is necessary to first collapse both levels and aggregate the inter-hierarchy relations up one level, as is illustrated in Figures 3g and 3h. CR can now proceed. The collapsing and subsequent CR of corresponding levels continues until the root is reached. At this point, the process is reversed and levels are expanded again in an analogous fashion
until the leaf level is reached. After each expansion step, perlevel CR is performed again. This full collapse-and-expand
cycle of both hierarchies continues until the number of crossings cannot be reduced any further, at which point the hierarchies are considered to be sorted with respect to each
other. The collapse-and-expand cycle proposed here with
in-between Sugiyama-style CR is only one possible way
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

763

Danny Holten & Jarke J. van Wijk / Visual Comparison of Hierarchically Organized Data
T0

S(M(T0))

M(T0)

S(M(T0))

L0
L1
L2

Remove
nonmatched

Stretch
trees to
equalize

L3

tree
nodes

number
of levels

L4

L4

L3
L2

(a)
T1

(b)

(c)

M(T1)
Perform per-level crossing reduction

S(M(T0))

S(M(T1))

L1

T0

M(T0)

(g)

L0

S(M(T1))
Collapse L4 to L3

L0

S(M(T0))

L1
Cut back
trees to
restore

Reinsert
nonmatched

original
number
of levels

tree
nodes

L2
L3
L3
L2
L1

(e)

(d)
S(M(T1))

(f)

M(T1)

T1

L0

(h)
S(M(T1))

Figure 3: (a) through (f) Sorting both hierarchies with respect to each other is performed by means of crossing reduction (CR)
of inter-hierarchy relations. Individual steps required to prepare hierarchies for CR and to restore hierarchy structure after
CR are shown. S(M(T)) = Stretched(Matched(T)); (g) and (h) Collapse of levels L4 to L3 results in inter-hierarchy relations
between elements of L3 to be aggregated up one level to produce inter-hierarchy relations between elements of L4.
of solving the CR problem. Alternative approaches and/or
changes in the order in which the collapse-and-expand cycles are performed are worth investigation as well.
Two steps remain: the original number of levels in both hierarchies needs to be restored and non-matching nodes that
were removed from both hierarchies need to be reinserted.
As is shown in Figure 3f, we choose to reinsert nodes back
into the hierarchy at the end of the set of siblings that are already present ("insert last"-approach). However, alternative
reinsertion strategies are possible as well.
3.4

User Interaction

In addition to direct selection of nodes in each of the icicle
plots by means of clicking, we want to provide users with
a form of interaction that is well-suited for the HEB-based
inter-hierarchy relations as well. We propose to use crossing
as an interaction method, which allows users to draw a line
through relations that they want to select. This allows users
to interact more directly with the actual inter-hierarchy relations instead of with the nodes that comprise the hierarchies.

4

Results

This section demonstrates our method by means of illustrative examples in which an SE explores modified software
systems. Examples are given of how HEBs reduce clutter
and how they emphasize splits, joins, and relocations (Section 4.1), how (de)activation of levels is used to control
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

bundling (Section 4.2), how interaction is performed (Section 4.3), and how larger data sets are handled (Section 4.4).
Some of the hierarchy labels have been obscured in a couple
of visualizations due to reasons of confidentiality.
4.1

Hierarchical Edge Bundling

Figure 4 shows two visualizations of a pair of versions of
the FEI data set. The original version is located at the top,
the alternative decomposition generated by Bunch is located
at the bottom of each visualization. Although the straight
lines in Figure 4a show the actual correspondence between
the hierarchies, they do not show any higher-level information, i.e., information pertaining to the splitting and joining
of lower-level elements or information regarding the relocation of (complete) subhierarchies, which can be of importance to an SE. Figures 4b and 4c show how increasing the
bundling strength can be used to visualize this information.
4.2

Bundling at Speci ed Levels

The Philips data set comprises a three-level architectural
decomposition of the system, i.e., Layers decomposed into
Units decomposed into Modules. Figure 5 shows visualizations of the original data (top) and an alternative decomposition generated by Bunch (bottom). It is immediately clear
from Figure 5a that Bunch performed a substantial reorganization. However, it is not immediately clear if substantial
reorganization was performed at the Unit level as well or

764

Danny Holten & Jarke J. van Wijk / Visual Comparison of Hierarchically Organized Data

(a)

(b)

(c)

Figure 4: An SE increases the bundling strength to get insight in the high-level correspondence between hierarchies; (a)
straight lines only show correspondence between leaf elements; (b) & (c) increasing the bundling strength shows splits / joins
that pertain to high-level changes in a software system as well.

(a)

(b)

Figure 5: Bundling at speci ed levels; (a) the Philips data (top) was substantially reorganized by Bunch (bottom). Whether
substantial Unit reorganization was performed is not directly clear, since bundling at the Layer level (encircled) partially obscures this information; (b) disabling Layer-level bundling still leaves many splits / joins at the Unit level (encircled), indicating
that substantial reorganization was performed at the Unit level as well.
mainly at the Layer level, since bundling at the Layer level
partially obscures this information. To get insight in the reorganization at the Unit level, one can disable bundling at
the Layer level. Figure 5b shows that there are many splits /
joins left at the Unit level, which is indicative of substantial
reorganization at the Unit level as well.
4.3

Interacting with the Visualization

User interaction by means of crossing is illustrated in Figure
6 using the FEI data set. Figure 6b shows how crossing of an
area of interest encircled in Figure 6a results in the highlighting of a bundle of inter-hierarchy relations. Nodes pertaining
to the selected relations are shaded as well. Full green shading indicates that the complete subhierarchy starting at that
node is part of the selected relations. In case of a partial selection, blue shading is used to depict the percentage of child
nodes that are part of the bundle selection.
Figure 6c shows how automatic (animated) zooming is
performed after crossing. The resulting visualization gives

an SE a more detailed view of the inter-hierarchy relations
and the parts of the hierarchy that are involved. Zooming can
also be performed manually instead of automatically.
4.4

Comparing Larger Data Sets

Scaling of our technique is illustrated in Figure 7 using two
versions of the Azureus data set. An encircled area in Figure 7a hints at relocation of part of the hierarchy; Figure
7b shows how an SE inspects this area in more detail by
means of crossing and zooming. The top hierarchy (version
2.2) consists of 2,283 leaf elements, the bottom hierarchy
(version 2.3) consists of 3,179 leaf elements. The changes
are less substantial in this case, since two consecutive, manually modified versions of Azureus have been used instead
of a comparison between an original Azureus version and a
decomposition generated by Bunch. This example also illustrates the presence of elements that are unique to each hierarchy; these elements are depicted in red. (In case of the
Philips and FEI data, the new decompositions generated by
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

Danny Holten & Jarke J. van Wijk / Visual Comparison of Hierarchically Organized Data

(a)

(b)

765

(c)

Figure 6: User interaction by means of crossing. (a) Original FEI data (top) is compared to a Bunch-reorganized version
(bottom). An area of interest is encircled; (b) crossing of the encircled bundles results in highlighting of the inter-hierarchy
relations and shading of the nodes pertaining to the selected relations; (c) automatic animated zooming is performed after
crossing to give an SE a more detailed view of the inter-hierarchy relations and parts of the hierarchy that are involved.

(a)

(b)

Figure 8: Using a horizontal
orientation could facilitate the
Figure 7: Comparison of larger data sets; (a) Azureus v2.2 (top, 2,283 leafs) is compared to detection of (a)symmetry beAzureus v2.3 (bottom, 3,179 leafs). Red shading is used to depict nodes that are unique to each tween a pair of hierarchies.
hierarchy. The encircled area hints at relocation of part of the hierarchy; (b) an SE inspects the
encircled area in more detail by crossing it. Zooming is subsequently performed to provide the
SE with a more detailed view of the changes.
Bunch used all of the original leaf elements; therefore, no
red shaded nodes are present in the Philips and FEI cases).

5

Discussion

We now discuss advantages and limitations of our technique
based on insight that we obtained from the visualizations that
were generated using the Philips, FEI, and Azureus data. Informal user feedback gathered during demonstrations of our
tool to industrial partners is taken into account as well.
Advantageous features of our approach are the following:
• Our technique can be used to provide a global, high-level
overview of the correspondence between two hierarchies
in a single picture. This is realized by explicitly visualizing the inter-hierarchy relations using HEBs, which provide a high-level view of the splits, joins, and relocations
of nodes at various hierarchy levels;
• Users can determine the hierarchy level(s) at which
bundling is performed. This enables a user to see if two
hierarchies differ from each other at a certain level;
• To facilitate comparison, both hierarchies are sorted with
respect to each other in such a way that matching nodes
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

are positioned opposite of each other as well as possible.
This also reduces the number of crossings between interhierarchy relations;
• Bundle-based interaction by means of crossing allows
a user to interact more directly with the actual interhierarchy relations (instead of with the nodes that comprise the hierarchies) to explore the correspondence between hierarchies in more detail.
We have identified the following disadvantages as well:
• Although bundling of relations is useful to create a highlevel view of the correspondence, it also makes it harder
to see individual relations within a bundle. It is therefore
necessary to provide an option to interactively control the
bundling strength to enables a trade-off between a bundled
and a non-bundled representation;
• The comparison depends on the availability of a matching
list. A considerable amount of work can be involved, since
sensible matching criteria need to be chosen and custom
tools are often needed to generate the matching;
• The non-atomicity of matching elements can be problematic in some cases. An example is the matching performed

766

Danny Holten & Jarke J. van Wijk / Visual Comparison of Hierarchically Organized Data

on methods in case of software. If a method is split into
multiple methods or if the source code within a method
is changed, this cannot be detected reliably by a matching
procedure that operates at a higher granularity level.

6

Future Work

Based on insight that we obtained while working on our tool
and the informal feedback gathered during demonstrations,
possible directions for future work are now proposed.
In order for our tool to be useful to expert users, more
detailed information needs to be provided about certain elements. Some additional visual cues can be readily added
to the current visualization and (automatic) zooming already
helps to show more information. However, additional interaction techniques and/or views should be added to provide a
user with an easy way to obtain this information.
As an alternative to the proposed vertical layout, a horizontally oriented layout could be used instead (Figure 8).
From the perspective of visual perception, it might actually
be easier for users to detect (a)symmetry between a pair of
hierarchies that are positioned in this way.
As mentioned in Section 3.3, we reinsert nodes back into
the hierarchy using an "insert last"-approach as the final CR
step (Figure 3f). This introduces some skewing, which might
be reduced by exploring alternative reinsertion strategies.
We are furthermore planning to make our tool (including
the Azureus data set) available online to allow users to examine their own data sets. We would like to receive feedback
from these users and perform additional user experiments,
e.g., in collaboration with our industrial partners, to gain insight in the practical usability of our approach.

7

Acknowledgements

We would like to thank Philips Medical Systems Eindhoven
and FEI Company Eindhoven for providing us with input
data sets. This project is funded by the Netherlands Organization for Scientific Research (NWO) Jacquard program under research grant no. 638.001.408 (Reconstructor Project).
References
[BETT99] BATTISTA G. D., E ADES P., TAMASSIA R.,
T OLLIS I. G.: Graph Drawing: Algorithms for the Visualization of Graphs. Prentice Hall, 1999.
[Ead92] E ADES P.: Drawing Free Trees. Bulletin of the Institute for Combinatorics and its Applications 5, 2 (1992),
10–36.
[FZ94] F URNAS G. W., Z ACKS J.: MultiTrees: Enriching and Reusing Hierarchical Structure. In Proc. of ACM
SIGCHI'94 (1994), pp. 330–336.
[GK05] G RAHAM M., K ENNEDY J.: Extending Taxonomic Visualisation to Incorporate Synonymy and Structural Markers. Information Visualization 4, 3 (2005), 206–
223.
[HMM00] H ERMAN I., M ELANÇON G., M ARSHALL
M. S.: Graph Visualization and Navigation in Information
Visualization: A Survey. IEEE TVCG 6, 1 (2000), 24–43.

[Hol06] H OLTEN D.: Hierarchical Edge Bundles: Visualization of Adjacency Relations in Hierarchical Data. IEEE
TVCG 12, 5 (2006), 741–748.
[IC07] I SENBERG P., C ARPENDALE S.: Interactive Tree
Comparison for Co-located Collaborative Information Visualization. IEEE TVCG 13, 6 (2007), 1232–1238.
[LR96] L AMPING J., R AO R.: The Hyperbolic Browser: A
Focus + Context Technique for Visualizing Large Hierarchies. Elsevier VLC 7, 1 (1996), 33–55.
[LRCP07] L EE B., ROBERTSON G. G., C ZERWINSKI M.,
PARR C. S.: CandidTree: Visualizing Structural Uncertainty in Similar Hierarchies. Information Visualization 6,
3 (2007), 233–246.
[MGT∗ 03] M UNZNER T., G UIMBRETIÈRE F., TASIRAN
S., Z HANG L., Z HOU Y.: TreeJuxtaposer: Scalable Tree
Comparison Using Focus+Context with Guaranteed Visibility. ACM TOG 22, 3 (2003), 453–462.
[MMCG99] M ANCORIDIS S., M ITCHELL B. S., C HEN
Y., G ANSNER E. R.: Bunch: A Clustering Tool for the
Recovery and Maintenance of Software System Structures.
In Proc. of IEEE ICSM'99 (1999), pp. 50–59.
[Mun97] M UNZNER T.: H3: Laying out Large Directed
Graphs in 3D Hyperbolic Space. In Proc. of IEEE InfoVis'97 (1997), pp. 2–10.
[NH02] N GUYEN Q. V., H UANG M. L.: A SpaceOptimized Tree Visualization. In Proc. of IEEE InfoVis'02
(2002), pp. 85–92.
[RMC91] ROBERTSON G. G., M ACKINLAY J. D., C ARD
S. K.: Cone Trees: Animated 3D Visualizations of Hierarchical Information. In Proc. of ACM SIGCHI'91 (1991),
pp. 189–194.
[RT81] R EINGOLD E. M., T ILFORD J. S.: Tidier Drawings
of Trees. IEEE TSE 7, 2 (1981), 223–228.
[SBB∗ 03] S HETH N., B ORNER K., BAUMGARTNER J.,
M ANE K., W ERNERT E.: Treemap, Radial Tree and 3D
Tree Visualizations. In Proc. of IEEE InfoVis'03 (Poster
Compendium) (2003), pp. 128–129.
[Shn92] S HNEIDERMAN B.: Tree Visualization with TreeMaps: 2-d Space-Filling Approach. ACM TOG 11, 1
(1992), 92–99.
[Sif06] S IFER M.: Filter Co-ordinations for Exploring
Multi-Dimensional Data. Elsevier VLC 17, 2 (2006), 107–
125.
[SM95] S TOREY M.-A. D., M ÜLLER H. A.: Manipulating and Documenting Software Structures using SHriMP
Views. In Proc. of IEEE ICSM'95 (1995), pp. 275–284.
[STT81] S UGIYAMA K., TAGAWA S., T ODA M.: Methods
for Visual Understanding of Hierarchical System Structures. IEEE TSMC 11, 2 (1981), 109–125.
[TS07] T U Y., S HEN H.-W.: Visualizing Changes of Hierarchical Data using Treemaps. IEEE TVCG 13, 6 (2007),
1286–1293.
[vis] IEEE VISSOFT'07 Tool Demo Challenge Data.
[ZMC05] Z HAO S., M C G UFFIN M. J., C HIGNELL M. H.:
Elastic Hierarchies: Combining Treemaps and Node-Link
Diagrams. In Proc. of IEEE InfoVis'05 (2005), pp. 57–64.
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.


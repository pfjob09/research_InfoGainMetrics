DOI: 10.1111/j.1467-8659.2008.01198.x

COMPUTER GRAPHICS

forum

Volume 27 (2008), number 8 pp. 2128–2142

Adaptive Surface Texture Synthesis Using Round-Shaped
Neighbourhoods
D. Chen1 and F. Dong2
1 Department

of Information Systems and Computing, Brunel University, UK
dongbin.chen@brunel.ac.uk
2 Department of Computing and Information Systems, University of Bedfordshire, UK
feng.dong@beds.ac.uk

Abstract
This paper presents a novel surface texture synthesis method, which is capable of producing high-quality results
by performing the synthesis within an effective multi-resolution scheme using an adaptive texture similarity
metric. Compared with related works, our method allows us to directly carry out multi-resolution synthesis
without involving complicated operations such as mesh hierarchy and partitioning on the target surface. Also, the
adaptive similarity metric focuses on measuring texture properties at different scales ranging from local to global,
allowing for consistency within differently-sized texture structures. Further, with the introduced round shaped
neighbourhoods, we can save considerable amount of computation for the surface texture synthesis over variable
texture directions. Experimental results are provided and comparisons are made against other latest works.
Keywords: Texture synthesis, texture mapping, surface model
ACM CCS: I.3.3 [Computer Graphics]: Picture/ image generation; I.3.6 [Computer Graphics]: Methodology and
techniques

1. Introduction
Textures have produced profound impact in computer graphics. They have been widely used to enhance details of surface
models. A surface model can be associated with different
colour appearances using different textures, allowing a great
deal of visual effect. This has triggered many interests both
from academia and industries.
However, synthesizing textures on a 3D surface is not a
straightforward task, facing a considerable number of critical
challenges including processing speed, texture distortion, etc.
Besides, surface texture synthesis often involves the change
of texture orientations at different locations on the target surface, which often triggers heavy recomputations and causes
delays to the surface rendering.
Multi-resolution is a common way to improve performance speed by making use of results from lower resolution
to speed up the synthesis calculations at higher resolutions.
Notably, performing multi-resolution synthesis on an arbitrary surface is far more complicated than doing it in a 2D
c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and
Blackwell Publishing Ltd. Published by Blackwell Publishing,
9600 Garsington Road, Oxford OX4 2DQ, UK and 350 Main
Street, Malden, MA 02148, USA.

image domain. Many existing works require complicated
mesh operations such as mesh hierarchy [Tur01, WLe01],
mesh partitioning [GIS03, ZDW∗ 05], etc., some of which
involve user interactions.
This work was designed to address these challenges in 3D
surface texture synthesis. We are aiming at automatic and
rapid texture synthesis without involving manual operations
on the target surface, and thus reducing user labours and
facilitating the synthesis process.
Another new technical contribution of the paper is the introduction of using round shaped neighbourhoods to measure
local texture properties on surface, instead of using rectangle
shaped neighbourhood as in many existing methods. The use
of round shaped neighbourhoods provides following benefits:
(i)

2128

Round shaped neighbourhood is designed to save computational costs for texturing a target surface with
different texture orientations. Surface texture synthesis involves considerable amount of computation in

Submitted December 2006
Revised December 2007
Accepted August 2008

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

(ii)

marching on the target surface. While computing a
rectangle shaped neighbourhood needs to perform different marching on the surface according to different
texture orientations, the marching for a round shaped
neighbourhood is invariant with respect to different texture directions. This allows us to treat surface marching
as a completely automatic and once performed preprocessing for a given target surface and hence saves
considerable computations.
In addition, the proposed round shaped neighbourhood intrinsically corrects texture distortion on target
surfaces. Distortion happens when a texture image is
mapped on a 3D target surface either by flattening local surface patch [WLe01] or by performing surface
marching [Tur01]. By using a round shaped neighbourhood, such a distortion can be minimized.

Besides, within the round shaped neighbourhoods on 3D
surfaces, we apply an adaptive texture similarity metric to
the texture synthesis. Essentially texture synthesis techniques
generate new texture images by seeking matched texture pixels and subsequently stitching them together in an adequate
way [EFr01, KSE03], the issue regarding how to define similarity metric for texture pixels constitutes the core of all
the texture synthesis techniques. This adaptive metric provides adequate measures on texture similarities at different
scales ranging from local to global, accounting for texture
variations across different image regions. It allows for consistency within differently-sized texture structures and hence
effectively overcomes the errors from the conventional single
valued summed squared difference (SSD) metric which was
mostly used in existing methods.
The rest of the paper is organized as follows: Section 2
gives a brief survey on the previous works; Section 3 gives
an overview of the proposed method; Section 4 describes
how to use round shaped neighbourhoods for surface texture
synthesis; Section 5 introduces the adaptive texture similarity metric. Section 6 presents how to perform the adaptive surface texture synthesis in multi-resolution form; Section 7 shows the results. Finally, the conclusion is drawn in
Section 8.
2. Previous Work
This section provides a technical overview from four different aspects. First, we look at the general approach and
challenges of surface texture synthesis. Next, we discuss the
pre-processing that normally required for texture samples and
target surfaces. Also, we look into the distortion problem in
surface texture synthesis.

2129

community. Besides, some early work based on the global
statistical analysis approach, such as [deB97, PSi00], more
recent works follow either the pixel based [Ash01, WLe00]
or the patch based approach [CSH∗ 03, EFr01, KSE∗ 03,
LLX∗ 01, WYu04, XGS00].
A pixel-based texture synthesis generates a synthesized
image pixel by pixel. The colour of each synthesized pixel
is given by the most similar pixel in sample texture. The
similarity between two pixels is measured from their already
synthesized neighbours. The similarity metric is the key here.
As each new pixel is determined by the already synthesized
pixels, any wrongly synthesized pixels during the process
can affect the rest of the result.
A patch-based texture synthesis makes a new texture image by taking patches from sample texture and pasting them
together in a consistent way. The advantage is that the texture structures inside the patches are maintained. However,
great effort is required to make the patches ’agree with’ their
neighbours.
There are also recent works on texture synthesis using
global optimization [KEB05]; parallel architecture [LHo05]
and appearance space [LHo06].
Likewise 2D texture synthesis, surface texture synthesis can also be divided into pixel based [ Tur01, WLe01,
ZZV∗ 03] and patch based [DML∗ 02, MKr03,PFH00,
SCA02]. As a comparison, the pixel based approach is more
flexible to give different texture directions at different vertices on the target surface. Therefore, the method presented
in this paper follows the pixel based approach.
Besides the problems inherited from 2D texture synthesis,
surface texture synthesis has a number of new challenges,
such as complex surface topology, long computational time,
image distortion, etc. The rest of this section looks at these
issues by providing a brief overview on the related work.

2.2. Pre-processing on texture samples
To address the challenge on computational time, a number of
recent works have used different pre-processing techniques
on texture samples to speed up the surface texture synthesis.
Such a pre-processing is required only once for a sample texture, and the subsequent surface texture synthesis can achieve
very impressive speed.

2.1. 2D versus 3D surface texture synthesis

Magda and Kriegman [MKr03] use clustering techniques
to identify sets of pixels in the sample texture whose neighbourhoods have similar appearance. This results in a set of
textons and each set contains a number of similar textons.
This contributes to the fast search for the patches that match
to each other.

Two-dimensional texture synthesis has received a large
amount of research attention from the computer graphics

Zelinka and Garland [ZGa03] employ jump maps, which
store a small set of similarity weighted pixels for each pixel

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

2130

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

of the sample texture. This helps to speed up the search for
similar pixels since searching in the full sample texture is
avoided.
Lefebvre and Hoppe [LHo06] propose texture synthesis
using appearance space, which consists of colours, features
and radiance. Principal component analysis (PCA) is used
to transfer a texture sample to the appearance space, which
more effectively incorporates texture prosperities.
Dischler et al. [DML∗ 02] synthesize new texture images
by semi-automatically segmenting the given texture sample
into a few number of texture particles and placing them in
accordance with the layout extracted from the sample.
Zhang et al. [ZZV∗ 03] generate texton masks from input texture sample by using semi-automatic segmentation.
The texton masks are used to prevent the break apart of texture elements during the synthesis of progressively-variant
textures.
In another related example, Tong et al. [TZL02] apply preprocessing to bi-directional texture function (BTF) sample
for the synthesis of BTF on arbitrary surfaces. Clustering
method is used to generate 3D textons from the input BTF
sample.
A common weakness of the above methods is that preprocessing for each new texture sample takes considerably
long time. For example, [MKr03] need up to 16 minutes to
process a 256 × 256 texture; [DML∗ 02] require involving
manual segmentation to obtain texture particles.

2.3. Pre-processing on target surfaces
To facilitate texture synthesis, pre-processing techniques
have also been used to target surfaces in many related works.
This needs to be done only once for each target surface before
the synthesis takes place, allowing the production of different
textures.
Mesh hierarchy is used in both [WLe01] and [Tur01] to
perform pixel based multi-resolution texture synthesis. This
is done by using mesh simplification algorithms which simplify the mesh at different levels of details.
Besides using mesh hierarchy, many related works have
employed different kinds of mesh partition methods to divide target surface into a number of regions, within which
the texture synthesis takes place, taking into account texture continuity between the regions. For example, Zhou
et al. [ZDW∗ 05] partition the mesh into large charters which
are parameterized with minimized stretch to allow texture
synthesis; Soler et al. [SCA02] propose hierarchical pattern
mapping which requires to set up a hierarchy of mesh regions;
Gorla et al. [GIS03] also need mesh partitioning which divides the target mesh into a minimum number of approximate
planar patches; Ying et al. [Ying01] require that the target

surface is covered by an atlas of overlapping charts, each of
which is a map from a surface region into a plane.
Although such a mesh processing is only required once
for a particular target surface, it is neither straightforward
nor completely automatic. For example, generating surface
hierarchy using mesh simplification involves a considerable
number of parameter settings which can lead to significantly
different results; many mesh partitioning is often not fully
automatic and needs user interventions.
2.4. Mapping distortion
Placing a 2D image onto a 3D surface inevitably brings distortions. This is normally caused by placing the image over the
3D surface, either through direct surface marching, e.g. Turk
[Tur01], or through flattening and resampling local surface
patches, e.g. Wei and Levoy [WLe01], Soler et al. [SCA02],
Gorla et al. [GIS03]. Also, some other works use tangent
plane at each vertex to map the 2D texture into 3D, e.g.
Zelinka et al. [ZGa03], Zhang et al. [ZZV∗ 03], Zhou et al.
[ZHW∗ 06], etc.
All of these mapping methods can potentially create severe distortions, especially at the places where the surface
curvature is high. To avoid this, the partitioning methods employed in [GIS03] and [SCA02] require that each divided
region is either small or sufficiently flat. For the methods that
use direct surface marching and resampling [Tur01], dense
sample is required at high curvature area to avoid artefacts.
Apart from the works mentioned above, there are also recent works on the surface texture synthesis of geometric textures from geometry examples. More details of these works
can be found at Zhou et al. [ZHW∗ 06], Bhat et al. [BIT04]
and Lagae et al. [LDD05].
3. General Synthesis Outline
This section gives a brief description on the general outline
of the proposed surface texture synthesis.
As shown in Figure 1, the proposed method follows a
multi-resolution framework, in which the lowest resolution
result is first synthesized on the target surface – see the left
branch in Figure 1. This is followed by a quick generation of
higher resolution textures from the lower resolution results –
see the right branch in Figure 1.
At the lowest resolution, the synthesis starts from location selection. This specifies the position on the target
surface where the synthesis takes place at each step. The
first location is always a random position on the surface,
and next, we take a synthesis order similar to the one
used in [ZGa03, ZHW∗ 06], which picks up a vertex whose
neighbourhood covers the largest number of already synthesized vertices (hence provides the most reliable texture
property measure). This synthesis process continues on a

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

ularly important for anisotropic textures. These orientations
can be assigned in different ways, for example, using constant or principal curvature directions at the vertices [GIS03];
using relaxation methods [WLe01]; or by user interactions
[PFH00]. Different texture directions lead to different texture
synthesis results.

for each
resolution

Y

Location
Selection

Lowest
Resolution?

2131

N

Synthesis from
next lower
resolution (See
Section 6)

Synthesis with
round shaped
neighborhood
and adaptive
metric (See
Section 4 & 5)

To synthesize textures following the texture orientation at
a vertex, the common approach adopted by many methods
involves two steps:
(i)

(ii)

Figure 1: A general framework of multi-resolution surface
texture synthesis.
vertex-by-vertex basis until all of the vertices on the target
surface are covered.
When synthesize colour for a vertex, a round shaped neighbourhood is used to take samples from both the target surface
and the texture sample. By using the adaptive similarity metric, the colour at each vertex is decided by choosing the best
pixel colour from the texture sample according to its similarity difference with the already synthesized local and global
texture structures on the target surface. The round shaped
neighbourhood allows us to efficiently synthesize along different texture directions, and inherently provides minimum
distortion of a 2D texture on the 3D target surface – see more
details in Sections 4 and 5.
Once the synthesis for the lowest resolution is completed,
the multi-resolution synthesis allows rapid synthesis for
higher resolution results until the full resolution is reached –
see more details in Section 6.
4. Round Shaped Neighbourhoods
Round shaped neighbourhood is designed to speed up the
surface texture synthesis via carrying out pre-computing for
the surface marching required during the synthesis. The key
advantage here is to allow the reuse of surface marching
results for different texture directions without requiring recomputation.

4.1. Problem analysis – synthesis with texture
orientations
Normally, surface texture synthesis has to follow the orientations given at the vertices of the target surface. This is partic-

First, place a local neighbourhood along the orientation
at each vertex, according to which the local texture is
resampled.
Second, compare the resampled neighbourhood with
the colours in the texture sample using a texture similarity metric and identify the most similar colour.

This resampling process requires either geometric marching on the surface or flattening the local surface patch, both
of which involve a considerable amount of computation. This
paper takes the surface marching approach with the purpose
of reducing texture distortions. However, computing a surface marching takes considerable time, especially if such a
marching depends on local texture orientations, it involves
considerable amount of re-computation.
Our focus here is to avoid the recomputation of surface
marching for different texture directions by carrying out direction independent surface marching, i.e. the marching is
invariant with respect to different texture orientations and
hence only needs to be done only once for each vertex on
the surface. This can be achieved by using round shaped
neighbourhood as described below.

4.2. Defining a round shaped neighbourhood
To fulfil the above target, a novel neighbourhood sampling
method using round shaped neighbourhoods is presented.
The neighbourhood of a surface vertex consists of sampling
points situated on the concentric circles centred at the vertex.
We use Figure 2 to show the round shaped neighbourhood
of a vertex on a 3D model. To clearly present the definition
of such a round shaped neighbourhood, a 2D illustration is
given at the bottom of Figure 2.
As shown in Figure 2, the neighbourhood consists of resampling points located on the concentric circles whose radiuses are evenly increased. The red and green coloured dots
in Figure 2 show the resampling points in the round shaped
neighbourhood. Their positions are decided by the intersections between the circles and the blue coloured grid. The
raster structured grid is formed by two groups of parallel
lines, which are perpendicular to each other. Notably, these
resampling positions are calculated with reference to the texture direction indicated by the yellow arrow.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

2132

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

Figure 2; L m is the perimeter of the mth circle; arclength(P n,m ,
P 0,m ) is the length of the arc between P n,m , P 0,m .
Therefore, each resampling point is recorded by
(i)
(ii)

the number of the circle on which it is located and
its percentage position relative to the circle perimeter.

4.3. Resampling on surface
Given the above definition of a round shaped neighbourhood,
this section discusses how to compute such a neighbourhood
at a vertex of the target surface.
The computation of a neighbourhood involves two parts,
including geometry computation, which calculates the resampling positions (such as the red and green dots in Figure
2) on the target surface, and colour resampling, which obtains
colours for the resampling points.
To calculate the resampling positions around a vertex on
the surface, surface marching needs to be carried out to generate concentric circles centred at the vertex. This calculation
is performed by intersecting the surface patch around the vertex with a number of co-axis cylinders which have the same
sizes as the circles. The axis of these cylinders is placed along
the surface normal at the vertex.
Remarkably, this marching computation is completely automatic without involving any user intervention. Further, it
needs to be done only once as the calculated concentric circles can be used for any texture orientations at the vertex.
Therefore, this can be treated as a pre-computing step.

Texture Direction

Figure 2: A round shaped neighbourhood illustration.
The size of the grid cell decides the resampling density
(we also call this resampling distance), which controls the
scale of the texture synthesized on the surface. A smaller
size indicates that a higher resampling density is involved,
which also implies that the texture covers a smaller area on
the surface.
Mathematically, we can use a series of numbers to represent the concentric circles in terms of their radius as [r, 2r, 3r,
4r. . .], where r is the resampling index (size of a grid cell),
as shown in Figure 2.
To facilitate the calculation of the positions of the resampling points, we use the following percentage descriptor to
record the nth point on the mth circle P n,m in terms of the
percentage of its arc length against the perimeter:
percentage(Pn,m ) = arclength(Pn,m , P0,m )/Lm

(1)

where P 0,m denotes the first point on the mth circle, which
is decided by the texture direction – see the green points in

Given the calculated concentric circles on the surface, the
positions of the resampling points on each of these circles
can be decided using Equation (1). More specifically, as the
percentage position of a resampling point is already recorded
in Section 4.2, we can work out the arc length between P 0,m
and P n,m using Equation (1) as follows:
arclength(Pn,m , P0,m ) = percentage(Pn,m ) × Lm .
The position of P 0,m is decided by the texture direction at
the vertex. It is obtained by intersecting the mth circle against
the texture direction.
Given the position of P 0,m and the arclength, we can easily
have the position of P n,m . From this process, the positions of
all of the resampling points are calculated. This part of the
computation is light and therefore can be performed quickly
for different texture directions.
The colours of the resampling points are determined by
their positions. For each resampling point, its colour is calculated from the triangle in which the point is located. Linear
interpolation is used to calculate the colour from the three
vertices of the triangle. Notably, if the resampling point is

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

2133

dragged away from M and N. This gives an unwanted effect
that the image is ripped by the underneath surface.
One solution to rectify such a distortion is to use nonuniform sampling distance. In the case of Figure 3(a), relatively larger sampling distance should be used in the middle
of the image, so that it can be stretched over the sharp curvature to keep its distance with the other two sides of the image
– see Figure 3(b).
Such a non-uniform sampling distance can be inherently
achieved by using the proposed round shaped neighbourhoods. As mentioned in Section 4.3, a round shaped neighbourhood of a vertex is formed by intersecting the surface
patch around the vertex with some co-axis cylinders placed
along with the surface normal at the vertex. The positions
of the resampling points calculated using Equation (1) are
naturally distributed in accordance with the local patch geometry. Hence, the texture placed using these resampling
points is adequately stretched to avoid local distortions.

5. Synthesis with Adaptive Similarity Metric
Given the resampling result around the vertex using its round
shaped neighbourhood from Section 4.3, this section discusses how to find the right colour for the vertex by searching
in the texture sample.

Figure 3: Illustration of texture distortions on surface:
(a) using uniformed sampling density causes distortion;
(b) correct the distortion using non-uniformed sampling density.
located in a triangle which has not been assigned texture
colours during the synthesis, then this resampling point is
marked as a non-coloured point. Only coloured resampling
points in the neighbourhood are used during the synthesis to
determine the colour at the vertex.
4.4. Reducing texture distortions
An important issue of surface texture synthesis is to reduce
distortion caused by presenting 2D textures on a 3D surface.
As an important advantage, the round shaped neighbourhood
proposed here can naturally avoid such a texture distortion.
Normally, texture distortions happen in surface areas with
large curvature variations. Figure 3(a) gives such an illustration. Assume L, M and N are three points located on the same
image edge. When the image is mapped onto the surface area
using uniformed sampling density, the middle part of the image is lifted up by the underneath sharp curvature, while the
other sides of the image remain flat. As a result, point L is

During the search, the resampling result in the neighbourhood of the vertex is compared against the neighbourhood
of all the candidate pixels in the texture sample, and subsequently the colour of the most similar candidate pixel is
assigned to the vertex.
The above process concerns a number of issues, including
how to make a candidate pixel set, from which the most suitable pixel colour is selected, and how to compare pixels using
a similarity metric. These issues are discussed as follows.

5.1. Candidate pixels
To select a number of candidate pixels from the texture
sample, we adopt a similar strategy to [Ash01], which uses
colours of the synthesized vertices within the neighbourhood
to suggest candidate pixel colours. This narrows down the
scope of the colour search within the texture sample and
also encourages the copy of texture patches from the texture
sample to the target surface.
For example, if v 1 is the vertex to be synthesized, and v 2 is
an already synthesized vertex located within the neighbourhood of v 1 . Assume the colour of v 2 comes from pixle p(x,y)
in the texture sample, then we can obtain a candidate pixel
for v 1 as follows:
q = ( p + tolmageSpace(v1 − v2 ))

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

2134

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

where q is the candidate pixel in the texture sample, and
toImageSpace( ) is a function which converts the distance
on the surface to the image space according to the assigned
texture scale.

5.2. Adaptive texture similarity metric
A similarity metric is used to compare the difference between
the textures within two neighbourhoods. This poses as a key
problem in texture synthesis. Traditionally, such a difference is measured by the SSD of corresponding pixels in the
neighbourhood. However, the SSD metric may cause some
significant errors to real texture images, which are mainly
dominated by a pattern of approximately repeated textural
elements.
A key parameter for the SSD metric is the size of the
neighbour, which was set imperially in many previous works.
In general, a large sized neighbourhood provides measurement for global scaled texture structures, while a small sized
neighbourhood looks after local scaled textures. Since the
measurement results at different texture scales are often inconsistent, e.g. a 7 × 7 neighbourhood does not necessarily
provide the same results as a 5 × 5 neighbourhood, a good
neighbourhood size has to be decided by considering the balance between differently sized texture structures. Therefore,
instead of using a single and fixed neighbourhood, a more
suitable scheme is to allow variable neighbourhood size at
different areas of the texture image.
In addition, making similarity measurement using a single
large neighbourhood is more likely to count in outliers. Each
outlier is a pair of pixels whose difference is considerably
larger than the rest of other pixels in the neighbourhood.
This can easily give rise to wrong results.
From these observations, the adaptive pixel similarity metric proposed takes into account texture structures at a range
of different sizes from local to global – see Section 5.2.1.
Besides, it also adaptively decides the neighbourhood size
according to local texture characteristics – see Section 5.2.2.

5.2.1. Measures
Given the resampling result in the neighbourhood of the
vertex, we compare it with the neighbourhood of each of the
pixels in the candidate pixel list given in Section 5.1. This is
an overall comparison of their texture similarity at different
scales, which takes place incrementally – from local (3 × 3)
up to the size that is decided adaptively at different texture
regions. More specifically,
(i)
(ii)

we start from calculating SSD using the smallest neighbourhood (3 × 3);
perform SSD calculation using a bigger neighbourhood (5 × 5);

Figure 4: Identifying the similar pixels with small SSD values as those at the low end of the standard deviation.

(iii)
(iv)

sum up the results from the first two steps; and
continue to calculate SSD at an incrementallyincreased scale, and add the result into the sum. This
continues until the top size of the neighbourhood is
reached.

The top size of the neighbourhood is region dependent, i.e.
it varies according to local texture properties. Section 5.2.2
shows how to decide it.

5.2.2. Neighbourhood size
We use statistical analysis to decide the top size that the
neighbourhood needs to go up to. Also, it allows us to rule out
outliners from the neighbourhood as mentioned in Section
5.2.1.
More specifically, starting from the smallest local size
(3 × 3), a subset is selected from the candidate pixel list
according to the statistics. To do this, the SSD of all the
pixels in the candidate list is calculated, from which a SSD
histogram is drawn to show the distribution, as shown in
Figure 4, where the SSD values are given along x direction,
and the number of pixels with different SSD is shown in y
direction. Therefore, this diagram shows the number of pixels
(y-axis) with different SSD values (x-axis). This distribution
comes together with the mean and standard deviation. The
subset consists of the pixels that fall outside of the low end
of the standard deviation, as indicated by the red coloured
distribution in Figure 4.
Given the subset, similar calculation is carried out again
to form a smaller subset using an incrementally increased
neighbourhood (5 × 5). This continues until only one pixel
is left in the newly formed subset. Then, the size of the
neighbourhood is used as the top neighbourhood size for the
synthesis.
Notably, the above scheme also allows us to rule out outliers. During the neighbourhood comparison, if a pair of pixel

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

2135

falls out of two times of standard deviation, then this pair is
identified as an outlier and excluded from the similarity measurement.

5.3. Resampling in texture sample
To allow the comparison between the round shaped neighbourhood resampled around the vertex and the candidate
pixels, we need to carry out resampling in the texture sample.
More specifically, for each pixel in the texture sample, we
need to resample its local texture property within a round
shaped neighbourhood as illustrated in Figure 2. Linear interpolations are used to find the colours of these resampling
points, which are the intersections between the parallel lines
and circles. This is a completely automatic process and only
needs to be done only once for each particular texture sample
image.

6. Multi-resolution Synthesis
The idea of the multi-resolution synthesis is to apply the
techniques described in Sections 4 and 5 to synthesize the
lowest resolution texture from the lowest resolution texture
sample. Then, by using this result to suggest the candidate
pixels for the higher resolutions, we can quickly perform the
synthesis until the full resolution is reached.
Performing texture synthesis using multi-resolution saves
significant amount of computational time. As only the lowest
resolution texture is synthesized using the adaptive similarity metric, the synthesis requires considerably low cost. For
the synthesis at the higher resolutions, we can avoid extensive searches within the sample texture images for the most
suitable colours by using a small set of candidate pixels suggested from the textures synthesized in the lower resolutions.
Remarkably, the multi-resolution method presented here
can be directly applied to texturing a surface model without
involving complicated operations such as mesh hierarchy,
mesh partitioning on the surface.

Figure 5: Pixel links between two hierarchy images – (px,
py) in I n−1 corresponds to four pixels (2px, 2py), (2px +
1,2py), (2px + 1,2py + 1), (2px, 2py + 1) in I n (textured).

Then, it is straightforward to calculate the texture coordinates of these pixels at different levels. If the size of the
sample texture image at level n is (nWidth × nHeight), then
the size at level n + 1 is (4 × nWidth × nHeight). From these,
we can calculate the texture coordinate of p n (px, py) at level
n as
(pu, pv) = (px/nW idth, py/nH eigth).
Similarly, we can compute the texture coordinates of the
four correspondent pixels on the next level n + 1 according
to their texture coordinates and the image size.

6.2. Multi-resolution neighbourhoods
Performing multi-resolution texture synthesis has to involve
multi-resolution resampling densities for different resolutions. Given the above hierarchy relationship, the neighbourhood that we use for the texture image at level n has half
density than the neighbourhood at level n + 1. More specifically, if the concentric circles used for level n are [r, 2r, 3r,
4r. . .], then the circles for the next level n + 1 are [r/2, r,
3r/2, 2r. . .].

6.3. Synthesis with multi-resolution
6.1. Multi-resolution pyramid
To performance the multi-resolution synthesis, we use an
image hierarchy (pyramid) to represent the texture sample.
Within the pyramid of a sample texture I, a pixel at level
n p n (px, py) corresponds to four pixels on the next level n +
1, whose coordinates are
(2px, 2py), (2px + 1, 2py), (2px + 1, 2py + 1),
(2px, 2py + 1).

(2)

Figure 5 provides an illustration for such a hierarchy link.

Given the above hierarchy links between the different resolution levels, we can speed up the synthesis for higher multiresolutions by only comparing texture similarity with a small
number of candidate pixels suggested by these hierarchy
links.
More specifically, if a vertex colour comes from the pixel
at p n (px, py) in the texture sample at the resolution n, then
in the next resolution n + 1, we only consider the candidate
pixels that are located within a geometrically close distance
to its four hierarchy links given in Equation (2). We use a
threshold dist_range to decide this distance. In practice, it is
normally set at 2 or 3 pixels.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

2136

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

Figure 6: (a) 2D texture synthesis comparison with some previous work (part I); (b) 2D texture synthesis comparison with
some previous work (part II).
This colour selection process only requires very light computation as only a limited number of pixel similarity computation is involved. This provides a quick ’expansion’ from
the lowest resolution result to the full resolution. Therefore,
the multi-resolution offers very rapid synthesis.
7. Results and Discussions
This algorithm was implemented on a PC with 3.8 Ghz Pentium Processor, 2 GB RAM. Figures 6–9 present some results.
To demonstrate the effectiveness of the adaptive texture
synthesis metric, Figure 6(a) and 6(b) show some 2D texture
synthesis results in comparison with some related work, including those from [Ash01,KSE∗ 03, KEB∗ 05, LHo05]. See
Figure 6 for more details of the comparison. It is suggested
that our method produces very close or even better quality
than those from the state of the art in this area. On average,
the computational time is around 15 seconds to synthesize a
360 × 360 image.
Our processing time on 2D texture images is generally
faster than the related work. Producing a result image sized

at 512 × 512 generally takes about 30 seconds. This is fast
in contrast to existing methods. For example, our implementation on [EFr01] took up to several minutes to generate a
512 × 512 result; and in some of the latest works, Kwatra
et al. [KEB∗ 05] required 1–3 minutes to generate a 256 ×
256 texture; Wu and Yu [WYu04] needed around 2 minutes
to generate a 256 × 256 texture from a sample at 128 × 128.
Further, Figure 7(b–d) presents our results of surface
texture synthesis on three different models, and Figure 8
shows texture synthesis on one model along different texture directions using round shaped neighbourhoods. Texture
sample images that were used for the synthesis are given
at the top row of Figure 7(a). The sizes of these models
are:
Head: 1487 vertices; 2918 triangles;
Space shuttle: 2376 vertices, 3952 triangles;
Bunny: 34834 vertices; 69451 triangles; and
Horse: 48485 vertices; 96966 triangles.
In addition, in Figure 7(c) and (d), we zoom into the high
curvature area of the models to display the results.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

2137

Figure 6: (Continued)
c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

2138

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

Figure 7: (a) Texture samples for the surface texture synthesis: (b) surface texture synthesis results (part I); (c) surface texture
synthesis results (part II); and (d) surface texture synthesis results (part III).

By using round shaped neighbourhood, we can save a
considerable amount of computational time by significantly
avoiding recomputation. As mentioned earlier in Section 4, a
surface texture synthesis involves neighbourhood computing
for each surface vertex, as well as the search in the texture
sample for a suitable pixel colour. During the neighbourhood
computing, surface marching is needed, which can have significant cost.

In a conventional scheme, surface marching needs to be
recalculated upon the change of the texture orientations at
the surface vertices. When using round shaped neighbourhoods for the synthesis, this is required only once and can be
created as a pre-process as it is invariant with any changes
of texture orientations. Also, it is a completely automatic
process without requiring user labours. Hence, we can save
substantial time by using round shaped neighbourhoods.

From our statistics, the computation on the surface marching takes the majority of the computational time. This is
particularly true to middle to large sized models – for example, it takes less than 10 seconds to calculate the marching
for all the vertices of a small model like the Head, but takes
around 5 minutes to do this for a model that has similar
size to the Horse. After we obtain the surface marching results, the following calculations (such as colour searching,
etc.) is relatively much faster. For example, it takes about
10–15 seconds to complete the rest of the computation during the synthesis for the Horse model. This is a very small
amount of time as compared to that is spent on the surface
marching.

Figure 9 shows another advantage of using round shaped
neighbourhoods. As mentioned in Section 4.4, using round
shaped neighbourhoods can reduce distortion in areas with
high curvatures. Standard uniform sampling may involve distortions at highly curved areas, such as shown in the two images in Figure 9. These distortions do not exist in our results
in Figure 7.
A major limitation of this proposed method is that it cannot be efficiently mapped onto a parallel architecture like a
GPU. This is mostly because the adaptive texture synthesis
is of sequential nature – the pixel colours in the result image
have to be decided one by one, and the previously synthesized colours have significant influences on the rest of the

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

2139

Figure 7: (Continued)
unsynthesized pixels. In fact, this is a common weakness of
many pixel and patch based texture synthesis methods. Making a texture synthesis method parallel requires a significant
amount of work – see [LHo05].
8. Conclusion and Future Work
This paper presents an adaptive surface texture synthesis using round shaped neighbourhoods. Instead of using fixed
local measurement area for measuring pixel similarity, the
proposed method uses an adaptive texture similarity metric,
taking into account texture property variations across different regions in the image. As a result, the proposed method
avoids the errors from the single valued SSD metric and consequently achieves high quality in our results. To avoid ex-

cessive computation, surface texture synthesis is performed
within a multi-resolution framework without requiring any
manual operation or processing on the target surface. Also,
by using the proposed round shaped neighbourhood, textures
can be synthesized along different texture directions without
involving too much recalculation on the surface marching.
Our future work will considerably extend the method to
the geometric texture synthesis on 3D surfaces, which allows
making geometric textures from a given sample.
Acknowledgement
This work was supported by grant No. EP/C006623/1 from
the Engineering and Physical Sciences Research Council of
the UK.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

2140

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

Figure 7: (Continued)

Figure 8: Surface texture synthesis over different directions.
c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

D. Chen and F. Dong / Adaptive Surface Texture Synthesis

2141

Figure 9: Distortions from uniform-sampled surface texture synthesis.
graph cuts. ACM Transactions on Graphics 22, 3 (2003),
277–286.

References
[Ash01] ASHIKHMIN M.: Synthesizing natural textures. In
Proceedings of the ACM Symposium on Interactive 3D
Graphics (2001), pp. 217–226.
[BIT04] BHAT P., INGRAM S., TURK G.: Geometric texture
synthesis by example. In Eurographics Symposium on Geometry Processing (2004), pp. 41–46.
[CSH∗ 03] COHEN M.F., SHADE J., HILLER S., DEUSSEN O.:
Wang tiles for image and texture generation. ACM Transactions on Graphics 22, 3 (2003), 287–294.
[deB97] DE BONET J. S.: Multiresolution sampling procedure for analysis and synthesis of texture images. In Proceedings of SIGGRAPH 97, (1997), pp. 361–368.
[DML∗ 02] DISCHLER J. M., MARITAUD K., LEVY B.,
GHAZANFARPOUR D.: Texture Particles. Computer Graphics
Forum 21, 3 (2002), 401–410.
[EFr01] EFROS A. A., FREEMAN W. T.: Image quilting for
texture synthesis and transfer. In Proceedings of SIGGRAPH 01, (2001), pp. 341–346.
[GIS03] GORLA G., INTERRANTE V., SAPIRO G.: Texture synthesis for 3D shape representation. IEEE Transactions on
Visualization and Computer Graphics 9, 4 (2003), 512–
524.

[LDD05] LAGAE A., DUMONT O., DUTRE P.: Geometry synthesis by example. Shape Modeling International (2005),
174–183.
[LHo05] LEFEBVRE S., HOPPE H.: Parallel controllable texture synthesis. ACM Transactions on Graphics 24, 3
(2005), 777–786.
[LHo06] LEFEBVRE S., HOPPE H.: Appearance-space texture
synthesis. ACM Transactions on Graphics 25, 3 (2006),
541–548.
[LLX∗ 01] LIANG L., LIU C., XU Y., GUO B., SHUM H.: Realtime texture synthesis by patch-based sampling. ACM
Transactions on graphics 20, 3 (2001), 127–150.
[MKr03] MAGDA S., KRIEGMAN D.: Fast texture synthesis on
arbitrary meshes. Eurographics Symposium on Rendering
(2003), 82–89.
[PFH00] PRAUN E., FINKELSTEIN A., HOPPE H.: Lapped textures. In ACM Proceedings of SIGGRAPH’00 (2000), pp.
465–470.
[PSi00] PORTILLA J., SIMONCELLI E.P.: A parametric texture
model based on joint statistics of complex wavelet coefficients. International Journal of Computer Vision 40, 1
(2000), 49–71.

[KEB05] KWATRA V., ESSA I., BOBICK A., KWATRA
N.: Texture optimization for example-based synthesis.
ACM Transactions on Graphics 24, 3 (2005), 795–
802.

[SCA02] SOLER C., CANI M., ANGELIDIS A.: Hierarchical
pattern mapping. ACM Transactions on Graphics 21, 3
(2002), 673–680.

[KSE∗ 03] KWATRA V., SCHODL A., ESSA I., TURK G., BOBICK
A.: Graphcut textures: Image and video synthesis using

[Tur01] TURK G., Texture synthesis on surfaces. In ACM
Proceedings of SIGGRAPH (2001), pp. 347–354.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

2142

D. Chen and F. Dong / Adaptive Surface Texture Synthesis
∗

[TZL 02] TONG X., ZHANG J., LIU L., WANG X., GUO B.,
SHUM h.Y.: Synthesis of bidirectional texture functions on
arbitrary surfaces. ACM Transactions on Graphics 21, 3
(2002), 665–672.

[Ying01] YING L., HERTZMANN A., BIERMANN H., ZORIN D.:
Texture and shape synthesis on surfaces. In Proceedings
12th Eurographics Workshop Rendering (June 2001), pp.
302–312.

[WLe00] WEI L.Y., LEVOY M.: Fast texture synthesis using tree-structured vector quantization. In Proceedings of
SIGGRAPH 00 (2000), pp. 479–488.

[ZDW∗ 05] ZHOU K., DU P., WANG L., MATSUSHITA Y., SHI
J., GUO B., SHUM H.-Y.: Decorating surfaces with bidirectional texture functions. IEEE Transactions on Visualization and Computer Graphics 11, 5 (2005), 519–
528.

[WLe01] WEI L., LEVOY M.: Texture synthesis over arbitrary manifold surfaces. In Proceedings of SIGGRAPH
(2001), pp. 355–360.
[WYu04] WU Q., YU Y.: Feature matching and deformation
for texture synthesis. ACM Transactions on Graphics 23,
3 (2004), 364–367.

[ZGa03] ZELINKA S., GARLAND M.: Interactive texture synthesis on surfaces using jump maps. In Eurographics Symposium on Rendering (2003), pp. 90–96.

[XGS00] XU Y., GUO B., SHUM H.: Chaos Mosaic: Fast
and Memory Efficient Texture Synthesis. Technical Report
MSR-TR-2000-32, Microsoft Research, April 2000.

[ZHW∗ 06] ZHOU K., HUANG X., WANG X., TONG Y.,
DESBRUN M., GUO B., SHUM H.: Mesh quilting geometric texture synthesis. ACM Transactions on Graphics 25,
3 (2006), 690–697.

[YHB∗ 01] YING L., HERTZMANN A., BIERMANN H., ZORIN D.:
Texture and shape synthesis on surfaces. In Proceedings
12th Eurographics Workshop Rendering (June 2001), pp.
302–312.

[ZZV∗ 03] ZHANG J., ZHOU K., VELHO L., GUO B., SHUM H.:
Synthesis of progressively-variant textures on arbitrary
surfaces. ACM Transactions on Graphics 22, 3 (2003),
295–302.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.


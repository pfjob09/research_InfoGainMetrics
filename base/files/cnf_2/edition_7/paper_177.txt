Pacific Graphics 2009
S. Lee, D. Lischinski, and Y. Yu
(Guest Editors)

Volume 28 (2009), Number 7

Approximate on-Surface Distance Computation using
Quasi-Developable Charts
Rafael P. Torchelsen1 Francisco Pinto1 Rui Bastos2 João L. D. Comba1
1 Instituto

de Informática - PPGC, UFRGS - Brazil
2 NVIDIA Corporation

Abstract
There is a vast number of applications that require distance field computation over triangular meshes. State-of-theart algorithms have quadratic or sub-quadratic worst-case complexity, making them impractical for interactive
applications. While most of the research on this subject has been focused on reducing the computation complexity
of the algorithms, in this work we propose an approximate algorithm that achieves similar results working in
lower resolutions of the input meshes. The creation of lower resolution meshes is the essence of our proposal. The
idea is to identify regions on the input mesh that can be unfolded into planar regions with minimal area distortion
(i.e. quasi-developable charts). Once charts are computed, their interior is re-triangulated to reduce the number
of triangles, which results in a collection of simplified charts that we call a base mesh. Due to the properties of
quasi-developable regions, we are able to compute distance fields over the base mesh instead of over the input
mesh. This reduces the memory footprint and data processed for distance computations, which is the bottleneck of
these algorithms. We present results that are one order of magnitude faster than current exact solutions, with low
approximation errors.
Categories and Subject Descriptors (according to ACM CCS): Computer Graphics [I.3.5]: Computational Geometry
and Object Modeling—Computer Graphics [I.3.8]: Applications—

1. Introduction
Computing distances on triangular meshes is required in
several fields, including procedural textures [WFM01], surface labeling [CG08], remeshing [PC05], segmentation
[FKS∗ 04] and parameterization [PC05]. Distance evaluation
for interactive applications has been limited to poor approximations, due to the computational cost of exact solutions.
Most interactive applications that require on-the-fly distance
calculation, such as path planning, use variations of the Dijkstra algorithm. However, resulting paths are not smooth,
since they are constrained to pass through the edges of the
triangulation. Recent efforts on computing exact solutions
more efficiently are described in Surazhsky et al. [SSK∗ 05],
Liu et al. [LZH07] and Balasubramanian et al. [BPS09].
However, due to the greedy nature of these algorithms, their
computational time and large memory requirements make
them too expensive for interactive applications.
In this work we propose an approximate algorithm that
produces distance computation with minimal precision loss
c 2009 The Author(s)
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.
Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and
350 Main Street, Malden, MA 02148, USA.

at an order of magnitude faster than an exact algorithm. Our
proposal relies on the properties of quasi-developable charts,
which allow distance computation to be performed over a
simplified version of the input mesh. Distance computation
is performed over simplified charts, thus reducing the computational cost and memory footprint. In Figure 1, we compare distance fields computed on the input mesh (items (a)
and (c)) against results computed over the base mesh using our approach (items (b) and (d)). Colormaps and isolines in both cases are mapped and displayed over the input
mesh, even for the one computed on the base mesh. Figure
1(e) presents an error histogram of the approximation error.
While the distance field using the input mesh required 13
seconds to compute, our method took only 0.4 seconds and
the memory footprint was reduced 19 times.
The main contributions of our approach can be summarized as follows:
• Developability as a simplification criteria: Input mesh
is divided into quasi-developable segments that are un-

1782

Rafael Torchelsen et al. / Approximate on-Surface Distance Computation using Quasi-Developable Charts
1

Number of
Vertices

0.9
0.8

50
50

0.7

Number of Vertices

40

0.6
0.5
0.4

30

40

20
10
0
30

20

0.3
0

0.2
0.1

(b) Base mesh

0.2

0.3

10
0.4

0.5

0.6

Exact Distance

0

(a) Input mesh

0.1

(c) Input mesh

(d) Base mesh

0.7

0.8

0.9

1

0

0.02

0.04

0.06

0.08

0.1

0.12
0

Error

(e) Base mesh error histogram

Figure 1: Distance field computed on the input mesh and on the simplified base mesh; all results mapped on the input mesh,
the captions denote where each result was computed. Distance fields are represented by the color-coded, normalized distance
between each point, on the surface, to the source point (distance 0) - (a) and (b). Isolines extracted from (a) and (b) are shown
in (c) and (d), respectively. Approximation error is presented in a 3D histogram (e): difference between distances computed on
each mesh. The distances computed on the input mesh are exact. We can control the accuracy of our method.

folded into charts and then simplified (remeshed) with
no additional distortion. Distance computation algorithms
over simplified charts lead to better performance with an
acceptable loss of accuracy, caused by distortion in mesh
unfolding.
• Accuracy control: Most meshes are not developable or
quasi-developable, which causes distortion in the mapping between the input mesh and the base mesh, thus reducing accuracy. Distortion error is controlled by dividing
the input mesh into regions where the unfolding distortion
does not pass a given threshold.
• Improved performance: Memory footprint is reduced,
which leads to smaller computational cost for calculating
distances.
• Generic solution: Algorithms for distance computation
can be adapted to use our simplified mesh, such as Dijkstra [Dij59], Sethian [Set99], Surazhsky et al. [SSK∗ 05]
and Martinez et al. [MVC05].
2. Related Work
In this section we review the related work on distance computation on triangular meshes - which has a good survey
in [BPS09] - and quasi-developable mesh segmentation.
Distance Computation Algorithms
The well-known Dijkstra algorithm [Dij59], and its variations, have been extensively used to compute distances on
meshes. Instead of computing geodesic paths, Disjkstra-like
algorithms compute paths over the edges of the mesh, resulting, in most cases, in poor approximations. Another algorithm that gives approximate results, with attractive performance, is the Fast Marching (FM) [Set99]. FM uses wave

propagations on the mesh surface to generate a distance field.
As in most distance field-based algorithms, the shortest path
on the mesh surface connecting two points can be found by
gradient descent on the distance field.
Martinez et al. [MVC05] computes shortest paths between
two points, but its computational cost is higher than Dijkstra and FM. They compute the exact solution based on an
initial guess, computed using FM. Performance depends on
the accuracy of the initial guess, which motivated the use
of FM instead of the faster Dijkstra algorithm. Mitchell et
al. [MMP87] proposal was extended by Surazhsky et al.
[SSK∗ 05] to calculate exact distances from a given point
on the mesh surface to any other point on the mesh. They
showed that their method has similar performance, however,
improved precision if compared to FM. Recently, Balasubramanian et al. [BPS09] proposed an algorithm based on the iterative growth of triangle strips. The goal is to find the triangle strip that has the shortest path connecting two points on
the mesh surface. According to the authors, their method has
approximately half of the computational cost of [SSK∗ 05].
Quasi-Developable Segmentation
The segmentation of non-developable meshes into quasidevelopable charts has attracted considerable attention, due
to the practical applications and difficulty of the task. The
work of Julius et al. [JKS05] has accomplished quasidevelopable mesh segmentation by computing the angle between each triangle normal and a common axis and grouping
triangles with constant angle variation. Alternatively, Yamaguchi et al. [YGZS05] introduced a segmentation based on
Gauss area, where the segmentation can be accomplished by
grouping regions of the mesh with zero Gauss area. Recent
work of Wang [Wan08] obtained quasi-developable charts
c 2009 The Author(s)
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

Rafael Torchelsen et al. / Approximate on-Surface Distance Computation using Quasi-Developable Charts

by merging charts generated by the method of Cohen-Steiner
et al. [CSAD04]. The idea is to identify several small quasidevelopable charts and test if two charts can be merged without generating too much distortion.
3. Triangular Mesh Simplification for on-Surface
Distance Computation
3.1. Distance Computation on Developable Surfaces
Developable surfaces (such as cylinders and conical surfaces) are surfaces
with zero Gaussian curvature everywhere. Such surfaces admit isometric parameterization to the plane, and
we refer the reader to [SPR06] for
more details. The distance-preserving
property of such parameterizations is
the characteristic that motivates our
approach. Consider, for instance, the
computation of the shortest path between two points on a cylinder. The
shortest path curve over the cylinder
becomes a line when the cylinder is unfolded. The resulting path is a line, because the distance variation is constant
inside unfolded developable surfaces. However, the shortest
path connecting both points is not the only possible path connecting them. Finding the shortest path among all possible
paths is the goal of most distance computation algorithms.
A common way to compute distances on the surface of
triangular meshes is using wave propagation. To determine
the shortest path, between two points, a wave propagation
from an origin point is started. Consider the example show
in Figure 2, where color represents the distance to each point
inside the wave to the origin point. When the wave collides
with itself, the front closer to the origin pushes the other
front until both fronts have the same distance to the origin. The process continues until the entire surface is covered. Finding the shortest path is a matter of descending the
gradient of the distance field from destination to origin.
Wave propagation, on triangular meshes, is performed by
walking over the triangles in steps equal to the triangles
adjacent to the wave front (Figure 3), thus the number of
triangles greatly affects the performance of this process. If
the distance varies constantly and isotropically over the unfolded triangular mesh surface, the number of triangles does
not alter the resulting distance field (i. e., the size of the prop-

Figure 2: Wave propagation on developable meshes.

c 2009 The Author(s)
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

(a) 1 Step

(b) 2 Steps

(c) 6 Steps

1783

(d) 1 Step

Figure 3: Wave propagation on two triangular meshes with
same area. (a)-(c) represents the propagation on an unfolded
mesh (input mesh), while (d) represents the propagation on
a simplified version of the mesh (base mesh). Resulting distance fields are the same but more efficiently computed on
the simpler mesh (base mesh).

(a) Base Mesh + Distance Field

(b) Unfolded Input Mesh

Figure 4: Shortest path. Path computed on the base mesh is
mapped to the input mesh, and reconstructed by computing
intersections against the triangles (yellow arrows).

agation step does not change the result). In this sense, for
computing distances on a developable mesh, we can find a
simplified triangulation (base mesh) that does not alter the
borders of the unfolded mesh (input mesh) and compute distances on this simplified triangulation, thus optimizing the
process.
Figure 4 illustrates a path computed on the base mesh and
mapped to the input mesh. We can map a point from one
mesh into the other because the base mesh has the same area
and borders of the unfolded input mesh. The dashed rectangle, in Figure 4, illustrates the border of the input mesh,
which is the same on the base mesh.
This method applied on developable meshes computes
distances without loss of precision or generality. However,
on non-developable meshes, a global unfolding may result
in high amounts of distortion, which leads to loss of accuracy on distance computation. To overcome this problem,
we first segment the input mesh in charts that can be unfolded with limited and controlled distortion. Next, we simplify each chart independently, and the collection of all simplified charts results in our base mesh.
3.2. Quasi-Developable Mesh Segmentation
The mesh segmentation technique we use is based on the
work of Wang [Wan08], which merges the charts generated
using the Cohen-Steiner et al. [CSAD04] algorithm. This
choice was based on the features of the method: distortion
control and reduced number of charts. We can control the
distortion by defining the initial number of charts generated with [CSAD04]. The merging of charts, as presented
by Wang [Wan08], reduces the final number of charts, con-

1784

Rafael Torchelsen et al. / Approximate on-Surface Distance Computation using Quasi-Developable Charts

(a) Input Mesh

(b)

(c)

(d) Base Mesh

Figure 5: Base mesh construction pipeline. Given an input mesh, the first step is to identify quasi-developable regions on the
mesh (a); followed by the unfolding of those regions (b). Chart simplification removes interior vertices without changing the
boundary (simple polygon) (c). Finally, charts are re-triangulated (d). In this example, the input mesh was formed by 20,180
triangles, while the base mesh is composed by 1,148 triangles. Notice the reduction in number of triangles from (b) to (d).

trolled by a pre-defined threshold on the maximum distortion
allowed. Figure 5(a) illustrates a mesh segmentation. The parameterization method used is the one described in Sheffer
et al. [SLMB05], and an example of charts that we obtain
can be seen on Figure 5(b).
3.3. Chart Simplification
After the mesh segmentation and parameterization we have
the regions of the input mesh that are quasi-developable. We
simplify each chart, first by removing all interior vertices.
The result is a simple polygon: the chart border. Figure 5(c)
depicts the region of the charts that are not modified during the simplification process. We do not modify the vertices
and edges in the borders to enforce the connection between
neighboring charts, allowing us to navigate between charts.
In other words, we have a bijective mapping between the
borders of neighboring charts.

3.4. Adapting a Distance Computation Algorithm
For calculating distances on the base mesh, we adapted the
algorithm from Surazhsky et al. [SSK∗ 05], which calculates
exact minimal geodesic distances on triangular meshes. We
generated our results with this algorithm to avoid contaminating the approximated distances obtained through our approach with any other source of inaccuracies. We used the
robust implementation from Liu et al. [LZH07], with the
adaptation described in this subsection.

We assume that the distance variation inside the red polygons in Figure 5 is constant in any direction, as a result of
the quasi-developable mesh segmentation. In order to use
existing distance computation algorithms we need a triangular mesh. In that sense, we re-triangulate the interior of the
polygons. Figure 5(d) illustrates the charts re-triangulation,
showing a considerable reduction in the number of triangles
to the original shown in 5(b).

In the algorithm of Surazhsky et al., the source point, from
which geodesic distances are calculated, casts windows (Figure 6(a)) that are successively propagated across adjacent triangles. Windows represent regions of the mesh for which a
shortest path candidate to the source point is already defined.
Therefore, windows shapes must not be changed when they
are propagated across triangles; however, in the base mesh,
a window may be propagated across the frontier between
two charts, where the shared edges (red polygons on Figure
5) usually do not have the same length on both charts, due
to the parametrization non-uniform distortion. For handling
this peculiarity, with minimum changes on the original algorithm, we added to the window representation a scale factor
β, which changes when the window is propagated across the
frontier. The original parameters for the window representation are depicted in Figure 6(a).

After each chart has been simplified, we have the base
mesh. We use this flat mesh as input for distance computation algorithms. Note that the charts are logically connected by shared edges (red polygons). However, as a result
of the independent chart parameterization shared edges do
not share the same length; in other words, the connection
between charts is implicit and not explicit. This logical connection and the difference in length between shared edges
guide the necessary modifications on distance computation
algorithms to apply them to the base mesh. The next section
describes how one can adapt a distance computation algorithm designed for usual triangular meshes.

The scale factor β is initially set to one for every created window. When a window is propagated across the frontier between two charts, its width may change, as shown in
Figure 6(b) due to the difference in edge length between
both sides of the frontier. In this transition, the shape of the
window can be kept unchanged by scaling b1, b2, d1, d2 and
σ by the same scale factor that changed the window width.
This scale factor is the ratio between the length of the frontier edges on each chart (see Figure 6(b)). The scale factor
is also accumulated in β at successive window propagations.
This way, the scale of the window may be removed by dividing b1, b2, d1, d2 and σ by β. Removing the window scalc 2009 The Author(s)
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

Rafael Torchelsen et al. / Approximate on-Surface Distance Computation using Quasi-Developable Charts
S

S

distances on the base mesh, we need 613 KB to store the
windows necessary to generate the distance field of Figure
1(b) and 1(c). Figure 1(e) presents the error histogram of the
distance field computed using our method.
β = β’ * (Edge / Edge’)

W = (d1, d2, b1, b2, σ, τ)

1785

W = (d1, d2, b1, b2, σ, τ, β)

(a) Window as in Surazhsky et al. (b) Window adapted to include a scale factor

Figure 6: Modified window representation. The scale factor β is the ratio between the frontier edges crossed by the
window. In this case, each triangle in (b) is a chart.

ing is necessary when the actual length of the shortest path
candidate encoded by the window must be known. Finding
shortest paths and resolving windows superpositions are examples of such situation.
Note that this modification is related to the distance computation algorithm presented by Surazhsky et al. [SSK∗ 05].
Another solution may be required for a different distance
computation algorithm.
4. Results
We tested the algorithms on an Intel CoreTM 2 1.86GHz
PC with 4GB RAM. We used, as segmentation method, the
approach presented by Wang [Wan08], while the following
unfolding of the segments was done using the method of
Sheffer et al. [SLMB05]. Both mesh segmentation and parameterization can be accomplished with several different
methods, see [Sha08] for a survey about mesh segmentation
and [SPR06] for a survey about mesh parameterization. The
constraints which must be considered during the construction of the base mesh are the parameterization distortion and
the number of charts. Distortion controls the accuracy of the
computed distances, and the number of charts controls the
mesh simplification. We use the metric presented by Sander
et al. [SSGH01] to measure the parametric distortion.
Table 1 presents the results for the models depicted in
Figures 1, 9 and 10. Figure 1 illustrates the distance field
computed for the Moai model, using the segmentation from
Figure 5(a), parameterization from 5(b) and base mesh from
5(d). Distance computation in the base mesh compared to
using the original input mesh leads to a speedup of 28
times, with an average error of 0.017. Using the input mesh,
the method of Surazhsky et al. [SSK∗ 05] requires 299, 000
windows, while on the base mesh it requires only 13, 096 - a
reduction of 22 times. Using the original window description
(b1, b2, d1, d2, σ, τ) and double precision, we need 11, 679
KB to store the windows necessary to compute the distance
field represented in Figure 1(a) and (c). Including the scale
factor β, into the window representation, and computing the
c 2009 The Author(s)
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

The distance field and isolines for the models Ramesses
and Dancer (non-genus zero mesh) are presented in Figure 9
and error histograms in Figure 7. Two results are presented
for the Dancer, each using different base mesh resolutions
(see Table 1). Note that in our mesh simplification scheme
higher distortion thresholds imply lower base mesh resolutions, which allow us to indirectly control distance computation accuracy and performance.
Figure 8 illustrates how our method can be used on
meshes that are far from developable. This mesh was created applying random noise to a planar mesh, where the amplitude of the noise is low at the lower-left corner of the
mesh and increases towards the upper-right corner. Note the
self-intersections in the region with high noise amplitude.
The Gaussian curvature of that noisy mesh computed as presented in Meyer et al. [MDSB02] ranges from -4640.19 to
20994.02, while the plane, which is the surface where the input mesh is parameterized, has Gaussian curvature equal to
0. The colormap in Figure 8(d) illustrates the Gaussian curvature of the input mesh. To declutter the figure we clamped
the curvature range, removing the 5% higher and lower vertices to generate the colormap. Note that in regions with
higher peaks the number of charts is larger, compared to
flatter regions (colored in green shades - closer to 0 Gaussian curvature in the color scale). Regions with higher peaks
are farther away from a plane (and thus not as developable),
and require more and smaller charts, which reduces the
amount of simplification. Those small charts, after the chart
re-triangulation, remain with the same number of triangles,
as in the input mesh. However, in most cases, meshes are
not formed only by regions with high Gaussian curvature,
in that sense, most cases present some room for simplification. Therefore, we reached a maximum error of 0.05 and
a speedup of 1.65 times by computing distances in a base
mesh resulting from a 43% simplification of the input mesh.
Figure 10 illustrates the isolines computed on a terrain
model. This particular model is an example of surface where
distance computation is frequently required. For example, in
games where performance has priority over precision, our
method can be used to compute paths for agents. Figure 11
illustrates the effect of introducing noise in the input mesh
before the simplification process.

5. Discussion
This work is based on quasi-developable mesh segmentation
and parameterization. In that sense, meshes with high Gaussian curvature require small charts to avoid distortion, limiting the amount of simplification. While parameterizing the
mesh in charts reduces global distortion, this approach tends

Rafael Torchelsen et al. / Approximate on-Surface Distance Computation using Quasi-Developable Charts

1786

Mesh Faces
Input
Base
20,180
1,148
50,004
5,288
50,004
4,038
100,000
587
386,500
16,852

Model
Moai
Dancer L.1
Dancer L.2
Kilimangiaro
Ramesses

L∞
Avg.
1.021
1.006
1.016
1.011
1.006

L2
Max
7.084
1.627
2.258
3.022
4.944

Avg.
1.008
1.002
1.011
1.005
1.003

Error
Avg.
Max
0.017
0.131
0.006
0.02
0.009
0.033
0.002
0.01
0.006
0.035

Max
5.009
1.609
2.076
2.137
4.648

Dynamic Mem. (KB)
Input
Base
11,679
613
39,505
5,117
39,505
3,724
92,870
93
319,536
24,920

Time (sec)
Input
Base
13
0.4
39
4
39
2.8
70
0.03
263
23

Table 1: Performance and accuracy of computing distances on the base mesh (our method) and computing
on the input mesh. The relative error is given by the difference between the distance computed on the base
mesh and on the input mesh, normalized by the farthest point found on both meshes; |DBaseMesh (M(Vn )) −
DInputMesh (Vn )|/Max(Max(DInputMesh (V ), Max(DBaseMesh (M(V )))), where M maps a point in 3D (input mesh) to 2D (base
mesh), Vn ∈ V and V is the set of vertices of the input mesh.
Number of
Vertices

2000

1500

0

1000

Number of Vertices

Number of Vertices

500

150

200

1500
1000

Number of
Vertices

150

200

150
100

100
50
0

Number of Vertices

2000

Number of
Vertices

150
100

100
50
0

50
0

0.1

0
0.2

500
0.3

0.4

0.5

Exact Distance

0.6

0.7

0.8

0.9

1

0

0.005

0.01

0.015

0.02

0.025

0.03

0.035

0.1

50
0

0.2

0.3

0.4

0.5

0.6

Exact Distance
0

Error

(a) Ramesses

0.7

0.8

0.9

1

0

0.005

0.01

0.015

0.02

0.025

0.03

Error

(b) Dancer Mesh Level 1

0.035

0.04

0.1

0.2

0.3

0.4

0.5

0.6

Exact Distance
0

0.7

0.8

0.9

1

0

0.005

0.01

0.015

0.02

0.025

0.03

0.035

0.04

0

Error

(c) Dancer Mesh Level 2

Figure 7: Distance Error histograms for Ramesses and Dancer datasets. Ramesses histogram show small distance error for
nearly all vertices (observe near zero concentration on the Error axis). The average L∞ and L2 distortion is of 1.006 and 1.003,
respectively. Due to the low average distortion, error is also low. In highly distorted regions (max L∞ of 4.944) some error is
introduced, which is not localized (as in the parametrization distortion) since the error is propagated. The Dancer histograms
compare two base meshes with high (b) and low (c) resolutions. Both histograms have the same upper bound error, but only
level 2 reaches this limit, illustrating the tradeoff between accuracy and mesh simplification.

(a) Chart boundary

(b) Isoline

Figure 12: Chart boundary between two charts (a) and isoline visualization (b). Note the discontinuity in (b) due to
edges having different sizes in each chart.

to concentrate distortion in the boundary between charts. As
a result, chart boundaries can present discontinuities (Figure
12). Note the discontinuity in the isoline that is crossing a
frontier between charts. This may not be suitable for applications where the distance field must be smooth. A possible

solution is to use a global smooth parameterization, as in the
work of Khodakovsky et al. [KLS03]. The use of such approach would allow us to remove the scale factor used to
transmit the windows between charts frontiers. This would
further reduce the memory footprint, of our method, and
would allow the direct use of distance computation algorithms developed for triangular meshes, without modifications such the one presented in section 3.4. However, such
global parameterizations tend to have a larger total distortion, compared to independent charts.
A limitation of our method is related to the base mesh
construction, which can not be done in real-time, limiting
its use to static meshes. Considering memory footprint, our
method requires more static memory, due to requiring two
meshes (input mesh and base mesh) and the mapping between them. However, only the static memory footprint is
increased, which is not the bottleneck of state-of-the-art distance computation algorithms. On the other hand, the same
parameterization, used in the mapping between both meshes,
can be used to map textures on the input mesh. Mapping textures is required in several applications, and reusing the pac 2009 The Author(s)
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

Rafael Torchelsen et al. / Approximate on-Surface Distance Computation using Quasi-Developable Charts

1787

0

(a) Input Mesh

(b) Base Mesh

(c) Segmented Input Mesh

(d) Gaussian Curvature

Figure 8: Distance computation on meshes with high Gaussian curvatures. Our method can handle meshes which are far from
developable, however, the amount of simplification becomes limited. Note, on item (c), the concentration of charts in the regions
where the Gaussian curvature frequency is higher, see (d). However, in low frequency regions the charts are larger.

rameterization for this task can be explored, for example, to
improve the performance of procedural texture techniques.

[FKS∗ 04] F UNKHOUSER T., K AZHDAN M., S HILANE P., M IN
P., K IEFER W., TAL A., RUSINKIEWICZ S., D OBKIN D.: Modeling by example. ACM TOG 23, 3 (2004), 652–663.

6. Conclusion and Future Work

[JKS05] J ULIUS D., K RAEVOY V., S HEFFER A.: D-charts:
Quasi-developable mesh segmentation. In Comput. Graph. Forum (Eurographics) (2005), vol. 24(3), pp. 581–590.

We presented a mesh simplification method for accelerating
on-surface distance computation. The results show that our
method can improve the performance of distance computation algorithms with controllable accuracy. The method is
particularly useful for real-time applications, such as games,
where several agents must navigate on the surface of meshes.
We are currently exploring the GPU parallelism for computing distances. Another possible extension is the use of levelsof-detail to compute distances with increasing accuracy.
7. Acknowledgment
We thank Leandro A. F. Fernandes and friends from the lab.
We thank anonymous reviewers on suggestions to improve
this work, and NVIDIA for equipment donations. This work
was sponsored by CNPq-Brazil (grants 140241/2007-8,
141990/2008-2, 485853/2007-8 and 569239/2008-7).
Meshes are provided by the AIM@SHAPE project
(http://www.aimatshape.net). Special thanks goes
to the authors of the following tools: CGAL (http://
www.cgal.org), Graphite (http://alice.loria.fr),
VCG (http://vcg.sourceforge.net) and AntTweakBar
(http://www.antisphere.com).
References
[BPS09] BALASUBRAMANIAN M., P OLIMENI J. R.,
S CHWARTZ E. L.: Exact geodesics and shortest paths on
polyhedral surfaces. IEEE TPAMI 31, 6 (2009).
[CG08] C IPRIANO G., G LEICHER M.: Text scaffolds for effective surface labeling. IEEE TVCG 14, 6 (2008), 1675–1682.
[CSAD04] C OHEN -S TEINER D., A LLIEZ P., D ESBRUN M.:
Variational shape approximation. ACM Trans. Graph. 23, 3
(2004), 905–914.
[Dij59] D IJKSTRA E. W.: A note on two problems in connexion
with graphs. Numerische Mathematik 1 (1959), 269–271.
c 2009 The Author(s)
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

[KLS03] K HODAKOVSKY A., L ITKE N., S CHRÖDER P.: Globally smooth parameterizations with low distortion. In ACM SIGGRAPH (2003), pp. 350–357.
[LZH07] L IU Y.-J., Z HOU Q.-Y., H U S.-M.: Handling degenerate cases in exact geodesic computation on triangle meshes.
Visual Comput. 23, 9 (2007), 661–668.
[MDSB02] M EYER M., D ESBRUN M., S CHROEDER P., BARR
A.: Discrete differential geometry operators for triangulated 2manifolds. In VisMath ’02 Proceedings (2002).
[MMP87] M ITCHELL J. S. B., M OUNT D. M., PAPADIMITRIOU
C. H.: The discrete geodesic problem. SIAM J. Comput. 16, 4
(1987), 647–668.
[MVC05] M OREIRA D. M., V ELHO L., C ARVALHO P. C.:
Geodesic paths on triangular meshes. Computers & Graphics
Journal 29, 5 (2005), 667–675.
[PC05] P EYRÉ G., C OHEN L.: Geodesic computations for fast
and accurate surface remeshing and parameterization. Progress
in Nonlinear Differential Equations and Their Applications 63
(2005), 157–171.
[Set99] S ETHIAN J.: Level Set Methods and Fast Marching Methods. Cambridge University Press, 1999.
[Sha08] S HAMIR A.: A survey on mesh segmentation techniques.
Comput. Graph. Forum 27, 6 (2008), 1539–1556.
[SLMB05]

S HEFFER A.,
GOMYAKOV A.: Abf++:

L ÉVY B., M OGILNITSKY M., B O fast and robust angle based flattening.
ACM TOG 24, 2 (2005), 311–330.

[SPR06] S HEFFER A., P RAUN E., ROSE K.: Mesh parameterization methods and their applications. Found. Trends. Comput.
Graph. Vis. 2, 2 (2006), 105–171.
[SSGH01] S ANDER P. V., S NYDER J., G ORTLER S. J., H OPPE
H.: Texture mapping progressive meshes. In ACM SIGGRAPH
(2001), pp. 409–416.
[SSK∗ 05] S URAZHSKY V., S URAZHSKY T., K IRSANOV D.,
G ORTLER S. J., H OPPE H.: Fast exact and approximate
geodesics on meshes. ACM TOG 24(3) (2005), 553–560.
[Wan08] WANG C.: Computing length-preserved free boundary
for quasi-developable mesh segmentation. IEEE TVCG 14, 1
(2008), 25–36.

1788

Rafael Torchelsen et al. / Approximate on-Surface Distance Computation using Quasi-Developable Charts

(a)

(b)

(c)

(d)

(e)

(f)

(g)

(h)

(i)

(o)

(j)

(k)

(p)

(l)

(m)

(n)

(q)

Figure 9: Distance field, isolines and zoomed details for the Ramesses, computed on the input mesh (a-d) and on the base mesh
(e-h). Next the results for the Dancer: input mesh (i-j) and from base meshes with different resolutions (k-l and m-n). Zoomed
versions appear in the last row: input mesh (o), base mesh resolution 1 (p) and resolution 2 (q), note the difference in accuracy.
c 2009 The Author(s)
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

Rafael Torchelsen et al. / Approximate on-Surface Distance Computation using Quasi-Developable Charts

(a) Input Mesh

(b) Base Mesh

1789

(c) Base Mesh (Input Mesh + Noise)

Figure 10: Kilimangiaro terrain. Item (a) represents isolines of the distance field computed on the input mesh. Item (b) illustrates
the isolines computed on the base mesh. This base mesh was constructed from a global parameterization of the input mesh.
While the base mesh, from item (c), was too constructed from a global parameterization, noise was introduced on the input
mesh (only the result computed on the base mesh is illustrated). See Figure 11 for the histograms of item (b) and (c).
Number of
Vertices

Number of
Vertices
300
300

200

200

250
200

100
50

150

0

100

Number of Vertices

Number of Vertices

150

100

200

0
150

100

0

0.1

0

0.2

50
0.3

0.4

0.5

0.6

Exact Distance

(a)

L2

0.01
0.7

0.8

0.9

0.004
1

0

0.006

0.002

Error

(b) Kilimangiaro Mesh

0.008

0.1

0.2

0.3

0.4

50
0.5

0.6

Exact Distance
0

0.7

0.8

0.9

1

0

0.01

0.02

0.03

0.04

0.05

0.06
0

Error

(c) Kilimangiaro Mesh + Noise

Figure 11: Relation between parametric distortion and error on the distance computation. (a) depict the L2 distortion present
in the parameterizations that constructed the base meshes used on (b) and (c) from Figure 10. The uniform distribution of
distortion, due to the introduction of noise, results in an almost linear increase of error, see (c). This is the result of the wave
front continually passing over distortion. As a result, the error, created due the distortion, is continuously added to the distance
that the wave front encode. Note that the upper bound error in (b) and (c) is different.

[WFM01] WALTER M., F OURNIER A., M ENEVAUX D.: Integrating shape and pattern in mammalian models. In ACM SIGGRAPH (2001), pp. 317–326.
[YGZS05] YAMAUCHI H., G UMHOLD S., Z AYER R., S EIDEL
H.-P.: Mesh segmentation driven by gaussian curvature. Visual
Comput. 21, 8-10 (2005), 659–668.

c 2009 The Author(s)
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.


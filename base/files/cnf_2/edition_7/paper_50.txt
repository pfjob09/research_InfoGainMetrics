Volume 28 (2009), Number 2

EUROGRAPHICS 2009 / P. Dutré and M. Stamminger
(Guest Editors)

Physically Guided Animation of Trees
Ralf Habel1 , Alexander Kusternig1 and Michael Wimmer1
1 Institute

of Computer Graphics and Algorithms
Vienna University of Technology, Austria

Abstract
This paper presents a new method to animate the interaction of a tree with wind both realistically and in real
time. The main idea is to combine statistical observations with physical properties in two major parts of tree
animation. First, the interaction of a single branch with the forces applied to it is approximated by a novel efficient
two step nonlinear deformation method, allowing arbitrary continuous deformations and circumventing the need
to segment a branch to model its deformation behavior. Second, the interaction of wind with the dynamic system
representing a tree is statistically modeled. By precomputing the response function of branches to turbulent wind
in frequency space, the motion of a branch can be synthesized efficiently by sampling a 2D motion texture.
Using a hierarchical form of vertex displacement, both methods can be combined in a single vertex shader, fully
leveraging the power of modern GPUs to realistically animate thousands of branches and ten thousands of leaves
at practically no cost.
Categories and Subject Descriptors (according to ACM CCS):
Phenomena,Vegetation,Tree,Animation—

1. Introduction
Plants, especially trees, are an important element of many
interactive applications. While there have been significant
advances in the realistic rendering of trees, it is probably
the quality of animation that has most influence on how
convincing a tree looks. Visually convincing animation of
trees in real time is a difficult problem due to several factors. Trees are geometrically very complex, consisting of
thousands of branches and leaves. All these geometric elements are connected in a complex dynamic system that is
hard to solve. The characteristics of tree animation are determined mainly by the high-frequency behavior, for example
the jittery movement of leaves even in light wind. This cannot be expressed using simple approximations like simple
sinusoidal movement of tree branches. As yet, there are only
few methods that provide real-time animation of trees while
addressing at least some of these factors.
In general, animating a tree involves different components: a wind model which describes the characteristics of
turbulent wind interacting with a tree; the dynamic system,
which describes how the interconnected branches and leaves
react to the external wind force; the geometric model, which
describes how the forces resulting from the dynamic system
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.
Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and
350 Main Street, Malden, MA 02148, USA.

Computer Graphics [I.3.3]: Natural

affect the geometry of the tree by for example bending the
branches; and the structural model which describes the hierarchical organization of the geometry.
The prevalent structural model for trees is skinned skeletal
animation. This model has the disadvantage that it places a
burden on the CPU because the bone matrix for each branch
has to be recalculated every frame. Usually this is combined
with a rigid geometric model, i.e., each sub-branch (between
joints) is rigid and does not deform (bend). Some approaches
introduce limited bending by adding more joints, leading to
even more overhead. Furthermore, most real-time tree animation approaches have greatly simplified dynamics, for example by using a static mass-spring model instead of integrating forces over time.
In this paper, we introduce a new real-time tree animation method that is both significantly faster and more physically plausible than previous methods. Quality is improved
using both a physically based geometric and dynamic model,
leading to realistic bending and swaying motion of branches
in the wind. Speed is improved by choosing all elements
so that they can be localized to a vertex: in the structural
model, skeletal animation is replaced by hierarchical vertex
displacement, which directly evaluates the branch hierarchy

524

R. Habel & A. Kusternig & M. Wimmer / Physically Guided Animation of Trees

in the vertex shader; the geometric model is expressed using
an explicit analytic formula for the Euler Bernoulli beam
model that has no dependencies on other parts of the tree;
and the dynamics model is calculated in the frequency domain and evaluated using noise functions.

wind itself is not visible. Thus, the characteristics of the animation are mainly determined by the frequencies and amplitudes of branches. In comparison to these methods, we
introduce 2D motion textures to efficiently generate a large
number of aperiodic noise functions.

While deformation of branches is rarely even considered
in real-time animation, our geometric model even improves
on previous offline methods, which are based on the common assumption of uniform-thickness beams. We show an
efficient analytic deformation operator for tree branches,
whose thickness vary significantly along the length, causing
different bending behaviors. We also show the corresponding analytic formulation for transforming normals and tangents for realistic shading of the deformed trees.

It turns out that for certain sets of tree parameters, the resulting spectral response function has roughly the shape of
1/ f β , which has been exploited by [SFT∗ 03] to drive motion
directly by 1/ f β noise.

The main observation underlying our dynamics model is
that most of the visual effect caused by the dynamic system in a tree can be obtained by looking only at the decoupled system, i.e., where branches have no direct influence
on each other [CGZ∗ 05]. This is plausible because there is
in general little overlap in the vibration frequencies of connected branches. We model each branch as a damped harmonic oscillator, and calculate its interaction with wind in
frequency space. For efficient evaluation of the result in primary space, we introduce 2D motion textures, which provide an extremely efficient way to generate thousands of
functions for the whole tree while avoiding periodicity, and
which can be evaluated in the vertex shader.
Thus, all computations are done in the vertex shader and
are usually hidden by shading computations. Furthermore,
we provide a set of intuitive parameters which control the
animation and can be changed in real time.

2. Related Work
Previous approaches for simulating the dynamic system
of trees can be roughly categorized in full simulation approaches, based on a computationally expensive integration
of the equations of motion ( [AK06,ZST∗ 06,SF92,ZST∗ 06,
SO99]) and heuristic approaches ( [SFT∗ 03, WS05, Zio07,
Sou07]) which do not consider the physical properties of
trees. There are also hybrid techniques [GCF01, WVHR06].
All of these typically make use of stochastic approximations,
especially for wind.
Stam [Sta97] carries out the simulation in the frequency
domain, reducing computation time by modal analysis.
The result is a precalculated stochastic periodic motion.
[CGZ∗ 05] uses similar spectral methods to model a large
range of natural phenomena. For trees, they consider a simplified, uncoupled dynamic system based on a harmonic oscillator per branch, which is also the basis of our texture
based motion synthesis. The basis of this simplification is
that an observer cannot judge the correctness of the response
function of a highly complex dynamical system because the

A common geometric model for representing tree structures is based on deformable uniform thickness beams
[SF92, CGZ∗ 05], while our method on the other hand correctly takes taper and length into account, which has an
essential impact on the deflection of a branch. Interactive
methods, on the other hand, usually do not consider deformation of branches [SO99, SFT∗ 03]. Joint segmentation
could be used, but would get prohibitively expensive for
highly detailed trees. Our example tree would require about
30000 joints with the corresponding hierarchy and smooth
skinning.

3. Hierachical Vertex Displacement
The key element for real-time performance is to localize all
computations in a vertex shader, leading to so-called vertex displacement. This is often used to animate simple vegetation represented as billboards (e.g., grass) or billboard
clouds (e.g. simple tree models [Sou07]). For hierarchical,
full-geometry tree models, this is not straight-forward.
The main idea is to expose the relevant part of the tree
structure (i.e., hierarchy) to every vertex. Thus, the hierarchical deformations of all parent branches can be explicitly performed inside the vertex shader and no information
needs to be propagated at runtime. We can achieve this by
assigning each vertex an index into a texture that holds all
information necessary for that vertex, so every vertex within
a branch has the same index. Additionally, since we allow
sub-branches to emanate at any position of its parent branch,
the relations of each vertex to all parent hierarchy levels are
required. For this, we precalculate the normalized local coordinate x ∈ [0..1] of the vertex, where x is along the principal
axis of a branch. We also calculate the x-values at parentbranch connections and propagate them down the branch hierarchy (see Figure 1). These are stored with each vertex in
addition to its own x-value. The trees in our examples have
4 hierarchy levels, so each vertex has a vector w of 4 values
associated in addition to the branch index.
In order to allow non-rigid deformations, the deformation
model needs to be able to correctly transform the local coordinate axes between hierarchy levels. For this, we introduce
a novel two step deformation method in Section 4 based on
a structural mechanics model that takes the basic physical
properties of a branch into account. The model has a closed
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

R. Habel & A. Kusternig & M. Wimmer / Physically Guided Animation of Trees

525

Figure 2: Beam model used to calculate the deflection of
branches
Figure 1: w distribution of branches in a tree.

form solution, allowing for the required tangent and normal
transformation.
To animate this model, Section 5 covers how the motion
affecting each individual beam are modeled using a wind
model and a dynamic system.
Applying these two main components of our system to actual tree geometry is explained in Section 6, while Section 7
shows the application of both methods to leaves.
4. Beam Model
The model used for describing the geometry and physics of a
beam determines how realistic branches swaying in the wind
appear to the viewer. A common approximation for realistic
animation systems is to model the beam as an elastic cylinder
(uniform beam), and describe the deformation due to a uniform traversal force using a polynomial deflection function
depending on some basic physical properties of the beam.
However, uniform beams are not a good approximation of
tree branches, leading to unrealistic bending. As can be seen
by the direct comparison in the accompanying video, the tips
of branches are more flexible while thicker parts are stiffer
which is not accounted for in uniform beams.
In this section, we describe a beam model that is more
appropriate for branches in combination with a method to
maintain the length of branches even though we make use
of transversal deflection without breaking the restrictions of
hierarchical vertex displacement.
4.1. Euler-Bernoulli Beam Model
The Euler-Bernoulli Beam Model is a structural mechanics
model for long and thin beams with a length to thickness ratio of 15:1 and above, and is therefore suitable for trunks and
branches [TYW74]. A branch is treated as a linearly tapered
circular beam as seen in Figure 2, defined by its length L and
the radii s1 , s2 at the root and free end, thus incorporating the
essential physical properties of a branch or trunk.
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

The deflection of a branch is described by the EulerBernoulli differential equation
∂2
∂2 u(x)
(EI(x)
)=F
(1)
2
∂x
∂x2
where u(x) is the (unknown) deflection of the beam according to the constant transversal force F. I is the area moment
of inertia (not to be confused with the mass moment of inertia), and E is the elastic modulus, which we assume to be
constant.
As each branch is fixed at its root, the boundary conditions
at the root are
∂u
u|x=0 = 0
(2)
|x=0 = 0.
∂x
The boundary conditions at the free end are
∂3 u
∂2 u
|
=
0
|x=L = 0
(3)
x=L
∂x2
∂x3
To simplify the solution and to fit it to the hierarchical vertex
displacement data in Section 3, we normalize the model to
unit length by scaling the radii by L, and introduce the taper
ratio α of the two radii
s1,2
r
r1,2 =
(4)
α= 2
L
r1
and a rescaled elasticity modulus E = EL. The area moment
of inertia for a circular area corresponding to the beam axis
is
πr4
(5)
4
with the radius varying linearly over the length of the beam.
Here the importance of the taper of a branch becomes evident as the area moment is a quartic function of the radius,
thus significantly affecting the resulting deflection as the radius varies. The area moment of inertia along the beam results in
I=

I(x) =

πr14 ((α − 1)x + 1)4
.
4

(6)

Under the given boundary conditions (2) (3) and varying
I(x) (6), the Euler-Bernoulli Equation (1) has an analytical

526

R. Habel & A. Kusternig & M. Wimmer / Physically Guided Animation of Trees

α
0.05
0.1
0.2
0.3

c2
0.221875
0.3326
0.374571
0.364816

c4
0.754029
0.398924
0.129428
0.024577

the transverse direction. Unfortunately, the exact incorporation of the length requires the solution of an elliptical integral [BD45] which can not be formulated explicitly. In order

∆xmax
0.0469
0.0024
0.0081
0.006

Table 1: Coefficients for equation (7) of different values of
the taper ratio α.

p

d

u/u’

yet not trivial solution which is given in Appendix A. It is
interesting to note that the force F affects the solution linearly, which means that the amplitude of the deflection u(x)
is proportional to F, while the root radius influences the deflection with r1−4 . Figure 3 shows the deflection for different
taper ratios normed to E F/r14 = 1. As can be seen, the taper

s u’
1
u
x

Figure 4: Geometry of length correction (parameter x omitted for clarity).
to length correct a deflected branch, we correct the stretch
introduced by the shear of 7 by moving the deflected vertex
along its tangent, effectively converting the shear into a rotation. Using the stretch factor of the shear (which is also the
length of the tangent vector), s(x) = 1 + u 2 (x), the local
length difference d(x) of the original and deflected beam is
d(x) =

u(x)
(s(x) − 1)
u (x)

(8)

Starting from an original point on a branch po = (x, y)T , the
uncorrected point would be pu = (x, y + u(x))T . The final
deflected point p can be found by moving the originally deflected point pu along the tangent direction to unstretch the
beam (see Figure 4):
Figure 3: Deflection for different taper ratios. With decreasing taper ratio, the beam deflection increases due to the thinning of the branch.
of a branch has a very strong influence on both the deflection amplitude and the form of the deflection and can not be
neglected in a realistic branch model. A beam with no taper
(α = 1) as commonly used (e.g. [SF92]) deflects in a way
that the free end is nearly linear, compared to a very curved
and stronger deflection along the beam at small taper ratios.

px = x −

d(x)
s(x)

py = y + u(x) −

u (x)d(x)
u(x)
= y+
s(x)
s(x)

(9)

with x ∈ [0..1]. Thus, the original point is deflected using the
offset vector o(x):
p = po + o(x),

o(x) =

1
−d(x)
s(x) u(x)

(10)

In order to speed up the calculation of u(x), which will
be done in a vertex shader, we perform a least squares fit of
equation (25) to the polynomial
u(x) = c2 x2 + c4 x4

(7)

depending on the taper ratio of each branch. Table 1 shows
coefficients for some taper ratios, along with the maximum
absolute error ∆xmax of this approximation. For taper ratios
above 0.1, the fit is virtually exact. Through the fit, α, E and
r1 are represented by the coefficients c2 and c4.
4.2. Length Correction
The Euler Bernoulli beam model works well for small deflections, but strong deflections (amplitude > L/4) show noticeable stretching since the deflection is only applied in

Figure 5: Strongly deflected and length corrected beam.
Figure 5 compares a strong deflection to its corrected deformation and a direct comparison of a length corrected to a
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

R. Habel & A. Kusternig & M. Wimmer / Physically Guided Animation of Trees

beam without length correction can be seen in the accompanying video.
4.3. Branch Deformation
The previous subsection derived a 2D deflection operator
for a unit-length beam. In order to apply the deflection and
length correction to the vertices of an arbitrary branch, we
need to express the deflection in the local coordinate system
of the branch and un-normalize to the original branch length
L. We assume that each vertex is given in the local coordinate frame (t, r, s) of the branch, where t goes along the axis
of the beam (see Figure 6).
Let x be the coordinate along t, then x = x/L, x ∈ [0..1],
and the unnormalized deflection function u(x) = u(x). By
the chain rule, ∂u/∂x = 1/L∂u/∂x. To take care of the ampli-

Figure 6: Local coordinates for a branch
tude of the deformation, we project the amplitude A, which
is proportional to the net force acting on the branch, onto
r and s, and multiply the deflection with the corresponding
amplitudes Ar and As to arrive at deflection curves in the two
directions, using the normalized coordinate x:
u (x)
(11)
L
Please note that Ar,s does not directly set the strength of the
deflection since taper ratios and radii vary from branch to
branch. The resulting 3D position is thus


−dr (x)/sr (x) − ds (x)/ss (x)

ur (x)/sr (x)
p = po + o(x), o(x) = 
us (x)/ss (x)
(12)
ur,s (x) = Ar,s u(x),

ur,s (x) = Ar,s

To transform tangents and normals, we would have to
calculate the Jacobian J p of this transformation. However,
the length-corrected deformation leads to several complex
higher-order terms, which are difficult to evaluate in real
time. We therefore use the Jacobian of the non lengthcorrected deflection and evaluate it at the length corrected
position


1
0 0
J pu = ur (x − dr (x)/sr (x)) 1 0
(13)
us (x − ds (x)/sr (x)) 0 1
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

527

and find the deflected (unnormalized) tangents as t = J pu to ,
and the deflected (unnormalized) normals as n = J p−T
no ,
u
where to , no are the tangent and normal vectors of a vertex
projected into the local frame of a branch. The error introduced is minimal (a maximum 2.4 degrees for the tip of the
beam) since the derivatives of the deflected curve and the
length corrected curve are virtually the same for the same x
(see Figure 5). Section 6 will show how this deformation can
be implemented hierarchically.
5. Synthesizing Branch Motion
A tree interacting with wind is a highly complex dynamic
system that is difficult to solve through numerical simulation and we also want to uphold the restrictions of hierarchical vertex displacement, not allowing any access to previous states. Since the characteristics of branches swaying
in wind is mainly determined by the vibration frequencies of
the branches, we use spectral methods similar to [CGZ∗ 05]
to synthesize branch motion to drive the branch deformation model. The principal idea is to generate noise functions
that obey similar frequency distributions as empirically observed data or results of a full simulation. In this section, we
show an optimized method of synthesizing noise functions
that allow fully aperiodic motion for a whole tree using only
a small number of noise textures, making the method well
suited for real-time applications.
5.1. Turbulent Wind
Trees cause the wind acting upon them to become much
more turbulent than free flowing wind. The turbulence in
the wind field is dominant over the directional contribution,
making it hard to tell the wind direction from tree motion
(at least in low to medium wind). This makes it possible to
model wind velocity using its power spectrum. A common
model has been created from empirical data [SS86]:
vm
Pw ( f ) ∝
(14)
5
(1 + f /vm ) 3
where vm is the mean velocity of the wind.
5.2. Motion Spectrum
The overall motion of a branch can be approximated using
the physical model of a damped harmonic oscillator, incorporating the dynamic properties of a branch such as its resonance frequency fh , mass m, and damping γh caused for
example by the leaves’ resistance to wind and internal damping. While coupling due to the branch hierarchy can be incorporated at higher processing and memory cost [Sta97], a
reasonable assumption is that each branch oscillates about its
root independently [CGZ∗ 05]. This is mainly because due to
the typically different branch lengths at different hierarchy
levels, the resonance frequencies are far apart.
The amplitude spectrum of the stationary solution of a

528

R. Habel & A. Kusternig & M. Wimmer / Physically Guided Animation of Trees

harmonic oscillator with its resonance frequency fh and
damping γh , driven by an external force (14) is given by:
Vh ( f ) =

Vw ( f )
1
2
2πm(2π( fh − f 2 )2 + (2π f γh )2 ) 2

(15)

trajectories are aperiodic as long as the trajectory does not
close on itself. To avoid this case, we test for the irrationality
of the vector component ratio mx /my and reject the vector if
the ratio is very close to a rational value with a small nominator and denominator. Figure 7 shows an example trajectory
through a motion texture and its result.

where Vw ( f ) is the force spectrum of wind. We introduce a
light form of coupling between branches by calculating the
mass m of each oscillator from the branch itself and all its
subbranches, with ρw being the density of wood:
m = ρw ∑
i

πLi 2
(s + si,1 si,2 + s2i,2 )
3 i,1

(16)

5.3. Stochastic Motion Synthesis
To synthesize motion in the time domain, we generate noise
in the frequency domain, modulate it by wind and oscillator response functions, and transform back to time domain
– hence the name “spectral method”. More specifically, we
first generate a “noisy” wind force spectrum by modulating a random Gaussian field G( f ) by the square root of
the power spectrum of wind Pw ( f ) = G( f ) Pw ( f ). Similar to [CGZ∗ 05], we assume wind force to be proportional
to wind velocity: Vw ( f ) ∝ Pw ( f ). Plugging this into (15) and
taking the inverse Fourier transform of Vh ( f ) gives the motion texture in the time domain. Please note that we do not
consider phase shift since the phases of the Gaussian field
as well as the resulting velocity spectrum are both uniformly
distributed. Other noise functions such as Perlin noise can be
used for a non physical approach, but they can not account
for the resonance frequency of branches and a correct wind
spectrum.
5.4. 2D Motion Textures
The process described so far gives 1D noise functions in the
time domain. Realistic trees have thousands of branches, requiring a massive number of different noise functions, all of
which should be aperiodic.
The main idea of our motion synthesis method is to
generate 2D motion textures instead of 1D functions. Observe that the velocity spectrum can be written as Vh ( f ) =
G( f )H( f ), with H( f ) representing the combined spectral
response function of the harmonic oscillator and wind. We
start from a 2D random Gaussian field G(x, y) and calculate a 2D velocity spectrum Vh (x, y) = G(x, y)Vh ( x2 + y2 ).
The corresponding 2D motion texture is the inverse Fourier
transform of Vh (x, y).
Trajectories. Let us define a linear trajectory of a texture
sample point with a random 2D vector m, sampling the 2Dperiodic (due to the fourier transform) motion texture with
texture repeat for values outside the unit square. Since the
spectrum is radially symmetric, each such trajectory creates
a 1D signal with a spectrum of Vh ( f ). Furthermore, such

Figure 7: Example wrapped trajectory through the motion
texture (left) which results in a aperiodic signal with a defined spectrum (right).

Usage for branches. We exploit 2D motion textures in two
different ways: First, all trajectories through the texture are
aperiodic, thus the tree animation will not show annoying
periodicity artifacts. Second, we reduce the memory requirements for branches. Instead of generating a separate motion
function for each branch, we use just one 2D motion texture for each hierarchy level and generate a trajectory for
each branch in this level from a unique random vector. The
physical properties that enter the computation of a motion
texture are averaged from all branches at the corresponding
hierarchy level. While this approach ignores differences in
some physical attributes of branches at the same hierarchy
level, this is a valid approximation since these branches have
roughly the same properties and attributes, such as number
of sub-branches and leaves attached.
Branch frequencies. However, there is one way to reintroduce variation. Instead of following the trajectory with the
exact speed determined by the fh which was used to create
the texture, we vary fh individually by varying the length of
the motion vector m for each branch. This effectively scales
the spectrum of Vh ( f ) in the time domain. In order to determine an appropriate fh for each branch, we use empirical
data from [Cod00], which incorporates the dragging forces
and internal damping of a branch, giving:
fh = 2.55L−0.59

(17)

Thus each branch has its own resonant frequency according to its length. Since branches in one hierarchy level have
roughly similar lengths, the rescaling is small and the difference to a motion texture calculated using fh in the first place
is imperceptible. Note that this empirical result is based
on broad leaf trees and needs to be modified for leafless
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

529

R. Habel & A. Kusternig & M. Wimmer / Physically Guided Animation of Trees

branches or fir tree branches. Leafless branches have approximately 2.5 times the frequency calculated by equation (17).
Signal smoothing. The inverse Fourier Transform generates textures where the highest frequency is 2 texels per cycle. A good reconstruction of such a signal would require an
appropriate reconstruction filter (e.g., sinc). However, graphics hardware provides only linear filtering, which would lead
to unpleasant motion artifacts. Therefore, we prefilter the
motion texture. Since we start with a frequency space representation, this can easily be done by applying a box filter to
the spectrum. In practice, we start with the desired frequency
range and extend the frequency domain by a factor of 4,
padding the additional frequencies with 0. The resulting motion texture has a highest frequency of 8 texels per cycle, giving a much smoother result after linear interpolation. Since
it is the frequency range around the resonance frequency
which needs to be represented best, we set fmax = 2 fh as
the maximum frequency represented in the box region. The
lowest representable frequency is thus fmin = fmax /(8res),
where res is the texture resolution.
Damping. Damping is one of the critical parameters in determining branch motion. Figure 8 shows the spectra and
parts of the resulting texture in the normally damped (low
γ f ) and overdamped (high γ f ) case. In the former case, the
resonance frequency is dominant and will show up in the
time domain accordingly, whereas the latter case hides the
resonance frequency. Note that the overdamped case has a
spectrum very close to a 1/ f β with β ≈ 2, which explains
why 1/ f β noise can be used to approximate the motion in
some cases (as in [SFT∗ 03]). However, this example demonstrates that it is important to take branch physics into account
when animating trees. In practice, it is hard to estimate the
damping coefficient γh of branches, as it depends on parameters such as the leaf mass, leaf distribution as well as distribution and viscoelastic damping of wood. Furthermore,
trees targeted at real-time graphics are modeled after their
appearance and not according to the correct dynamics of a
tree, which leads to unsatisfactory results if γh is derived
from the geometry. A comparison of empirical measurements [MM04] suggests values of γh in the slightly underdamped region, whereas large branches with a large number
of subbranches and leaves are close to the critically damped
case.

Figure 8: Spectra and parts of the resulting textures for the
damped (top) and the overdamped case (bottom).

tation of the branch, given by its local frame:
Ar = Ar + (r · W )

(18)

As = As + (s · W )

(19)

We also very slowly modulate the wind strength (length of
W ) to increase the realism of the animation.
6. Applying Beam Deformation and Branch Motion
Since we need to carry out several deformations for each vertex, we store vertices in object coordinates and express the
deformation, i.e., the offset, tangent and normal transformations shown in Section 4.3 in terms of the branch coordinate
frame vectors, thus avoiding a full transformation into the local space. The positional deformation of one level simplifies
to
pD = p o −

tdr (x) − rur (x) tds (x) − sus (x)
−
sr (x)
ss (x)

(20)

with the length corrected x values
xD,r,s = x −

dr,s (x)
sr,s (x)

(21)

the tangent and normal transformation results to
5.5. Wind Direction
As already mentioned, the wind direction is not essential for
slight to medium winds, which are governed by turbulence.
Stronger winds, however, will cause large branches that are
orthogonal to the wind direction W to receive a directional
force that causes strong bending. To model that behavior,
for each branch the turbulent wind amplitude is offset by the
force of the strong wind component according to the orienc 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

tD = to + (ur (xD,r )r + us (xD,s )s)(t · to )

(22)

nD = no − (ur (xD,r )(r · no ) + us (xD,s )(s · no ))t (23)
The deformation is executed down the tree hierarchy, starting from the trunk until the level of the vertex is reached (i.e.,
as long as x = wi = 0). For the first iteration, po , to , no are
the original position, tangent and normal in object space, for
all further iterations they are set to pD , tD , nD from the previous iteration. Analogue to the tangents, all involved child

530
Per hierarchy level
Per branch
Per vertex

R. Habel & A. Kusternig & M. Wimmer / Physically Guided Animation of Trees

motion texture
c2 , c4 , L, t, r, s, m motion tex. index
w, branch index

Table 2: Data required to deform a vertex and associated normal and tangent. The per branch data is accessed
through the branch index and the motion textures are accessed through the motion texture index.

branch local frames under the current hierarchy level need to
be transformed according to equation 22. Normals and tangents need to be normalized only after all deformations have
been carried out. As shown in 3, the vertex needs access to
the branch parameters of all its parent branches to execute
these transformations. In particular, the terms dependent on
x (e.g., ur,s (x)) are simple polynomials in x with parameters
c2 , c4 (equation 7). Denormalization also requires the length
L, and motion is accounted for by looking up Ar,s from a motion texture (equation (11)). We store the branch parameters
of the whole tree in a branch data texture, which the vertex
can access based on its branch index, treating the texture as
a data array accessible in the vertex shader. Each column of
this floating point texture contains all the data of a branch,
followed by the data of all parent branches. Analogue to the
branch index, every branch has a motion texture index and
motion vector m for the texture lookups to obtain Ar,s (used
in the evaluation of ur,s ). Using a texture-based data representation has the advantage that low-level per-branch parameters such as α or L can be edited in real time by simply modifying the corresponding texels. Table 2 summarizes which
variables are represented on which level.
7. Leaves
Leaves need to be treated slightly different from branches
because they do not need complex deformation and their
motion behavior is different. But we can apply modified versions of the shown set of methods to ensure full consistency
of the branch and leaf animation.
7.1. Leaf Deformation
We represent leaves as flat quads (although any geometric
representation could be used). Leaves are treated as part of
the last branch hierarchy and inherit all deformations of their
parent branches, so a leaf vertex has the same data as the
branch it is attached to. Apart from the inherited branch deformations, an additional animation is executed to perform
the fluttering of leaves in the wind, modeled with a simplified version of the branch deformation, but with additional
torsional motion.
For the local coordinate system, we make use of the tangent space (tt , bt , nt ). The UV coordinates (denoted by ut , vt
to avoid confusion) of the vertices serve as local coordinates

in this space, using a corrected coordinate ut = (1 − ut )/2
along the tt axis, assuming a centered stipe of the leaf (see
Figure 9). The branch deformer from Section 4.3 is applied
twice: for translational and for torsional flutter. For the translational flutter, the local coordinate axes (t, r, s) are set to
(bt , nt , tt ), so that vt is used for x. For the torsional flutter,
(t, r, s) are set to (tt , bt , nt ), with the corrected ut used for x.
Note that the opposing signs of ut ensure the counter movement of opposing vertices.
In both cases, we execute equation (20) and (23) to carry
out the deformation. However, as opposed to branches, we
do not need a non-linear deformation for leaves, so we use
a simple linear function ul (x) = Al x for all evaluations of
u(x), where Al determines the strength of the deformation
from motion texture lookups (see next subsection).

Figure 9: Additional torsional deformation preceding the
transversal deformation for the leaves.

7.2. Leaf Animation
Since leaves are lightweight and small, we treat them as samplers of the turbulent wind field, and generate motion textures that use only the wind spectrum Pw ( f ) as input (see
Section 5.3). The spatial relation of leaves in gusts of wind
causes leaves to behave in a similar way if they are close
together, i.e., nearby leaves should have similar amplitudes
and frequencies (but not necessarily directions). This could
be accounted for by creating a 3D turbulence field for each
flutter direction and moving this field along the wind direction W . However, 3D textures of sufficient resolution to
transport high frequencies and to avoid periodicity would be
too memory intensive.
Instead, we show a solution using three independent motion textures: Each leaf vertex is projected onto the three
different planes x, y, z = 0 in object space and noise values
p
Axy,xz,yz are fetched from the motion textures after offsetting
the vertex position by −Wt where t represents time. These 3
values are spatially correlated as desired. However their frequency spectra are scaled by the projection of the wind vector on the coordinate planes. We therefore blend the 3 values
in a way that the textures whose frequency is best preserved
receives the largest weight:
p

Al = Axy (1 −

|Wy |
|Wz |
|Wx |
p
p
) + Ayz (1 −
) + Axz (1 −
) (24)
|W |
|W |
|W |

c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

R. Habel & A. Kusternig & M. Wimmer / Physically Guided Animation of Trees

While linear trajectories in the resulting 3D turbulence field
do not have the exact desired spectra, they are still consistent and spatially correlated. The same measures against
periodicity should be taken for the wind vector as in Section 5.3. Figure 10 shows a visualization of the lookups for
one leaf vertex. The three noise textures for the three axes
of leaf deformation (Section 7.1) are stored in the 3 channels of an RGB texture. The texture resolution is chosen so

unshaded
shaded
simplified
4 trees

static(fps)
299
56
56
49

animated(fps)
290
48
52
32

531
time(ms)
0.104
1.49
0.68
5.4

Table 3: Framerate comparison and animation-only time in
the unshaded, shaded and full simplification and multiple
trees case.

shader architecture and interleaving of texture lookups and
ALU calculations of current graphics hardware, we compare to rendering the non-animated tree, both shaded and
unshaded. The shaded scene is rendered with a full HDR
pipeline and dynamic filtered shadow maps and advanced
shading algorithms, thus using the same resources as a modern computer game.

Figure 10: 3D turbulence field through averaged lookups of
3 motion textures.
that the minimum wavelength represented in the leaf motion textures is 4 times the maximum leaf size. This avoids
too high frequencies which could cause vertices of a single
leaf to behave inconsistently. Nonetheless, each vertex of a
leaf performs a slightly different movement, so the leaf itself
does not stay flat. This adds complexity to the overall appearance by mimicking the complex behavior of leaves in wind
compared to the rigid rotation of flat quads [SFT∗ 03], which
especially becomes apparent if a specular shading model is
used for the leaves.
8. Implementation, Results and Discussion
For validation of the method, we have used trees of about
75k vertices, resulting in around 1,500 branches and about
10,000 leaves, divided into 4 hierarchy levels. As input for
our method, we require only the geometric description of a
tree. In addition, we need the full branch hierarchy including local coordinate frames and beam radii. We have implemented a simple conversion routine to create full hierarchy
data just from the geometric description. In this way, we can
for example animate Xfrog [DL04] trees without manual intervention. For trees with continuous geometry, one simply
needs to determine w through the relative position to the local branch coordinate system.
The implementation and performance measurements were
done using DirectX 10 and a NVIDIA 8800 GTS graphics
card with 512 MB RAM on a Pentium 4 (3.2 GHz). Since
it is difficult to measure times separately due to the unified
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

For the shaded and simplified case, the animation is executed two times due to the shadow mapping pass which is
corrected for in the frame rate comparison in Table 3. In the
shaded case, the animation time is longer since fewer shading units are available due to load balancing.
It can be seen that the cost of animation (last column) of
a full geometry tree is negligible compared to shading the
tree, allowing the animation of several highly detailed trees
with a cost that scales linearly with the number of trees. We
also compare the quality of the animation directly to reallife footage of trees in wind in the accompanying video in
order to show that the characteristics of tree motion can be
captured well. The video also contains a comparison of a tree
under different wind conditions. The proposed technique can
be adapted to the animation and shading requirements of a
scene. To further marginalize the performance impact, the
length correction described in Section (4.2) can be omitted
for small deflections in light wind. Additionally, by calculating only the positional animation and shading the tree in
its undeformed state, the performance impact can be minimized (see Table 3) without loosing the overall appearance
of the animation. A direct comparison of the full and simplified method for light wind is also included in the video.
Though we derive values for all parameters from physical
properties, these parameters can be tuned to match different
needs or artists’ visions, which we assume will be the common use case. A screenshot of our tuning setup can be seen
in Figure 11. Every single parameter can be set or overridden
in real time on a per-level, per-branch and per-vertex basis
since previous states of the animation are never accessed.
9. Conclusion and Future Work
We proposed an efficient technique to achieve high-quality
animation and deformation of trees using a novel physically
based deformation method and physically guided stochastic approach to animate a massive amount of branches and

532

R. Habel & A. Kusternig & M. Wimmer / Physically Guided Animation of Trees

References
[AK06] A KAGI Y., K ITAJIMA K.: Computer animation of swaying trees based on physical simulation. Computers and Graphics
30, 4 (2006), 529–539.
[BD45] B ISSHOPP K. E., D RUCKER D. C.: Large deflection of
cantilever beams. Quarterly of applied Math 3, 3 (1945), 272–
275.
[CGZ∗ 05] C HUANG Y.-Y., G OLDMAN D. B., Z HENG K. C.,
C URLESS B., S ALESIN D. H., S ZELISKI R.: Animating pictures with stochastic motion textures. ACM Trans. Graph. 24, 3
(2005), 853–860.

Figure 11: Prototypical user interface to tune animation parameters.

leaves at no considerable cost. The presented methods are
confined to a vertex shader using hierarchical vertex displacement, leveraging the performance of GPUs and also
making it easy to integrate into existing frameworks. The
main novel contributions of this work are: a deformation
model for tree branches that does not assume uniform beams
but correctly accounts for taper; through the analytic expression of the deformation model, normals and tangents can be
transformed efficiently to allow advanced shading on the deformed tree; a technique to synthesize an arbitrary number
of aperiodic noise functions with a defined power spectrum
from a simple 2D texture, thus allowing memory reduction
and performance increase for real-time applications.
In summary, the appeal of the method lies in its simplicity and efficiency while still achieving high-quality animations: there is no precomputation required, so all animation
parameters can be changed interactively and the method is
self contained. A large class of tree models can be used directly, making the method immediately accessible. At the
same time, the method also improves on the physical plausibility of previous methods by using a more accurate beam
model. In the future, we would like to apply the shown methods to other tree representations such as billboard clouds to
create consistent animation levels of detail for highly detailed forest scenes.

[Cod00] C ODER K. D.: Sway frequency in tree stems. University
Outreach Publication FOR00-24 (2000).
[DL04] D EUSSEN O., L INTERMANN B.: Digital Design of Nature: Computer Generated Plants and Organics. SpringerVerlag,
2004.
[GCF01] G IACOMO T. D., C APO S., FAURE F.: An interactive
forest. In Eurographics Workshop on Computer Animation and
Simulation (EGCAS) (sept. 2001), Springer, pp. 65–74. Manchester.
[MM04] M OORE J. R., M AGUIRE D. A.: Natural sway frequencies and damping ratios of trees: concepts, review and synthesis
˝
of previous studies. Trees 3, 18 (2004), 195U203.
[SF92] S HINYA M., F OURNIER A.: Stochastic motion-motion
under the influence of wind. Comput. Graph. Forum 11, 3 (1992),
119–128.
[SFT∗ 03] S HIN O., F UJIMOTO T., TAMURA M., M URAOKA K.,
F UJITA K., C HIBA N.: 1/fβ noise-based real-time animation of
trees swaying in wind fields. In Computer Graphics International
(2003), pp. 52–59.
[SO99] S AKAGUCHI T., O HYA J.: Modeling and animation of
botanical trees for interactive virtual environments. In VRST ’99
(New York, NY, USA, 1999), ACM, pp. 139–146.
[Sou07] S OUSA T.: Vegetation procedural animation and shading
in crysis. In GPU Gems 3, Nguyen H., (Ed.). Addison Wesley,
2007, ch. 16.
[SS86] S IMIU E., S CANLAN R.: Wind Effects on Structures.
JohnWiley and Sons, 1986.
[Sta97] S TAM J.: Stochastic dynamics: Simulating the effects of
turbulence on flexible structures. Computer Graphics Forum 16,
3 (1997), C159–C164.
[TYW74] T IMOSHENKO S., YOUNG D., WEAWER,
W ILLIAMS , J R .: Vibration problems in engineering. New-York
: 1974, 1974.

Acknowledgements

[WS05] W ESSLÉN D., S EIPEL S.: Real-time visualization of animated trees. The Visual Computer 21, 6 (2005), 397–405.

This research was funded by the Austrian Science Fund
(FWF) under contract no. P17261-N04.

[WVHR06] W ILLIAM VAN H AEVRE F. D. F., R EETH F. V.:
Physically-based driven tree animations. Eurographics Workshop
on Natural Phenomena (2006), 75–82.

Appendix A

[Zio07] Z IOMA R.: Gpu-generated procedural wind animations
for trees. In GPU Gems 3, Nguyen H., (Ed.). Addison Wesley,
2007, ch. 6.

u(x) =

E F
x(α − 1)(6 + x(α − 1)(2x(α − 1)(3 + (α − 3)α)
r14

+ 3(4 + (α − 2)α))) − 6(1 + x(α − 1))2 log (1 + x(α − 1))
·

3π(1 + x(α − 1))2 (α − 1)4

−1

[ZST∗ 06] Z HANG L., S ONG C., TAN Q., C HEN W., P ENG Q.:
Quasi-physical simulation of large-scale dynamic forest scenes.
In Computer Graphics International (2006), pp. 735–742.

(25)

c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.


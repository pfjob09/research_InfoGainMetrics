Pacific Graphics 2009
S. Lee, D. Lischinski, and Y. Yu
(Guest Editors)

Volume 28 (2009), Number 7

ProcDef: Local-to-global Deformation for
Skeleton-free Character Animation
Takashi Ijiri1, 2, Kenshi Takayama2, Hideo Yokota1, and Takeo Igarashi2, 3
1

Riken,

2

The University of Tokyo, and

3

JST ERATO

Abstract
Animations of characters with flexible bodies such as jellyfish, snails, and, hearts are difficult to design using
traditional skeleton-based approaches. A standard approach is keyframing, but adjusting the shape of the flexible body for each key frame is tedious. In addition, the character cannot dynamically adjust its motion to respond to the environment or user input. This paper introduces a new procedural deformation framework (ProcDef) for designing and driving animations of such flexible objects. Our approach is to synthesize global motions
procedurally by integrating local deformations. ProcDef provides an efficient design scheme for local deformation patterns; the user can control the orientation and magnitude of local deformations as well as the propagation of deformation signals by specifying line charts and volumetric fields. We also present a fast and robust deformation algorithm based on shape-matching dynamics and show some example animations to illustrate the
feasibility of our framework.
Categories and Subject Descriptors (according to ACM CCS): I.3.7 [Three-Dimensional Graphics and Realism]:
Animation.

(a)

(b)

(c)

(e)

(d)

(f)

Figure 1: Swimming jellyfish. The user constructs an orientation field (b) and a phase-shift field (c) on a tetrahedral model
(a) and sets deformation charts (d). Based on the specified parameters, the system synthesizes global motions induced by the
accumulation of local deformations (e). We visualize the propagation of deformation signals in (f), where excited vertices are
highlighted in red.
object is to set a sequence of discrete key poses and interpolate them in time, specifying individual key poses by
1. Introduction
manipulating many control points is tedious work. FurMost animation authoring methods are designed for rigged
thermore, making these objects respond to external forces
characters whereby the character body is divided into nearsuch as contacts and collisions after all key poses are comrigid parts such as arms and legs, and the user controls the
plete is very difficult.
joint angles between them. However, little work has dealt
To address this issue, we propose a procedural deformawith the animation of flexible objects without specific
tion framework (ProcDef) for designing animations of nonskeletal structures such as jellyfish, snails, slugs, hearts,
articulated objects that are difficult to handle using existing
and stomachs. While the typical approach to this type of
© 2009 The Author(s)
Journal compilation © 2009 The Eurographics Association and Blackwell Publishing Ltd.
Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and
350 Main Street, Malden, MA 02148, USA.

1822

T. Ijiri, K. Takayama, H. Yokota, & T. Igarashi / ProcDef: Local-to-global Deformation

skeleton- or keyframing-based methods. The key observation is that the deformations of such flexible objects are
driven by expansion and contraction of the local tissues.
Local tissues receive some excitation signals and transform
their shapes individually, and then the accumulation of the
local deformations induces the global motion. For example,
a heart is a muscular organ in which muscle fibers are
aligned in a spiral direction. When beating, the heart muscles receive an electronic signal arising in the sinoatrial
node and locally contract along their fiber orientations.
This induces a twisting global motion. Based on this observation, we propose to create the global motion of a flexible object by controlling its local deformations. The user
specifies local deformations such as contraction and expansion, and the system synthesizes the global motion by assembling the local deformations and taking the external
forces into account. We also show that stimuli–response
deformations can be naturally designed within this framework.
We present an efficient design scheme for complicated
local deformation patterns. We use line charts and three
volumetric fields over the model; these are an orientation
field, an amplitude field, and a phase-shift field. The line
charts, called deformation charts, define cyclic timevarying stretching and contraction of a local element in
three directions. The orientation field defines the direction
of the local stretching and contraction. The amplitude field
allows the space-dependent modulation of the deformation
magnitude. This field is particularly useful for designing
bending motions. The phase-shift field allows the user to
design excitation propagation phenomena. We provide a
direct manipulation interface for the line charts and painting interfaces [TOII08] for constructing these three volumetric fields.
We also introduce a robust and efficient algorithm based
on shape matching dynamics [MHTG05; RJ07] for computing global motions induced by the accumulations of local
deformations. Our algorithm is an extension of lattice
shape matching (LSM) [RJ07] with two main differences.
First, while LSM uses the original lattice shape as a rest
configuration, we locally deform the original shape based
on the user-specified parameters and use the deformed
shape as a rest configuration. Second, we use a tetrahedral
mesh instead of a regular lattice. Since we rely on shape
matching dynamics, we can share the same advantages
with them: unconditional robustness and low computational cost.
Figure 1 shows an example animation of a swimming
jellyfish. The user can easily design such animations by
specifying the volumetric fields and the deformation charts.
The resulting animations are computed in real time and the
user can interactively add external forces by dragging part
of an object with the mouse during the animation.
Contributions:
- Introducing a new procedural animation framework whereby global motions are induced by accumulations of local
deformations (Sec. 3).

- Presenting a sophisticated scheme for designing local
deformation patterns using line charts and three volumetric
fields (Sec. 4).
- Showing that shape matching dynamics are useful for
synthesizing motions driven by local deformations (Sec. 5).
- Showing some example animations demonstrating the
effectiveness of the approach (Sec. 6).
2. Related Work
Local-to-global deformation: The concept of local-toglobal deformations was originally presented by Barr
[Bar84]. However the paper only dealt with relatively simple cases where local deformations are globally consistent.
When local deformations contain some conflicts, local
shapes need to compromise each other. Such deformations
were presented in biologically motivated studies. Rolland
et al. [RBC03] studied the asymmetric growth of the petals
of a snapdragon in two dimensions. They represented a
petal with an elastic triangular mesh and emulated its
growth by modifying the rest length of each edge. Ijiri et al.
[IYKI08] extended this model to three dimensions, and
Combaz and Neyret introduced a semi-interactive modeling system for wrinkles of fabrics [CN02] and organic
shapes such as leaves [CN06]. Their systems deform an
elastic surface by locally expanding the user-specified
regions and relaxing the accumulated energies. In these
systems, the user specifies the local growth rate by textures
or painting interfaces. However, these studies are limited to
thin membranes and are intended only for growth (expansion) of tissues. In medical science, finite element-based
systems have been developed to simulate volumetric deformations of organs such as the heart [AKS*04;
WSSH04]. These systems, however, are either for off-line
simulations or require specific hardware.
Detail-preserving deformations: Gradient domain
mesh deformation method is an active research area. The
key concept is to cast mesh deformation as an energy minimization problem. The energy function contains the
terms for detail preservation and positional constraints. The
detail preservation term involves both the local differentials and local transformations. We refer the reader to surveys of this field [Sor06; BS08]. Note that these methods
only consider static surface geometry; it is difficult to apply them to dynamic deformations driven by internal forces.
Deformable models: After Terzopoulos et al. [TPBF87]
introduced a finite difference approach, many physically
based methods and models have been developed to simulate deformable objects including mass-spring models, and
finite element or volume methods. More information is
contained in surveys of this field [GM97; NMK*05].
Shape-matching methods have been recently introduced
to achieve fast and unconditionally stable deformations.
Müller et al. [MHTG05] first applied shape matching to
deformable models. They find the best matching rigid (or
linear) transformation from an undeformed rest shape to
the current deformed shape and determine the goal position
© 2009 The Author(s)
Journal compilation © 2009 The Eurographics Association and Blackwell Publishing Ltd.

1823

T. Ijiri, K. Takayama, H. Yokota, & T. Igarashi / ProcDef: Local-to-global Deformation
of each particle by the transformed rest shape. They then
pull particles to their goal positions. Rivers and James
[RJ07] proposed an extension of this approach called lattice shape matching (LSM) to simulate more degrees of
freedom. They construct overlapped local regions for all
particles of a volumetric lattice. They then apply shape
matching to each local region, and blend the results to obtain the smoothed goal positions. Steinemann et al.
[SOG08] extended LSM by applying dynamic adaptive
sampling to represent heterogeneous stiffness, and Stumpp
et al. [SSBT08] apply a similar approach to cloth.
Virtual character design environment: Some platforms exist in which users can create virtual characters and
design their motions from scratch. Modulobe [EHW*08]
provide LEGO-like interfaces. The user can construct virtual creatures by connecting primitives such as rectangular
solids or shafts. The user can also control the angles of
joints by cyclic functions to design motions. However,
these systems are limited to articulated models. Sodaplay
[Bur] and Springs World 3D [Fal] allow the user to create
elastic characters. In these systems, the user constructs a
model by connecting springs and designs animation by
updating the rest length of each spring using a cyclic function. Although these systems are capable of creating elastic
character animations, the spring model is unstable for large
deformations or strong external forces, and easily generates
undesired oscillations. In addition, these systems require
the user to control the motion of each spring one-by-one,
which makes creating characters with many springs both
tedious and difficult.

The local deformation function Ti(t) depends on vertex i
and time t. We define Ti(t) as a linear transformation to
simplify the problem. Note that even locally linear transformations can generate globally complicated nonlinear
deformations (Sec. 6). A naive approach is to have the user
define the individual Ti(t) manually as described by [Bur].
However, designing expressive motions in this way is too
time-consuming and difficult. In the next section, we therefore present an efficient scheme for defining Ti(t) with few
global controls.

(a)

Ni
(b)

T(t0)

T(t1)

(c)

(d)

(e)

Figure 2: Overview of ProcDef. We first deform individual
local regions Ni (b)(d) of the original mesh (a) by the userspecified T(t) and synthesize the global shape that satisfies
the deformed local shapes (c)(e).
4. Local Deformation Pattern Design

3. ProcDef: Local-to-Global Animation Framework
We introduce a new procedural deformation framework
(ProcDef) for animating flexible objects. Although many
studies on deformable models have been carried out, some
of which are mentioned above, most of them focus on passive deformations caused by external forces. In contrast,
this paper focuses mainly on self-activated motions. Our
framework is useful for designing animations of actively
moving flexible characters (e.g., jellyfish and worms) or
organs (e.g., hearts and stomachs).
We assume that global motion of a flexible object is driven by the accumulation of local deformations. Figure 2
shows an overview of the ProcDef framework. Before the
animation, we prepare a volumetric tetrahedral mesh and
define a local region Ni around each mesh vertex xi by
connecting immediate (1-ring) neighborhood vertices.
Neighboring local regions overlap each other (a). In each
animation step, we first deform each region Ni of the original mesh based on the user-specified deformation function
Ti(t), and then synthesize a new global shape that satisfies
the deformed local regions as much as possible. For example, if we horizontally expand the upper regions and contract the lower regions (b), the global shape bends downward (c). If we contract the upper regions and expand the
lower regions (d), the global shape bends in the opposite
direction (e).
© 2009 The Author(s)
Journal compilation © 2009 The Eurographics Association and Blackwell Publishing Ltd.

This section introduces an efficient and intuitive scheme
for designing local deformation patterns Ti(t) ∈ R3×3. We
assume that a single static orientation field (a set of three
orthogonal vector fields) is defined inside the model. This
orientation field determines the orientations of the local
deformations. We believe that this assumption is natural,
since organic objects usually have fixed fiber orientations
and the local deformations are aligned to the orientations
(e.g., the heart). We provide a graph interface called deformation charts to control the time-varying cyclic deformations. The system allows the user to optionally specify
an amplitude field and a phase-shift field for more complicated deformation patterns. We provide painting interfaces
for constructing these fields. We also introduce a stimuli–
response framework that allows the user to design specific
behaviors when the object contacts obstacles.
4.1 Orientation Field Design
In our definition, an orientation field is a set of three orthogonal vector fields in which three orthogonal unit vectors
(d1, d2, d3) are defined at each vertex. Since designing
appropriate orthogonal vector fields over the whole model
is generally difficult for the user, we divide the design
process into two steps [TOII08].

1824

T. Ijiri, K. Takayama, H. Yokota, & T. Igarashi / ProcDef: Local-to-global Deformation

In the first step, the user constructs a smooth layer field
by placing constraint points with a painting interface. The
user selects a color that represents a layer value; blue and
red correspond to the outermost and innermost parts respectively. The user then paints the color on the model
using three tools: a single face fill tool, a flat region fill
tool, and a stroke tool [TOII08]. The single face fill tool
allows the user to paint the selected color onto a triangle
under the mouse cursor, and the system places constraint
points with the selected layer value on three vertices of the
triangle. The flat region fill tool allows painting on multiple triangles that construct a near-flat surface (the user
can choose the angle threshold); the system places constraint points with the selected value at all vertices of the
near-flat surface. The stroke tool allows the user to draw a
colored stroke on the model surface and the system places
constraint points along the stroke. During painting, the user
can interactively cut the model by drawing a cutting stroke
and paint on the cross sections. After each painting action,
the system automatically interpolates the layer values associated with the constraints over the model so that it generates a smooth layer field. We apply a radial basis function
(RBF) for the interpolation [TO99], and we use the gradients of the obtained layer field as secondary directions of
the orientation field.
In the second step, the user specifies the primary directions of the orientation field by drawing strokes. The user
selects a layer (iso-surface of the layer field) and draws
strokes on the layer. This ensures that the stroke direction
is always perpendicular to the gradient direction of the
layer field. After drawing each stroke, the system immediately interpolates the stroke orientation over the model;
we individually interpolate x, y, and z values of the tangent
directions of the input strokes in three-dimensional space
using the RBF and then normalize the interpolated x, y, and
z values to obtain a unit vector at each vertex. Finally, the
system estimates the third directions of the orientation field
by taking the cross product of the primary and secondary
directions.
Figure 3 shows a design process of an orientation field
for the jellyfish model. The user first paints blue (outermost) on the outer surface and red (innermost) on the inner
surface of the model using the flat region fill tool (a) to
generate the smooth layer field (b). The user can cut the
model by drawing a cutting stroke (the red line in (b)) to
examine the layer structure. The user next draws four
strokes onto a layer to specify the primary direction of the
orientation field. Two strokes are placed on the near side
and the others are on the far side (c). The system finally
constructs the smooth orientation field (d). The three figures in (d) show the primary, secondary, and tertiary orientations from left to right.
4.2 Deformation Charts
After designing the smooth orientation field over the model,
the user specifies the local expansion/contraction rate using
three line charts that we call deformation charts (Fig. 4).
Each of the three charts represents an expansion / contrac-

(a)

(c)

(b)

(d)

Figure 3: User interface for designing an orientation field.

Time line

Tensor field
Control points

×A

expand
×1

0
×1/A

contract

T
For primary direction

0
For secondary direction

T

0

T
For tertiary direction

Figure 4: Deformation charts to define expansion / contraction rate. Top row shows an orientation field and a
local region (cube). The three charts define the deformation rate in the primary, secondary, and tertiary directions
of the orientation field.
tion rate in the primary, secondary, or tertiary direction of
the orientation field. While the horizontal axis corresponds
to the phase [0, T], where T is the user-specified time cycle,
the vertical axis represents the expansion/contraction rate
[1/A, A], where A > 1 is the user-specified amplitude value.
The left and right edges of the charts are connected to
represent cyclic deformation behavior. The vertical red bar
indicates the timeline and moves from left to right repeatedly. The user can modify the three charts by adding or
removing control points or by dragging existing control
points in the charts.
We also provide a volume preservation mode, whereby
the user can modify the chart for the primary direction, and
the system automatically adjusts the remaining secondary
and tertiary charts so that the local transformation always
preserves the original volume. The system adjusts the secondary and tertiary charts to maintain c1(t) × c2(t) × c3(t) =
1, where c1(t), c2(t), and c3(t) are the values of the primary,
secondary, and tertiary charts at time t. We provide two
options for the user: adjusting both charts in which we set
c2(t) = c3(t) = 1 / c1 (t ) , or adjusting the secondary chart
only in which we set c2(t) = 1/c1(t) and c3(t) = 1.
Calculation of local linear transformation: Given
three directions of the orientation field (d1, d2, d3) and
expansion/contraction rates from the deformation charts
(c1(t), c2(t), c3(t)) for a vertex i at time t, the local linear
transformation Ti(t) is defined as

Ti (t ) = D diag( c1 (t ), c 2 (t ), c 3 (t ) ) D T ,

(1)

where D = (d1 d2 d3) ∈ R3×3 and diag(c1, c2, c3) is a 3 × 3
diagonal matrix of which the diagonal elements are c1, c2,
and c3.
© 2009 The Author(s)
Journal compilation © 2009 The Eurographics Association and Blackwell Publishing Ltd.

T. Ijiri, K. Takayama, H. Yokota, & T. Igarashi / ProcDef: Local-to-global Deformation
4.3 Amplitude/Phase Shift Fields
The orientation field and the deformation charts deform the
entire local regions in the same way and lack the ability to
represent rich motions. To support more complicated control, we allow the user to optionally specify amplitude and
phase-shift fields [KA08]. We provide painting interfaces
to design both of these fields similar to that provided for
layer field construction.
The amplitude field allows modifying the magnitude of
the local deformations depending on the space. One can
bend an object by increasing the local deformation on one
side and reducing it on the other side as shown in Figure 5.
We define an amplitude field as being a smooth scalar field
over the model in which all vertices have values ranging
over [–1, 1]. To design this, the user first selects red (value
1), black (value 0), or blue (value –1) and then paints on
the model with the selected color using the three painting
tools. When a vertex has an amplitude field value As, the

1825

system modifies a deformation chart value c as c´ = cAs.
Thus, when As = 1, the system does not change the original
deformation rate. When As = 0, the system eliminates the
deformation effect by making the rate = 1. When As = –1,
the system inverts the deformation rate.
The phase-shift field allows the user to vary the timing
of local deformations depending on the position. This field
is useful for representing motion propagating through the
body, such as a swimming motion of a jellyfish or a peristaltic movement of a bowel. Figure 6 shows the effect of
this field. In our definition, a phase-shift field is a smooth
scalar field ranging over [0, 1]. The user can design this
field in a way similar to the amplitude field. In this field,
black (value 0) and green (value 1) correspond to the
source and sink of the deformation signals. In the animation process, the system shifts phases of the deformation
charts according to the specified field as c′(t) = c(t – Ps/vp),
where Ps is the value of the phase-shift field and vp is the
propagation speed specified by the user. The combination
of the phase-shift and amplitude fields is useful for generating a wavy motion (e.g., crawling snake).
4.4 Stimuli-Response Deformation

(d)

(a)

(b)

(c)

(e)

Figure 5: Bending effect due to an amplitude field. A bar
model and its orientation field are shown in (a). The user
constructs an amplitude field (c) with the painting interfaces (b). The amplitude field efficiently bends the target
model (d) and (e). The expansion rate in the primary
orientation is ×1.5 in (d) and ×1/1.5 in (e). Deformed
regions are highlighted in red (contraction) or light blue
(expansion).

In some natural objects, deformation signals are triggered
by environmental stimuli. For example, a snail deforms its
body when something touches it, and the deformation
usually starts at the contact point. ProcDef can easily emulate such stimuli–response phenomena. Here, we show an
example of stimuli–response interaction (Fig. 7).
(c)
(a)
(d)

(e)
(b)

(a)

(b)

t0

t1

t2

(c)

t3

t4

t0
t1
t2
t3
t4
Figure 6: Deformation propagation due to a phase-shift
field. The user constructs a phase-shift field (b) with a
painting interface (a) and sets the deformation chart for
the primary direction (c). The bottom row shows the sequential poses at times t0, t1, t2, t3, and t4 in (c). Contracted
and expanded regions are highlighted in red and light
blue, respectively.
© 2009 The Author(s)
Journal compilation © 2009 The Eurographics Association and Blackwell Publishing Ltd.

Figure 7: Stimuli–response interactions. The deformation
pattern is specified beforehand (a). When the user touches
the object (c), a deformation signal arises from the touched
point (d). We visualize excited regions in red (e).
Before animating an object, the user sets the propagation
speed vp and damping magnitude Dm of a deformation signal, and specifies a deformation pattern using the deformation charts (Fig. 7(a)). In the animation process, the system
allows the user to touch the object by mouse clicking (Fig.
7(b)). When the user touches the object, the system constructs a distance field from the touched point over the
object, and then propagates the deformation signal along
the distance field; the system dynamically constructs an
amplitude and phase shift for local regions according to the
distance field. When a vertex has a normalized distance
field value d, we define its phase-shift value as Ps = d, and
amplitude value as As = Dm-d; larger phase shift and smaller

1826

T. Ijiri, K. Takayama, H. Yokota, & T. Igarashi / ProcDef: Local-to-global Deformation

magnitude are applied to distant locations. A stimulus response is not a cyclic motion, so the system sweeps the
deformation charts only one cycle. This simple framework
successfully emulates deformations triggered by external
stimuli (Fig. 7(c) and (d)).

This section explains our algorithm that synthesizes global
motions from local deformations. An object is represented
by a volumetric tetrahedral mesh. We construct overlapping local regions Ni at each vertex xi by connecting the
immediate (1-ring) neighborhood. The deformation of each
local region Ni at time t is defined by the user-specified
linear transformation Ti(t).
Our algorithm is based on LSM [RJ07]; we first apply
shape matching to all regions and blend the results to obtain smoothed goal positions gi of vertex xi, and then pull
vertices to their goal positions. The main differences between LSM and our approach are as follows. While LSM
used the original lattice as a rest state, we transform each
local region Ni of the original tetra mesh by Ti and use the
deformed shape as a rest state (Fig. 2). Another difference
is the use of the tetrahedral mesh instead of a regular lattice.
In the lattice representation that embeds an actual model,
outer particles of a lattice are usually outside of the model,
and thus many regions do not fit inside the actual model.
Designing global motions by indirectly controlling such
unfitted regions is difficult and unintuitive. In our approach,
the tetrahedral mesh, in which all local regions are inside
the actual model, allows directly and intuitively specifying
local deformations.
Unfortunately, a fast summation operator of fastLSM is
not available in our case, since constructing a hierarchical
structure for the fast summation in a tetra mesh is difficult.
Note that the benefits of the fast summation would not be
significant even if it were available, since we use only
small local regions (1-ring neighborhood).
Finding goal position by shape matching: We denote
the mass of the ith vertex by mi. To ensure that vertices
belonging to many regions are not weighted more than
~ = m /|N |, for
others, we use modified vertex masses, m
i
i
i
shape matching, where |Ni| is the number of vertices in Ni.
For each local region Nr, [RJ07; MTHG05] find the bestfitting rotation matrix Rr that minimizes

∑ m~i (R r (xi0 − c0r ) − (xi − cr ) )

2

,

∑i∈N

.

(4)

i∈ N r

Rr

The best-fitting rotation matrix Rr can be estimated using
the rotation part of
~ ( x − c ) (T (x 0 − c 0 ))T ∈ R 3×3 .
(5)
Ar ≡ ∑ m
i
i
r
r
i
r

We can obtain the rotation matrix Rr via the polar decomposition Ar = RrSr, where Sr is a symmetric matrix
0
S r = A Tr A r . Given Rr, cr, and cr , we estimate the goal
position of the ith vertex in the local region Nr as,
x i = R r Tr (x i0 − c 0r ) + c r

i∈ Nr .

(6)

Finally, we obtain the goal positions by blending the
shape- matching results of all local regions,

gk =

1
∑ (R i Ti (x0k − ci0 ) + ci ) .
| N k | i∈N k

(7)

To accelerate computation, we precompute Mr and cr0 and
apply a warm start [RJ07] when computing A Tr A r .
Iterative approach for stiffness control: The original
LSM modifies the size of local regions to control the stiffness. However, this stiffness control is not applicable to
our method for the following reason. We assume that a
local region is uniformly deformed by a single linear transformation. Thus, a large local region would contain large
errors and induce inappropriate global deformations. Deforming large local regions nonuniformly may be possible,
for example, with multiple linear transformations. However, this requires the same local-to-global deformation assembly to calculate the nonuniform deformation of a large
region, which is too costly. We therefore control the stiffness by repeatedly applying shape matching to small local
regions.
When calculating the goal position, we first apply shape
matching to the current animated shape xi, to obtain the
goal position g0i. Next, we use the obtained g0i as the target
shape and apply the shape matching to g0i to obtain g1i. We
can iteratively calculate the gNi and use them as the goal
shape. N is a user-defined parameter. For a larger value of
N, a force applied on a vertex affects vertices farther away,
resulting in stiffer deformations (Fig. 8). Note that the
computational cost is proportional to N.

(2)

where xi0 and xi are vertex positions of the undeformed
mesh and the current deformed mesh, respectively, and cr0
and cr are the mass centers of Nr of the undeformed and
current mesh,
1
Mr

2

i∈ N r

Rr

c 0r =

∑ m~i (R r Tr (xi0 − c 0r ) − (xi − c r ))

i∈ N r

5. Implementation Detail

argmin

argmin

r

~ x0 , c = 1
m
i i
r
Mr

∑i∈N

r

~ x ,M =
~ . (3)
m
i i
r ∑i∈N mi
r

In our case, we use the local shape deformed by the linear
transformation Tr(t) as the rest configuration,

(a) N = 1

(b) N = 6

(c) N = 15

Figure 8: Stiffness control by iteration. We fix the center of
a worm in the air. Each figure shows the rest global shape
with different iteration size N.
Dynamics: When the goal positions are obtained, we update the vertex positions xi and velocities vi as described by
[MHTG05],

© 2009 The Author(s)
Journal compilation © 2009 The Eurographics Association and Blackwell Publishing Ltd.

1827

T. Ijiri, K. Takayama, H. Yokota, & T. Igarashi / ProcDef: Local-to-global Deformation

vi (t + h) = v i (t ) +

g i (t ) − xi (t )
+h
h
mi

x i (t + h ) = x i ( t ) + h v i ( t + h )

fiext (t )

,

(8)
(b)

(9)
(a)

where h is the time step of the simulation and fiext is the
external force applied to the i-th vertex. We also apply the
damping model introduced by [MHHR06; RJ07].
6. Results and Discussion
ProcDef supports general deformations that are induced by
muscular tissues and it covers a large variety of possible
motions. Figures 1 and 9 show swimming jellyfish and
crawling worms designed with ProcDef. The user can easily design these animations by setting the orientation field
and the three deformation charts. Our phase-shift field
supports the design of deformation propagation effects
(Figs. 1(c) and 9(a)). We set the amplitude field to create a
bending motion of the worm in Figure 9(c) and 9(e). Figure
10 shows scenes containing many moving objects. In these
examples, the system computes both the deformations and
collision avoidances between objects in real time. Note that
these characters have not been frequently used in video
games so far, because it was difficult and costly to design
and compute their motions. We hope our method can make
such currently unpopular characters to be heavily used in
the future.
Our system is also useful for animating organs. We prepared a heart ventricle model and defined its orientation
field as described by [TAI*08]. The primary directions of
the orientation field are aligned in a spiral form and the
secondary directions are oriented in the thickness directions of the ventricular wall (Fig. 11(a)). We then specify
the deformation charts to make the local regions contract
along the primary directions and expand in the secondary
directions (Fig. 11(b)). These parameters generate highly
realistic twisting motions of the heart (Fig. 11(c)). We also
designed animations of a bowel. We defined a ring-shaped
orientation field (Fig. 11(d)) and deformation charts (Fig.
11(e)). We then propagate deformation signals to generate
peristaltic motions (Fig. 11(f)). Figure 11(g) highlights the
deformation signals; red and light blue indicate contractions and expansions, respectively, in the primary orientation. Since these organ animations are computed in real
time on a standard PC and the user can interact with the
model, we believe ProcDef will be a useful tool for medical applications such as surgery simulations or electronic
charts.
Finally, Table 1 summarizes the performance of our current implementation for each scene in this paper. All timings are generated on a 2.4-GHz Intel Core 2 Duo CPU.
7. Conclusions
In this paper, we presented ProcDef, a new rig-less animation design framework for flexible objects. The key concept is to design the global motions by controlling local
© 2009 The Author(s)
Journal compilation © 2009 The Eurographics Association and Blackwell Publishing Ltd.

(c) Viewed from top

(d)

(e)

Figure 9: Crawling worms. We construct an orientation
and phase shift field on a worm model (a) and set deformation charts (b) to create a crawling motion (d). We can also
design bending motions(e) by setting an amplitude field (c).

Figure 10: Multiple moving objects: 31 swimming jellyfishes (left) and 101 short worms (right).
model
Jellyfish
Worm
Jellyfishes
Worms
Heart
Bowel

Figure
Fig. 1
Fig. 8
Fig. 10left
Fig. 10right
Fig. 11 a-c
Fig. 11 d-g

#Vertices
(#Regions)

854
470
315
73
1302
1576

#Models Iteration N Time(msec)
1
1
31
101
1
1

2
6
1
1
6
6

4.37
5.04
31.64
34.01
14.79
17.49

Table 1: Performance of ProcDef. The time row shows the
timings (millisecond) for computing local deformations Ti,
global motions, and collision avoidance, but for rendering.
deformations. ProcDef permits designing animations of
flexible organic objects that have been difficult to be dealt
with by skeleton- or keyframing-based approaches. ProcDef also allows interactively adding external forces and
stimuli during animation. We provided an efficient scheme
for designing local deformation patterns by setting charts
and volumetric fields. We applied the shape-matching method to synthesizing motions induced by local deformations robustly and efficiently.
One limitation of our method is the representation of
stiffness. Although we introduced an iterative method for
stiffness control, its computational cost is linearly proportional to the iteration size N. Development of a more sophisticated stiffness model remains an item for future work.
Another item for future research is inverse animation design. Currently, we control local deformations, and a global motion only emerges afterward. Allowing a designer to
set a global motion and to have the local deformation configurations computed automatically would be appealing
and useful. We would also like to combine ProcDef with
skeleton- or keyframing-based frameworks for designing
more complicated animations.

1828

T. Ijiri, K. Takayama, H. Yokota, & T. Igarashi / ProcDef: Local-to-global Deformation

Acknowledgements. We thank Dr. Kazuo Nakazawa, Prof.
Takashi Ashihara and Dr. Ryo Haraguchi for their helpful
comments and kindly providing the heart model (Fig. 11).
This paper was funded in part by Adobe Systems Inc. and
JSPS research fellowship.

[MHHR06] MÜLLER M., HEIDELBERGER B., HENNIX M., RATCLFF
J.: Position Based Dynamics. In Proc. VRIPhys 2006, 71–80.
[NMK*05] NEALEN A., MÜLLER M., KEISER R., BOXERMAN E.,
CARLSON M.: Physically Based Deformable Models in Computer Graphics. Computer Graphics Forum, 25, 4(2005), 809–836.

References

[RJ07] RIVERS A., JAMES D. L.: FastLSM: Fast Lattice Shape
Matching for Robust Real-Time Deformation. ACM Trans.
Graph. 26, 3(2007), 82.

[AKS*04] AMANO A., KANDA K., SHIBAYAMA T., KAMEI Y.,
MATSUDA T.: Model Generation Interface for Simulation of
Left Ventricular Motion. IEEE EMBC. 2004, 3658-3661.

[RBC03] ROLLAND A.-G., BANGHAM J. A., COEN E.: Growth
Dynamics Underlying Petal Shape and Asymmetry. Nature, 422,
161–163.

[Barr84] BARR, A. H. Global and Local Deformations of Solid
Primitives, Computer Graphics 17, 3(1984), 21-30.

[Sor06] SORKINE, O.: Differential representations for mesh
processing. Computer Graphics Forum, 25, 4(2006), 789–807.

[BS08] BOTSCH, M., SORKINE, O.: On linear variational surface
deformation methods. IEEE TVCG, 14, 1(2008), 213-230.

[SOG08] STEINEMANN D., OTADUY M., GROSS M.: Fast Adaptive
Shape Matching Deformations. In Proc. SCA 2008, 87–94.

[Bur] BURTON E.: Sodaplay. www.sodaplay.com/.

[SSBT08] STUMPP T., SPILLMANN J., BECKER M., TESCHNER M.:
A Geometric Deformation Model for Stable Cloth Simulation.
In Proc. VRIPHYS 2008, 13–14.

[CN02] COMBAZ J., NEYRET F.: Painting Folds Using Expansion
Textures. In Proc. Pacific Graphics 2002, 176–182.
[CN06] COMBAZ J., NEYRET F.: Semi-interactive Morphogenesis.
In Proc. Shape Modeling International 2006, 35.
[EHW*08] ETO K., HAMASAKI M., WATANABE K., KAWASAKI Y.,
MATSUO Y., NISHIMURA T.: Modulobe: A New 3D Model Creation Platform for Complex Motion Design. In Proc. CCASNS
2008.

[TAI*08] TAKAYAMA K., ASHIHARA T., IJIRI T., IGARASHI T.,
HARAGUCHI R., NAKAZAWA K.: A Sketch-based Interface for
Modeling Myocardial Fiber Orientation that Considers the
Layered Structure of the Ventricles. J. Physiol. Sci. 58, 7(2008),
487–492.

[Fal] FALCO M.: Springs World 3D. www.sw3d.net.

[TOII08] TAKAYAMA K., OKABE M., IJIRI I., IGARASHI T.: Lapped
solid textures: filling a model with anisotropic textures. ACM
Trans. Graph. 27. 3(2008).

[GM97] GIBSON S. F., MIRTICH B.: A Survey of Deformable Models in Computer Graphics. Tech. Rep. TR-97-19, Mitsubishi
Electric Research Laboratories, Cambridge, MA.

[TPBF87] TERZOPOULOS D., PLATT J., BARR A., FLEISCHER K.:
Elastically deformable models. In Proc. ACM SIGGRAPH ’87,
205–214.

[IYKI08] IJIRI T., YOKOO M., KAWABATA K., IGARASHI T.: Surface-based Growth Simulation for Opening Flowers. In Proc.
Graphics Interface 2008, 227–234.

[TO99] TURK G., O’BRIEN J. F.: Shape Transformation Using
Variational Implicit Functions. In Proc. ACM SIGGRAPH ’99,
335–342.

[KA08] KASS M., ANDERSON J.: Animating Oscillatory Motion
with Overlap: Wiggly Splines. ACM Trans. Graph. 27, 3(2008).

[WSSH04] WATANABE H. SUGANO T., SUGIURA S., HISADA T.:
Finite Element Analysis of Ventricular Wall Motion and IntraVentricular Blood Flow in Heart with Myocardial Infarction.
JSME. 47, 4(2004). 1019–1026.

[MHTG05] MÜLLER M., HEIDELBERGER B., TESCHNER M., GROSS
M.: Meshless Deformations Based on Shape Matching. ACM
Trans. Graph. 24, 3(2005), 471–478.

LV RV

LV RV

(a)

(b)

(d)

(e)

(c)

(f)

(g)

Figure 11: Animations of a heart and an S-shaped bowel. LV and RV indicate the left and right ventricles of the heart. We
show the representative poses of the heart motion in the top row of (c). The bottom row of (c) is an overhead view of the
sliced heart model. When beating, the left ventricle (LV) wall strongly thickens to reduce the size of the left ventricle (c).

© 2009 The Author(s)
Journal compilation © 2009 The Eurographics Association and Blackwell Publishing Ltd.


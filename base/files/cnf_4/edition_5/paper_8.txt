Efficiently Drawing a Significant Spanning Tree of a Directed Graph
Martin Harrigan∗

Patrick Healy†

Department of Computer Science and Information Systems, University of Limerick, Ireland.

A BSTRACT
A directed graph can model any ordered relationship between objects. However, visualizing such graphs can be a challenging task.
If the graph is undirected, a popular strategy is to choose a significant spanning tree, nominate a vertex as the root, for example
the vertex whose distance from all other vertices is minimal, hang
the significant spanning subtrees from this root and add in the remaining edges in some unobtrusive manner [18, 19, 25, 13]. In the
directed case the spanning tree is a tree DAG (a directed graph without any undirected cycles) and not simply a directed tree with one
appropriate root. It may have multiple sources (vertices with indegree equal to zero) that all warrant root status and so the undirected
approach must be modified somewhat.
In this paper, we present a method of drawing directed graphs
that emphasizes a significant spanning tree. It can be considered
a variation of the Sugiyama framework [23] in that it combines
two steps of the framework (leveling and crossing minimisation)
by finding, in linear time, a leveling of the graph that is level planar
with respect to some spanning tree and restricting the permutations
of the vertices on each level to those that constitute a level planar
embedding of this subgraph. The edges of the spanning tree will
therefore not cross each other. Using the globally oriented Fiedler
vector we choose permutations of the vertices on each level that
reduce the number of crossings between the remaining edges.
Keywords: graph drawing, significant spanning tree, level planarity, Fiedler vector.
1

I NTRODUCTION

A popular strategy when drawing graphs is to extract a spanning
tree or hierarchy, draw it using some simpler algorithm and then
handle the remaining edges. When the graph is undirected this
spanning tree is a free tree and we can nominate some vertex as the
root [2], draw the spanning tree using the simpler tree drawing algorithms [21, 24, 4] and add in the remaining edges. However, in the
directed case the spanning tree is not necessarily a directed tree with
one single source; it is a tree DAG (a directed graph without any cycles, directed or undirected) with potentially multiple sources. It is
inappropriate to choose any one of these vertices as the root and so
the simpler tree drawing algorithms are not suitable.
We propose finding a significant spanning tree DAG T using either domain-specific (e.g. edge weights associated with the graph)
or other graph-theoretic knowledge. We find a leveling of the graph
that is level planar with respect to T and restrict the permutations
of the vertices on each level to those that constitute a level planar
embedding of T . In this way we ensure that any crossings in the
final drawing do not involve two significant edges. We use a globally oriented Fiedler vector to choose permutations of the vertices
on each level that reduce the number of crossings between the remaining edges.
∗ e-mail:
† e-mail:

martin.harrigan@ul.ie
patrick.healy@ul.ie

Asia-Pacific Symposium on Visualisation 2007
5 - 7 February, Sydney, NSW, Australia
1-4244-0809-1/07/$20.00 © 2007 IEEE

In addition, we use appropriate visual cues, for example, drawing
the less significant edges in a lighter colour, to make the structure
more readily discernable.
This can be considered a variation of the Sugiyama framework [23] for drawing directed graphs. This framework temporarily
removes any directed cycles by reversing a small number of edges,
creates a proper leveling, permutes the vertices on each level to reduce the number of edge crossings, and balances the layout. An alternative goal when permuting the vertices on each level is to maximise the size of a level planar subgraph. Even if there are only
two levels and the vertices on one are fixed, both the crossing minimisation and maximum level planar subgraph problems are N Pcomplete [8, 7] and so heuristics are generally employed. Once we
have computed a Fiedler vector, our method efficiently combines
the leveling and crossing minimisation steps in linear time.
This paper is organised as follows. We begin with some preliminaries in Sect. 2. In Sect. 3 we show how to choose a significant
spanning tree DAG T . In Sect. 4 we present a recursive algorithm
that ensures the level planarity of T by inserting a small number of
dummy vertices. This also implies a simple embedding algorithm.
In Sect. 4.4 we describe a crossing minimisation heuristic based on
a Fiedler vector and show how it can be combined with the previous
step. Section 5 applies the method to a directed graph modeling the
dependency relationship between packages related to the Python
programming language and Sect. 6 gives some concluding remarks
and directions for future research.
2

P RELIMINARIES

A leveling of a DAG G = (V, E) is a mapping φ : V → {1, 2, . . . , k}
such that φ (v) ≥ φ (u) + 1, ∀(u, v) ∈ E. A leveling is proper if the
relation is strictly equality. A level drawing of G with leveling φ is
a drawing in which the vertices in φ −1 ( j), 1 ≤ j ≤ k, are placed on a
horizontal level l j and the edges are drawn as straight-line segments
between the vertices. A level drawing of G with leveling φ is level
planar if no two edges cross except at common endpoints. G with
leveling φ is level planar if it has a level planar drawing. A level
embedding of G with proper leveling φ consists of total orderings
< j of the vertices in φ −1 ( j), 1 ≤ j ≤ k. A level embedding is level
planar if any level drawing of the graph in which the order of the
vertices along l j satisfy < j , 1 ≤ j ≤ k, is level planar.
Every tree DAG T (a directed graph with no cycles, directed or
undirected) has a proper leveling φ . If T with leveling φ is not level
planar then we can make it so by inserting dummy vertices along
appropriate edges (see the spanning tree DAGs in Fig. 1).
The Laplacian L (G) is defined by

 deg (v)
−1
L (G)u,v =

0

if u = v,
if (u, v) ∈ E ∨ (v, u) ∈ E,
otherwise.

(1)

L (G) is positive semi-definite and so its eigenvalues, λ1 ≤ . . . ≤
λn , are all nonnegative. An eigenvector corresponding to the second smallest eigenvalue is known as a Fiedler vector and can be
calculated using power iteration on the matrix λn I − L (G) or more
efficiently using multi-scale methods [9].

53

Tv
...

u

v

u

v

r
(a)

(b)

Figure 1: A non-level planar and level planar drawing of spanning
tree DAGs (solid edges).

...

Figure 2: The Base Case.

3

C HOOSING A S IGNIFICANT S PANNING T REE DAG

Let G = (V, E) be a connected directed graph. We seek a significant spanning tree DAG T = (V, ET ) of G, i.e. one in which the
edges in ET are more significant than those in E \ ET . This may
be done using domain-specific knowledge or using any of the numerous methods to measure significance (see e.g., spanning tree
algorithms in [15] and structural indices in [17]). The method we
choose is to weight each edge (u, v) ∈ E by (xu − xv )2 where x is a
Fiedler vector of L (G). T is then a minimum weighted spanning
tree DAG of G. This will preserve intra-cluster edges at the expense
of inter-cluster edges.
Our choice of T is primarily due to the fact that we will be reusing x later. However, we give two reasons to justify T as being
a significant spanning tree DAG. Firstly, consider the problem of
embedding G in the line so that all edge lengths are kept short.
If the location of v ∈ V in the line is xv then we want to minimize ∑(u,v)∈E (xu − xv )2 subject to x x T = 1 (to avoid the trivial
solution of setting x = 0). It turns out that a solution is precisely
x. Secondly, xu can be interpreted as a measure of u’s ‘degreenormalized’ eigenvector centrality [1] and so ET are the edges that
propagate most of this centrality through G.
4

E NSURING L EVEL P LANARITY

Level planarity can be tested in O(|V |) time using the PQ-tree data
structure [12, 14] or in O(|V |2 ) time using the simpler VertexExchange Graph [10]. However, extending either method to ensure
level planarity for the special case of tree DAGs by inserting a small
number of dummy vertices is not obvious.
The algorithm makeTreeDAGLevelPlanar is based on the recursive nature of a tree DAG. It processes a tree DAG T with proper
leveling φ by recursively decomposing T into smaller tree DAGs
with fewer vertices of indegree greater than one. It computes a matrix M(T ) at each step where each column of M(T ) represents the
restrictions imposed on the level planarity of T by each smaller tree
DAG. We apply this algorithm twice, on T and on its reverse graph
(replacing every (u, v) ∈ E with (v, u)) after inserting the dummy
vertices from the first pass.
4.0.1 The Base Case.
Let T = (V, ET ) be a tree DAG with proper leveling φ and V =
{v ∈ V : indegree(v) > 1}. We assume |V | > 0 since otherwise T
with φ is trivially level planar. In the base case |V | = 1 and we let
this vertex be r. The vertices in the outgoing and incoming neighbours of v, N + (r) and N − (r), join r to the roots and vertices of
distinct directed trees respectively (see Fig. 2). We use the notation
Tv = (Vv , Ev ) to refer to the maximally connected component that
is joined to r through some v ∈ N + (r) ∪ N − (r). To ensure level
planarity, we need only insert dummy vertices along edges joining
N − (r) to r.

54

We proceed by populating a matrix M(T ). For each v ∈ N − (r)
we add a column to M(T ) as follows. We visit each vertex v along
the (undirected) path from v to the root of its respective tree Tv . If
there exists some vertex w that is a descendent of v in Tv such that
φ (w) ≥ φ (r) then we set the entry in row φ (v ) of the new column
to φ (w). Otherwise we leave the entry unpopulated. We note the
edge (v, r) that corresponds to each column.
M(T ) is a k × |N − (r)| matrix (where k is the number of levels) consisting of partially populated columns of consecutive nondecreasing entries. The rows with populated entries lie in the range
1 to φ (r) − 1. Each row represents the restrictions imposed on the
level planarity of T by directed subtrees whose roots lie on the corresponding level. Each column represents the restrictions imposed
on the level planarity of T by the corresponding Tv . From here on,
by referring to, say, the first entry in a row or column, we mean the
first populated entry. We use first(M(T ), j) and last(M(T ), j)
to denote the index of the first and last entries in column j respectively.
Lemma 4.1 If T is a tree DAG with leveling φ and has one vertex
of indegree greater than one then T is level planar if and only if
M(T ) has at most two (populated) entries in any one row.
Proof Suppose row j of M(T ) has three entries. Let {vi } ⊆
N − (r) and Tvi = (Vvi , Evi ), 1 ≤ i ≤ 3, such that Tvi is a directed tree
whose column in M(T ) contains an entry in row j. Let vi , wi ∈ Vvi ,
φ (vi ) = j and φ (wi ) ≥ φ (r), 1 ≤ i ≤ 3. For any total ordering < j
of the vertices in φ −1 ( j) there must be at least one crossing in any
level drawing of T (see Fig. 3). If there are at most two entries in
any one row, the directed trees can ‘hang’ over either side of r.
To insert a dummy vertex along an edge between some v ∈
N − (r) and r we decrement each entry in the corresponding column, shift the column up one row (adding extra rows to the top
of M(T ) if necessary) and repeatedly remove any last entry in the
column whose value is now less than φ (r). We call this operation
shiftUp(M(T ), j) where j is the index of the column to shift.
We wish to apply shiftUp(M(T ), j) a small number of times so
that each row contains at most two entries. We use the following
heuristic. Find the last row with more than two entries. Leave two
columns whose last entries occur the latest fixed ( jL and jR ). If
more than two columns meet this criterion, choose two of these
whose first entries occur the latest. If more than two columns meet
both criteria, then the choice between these columns is arbitrary.
Apply shiftUp(M(T ), j) to all other columns that have an entry in
this row. Go to the previous row and repeat.
The problem can be interpreted as a simple task scheduling problem. There are two identical processors, pL and pR , where pL handles the tasks or columns assigned to jL and likewise with pR and

Tv1

Tv2

Tv3

Tv

M (T ) =

j

rT v

wR

wL
r
Tv1

Tv2

v2

v1

j

Tv3

v1

v3

v2
r

w1

Figure 4: Tv smothers r.

v3
w2
w3

Figure 3: Row j of M(T ) has more than two entries and so T with
leveling φ is not level planar.

jR . There are at most |N − (r)| independent tasks. The tasks arrive in the (descending) order specified by last(M(T ), j) where j
is the index of the corresponding column. The processing times for
each task are the number of entries in j but each task has the added
peculiarity that making it wait (i.e. inserting a dummy vertex) may
result in the task becoming temporarily unavailable and requiring a
decreased processing time. Our goal is to minimise the sum of the
waiting times for all available tasks so we are employing a shortest
task first algorithm. This is optimal if the value of each entry is
sufficiently large so that the peculiarity does not arise.

Algorithm 1: makeTreeDAGLevelPlanar
Input: T = (V, ET ), φ
Output: M(T )
1 M(T ) ← empty;
2 col ← 1;
3 Choose r ∈ {v ∈ V : indegree(v) > 1} that maximises φ (r);
4 foreach v ∈ N − (r) do
5
while v = empty do
6
entry ← φ (v) + height(the tree in Tv rooted at v);
if entry ≥ φ (r) then
7
M(T )φ (v),col ← entry;
8
9
10
11
12

4.0.2 The Recursive Case.
If |V | > 1 we choose some r ∈ V that maximises φ (r). We proceed as before by populating a matrix M(T ). However, if any Tv is
not a directed tree, we need to recursively ensure its level planarity.
Let M(Tv ) be the final matrix associated with Tv . We populate a
new column jTv of the present matrix M(T ) in two steps. Firstly we
visit each vertex v along the (undirected) path from v to its earliest
ancestor whose indegree is anything other than one and set the entries as in the base case. Secondly, we combine M(Tv ) into the same
column by setting M(T )i, jTv = max(M(T )i, jTv , max j M(Tv )i, j ). This
column can be thought of as representing a directed tree that is at
least as restrictive as Tv on the level planarity of T .
An additional complication occurs if some Tv smothers r (see
Fig. 4). In this case Tv , whose level planarity we have already ensured, has three vertices rTv , wL , wR ∈ Vv such that rTv has indegree
greater than one, φ (wL ), φ (wR ) ≥ φ (r) and the least common ancestors of the pairs wL , rTv and rTv , wR are on the same level. In
other words, in any level planar drawing of Tv the undirected paths
from rTv to wL and from rTv to wR ‘hang’ on either side of r.
In terms of M(T ), Tv smothers r if M(T ) has more than one entry
in any one row whose index is less than φ (rTv ) and whose value is
greater than or equal to φ (r). The solution is much the same as in
the base case where we were required to shift the columns so that
each row has at most two entries. We start with the last row with
more than one entry whose index is less than φ (rTv ) and whose
value is greater than or equal to φ (r). Using the same criteria as before, we leave one column fixed ( jF ) and apply shiftUp(M(Tv ), j)
to the others. Go to the previous row and repeat.

13
14

v ← parent(v); /* empty if indegree(v) = 1
*/
if Tv is not a directed tree then
M(Tv ) ← makeTreeDAGLevelPlanar(Tv , φ );
Use shortest task first heuristic when applying
shiftUp(M(Tv ), j) to leave at most one (populated)
entry in certain rows of M(Tv ) (see Sect. 4.0.2);
Combine M(Tv ) into column col of M(T );
col ← col + 1;

15 Use shortest task first heuristic when applying

shiftUp(M(T ), j) to leave at most two (populated) entries in
any one row of M(T ) (see Sect. 4.0.1);
16 return M(T );
4.1 Proof of Correctness
Theorem 4.2 Given a tree DAG T with proper leveling φ ,
makeTreeDAGLevelPlanar(T, φ ) inserts dummy vertices to ensure level planarity.
Proof (based on a characterisation of level planar graphs [11]) T is
level planar if and only if it does not contain any minimal level nonplanar (MLNP) subgraph pattern. Since T is a tree DAG we need
to show that it does not contain the MLNP ‘tree pattern’. Briefly,
let i and j be the extreme levels of the pattern and r be a vertex with
three incident subtrees that have the following properties:
• Each subtree has at least one vertex on both extreme levels.
• Each subtree is either an undirected path or two branches
which are undirected paths.
• All leaf vertices are on the extreme levels and each subtree
has at most one leaf vertex on each extreme level.

55

i

i
M (T )
2

. . .

r

Column indices 1

2

1

. . .

1

2

(b)

4

. . .

(a)

(w, x) 0

3

1

(u, v) 0

2

4

3

. . .

j

r

. . .

j

5

j

r
(c)

the number of ‘pairs’ of entries
first index
offset
edge identifier

r

Figure 6: Storing M(T ) in sparse form.

(d)

number of distinct entries. The sparse form allows the initialisation
of M(T ), first(M(T ), j), last(M(T ), j) and shiftUp(M(T ), j)
operations to be performed in O(1) time.
The shortest task first heuristics (Lines 12 and 15 of Algorithm 1)
can easily be implemented using two nested for loops, however,
we need only visit the populated entries in each matrix. Using the
sparse form of M(T ) in Line 12 we can sort the columns in descending ordering according to last(M(Tv ), j) using bucket sort
(since the range of values is the range of levels occupied by the
graph and must be less than or equal to the number of vertices) and
then process each bucket from left to right as follows. Choose one
of the columns with the greatest first(M(Tv ), j) to be jF , apply
shiftUp(M(Tv ), j) to the other columns and add them to the next
bucket. A similar approach can be used in Line 15.

j

Figure 5: Two typical examples of the MNLP tree pattern ((a) and (b))
and the dummy vertices added to each to ensure level planarity ((c)
and (d) respectively).

• Those subtrees which are undirected paths have one or more
non-leaf vertices on the extreme level opposite to the level of
their leaf vertices.
There are two cases:
1. φ (r) = i or φ (r) = j (see Fig. 5(a)): At least one of the subtrees is an undirected path starting at r, going to the opposite
extreme level of r and finishing on r’s level.
2. i < φ (r) < j (see Fig. 5(b)): At least one of the subtrees is an
undirected path starting at r, going to the extreme level i and
finishing on j and at least one of the subtrees is an undirected
path starting at r, going to the extreme level j and finishing on
i.
Both cases are handled by makeTreeDAGLevelPlanar. In
Case 1, all three edges incident with r are directed similarly and
so dummy vertices are inserted along one of these edges to make
it level planar (see Fig. 5(c)). In Case 2, either all three edges incident with r are directed similarly, in which case it is handled as
in Case 1, or two edges incident with r are directed similarly and
the third is directed oppositively. This is handled by a recursive call
within makeTreeDAGLevelPlanar (see Fig. 5(d)). The symmetrical cases to those shown in Fig. 5 (swapping i with j) are handled
by the second pass of makeTreeDAGLevelPlanar.
4.2 Implementation
By storing M(T ) in sparse form, makeTreeDAGLevelPlanar can
be modified to run in O(|V |) time. For each column, we list an
edge identifer, an offset, the index of the first row where the column
has a populated entry, the number of pairs of entries and the entries
themselves (see Fig. 6). The edge identifier is the edge into which
we insert dummy vertices when applying shiftUp(M(T ), j). The
offset is used by shiftUp(M(T ), j) to update all entries in the column in constant time. When a column is shifted up the offset is first
decremented. The entries are encoded as pairs of values where the
first is the number of times the second value appears consecutively,
e.g. the entries 8, 7, 7, 5, 5 are encoded as 1, 8, 2, 7, 2, 5. If a column
with those values is shifted up for the first time we set its offset to
−1 and, if the second value in the last pair plus the offset is less than
φ (r) we remove the last pair from the entries and decrement the

56

. . .

i

. . .

. . .

i

4.3 Violating the leveling with respect to G
While ensuring the level planarity of T , we may be violating the leveling with respect to G (see the edge (u, v) in Fig. 1(b)). However,
we can insert compensating dummy vertices whenever the leveling
with respect to G is violated.
We previously defined a leveling of G to be a mapping φ : V →
{1, 2, . . . , k} where φ (v) specifies the level of each vertex v and,
implicity, the number of dummy vertices along each edge to make it
proper. Alternatively we can define a leveling of G to be a mapping
ψ : E → Z+ where ψ (e) specifies the number of dummy vertices
along each edge e to make it proper and, implicity, the level of each
vertex.
Every edge in E \ ET completes an (undirected) fundamental cycle C in T (see Fig. 7). By traversing each C in some arbitrary direction, we get the cycle vector χ (C) (with coordinates χ (C)e , ∀e ∈ E)
defined by

 1 if e is directed with the traversal of C,
−1 if e is directed against the traversal of C,
χ (C)e =
 0 if e is not in C.
(2)
A cycle is balanced if ∑ χ (C) = 0. The set of vectors C corresponding to a set of fundamental cycles constitute a basis for the
cycle vector space of G.
Now suppose we partition the edge set E = S = s1 ∪ . . . ∪ sk
such that each subset s j , 1 ≤ j ≤ k, is the maximal set of edges
shared between the same subset of cycles in C (see Fig. 8). In other
words, two edges belong to the same subset if they are both bridges
or belong to the same S-vertex of an SPQR-tree [6] of the same
biconnected component of the underlying undirected graph of G.
Then if ψ is some leveling of G, any dummy vertex along an edge
e ∈ s j , 1 ≤ j ≤ k, can be moved to any other similarly directed edge
(with respect to any cycle) in s j . In fact, we can specify an equivalence class of levelings of G using two mappings ψ+ : S → Z+

e1

e6

G
e3

e11

e7

e2

e10

e8

e4

e16
e13
e17

e14

e9

e15
e12

e5

e18

Figure 7: Each edge in E \ ET (the dashed edges) completes a fundamental cycle.

s7

s2
e6

e1

e3
e7

s8

e2
e4

e5

s9

s1

e11

e8
e9

s5
e13

s3

e14

e10
e16

s4

s6

s10

e17

e15
e18
e12

We define the vectors w (with coordinates ws , ∀s ∈ S, in the order
of the columns of F ) by ws = ψ+ (s) − ψ− (s) and b (with coordinates bC , ∀C ∈ C , in the order of the rows of F ) by bC = ∑ χ (C).
Now if ψ+ and ψ− specify a proper leveling of G then F w = b,
i.e. the dummy vertices balance the cycles.
So if we start with an initial leveling of G and add dummy vertices to edges to ensure level planarity with respect to T , we can
compensate by examining the nullspace of F . For example, if the
edge e13 in s5 needs an additional dummy vertex, this can be compensated by adding a dummy vertex to e11 in s1 and a dummy vertex
to one of e16 , e17 or e18 in s10 since the columns corresponding to
s1 , s5 and s10 in F are linearly dependent.
4.4 Crossing Minimisation
An
embedding
algorithm
is
implied
by
makeTreeDAGLevelPlanar.
Fixing columns ( jL , jR , and
jF ) decides the relative ordering of their corresponding vertices
on their respective levels. However, we have some freedom when
positioning the remaining vertices. For these we use an ordering
induced by a Fiedler vector of L (G). This heuristic has previously
been used to determine exact x-coordinates [5] when drawing a
directed graph and for the 2-level crossing minimisation problem [20]. It is based on a result [22] that shows a strong relation
between the Minimum Linear Arrangement (MLA) problem of a
bipartite graph, the bipartite crossing number and an algorithm for
finding an approximate solution to the MLA problem [16].
Given an undirected graph G = (V, E), the MLA problem is to
determine a bijection f : V → {1 . . . n} such that ∑(u,v)∈E | f (u) −
f (v)| is minimised. Juvan et al. [16] use a Fiedler vector x of
L (G) to induce an ordering (if xu < xv then f (u) < f (v)) which
is unique up to the relative ordering of repeated eigenvector elements. Shahrokhi et al. [22] show that in most cases, if we have
an approximate solution to the MLA problem for a bipartite graph
G = (V1 ∪V2 , E), we can place the vertices of V1 and V2 on two levels in the order obtained from f to obtain a good approximation for
the 2-level crossing minimisation problem. Empirical evidence [20]
suggests that this heuristic efficiently provides good solutions. We
use this same ordering to decide on the relative position of the vertices on their respective levels as a means of reducing the number
of crossings between the remaining edges.
5

Figure 8: The partitioning of the edge set in Fig. 7.

and ψ− : S → Z+ where ψ+ and ψ− specify the number of dummy
vertices along the edges in either direction in each subset s j . To
make sure that the directions are consistent, we use a fundamental
cycle-edge subset incidence matrix F defined by

1 if the directions of the edges in s




are consistent with the traversal of C,
−1 if the directions of the edges in s
(3)
FC,s =


are
inconsistent
with
the
traversal
of
C,


0 if s is not in C.
For example, the fundamental cycle-edge subset incidence matrix for the DAG in Fig. 7 is
C1
C2
F = C3
C4
C5

s1
0
0

1

0
0


s2 s3
1
0
−1 0
0
0
−1 1
−1 1

s4
0
0
1
1
1

s5
0
0
1
0
1

s6
0
0
0
1
0

s7
1
0
0
0
0

s8
0
1
0
1
1

s9
0
1
0
0
0

s10

0
0 

0 
. (4)
0 
1

A N A PPLICATION

The dependency relationship between packages in large software
systems tend to have a specific structure. Packages depend on base
packages with common functionality that is shared with many other
packages and, more significantly, on certain application-specific
packages. It is reasonable to assume that this graph has a significant spanning tree, e.g. the tree that propagates the most centrality,
and we want to draw it so that this spanning tree is emphasized.
Figure 9 depicts the largest connected component of the dependency graph for packages related to the Python programming
language1 . The significant spanning tree (solid edges) was computed as in Sect. 3 and the orderings of the vertices on each
level were determined by the embedding algorithm implied by
makeTreeDAGLevelPlanar along with the crossing minimisation
heuristic. The computation of the final x-coordinates was based on
[3] and the less significant edges (dashed edges) were added in by
hand.
The impetus for drawing the graph in this way is to emphasize
the significant dependencies. For example, consider the dependencies on the pygtk package (shaded). The six packages that significantly depend on pygtk are easily discernable. However, twisted’s
1 This graph was obtained automatically by querying the Gentoo package
management system (http://www.gentoo.org) and removing any redundant
dependencies by computing its transitive reduction.

57

cgkit
Package A
pyprotocols

depends on
Package B

gnomepythondesktop
gnome- bonobopython- python
extras

pythondateutil

matplot lib

numpy

ttfquery

pykde

pytz

tlslite

paramiko

pyqwt fonttools scientificpython pygame

visual

numeric

PyQt

drpython pythoncard

pytables

twistedwords
twistedweb
twistedxish

twistedconch

twistedrunner

twistedflow

twistedweb2

twistednews

twistedlore

twistedpair

pyds

twibber

pyxml

pygoogle

pyserial

medusa

twisteddocs

pycairo

fxpy

pyopengl

pyparsing

nevow

twistednames

twistedsnmp

docutils

pysnmp

pyopenssl

soya

mantissa

twistedmail

twisted

4suite

orbitpython

pyorbit

wxpython

ladaptor

epydoc

gnomepython

pygtk

numarray

sip

testoob

winpdb

cryptlib py m2crypto gmpy pycrypto

pyclimate

python- gstgtkextra python

pygtkglext rtgraph

reportlab

pyopenal editobj imaging

pyvorbis

vertex

axiom

epsilon

adodb-py django

sqlobject

orm

pyogg

pysqlite mysql-python formencode psycopg kinterbasdb simpleparse

egenix-mx-base

setuptools

cheetah

soappy

lxml

fpconst

pyode

pyrex

Figure 9: The dependency graph for Python packages.

dependency on pygtk is considered less significant and hence less
obvious. With some knowledge of the domain, we know that pygtk
consists of bindings for a GUI toolkit whereas twisted is concerned
with networking and so this choice of significance has some merit,
but of course our approach works equally well for any choice of
significant spanning tree.
6

C ONCLUSION

We have presented a method of drawing a directed graph that emphasizes a significant spanning tree. The spanning tree is a tree
DAG with multiple sources and so it is more appropriate to give
each of these vertices root status than to nominate any single vertex
and hang the subtrees from it. We ensure the level planarity of the
spanning tree by inserting dummy vertices and restrict the possible
level embeddings so that no two significant edges can cross. These
steps can be performed in linear time using a sparse form of matrix
storage.
The remaining freedom in the ordering of the vertices on their
respective levels is used to reduce the number of crossings between
the remaining edges. We avoid the level-by-level sweep found in
most implementations of the Sugiyama framework by using a globally oriented Fiedler vector as a multi-level crossing minimisation
heuristic. Upwardly directed edges in the final drawing can be fixed
using compensating dummy vertices, provided the edges are not
part of a directed cycle.
As a practical application, we used the approach to draw the significant spanning tree of the dependency relationship between the
packages related to the Python programming language. By using
appropriate visual cues, for example, drawing the less significant
edges in a lighter colour, the significant spanning tree and hence,
the significant dependencies, are easily discernable.

58

Future work will involve quantifying the total number of dummy
vertices – both the dummy vertices used to ensure the level planarity of the spanning tree and those used to compensate for any
upwardly directed edges. Evaluations, both experimental and userbased, may be beneficial in providing more conclusive evidence
regarding the advantages of this approach when drawing directed
graphs.
ACKNOWLEDGEMENTS
Martin Harrigan would like to acknowledge the support of the Irish
Research Council for Science, Engineering and Technology.
R EFERENCES
[1] P. Bonacich. Factoring and weighting approaches to status scores and
clique identification. Journal of Mathematical Sociology, 2:113–120,
1972.
[2] R. Botafogo, E. Rivlin, and B. Schneiderman. Structural analysis of
hypertexts: Identifying hierarchies and useful metrics. ACM Transactions on Information Systems, 10(2):142–180, 1992.
[3] U. Brandes and B. K¨opf. Fast and simple horizontal coordinate assignment. In P. Mutzel, M. J¨unger, and S. Leipert, editors, Graph Drawing
’01, pages 31–44. Springer, 2002.
[4] C. Buchheim, M. J¨unger, and S. Leipert. Improving Walker’s algorithm to run in linear time. In Graph Drawing ’02, pages 344–353.
Springer, 2002.
[5] L. Carmel, D. Harel, and Y. Koren. Combining hierarchy and energy
for drawing directed graphs. IEEE Transactions on Visualization and
Computer Graphics, 10(1), 2004.
[6] G. Di Battista and R. Tamassia. On-line maintenance of triconnected
components with SPQR-Trees. Algorithmica, 15(4):302–318, 1996.
[7] P. Eades and S. Whitesides. Drawing graphs in two layers. Theoretical
Computer Science, 131(2):361–374, 1994.

[8] P. Eades and N. C. Wormald. Edge crossings in drawings of bipartite
graphs. Algorithmica, 11(4):379–403, 1994.
[9] D. Harel and Y. Koren. A fast multi-scale method for drawing large
graphs. Journal of Graph Algorithms and Applications, 6(3):179–202,
2002.
[10] P. Healy and A. Kuusik. Algorithms for multi-level graph planarity
testing and layout. Theoretical Computer Science, 320(2-3):331–344,
2004.
[11] P. Healy, A. Kuusik, and S. Leipert. A characterization of level planar
graphs. Discrete Mathematics, 280(1-3):51–63, 2004.
[12] L. S. Heath and S. V. Pemmaraju. Stack and queue layouts of directed
acyclic graphs: Part II. SIAM Journal on Computing, 28(5):1588–
1626, 1999.
[13] I. Herman, G. Melanc¸on, and M. S. Marshall. Graph visualization and
navigation in information visualization: A survey. IEEE Transactions
on Visualization and Computer Graphics, 6(1):24–43, 2000.
[14] M. J¨unger, S. Leipert, and P. Mutzel. Level planarity testing in linear
time. In Graph Drawing ’98, pages 224–237. Springer, 1998.
[15] D. Jungnickel. Graphs, Networks and Algorithms. Algorithms and
Computation in Mathematics. Springer–Verlag, second edition, 1999.
[16] M. Juvan and B. Mohar. Optimal linear labelings and eigenvalues of
graphs. Discrete Applied Mathematics, 36(2):153–168, 1992.
[17] D. Kosch¨utzki, K. A. Lehmann, L. Peeters, S. Richter, T. D. Podehl,
and O. Zlotowski. Centrality indices. In U. Brandes and T. Erlebach,
editors, Network Analysis, pages 16–61. Springer, 2005.
[18] T. Munzner. H3: Laying out large directed graphs in 3D hyperbolic
space. In INFOVIS’97, pages 2–10. IEEE Computer Society, 1997.
[19] T. Munzner. Drawing large graphs with H3Viewer and site manager.
In Graph Drawing ’98, pages 384–393. Springer, 1998.
[20] M. Newton, O. S´ykora, and I. Vrt’o. Two new heuristics for twosided bipartite graph drawing. In Graph Drawing ’02, pages 312–319.
Springer, 2002.
[21] E. M. Reingold and J. S. Tilford. Tidier drawings of trees. IEEE
Transactions on Software Engineering, 7(2):223–228, 1981.
[22] F. Shahrokhi, O. S´ykora, L. A. Szkely, and I. Vrt’o. On bipartite drawings and the linear arrangement problem. SIAM Journal on Computing, 30(6):1773–1789, 2001.
[23] K. Sugiyama, S. Tagawa, and M. Toda. Methods for visual understanding of hierarchical systems. IEEE Transactions on Systems, Man,
and Cybernetics, 11(2):109–125, 1981.
[24] J. Q. Walker. A node-positioning algorithm for general trees. Software
– Practice and Experience, 20(7):685–705, 1990.
[25] G. J. Wills. NicheWorks – interactive visualization of very large
graphs. Journal of Computational and Graphical Statistics, 8(2):19–
212, 1999.

59


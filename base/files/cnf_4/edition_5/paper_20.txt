Particle-based Volume Rendering
Naohisa Sakamoto
Graduate School of Engineering
Kyoto University

Jorji Nonaka

Koji Koyamada

Center for the Promotion of
Excellence in Higher Education
Kyoto University

Satoshi Tanaka
Department of Media Technology
Ritsumeikan University

Figure 1: Rendering results of lobster data (128x128x34, 5M particles) using the proposed method. These rendering images show
the change in the level of semi-transparency with respect to the change in the sub-pixel level (from 2 to 6).

ABSTRACT

1

In this paper, we introduce a novel point-based volume
rendering technique based on tiny particles. In the proposed
technique, a set of tiny opaque particles is generated from a given
3D scalar field based on a user-specified transfer function and the
rejection method. The final image is then generated by projecting
these particles onto the image plane. The particle projection does
not need to be in order since the particle transparency values are
not taken into account. During the projection stage, only a simple
depth-order comparison is required to eliminate the occluded
particles. This is the main characteristic of the proposed technique
and should greatly facilitate the distributed processing. Semitransparency is one of the main characteristics of volume
rendering and, in the proposed technique the quantity of projected
particles greatly influences the degree of semi-transparency. Subpixel processing was used in order to obtain the semi-transparent
effect by controlling the projection of multiple particles onto each
of the pixel areas. When using sub-pixel processing, the final
pixel value is obtained by averaging the contribution from each of
the projected particles. In order to verify its usefulness, we applied
the proposed technique to volume rendering of multiple volume
data as well as irregular volume data.
CR Categories: I.3.3 [Computer Graphics]: Picture/Image
Generation - Display algorithms, Bitmap and framebuffer
operation; I.3.7 [Computer Graphics]: Three-Dimentional
Graphics and Realism - Raytracing; I.6.8 [Computer Graphics]:
Types of Simulation - Monte Carlo
Keywords: point-based volume rendering, particle generation,
sub-pixel processing

Volume rendering generally uses an illumination model in
which a 3D scalar field is characterized as a varying density
emitter with a single level of scattering. This illumination model
can be defined as a particle system in which the particles are
sufficiently small and of low albedo. It is worth noting that
conventional volume rendering techniques model the density of
particles, and not the particles themselves [1][2]. This density is
related to the opacity data value obtained from the transfer
function applied to scalar data value, as a result, a given scalar
field can be described as a continuous semi-transparent gel.
Therefore, the accumulating order during the volume rendering
calculation becomes crucial. Traditional volume rendering
assumes the semi-transparent particles to be of relatively large
size in the volume domain and performs alpha-blending
processing of these particles. For instance, in the ray-casting
algorithm, these particles are placed at each sampling point along
a viewing ray.
The computational cost of ray-casting is generally high because
this requires a 3D convolution for each sample point. Unnecessary
computation can occur since the sampling points may appear in
transparent regions. Splatting algorithm has been proposed to
cope with this problem. This algorithm can be categorized as
point-based volume rendering algorithm, and its efficiency is in
part due to the use of pre-integrated reconstruction kernels, called
footprints. A 2D convolution at each sample point is executed
during the volume integration along a viewing ray. It is assumed
that the footprints do not overlap and are in order from back to
front. This therefore makes the visibility ordering of the footprints
crucial. Since this ordering is a complex task, especially when the
footprints are irregularly located, the splatting algorithm might be
plagued by artifacts because of incorrect visibility determination.
When multiple volume datasets are rendered as a single scene,
these artifacts will be especially prominent in the overlapping
region. To solve this problem, we look back on the varying
density emitter model, which uses grainier particles than the
splatting algorithms and assumes that the particles are fully
opaque. Thus, the proposed technique requires neither alpha

e-mail: naohisas@mbox.kudpc.kyoto-u.ac.jp
e-mail: jorji@mbox.kudpc.kyoto-u.ac.jp
e-mail: koyamada@kudpc.kyoto-u.ac.jp
e-mail: stanaka@media.ritsumei.ac.jp

Asia-Pacific Symposium on Visualisation 2007
5 - 7 February, Sydney, NSW, Australia
1-4244-0809-1/07/$20.00 © 2007 IEEE

INTRODUCTION

129

blending nor visibility ordering. In order to realize the semitransparent appearance of the volume data, we introduce subpixels and average their brightness values at each pixel.
The present paper is outlined as follows: We first describe
previous research in Section 2, and then in Section 3, we present
the proposed particle generating framework. We start by
describing the Hit and Miss method, which restricts the generation
location at volume cell vertices. In addition, we introduce the
Metropolis method for generating particles by relaxing this
restriction. We then describe the proposed point-based volume
rendering algorithm using sub-pixel. In Section 4, we evaluate the
proposed technique. In Section 5, we summarize the proposed
technique and discuss areas for future study.
2

PARTICLE-BASED VOLUME RENDERING

In this section, we describe our new point-based volume
rendering technique. The proposed technique is composed of wo
parts:

130

Projection onto
the image plane

Collision

Pixel
Tiny particles generated
using the rejection method

Image plane

Figure 2: Particle generation and projection.

RELATED WORKS

Direct volume rendering with Splatting was first proposed by
Westover [3]. Splatting is attractive because of its efficiency,
which is derived from the use of pre-integrated reconstruction
kernels called footprints. A great deal of research has examined
the use of footprints to render primitives for sampled data. Laur
and Hanrahan [4] introduced hierarchical splatting for volume
rendering using Gouraud-shaded polygons. During volume
integration each sample point along a viewing ray is computed
using a 2D convolution. In contrast, ray-casting methods require a
3D convolution for each sample point. This provides splatting
algorithms with an inherent advantage in rendering efficiency.
Recently, Zwicker et al. [5] proposed the EWA volume
splatting technique, which enables high-quality rendering by
applying a Gaussian filter to the voxel’s footprint and decreasing
the aliasing effect. Although, recently, splatting techniques that
make use of high-performance Graphics Processing Units (GPUs)
in order to realize high-performance alpha-blending calculation
have been proposed [6][7], the GPU memory resource is scalable
to the total volume dataset size. In general, previous particlebased volume rendering techniques project a single particle onto
more than one pixel.
Recently, volume rendering technique which uses points as
rendering primitives has received increasing attention and is a
topic of ongoing research. Hopf and Ertl proposed the use of a
hierarchical data structure based on PCA clustering procedure in
order to accelerate the visualization of scattered point data [8].
This data structure enables fast sorting of semi-transparent
clusters and may therefore trade rendering speed for image quality.
The image is obtained!by traversing this structure for each frame.
In addition, the use of quantized relative coordinates reduced the
memory consumption. For a semi-transparent realization, their
technique requires alpha blending which requires the points to be
sorted according to their projected z coordinates.
The proposed particle-based volume rendering technique
represents the volume data as a set of particles. The particle
density is derived from a user-specified transfer function and
describes the probability that a particle is present at a given
position. Since these particles can be considered to be fully
opaque, no alpha blending is required during the rendering
calculation, which is advantageous in the distributed processing.
Csébfalvi proposed a similar technique [9][10] that can be
categorized as X-ray volume rendering, in which the number of
points on the image plane is simply counted, but the luminosity of
the points is not considered.
3

Volume data

• Particle generation: A set of particles is internally
generated for each volume dataset using a density
distribution function from a user-specified transfer function.
• Particle projection: In order to create a rendered image for
the volume dataset, the generated particles are then projected
onto the image plane and are stored in the corresponding
particle buffer. Particle buffers are allocated for each volume
dataset to store the projected particles. The final pixel values
are calculated for each particle buffer by using sub-pixel
processing.
These processes are detailed in turn in the following sections.
3.1
Particle Generation
Assuming that the volume data is a set of light-emitting cloud
particles, the brightness B at the eye position can be solved
numerically as follows:

B = B1 + B2 + L + Bk + L + Bn

Bk =

)

t k '1

tk

&
ck ( + (t ) ( exp$$ '
%

( k = 1 " exp("

!

t k "1

tk

)

t0

t

(1)

#
+ (* )d* !!dt.
"

& (' )d' ) % 1 " exp(" & k $ #t ) ,

(2)
(3)

where !t is the length of the sub-domain, ! k is the opacity
value, Bk is the intensity value, and ! k is the representative
density at the k-th sub-domain. Usually, opacity values are
determined from scalar values S. However, in our method the
particle densities implicitly relate to scalar values as follows:

) ( S ( x)) = 1 & exp(& * ( %t )
(4)
$ & log(1 & ) ( S ( x)))
!
() ( S ( x)) ' 1 & exp(&%t ))
* ( x)
= #
%t
(5)
!"
1.0
() ( S ( x)) > 1 & exp(&%t ))
where x is the position along the viewing ray. The particle
density can therefore be determined from opacity values which
are converted from scalar values using a user-specified transfer
function.
In order to generate particles in a volume space according to the
density distribution function ! ( x ) of Eq. 5, we propose two
methods; Hit and Miss method and Metropolis method.
3.1.1
Hit and Miss method
We use the Hit and Miss method to generate these random
numbers following a given continuous probability density
function. The Hit and Miss method can efficiently generate

particles simply by comparing the density distribution of particles
with the generated random numbers. The processing procedure of
the Hit and Miss method is as follows:
Step A. Generate a random number Y according to a given
density function g(x), to which the domain of f(x) is
equivalent.
Step B. Create a uniform random number R ! [0,1] .
Step C. If R " f (Y ) /{c ! g (Y )} , then accept Y such that x = Y,
otherwise reject Y and go back to Step A. Here, c is a
constant number that satisfies c > f ( x) / g ( x) .
In the proposed method, particles are assumed to be generated
at volume cell vertices according to a given density distribution
function ! using the hit and miss method. The random number Y,
generated in Step A at the volume cell vertex position, determines
whether a particle will be generated or not at each of the vertices.
In the proposed method, for simplification, it is assumed that g(x)
= 1 and c = 1. Therefore, the particle generation at a given volume
cell vertex position x is decided by simply comparing the density
! with the generated random number R as follows:
Step 1.
Step 2.

Generate a uniform random number R ! [0,1] .
If R " ! ( xi ) , generate a particle at xi . Otherwise, do

not generate a particle at xi .
3.1.2
Metropolis method
The Metropolis method generates particles one-by-one in a
volume space, starting at an arbitrary initial particle position x0 .
In the following, xi denotes the position of the i-th generated
particle. The particle generation is performed following the
standard algorithm of the Metropolis method![11]:
Step 1. Calculate ! ( xi ) for the current particle position xi .
Generate a new particle at a candidate (trial) position x'
that is chosen randomly in the volume space, and
calculate ! (x' ) .
Step 2. Calculate the ratio of ! (x' ) to ! ( xi ) , i.e.,
W ( xi # x ' ) " ! ( x ' ) ! ( xi ) .
Step 3. If W ( xi " x' ) ! 1 , accept x' as an updated particle
position xi +1 , and go back to Step 1. Otherwise, go on
to Step 4.
Step 4. Generate a uniform random number R ! [0,1) and
determine xi +1 as follows:

# x' if R % W ( xi $ x' )
xi +1 = "
otherwise
! xi
Adopt the above xi +1 as the updated particle position
and then go back to Step 1.
3.2
Particle projection
Using the aforementioned particle generation method, we can
generate particles in a volume space according to the density
function ! (x) . By projecting these particles onto the image plane,
we calculate brightness values of the corresponding pixels. We
also perform particle occlusion with the Z-buffer algorithm during
this projection stage. This incorporates the effects of particle
collision, which prevents some particles from reaching the image
plane.
In the present method, we assume that the particles are
completely opaque. Thus, neither alpha blending nor visibility
ordering is required. However, when the number of projected

particles is small, for instance one per pixel, it becomes difficult
to produce a semi-transparent appearance. This problem can be
solved by sub-pixel processing, i.e., by dividing a pixel into
multiple sub-pixels and averaging their brightness values within
the pixel.
A pixel with sub-pixel level N is divided into N ! N subdomains (sub-pixels). Performing particle occlusion for each subpixel causes the pixel to store at most N 2 particles, which affects
the averaging procedure used to determine the pixel value. An
increase in the sub-pixel level results in a greater transparency
effect because of the reduction in the number of occluded particles.
This is because the collision detection area becomes reduced and
more particles can reach the image plane. When performing the
sub-pixel processing, it is necessary to store multiple particles for
each of the pixels. Therefore, we allocated an area (particle
buffer) for storing these particles on the image plane.
4

SOME EXPERIMENTAL RESULTS

We conducted some experiments to verify the effectiveness of
our proposed technique. We used a PC with an Intel Xeon 3.06GHz CPU and 2 GB of RAM for the experimental evaluations.
4.1
Effect of sub-pixel processing
We applied different sub-pixel levels to the aforementioned
volume dataset in order to verify the semi-transparent effect when
utilizing the sub-pixel processing.
From Figure 1, we can verify the change in the semi-transparent
appearance for each image resolution while varying the sub-pixel
level. The increase in the sub-pixel level resulted in a greater
transparency effect because of the reduction in the quantity of
occluded particles. This is because the quantity of particle
projection areas per pixel is increased and so more particles have
the opportunity to reach the particle buffer.
4.2

Image quality improvement using the Metropolis
method
We have confirmed that the Hit and Miss method and sub-pixel
processing can efficiently obtain good rendering results with the
desired semi-transparency. However, a regular cross stripe pattern
may appear depending on the viewpoint because the particle
generation positions are restricted to the grid points when using
the Hit and Miss method. We have investigated the use of the
Metropolis method as an alternative method for improving image
quality because there is no such restriction when using the
Metropolis method and the quantity of particles being generated
can be easily controlled. We used the tornado data (1283) in order
to confirm the image quality improvement when using the
Metropolis method. The resulting images (1282) are shown in
Figure 3. The undesirable regular cross stripe pattern that appears
in Figure 3 (a) is eliminated in Figure 3 (b), even when using a

(a) Hit and Miss method

(b) Metropolis method

Figure 3: Image quality improvement using the Metropolis
3
method for tornado data (256 ).

131

Collision

Tetrahedron
Particle

Projection
Screen

(a)!Intermixing of particle buffers

Non-generated particle
Generated particle

Irregular Volume Data

(b)!Lobsters and teapot. Each
object consists of 0.5M particles.

Figure 4: Simultaneous rendering of multiple volume data.

similar number of stored particles in the particle buffer.
4.3
Simultaneous display of multiple volume data
In the proposed method, the rendering process of the final
image is based on the stored particles in the particle buffer. We
can therefore render multiple volume data simultaneously by
simply allocating particle buffers for each of the volume data. The
final image is then easily generated by processing the involved
particle buffers. In this case, the required operation is a basic
depth-order comparison of corresponding pixel areas. Two
examples of multiple volume data being simultaneously displayed
are shown in Figure 4. From these figures, we can verify that a
satisfactory semi-transparent display is possible even at the
overlapping areas.
4.4
Rendering of irregular volume data
Volume rendering of tetrahedral cell-based irregular volume
data has also been investigated. We applied the two-pass
voxelization method [12] in order to enable the generation of tiny
particles using the Hit and Miss method at regularly distributed
grid points. The rendering result of an irregular volume data
named “Aorta” which consists of 1,386,882 tetrahedral elements
is shown in Figure 5.
5

CONCLUSION

In the present paper, we have presented a novel particle-based
volume rendering technique based on tiny opaque particles.
Because of the use of fully opaque particles, this technique does
not require either depth sorting of sampled points in the volume
data or alpha blending. The tiny particles are generated using a
particle density distribution function from a user-specified transfer
function and the rejection method. The final image is generated by
projecting these particles onto the image plane. During the particle
projection, only a simple depth comparison is required for the
elimination of occluded particles. The semi-transparent
appearance can be obtained by using the sub-pixel processing
which has proven effective through experimentations. We have
also verified experimentally that the particle projection stage is
the most computationally intensive stage. However, as the
projection order is not required, this stage may be easily

132

Figure 5: Rendering of irregular volume data (Aorta data).

parallelizable and therefore accelerated by parallel processing. In
future studies, we are planning to develop a more dynamic point
generation method. In addition, we are planning to verify the
improvement in computational time when using parallel
processing for accelerating the volume rendering process.
REFERENCES
[1]

M.Levoy, Display of Surfaces from Volume Data, IEEE Computer
Graphics and Applications, vol.8 no.3, p.29-37, 1988.
[2] R.A.Drebin, L.Carpenter, and P.Hanrahan : Volume Rendering,
Computer Graphics, vol.22, no.4, pp.51-58, 1988.
[3] L.Westover : Footprint Evaluation for Volume Rendering, In Proc.
of ACM SIGGRAPH, pp.367-376, 1990.
[4] D.Laur, and P.Hanrahan, Hierarchical Splatting: A Progressive
Refinement Algorithm for Volume Rendering. In Proc. of ACM
SIGGRAPH ’91, pp. 285–288, 1991.
[5] M.Zwicker, H.Pfister, J.V.Baar, and M.Gross : EWA Volume
Splatting, In Proc. of IEEE Visualization, pp.29-36, 2001.
[6] W.Chen, L.Ren, M.Zwicker, and H.Pfister : Hardware-accelerated
Adaptive EWA Volume Splatting, In Proc. of IEEE Visualization,
pp.67-74, 2004.
[7] F.Vega-Higuera, P.Hastreiter, R.Fahlbusch, and G.Greiner : High
Performance Volume Splatting for Visualization of Neurovascular
Data, In Proc. of IEEE Visualization, pp.271-278, 2005.
[8] M. Hopf, and T. Ertl : Hierarchical Splatting of Scattered Data, In
Proc. of IEEE Visualization, pp.57-64, 2003.
[9] B.Csébfalvi, and L.Szirmay-Kalos : Monte Carlo Volume Rendering,
In Proc. of IEEE Visualization, pp.449-456, 2003.
[10] B.Csébfalvi : Interactive Transfer Function Control for Monte Carlo
Volume Rendering, In Proc. of IEEE Symposium on Volume
Visualization and Graphics 2004, pp.33-38, 2004.
[11] N.Metropolis, A.Rosenbluth, M.Rosenbluth, A.Teller, and E.Teller :
Equation of State Calculations by Fast Computing Machines, J. of
Chem. Physics, 21, pp.1087-1092, 1953.
[12] N.Sakamoto, K.Koyamada, K.Sakai, and M.Kikugawa :
Voxelization of Hexahedral Cell with the Two-Path Rasterization
Technique, In Proc. of International Conference on Visualization,
Imaging, and Image Processing, pp.253-259, 2004.


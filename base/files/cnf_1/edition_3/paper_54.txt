Visualized Subgraph Search∗
VAST 2009 Flitter Mini Challenge Award: Good Analytical debrief
´ Erdos
˝
Dora

Zsolt Fekete

´ Lukacs
´
Andras

Computer and Automation Research Institute (MTA SZTAKI), Hungarian Academy of Sciences
Data Mining and Web Search Group
{edori, zsfekete, lukacs@ilab.sztaki.hu}

A BSTRACT
We present a visually supported search and browsing system for
network-type data, especially a novel module for subgraph search
with a GUI to define subgraphs for queries. We describe how this
prototype was applied for the Vast Challenge 2009, Flitter Mini
Challenge.
Keywords: Visual Analytics, Heterogeneous Graph Visualization
Index Terms: E.1 [Data]: Data Structures—Graphs and networks;
K.6.1 [Visual Analytics]: Heterogeneous Graph Visualization—
1 I NTRODUCTION
In the Vast 2009 Flitter Mini Challenge data set, the connections
between the Flitter network users were given along with additional
geographical location data. The task was to identify a criminal network defined by a certain structure of the users. Our main idea
was to represent the Flitter users’ network as a graph with vertices
corresponding to users and edges to their connections. In this representation all information given in the textual description of the
criminal network could be fully converted by the analyst into constraints on the number of connections and geographic location of
members in specific roles. When regarding the Flitter network as a
graph, this description defines two subgraph structures for the two
scenarios that have to be identified.
Our in-house search and visualization tool was designed for
search and browsing in large scale network-type data. For the
VAST 2009 Challenge we developed a new module for general
subgraph search extending the previous single node or edge based
queries. The new subgraph based search seems fulfill the requirements arisen in the Flitter Mini Challange and in more general in
the targeted application area. The technical novelty of our method
lies in the user interface for subgraph structure description.
Juba et. al. ([1])designed a system with a similar approach for
searching for spanning trees in a graph.
In the next section we present the architecture of our system. In
Section 2.2 we describe the query language and in Section 2.3 the
subgraph search UI. Finally in Section 3 we show how we used the
subgraph search on the Flitter data.
2 O UR S EARCH AND V ISUALIZATION S YSTEM
2.1 Architecture of the Search System
The central notion of the system is an entity with several
attributes.
In the Flitter dataset the attributes include Id,
Name, City, Degree, IsAbroad, OtelloLinks, TulamukLinks,
TranspaskoLinks, AbroadLinks and CitySize. The type of an
attribute can be integer, double or string. A sample entity can be
e = {Id : 1, Name : @irvin, City : Koul, Degree : 300, IsAbroad :
0, OtelloLinks : 10, TulamukLinks : 9, TranspaskoLinks :
∗ Supported by the EU FP7 project LiWA—Living Web Archives and by
grant OTKA NK 72845.

IEEE Symposium on Visual Analytics Science and Technology
October 12 - 13, Atlantic City, New Jersey, USA
978-1-4244-5283-5/09/$25.00 ©2009 IEEE

Figure 1: A query window set for an entity match query

5, AbroadLinks : 24, CitySize : 4}. We note that our system can
handle multiple type of entities.
The system has a server part, which has been implemented in
C++, and a Java client, which provides the graphical user interface.
We mention that the data loaded into the system can be arbitrarily large, we use an embedded database manager for storing data.
Though in case of the Flitter dataset the total amount of data was
stored in the memory cache.
One of the main functionalities of the user interface is search: the
user can define a query by (partly) filling a query form. We say that
an entity matches a query if the appropriate attributes of the entity
are in the range required by the query. For example the entities
matching query q = {City : Koul, Degree : [30, 40], AbroadLinks :
[1, ∞)} are the Flitter persons that live in Koul, have degree between
30 and 40 and have at least one abroad link.
Additional functionalities of the interface include automatic layout, zoom, delete, save graph and graph export into an image file.
In order to browse, the user may double click on a node to display
the neighbors of this node. Some natural graph algorithms are also
included such as finding shortest paths or specified node pairs.
2.2 Query language
Subgraph search is composed of advanced search operators described below. An advanced search A = (S,C1 , . . . ,Ck ) contains an
base search S and constraints C1 , . . . ,Ck (where k can be 0).
Every base search S defines a result set, which is a set of entities.
A base search S can be one of the following.
• EntitySearch(q), where q is a query. The result set of this is
the set of entities matching query q.
• NeighborSearch(e1 , . . . , en ), where ei is an entity. The result
set is the set of entities that are connected to every entity ei by
an edge of the graph.
Every constraint is a boolean valued function on entities. A constraint Ci can be the following:

267

Figure 2: A window for assembling a subgraph structure. It shows
how the EntityConstraint is set.

• EntityConstraint(q) is true for entity e, if e matches query q
• NeighborConstraint(e1 , . . . , en ) is true for e, if e is a common
neighbor of e1 , . . . , en
• NonNeighborConstraint(e1 , . . . , en ) is true for e, if e is not
linked to any of entities e1 , . . . , en .
• A CompareConstraint is defined by an entity e0 an attribute
attr of entity e0 and a symbol α ∈ {<, >, ≤, ≥, =, =}. The
value of CompareConstraint(e0 , attr, α ) on entity e is the logical value of the following expression: e0 .attr α e.attr.
The result set of an advanced search A = (S,C1 , . . . ,Ck ) is the set
of entities that are included in the result set of the base search S and
satisfy all the constraints.
For example let S = NeighborSearch(e, f ), C1 =
NonNeighborConstraint(g), C2 = EntityConstraint(q), where
q = {City : Koul, Degree : 20} and let advanced search
A = (S,C1 ,C2 ). Then the result set of A is the set of entities
that are connected to e and f , not connected to g, have degree 20
and are living in Koul.
2.3 Search for Subgraphs
The search of a subgraph is defined by a list of advanced search
expressions A1 , . . . , An , so that in Ai (i ≥ 2) the ei entities appearing in NeighborSearch, EntitySearch, NeighborConstraint,
NonNeighborConstraint and CompareConstraint can be a symbol
(variable) Item j where j < k. We say that an n-tuple of entities
e1 , . . . , en matches the search list if ek is in the result set of Ak where
the symbols Item j ( j < k) were substituted by e j .
For better understanding we illustrate the above definitions by
a specific example. In the example below we are looking for a
”cherry” in the graph, i.e. we would like to find e1 , e2 , e3 so that
e1 e2 and e1 e3 are edges of the graph but e2 e3 is not an edge. And
suppose that we expect the three entities to be vertices with degrees between 30 and 40. So in this case we would define our
structure in the following way. Let q0 be the following query
{Degree : [30; 40]}. Now define the following advanced searches
A1 , A2 , A3 .
• A1

= (S1 )
–

S1

(without constraints), where

= EntitySearch(q0 )

• A2 = (S2 ,C12 ), where
– S2 = NeighborSearch(Item1 )
– C12 = EntityConstraint(q0 )
• A3 = (S3 ,C13 ,C23 ,C33 ), where
–
–
–
–

S3 = NeighborSearch(Item1 ),
C13 = EntityConstraint(q0 )
C23 = NonNeighborConstraint(Item2 )
C33 = CompareConstraint(Item2 , id, <)

The CompareConstraint C33 is needed because without that constraint we would get all results twice. Namely e1 e2 e3 would be a
solution and its permutation e1 e3 e2 too.

268

Figure 3: A structural search for scenario B

We implemented a user interface for defining subgraph structures. With this approach one can define an arbitrary subgraph
search. Moreover in this way the user does not only specify the expected subgraph, but specifies the algorithm executed by the server,
because the sequence A1 , . . . , An naturally defines a backtrack algorithm for finding the desired subgraph. The running time of this
algorithm is exponential in the number of vertices of the subgraph.
3 S UBGRAPH S EARCH OVER THE F LITTER DATA
For both scenarios we set up a structure in our graph visualization
tool. In scenario A we were looking for a subgraph with six while
in scenario B eight vertices. We set constraints on the degree of the
vertices and NeighborConstraints and NonNeighborConstraints
where needed. At first we did not put degree constraints on the
vertices corresponding to the middlemen and obtained 12 hits for
scenario A and over a thousand for scenario B. After imposing the
appropriate degree constraints on the middlemen (the degree of the
middleman is no more than 6 in scenario A and no more than 4
in B) we obtained two hits for the first scenario and none for the
second.
From the two hits we got for scenario A we manually chose
the subgraph where the geographic location of members in specific
roles fit the description better.
4 C ONCLUSIONS AND F UTURE W ORK
We solved the Vast Flitter Mini Challenge via a new subgraph
search interface in our graph search and visualization tool. Our experience was that we could define subgraph search in a very flexible
way, it was easy to modify parameters on the desired subgraph.
Since we use a backtrack algorithm the program could be easily
parallelized which would increase computational speed considerably. Currently it is quite complicated to define a scheme. So we
plan to improve the user interface of the prototype.
R EFERENCES
[1] D. Juba, T. Chabuk, and C. Hu. Visualizing Search in Networks.


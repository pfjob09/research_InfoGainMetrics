Reasonable Abstractions: Semantics for Dynamic Data Visualization
Joseph A. Cottam, and Andrew Lumsdaine

A BSTRACT

1

I NTRODUCTION

Formal models provide a basis for evaluating frameworks independent of implementation details and provide a means for the evaluating proposed features. As workloads and computational environments grow in complexity, such models will be essential for future
visualization frameworks. Our work establishes a model with the
following five capabilities: (1) dynamic data handling, (2) deterministic execution, (3) bounded resource consumption, (4) consistency in results and (5) interoperability. Informally, dynamic data
handling means that data may change while analysis is being performed. Deterministic execution indicates that only the inputs values matter in determining the resulting visualization (not timing artifacts in the system). Bounded resource consumption implies that
resource use is a reasonable function of the inputs. Consistency
indicates that the multiple parts of the visualizations stay synchronized with each other. Finally, interoperability is the ability to use
algorithm implementations with little framework-specific-specific
work. With these five properties, a wide variety of visualizations
can be addressed. Our exploration has lead to a formalization of
the data flow model of visualization in terms of Event-Driven Functional Reactive Programming (E-FRP). We have implemented the
Stencil visualization framework in accordance with E-FRP semantics and demonstrate a performance advantage when the semantics
are applied to find optimization opportunities.
2

R ELATED W ORK

The data-flow model of visualization as described by Chi [2] is an
expression of the dependencies between data transformations. Chi
showed that the data-flow model could be exchanged with a datastate model in a structured fashion. This enabled the prior experience with data-flow models to be applied to the relatively new datastate model and “information spreadsheets.” However, the models
presented did not include order of operation information, making
execution questions unapproachable.

IEEE Symposium on Visual Analytics Science and Technology
October 23 - 28, Providence, RI, USA
978-1-4673-0014-8/11/$26.00 ©2011 IEEE

Dispatcher

Deterministic

Index Terms: K.6.1 [Management of Computing and Information
Systems]: Project and People Management—Life Cycle; K.7.m
[The Computing Profession]: Miscellaneous—Ethics

Sequencer

Renderer

Keywords: Dynamic data, Semantics.

External Data Sources

Analysis
Engine

Chi showed how to treat visualization programing models abstractly. This provided a firm theoretical basis for the data-state
model of visualization. However, Chi’s models did not look deeper
into fine-grained program properties, such as execution semantics.
We present conditionally deterministic and resource bounded semantics for the data flow model of visualization based on E-FRP.
These semantics are used in the Stencil system to move between
data state and data flow execution, build task-based parallelism, and
build complex analysis chains for dynamic data. This initial work
also shows promise for other complex operators, compilation techniques to enable efficient use of time and space, and mixing task
and data parallelism.

Display
Figure 1: E-FRP visualization system block diagram. Event
streams provide data to the sequencer, which orders events for the
dispatcher. The dispatcher feeds the analysis engine, which produces a data store, rendered images and new events.

Functional-Reactive Programming (FRP) is a formalism for constructing synchronous data-flow networks. Formal semantics for
FRP show it is deterministic [5]. The core concepts of FRP are
(1) behaviors (time-varying values), (2) events (values a specific
time) and (3) combinators to construct new events and behaviors.
Pure FRP makes two broad assumptions: (1) that the system will
’react’ to a dynamic data and (2) that operations are pure functions with time parameters taken from a continuous space. EFRP is based on FRP, but removes the assumption of continuous
time by assuming that behavior values only change when discrete
events occur [6]. With E-FRP, stateful behaviors can include nonfunctions as long as state changes logically occur between events.
This provides a direct means for interoperating with programs not
specifically coded for E-FRP. E-FRP is deterministic and resource
bounded insofar as the operations employed are as well. This satisfies four of the five desired properties; consistency is provided by
treating rendering as response to an event in an E-FRP program.
There are four parts to an E-FRP visualization system, depicted
in Figure 1. First, the Sequencer gathers external events and selects
a ‘next’ event. Second, the Dispatcher accepts the ‘next’ event from
the sequencer to process in the analysis engine. Third, the analysis engine is configured with an E-FRP program that produces (1)
a data store and (2) a new E-FRP program. For visualization, the
data store includes update to visual store (from the InfoVis reference model [1]) and possibly new data to be analyzed. Fourth is a
store consumer, for Visualization this is split between the Display,
Dispatcher and Sequencer; each of these components may receive
parts of the results of the analysis engine. These parts are faithfully
implemented in Stencil.
3 S TENCIL : A N E-FRP BASED VISUALIZATION SYSTEM
As a synchronous network language, E-FRP fits closely with the
data-flow model of visualization. Informally, each link of a dataflow network becomes a event type in the E-FRP program. Transformations operations correspond to behavior definitions. When an
event occurs, behaviors execute according to the E-FRP semantics.
E-FPR semantics indicate that independent behaviors may be eval-

269

A

Dispatch

as
bs

A

cs

E

ds

C

D

es

bs

bs
es

ds

C

B

cs
es

D

E

	  Prefuse	  

ds

100000	  
Time	  ot	  Load	  (ms)	  

B

ds

1000000	  

as
ds

as

	  Stencil	  

10000	  
1000	  
100	  
10	  

uated in any order. Behaviors may see changes to behaviors earlier
in the network only if there is no backward dependency. Otherwise,
behaviors in mutually dependent groups can execute in any order,
but results are still deterministic because state changes only occur
between events. To force a specific order on loops, synthetic events
are constructed and loop breaking is be performed. (This is not
standard E-FRP, which uses a now/later tag to make updates visible at different times. The now/later tagging is (1) not sufficiently
general to break all loops and (2) not know to be deterministic or
resource bounded.) Figure 2 shows the loop-breaking techniques.
Synthetic events make the update order explicit in the network.
In the Stencil implementation, interoperating with existing algorithms is facilitated by wrapping the existing algorithm in a new
interface. The Stencil system has operators based on JUNG and
UMD TreeMap implementations. Each requires about 100 lines of
wrapper code around the 10K+ code bases. The wrapper code primarily buffer state changes so they logically occur between events.
Working with dynamic data requires properly timing rendering.
A consistent visualization is one where the different visualization
parts all reflect the same data. Waiting for all data to be processed
is generally impossible as dynamic data may be unbound. Frameworks often provide consistency by making analysis and rendering
mutually exclusive [3, 4]. Stencil abstractly represents this technique by making rendering an E-FRP event response. However, the
runtime uses persistent data structures to render concurrently with
analysis in a consistency-respecting fashion. This increases the the
number of data points that can be processed per unit time.
With E-FRP semantics and a simple effect system (analysis operations are labeled as either ‘function’, ‘reader’ or ‘writer’), Stencil
can efficiently handle dynamic data analysis. Particularly, the semantics and type system indicate when batch operation groups are
possible and how to concurrently perform render and analysis. We
compared Stencil performance to Prefuse performance on a simple
quadrant-filling layout. Prefuse was selected because it is a mature
framework implemented in Java and uses a column store. Stencil is
also implemented in Java and uses a column store. Each new datapoint requires all other points to move, introducing a worst-case
scenario for computation before rendering. A quadrant filling layout was used so all data points would remain on the screen, but no
zoom/pan calculations are required. To mediate framework differences, rendering was triggered Prefuse on a timer that matched the
frame-rates seen in the Stencil. Average runtimes over five executions are presented in Figure 3. For all but trivial data sizes, Stencil
enjoys sizable a performance advantage, despite being untyped and
interpreted while Prefuse is typed and compiled. The advantage
is achieved through Stencil’s application of E-FRP semantics and
abstract encoding of consistency.
4

O PEN Q UESTIONS

AND

C ONCLUSIONS

The semantics, presented here in outline, enable more detailed program analysis than Chi’s treatment. However, the semantics be-

270

8	  
16
	  
32
	  
64
	  
12
8	  
25
6	  
51
2
10 	  
24
20 	  
48
40 	  
96
81 	  
9
16 2	  
38
32 4	  
76
65 8	  
5
13 36	  
10
26 72	  
21
44
	  

1	  
2	  
4	  

1	  

Figure 2: Interleaved cycle broken by introducing synthetic events
that are consumed and ordered by the dispatcher.

Number	  of	  Data	  Points	  Loaded	  

Figure 3: Performance of Prefuse and Stencil on a quadrant-filling
layout using dynamically updated data.

come more useful with additional program meta-data. For example,
the performance results presented in Figure 3 rely on a simple effect
system. We are currently investigating other meta-data for creating
efficient visualization systems. Information about the data source
(e.g., that values are sorted or unique) may enable more efficient
memory use. More detailed information about analysis operators
also has applications (e.g., commutative and tolerance of benign
race conditions). Operator groups may enable situation specific operator implementation selection.
E-FRP semantics establish useful properties for Stencil (like
consistency and resource bounds). However, they are not necessarily the “best” semantics for a visualizations system. E-FRP semantics assume that strong memory consistency is desired and thus
limit data parallelism. Other semantic models (such as a process
calculus) may provide insights, and be more suitable for different
workloads and hardware configurations.
Even retaining E-FRP semantics, other visualization abstractions
may be formalized and then optimized. Cross-tab/pivot tables for
summarization, efficiently scheduling recalculations (for dynamic
data), axis/legend creation and data-based parallelization are all being investigated. Each presents a non-trivial problem for Visualization and the E-FRP semantics guide efficient implementations that
preserve the properties enjoyed by the basic framework.
The semantic framework of Stencil enables automatic reasoning
about visualization programs. As workloads become more demanding, framework semantics will become more important. E-FRP
provides a basis for deterministic, resource bounded computation
resulting in internally consistent visualizations.
R EFERENCES
[1] S. K. Card, J. Mackinlay, and B. Shneiderman. Readings in Information
Visualization: Using Vision to Think. Morgan Kaufman, 1999.
[2] E. H. Chi. A Framework for Visualizing Information (Human-Computer
Interaction Series). Springer-Verlag New York, Inc., Secaucus, NJ,
USA, 2002.
[3] J. Heer and M. Bostock. Declarative language design for interactive
visualization. IEEE Trans. Visualization & Comp. Graphics (Proc. InfoVis), 2010.
[4] W. Schroder, K. Martin, and B. Lorensen. The Visualization Toolkit:
An Object-Oriented Approach to 3D Graphics (3rd Edition). Kitware,
Inc., USA, 2002.
[5] Z. Wan and P. Hudak. Functional reactive programming from first principles. SIGPLAN Not., 35:242–252, May 2000.
[6] Z. Wan, W. Taha, and P. Hudak. Event-driven frp. In Proceedings of
the 4th International Symposium on Practical Aspects of Declarative
Languages, PADL ’02, pages 155–172, London, UK, 2002. SpringerVerlag.


Construction of 3D Composite Objects from Range Data

1

Keita Sato1, Yoshihiro Okada1,2, Koichi Niijima1
Graduate School of Information Science and Electrical Engineering, Kyushu University
6-1 Kasuga-koen, Kasuga, Fukuoka, 816-8580 JAPAN
{keita.sato, okada, niijima}@i.kyushu-u.ac.jp
2
Intelligent Cooperation and Control, PRESTO, JST
Abstract

Recent advances of computer hardware technologies
have made it possible to render 3D CG images in real
time, and 3D graphics has become in great demand for
various applications. However the development of 3D
graphics software is still laborious work compared to 2D
software development. Hence, the research group of the
authors has proposed a component-based 3D graphics
software development system called IntelligentBox.
However, developers have to construct 3D composite
components manually when developing an application
even using such a component-based tool, and this is time
consuming task.
Hence, this paper proposes an
automatic construction method of 3D composite objects
from range data of artifacts. The 3D object construction
system based on this method decomposes a unified
surface model obtained from range data of a certain
artifact to several elements by segmenting it,
automatically exchanges each element into its similar
shape model, which is already prepared as a functional
component of IntelligentBox, and composes them into
one functional composite component which looks like the
original artifact. In this way, the user obtains functional
composite 3D objects from range data easily.
Keywords--- Segmentation, Shape matching, 3D
Graphics, Polygonal models, Range data

1. Introduction
This paper proposes an automatic construction
method of 3D composite objects from range data of
artifacts existing in the real world. Recent advances of
computer hardware technologies have made it possible to
render 3D CG images in real time, and 3D CG and CG
animation have been in great demand for video game
industries and movie industries. Also, 3D graphics
software has become in great demand for various
applications. However the development of 3D graphics
software is still laborious work compared to 2D software
development. For this reason, many 3D software
development systems and tools have been proposed so
far. We also proposed a component-based 3D graphics

software development system called IntelligentBox [1, 2].
IntelligentBox provides various 3D reactive objects
called boxes. Boxes are manually operable objects,
which have a 3D visible shape and a unique functionality.
As IntelligentBox also provides a dynamic data linkage
mechanism called ‘slot connection’, the user can
construct interactively 3D graphics applications by
combining already existing boxes through direct
manipulations on a computer screen.
However,
developers have to construct 3D composite components
manually when developing an application even using any
component-based
development
tool
such
as
IntelligentBox, and this task is very time consuming.
Hence, Akazawa, et al, proposed an automatic 3D scene
generation system [3].
In this paper, we propose an automatic construction
method of 3D composite objects from range data of
artifacts existing in the real world. We implemented a
3D object construction system based on this method. It
decomposes a unified surface model obtained from range
data of a certain artifact to several elements by
segmenting it, automatically exchanges each element
into its similar shape model, which is already prepared as
a functional component of IntelligentBox, and composes
them into one functional composite component which
looks like the original artifact. In this way, the user
obtains functional composite 3D objects from range data
of artifacts existing in the real world. This can
drastically reduce the time consumed to develop 3D
graphics applications when using a component-based
development system such as IntelligentBox.
As related work, there are many researches on the
construction of 3D polygonal modes from 2D image data
or range data. For example, A. D. Sappa proposed a
method to generate surface models from range data
images of industrial environments [4]. This method
generates surface models of typical shape objects like
long shaft objects and cylindrical shape objects often
existing in industrial environments. However, it does not
generate functional composite objects. The difference of
our proposed method from his proposed method is that
our method generates functional composite objects.
This paper is organized as follows: Before
explaining details of our proposed method, we introduce

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

IntelligentBox briefly in Section 2. Section 3 describes
watershed method [5] that is used for the segmentation.
Although the watershed method is originally proposed
for the segmentation of 2D images, it can be extended for
the segmentation of 3D polygonal models. Our system
decomposes a unified surface model obtained from range
data to several elements using this segmentation method.
After that, the system exchanges each element into its
similar shape model. We employ D2 [6] as the shape
matching algorithm for this exchange. So, In Section 4,
we explain D2 and describe its usefulness by showing
several examples of typical shape models. After the
exchange of each element into its similar shape model,
the system assumes and assigns certain functionality to
the model. Section 5 discusses such functionality
assignment. In Section 6, we show some practically
constructed 3D composite objects, and discuss their
results and the performance of the system. Finally we
conclude the paper in Section 7.

2. IntelligentBox
This section explains essential mechanisms of
IntelligentBox briefly.
IntelligentBox employs the
following essential mechanisms.

2.1. Model-Display object (MD) structure
As shown in Figure 1, each box consists of two
objects, a model and a display object. This structure is
called MD (Model-Display object) structure. A model
holds state values of a box. They are stored in variables
called slots. A display object defines how the box
appears on a computer screen and also defines how the
box reacts to the user’s operations. Figure 1 also shows
the messages that are passed between a display object
and a model. This is an example of RotationBox, which
has a slot named ‘ratio’ that holds a double precision
number and stands for a rotation angle. This value is
normalized so that it ranges from zero to one. One
means one rotation. Through direct manipulation on a
box using a 2D mouse device, its associated slot value is
changed. For example, ‘ratio’ slot value of RotationBox
is changed proportionally to the moving distance of the
mouse device. Furthermore, its visual image change is
simultaneous with the change of the slot value. In this
way, a box reacts to the user's manipulation according to
its functionality.

Figure 1: An MD structure of a box and its internal
messages.
There are three standard types of messages, i.e., a set
message, a gimme message and an update message.
These messages have the following formats:
(1) Parent box set <slotname> <value>.
(2) Parent box gimme <slotname>.
(3) Child box update.
In the format (1), <value> represents any value, and
<slotname> in the formats (1) and (2) represents a userselected slot of the parent box that receives these two
messages. A set message writes a child box slot value
into its parent box slot. A gimme message reads a slot
value from a parent box and sets the value into its child
box slot. Update messages are issued from a parent box
to all of its child boxes to tell them that the parent box
slot value has changed.
Each box has three main flags that control the above
message flow, i.e., a set flag, a gimme flag, and an
update flag. These flags are properties of a display
object. A box works as an input device if its set flag is
set to true. On the contrary, a box works as an output
device if its gimme flag is set to true. A box sends
update messages if its update flag is set to true. The
child boxes take an action depending upon the states of
the set flag and the gimme flag after they receive an
update message or after they individually change their
slot values. There are two more flags for fully
controlling the data flow.

2.2. Message-sending protocol for slot
connections
Figure 2 illustrates a data linkage concept among
boxes. As shown in the figure, each box has multiple
slots. Its one slot can be connected to one of the slots of
other box. This connection is called slot connection.
Slot connection is carried out by some messages when
there is a parent-child relationship between two boxes.

Figure 2: Standard messages between boxes.

3. Segmentation by watershed method
This section presents the segmentation algorithm.
To decompose a unified surface obtained from range
data to several elements, we employ a watershed method

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

proposed by Alan P.Mangan [5]. The watershed method
is originally proposed for the segmentation of 2D images.
In the watershed method, feature values given as height
information are calculated, 3D topographical map is
made such as contour line figure by the feature values,
and water catchment areas are determined by flushing
down waters on the map. Consequently, the map is
divided into several areas based on the water catchment
areas. And this method is extended to be applicable to
3D polygonal models.

ªV xx V xy V xz º
«
»
C «V yx V yy V yz »
«V V V »
¬ zx zy zz ¼

(2)

D

(3)

C

3.1. Extension toward 3D polygonal models

3.3. Noise reduction

In the watershed method for 3D polygonal models, a
feature value is calculated and assigned to each vertex of
a polygonal model, 3D topographical map is made by the
feature values, and the segmentation process is done in
the same way as that of the 2D case. The watershed
method for 3D polygonal models is carried out by the
following six steps:
1. Calculate the curvature of every vertex as its
feature value.
2. Find the local minima of the curvatures and assign
a unique label to that vertex.
3. Find flat area and define local minimum curvature
area as Flat Minimum, others as Flat Plateau. And
assign a unique label to the Flat Minimum.
4. Allow each Flat Plateau to descend until they reach
labeled vertices (or area).
5. When Flat Plateau descends at Step 4, assign the
same label as the vertices or area to the vertices or
area that Flat Plateau passes.
6. Merge regions whose region depth is below a given
threshold value.
Through the above steps, a unified surface model is
divided into several elements.

The process of the steps described in 3.1 is not
enough for the precise segmentation of a unified surface
model because unified surface models generated from
range data include many noise vertices. We have to
reduce the noise affection. There is one research [7] to
reduce the noise affection for the segmentation of
polygonal models. It proposes wide range normal
evaluation method instead of the use of the above simple
curvature calculation. However, it is too complicated
and it takes a very long time to obtain a desirable result.
So we decided to calculate each vertex curvature as the
average of the vertex curvatures adjacent of this vertex to
reduce the noise affection.

3.2. Curvature calculation
The calculation of a vertex curvature in Step 1 uses
normals of faces adjacent to the vertex. Firstly, the
covariance of a vertex and vertices adjacent to this vertex
is calculated using next equation (1).
2
V ab

1 N
¦ (a t  a )(b t  b)
Nt0

(1)

Here, N represents the number of triangle faces
neighboring the vertex, a  {x, y , z} , b  {x, y , z} ,
and {xt , y t , z t } are the x, y, z element set of the normal
of triangle face t in the neighboring faces.
Next, covariance matrix C expressed in (2) is
calculated and then, the norm of covariance matrix C as
curvature D expressed in (3) is calculated.

4. Shape matching based on D2 method
Next, shape matching is applied to each element
divided by the watershed method of Section 3. In this
paper, the purpose of the shape matching is to use typical,
simple shaped polygonal models like a cylinder, a cube,
etc, which exclude any noises, instead of the original
divided elements which include many noises. Then each
divided element is replaced with its similar shaped
polygonal model. Here, the D2 method is used for the
shape matching.
The D2 method uses a histogram of distances
between any two random points on a 3D model surface
for the feature value of the model. Figure 3 shows
histograms of four typical shaped polygonal models
obtained by applying the D2 method. Each of (a), (b),
(c) and (d) corresponds to each of a cube, a cylinder, a
sphere and a torus shped models respectively. As shown
in Figure 3, typical shaped models have a different
histogram from each other. So, the similarity between
two 3D models can be calculated as the error between
those two histograms.
Figure 4 (a) shows one polygonal model represents
a button extracted from a unified surface model of range
data by the segmentation based on the watershed method.
Figure 4 (b) shows its histogram obtained by applying
the D2 method. By comparing the histogram shown in
Figure 4 (b) with each of the four histograms shown in
Figure 3, it is found that a calculator’s button shown in
Figure 4 (a) is most similar to a cube shape. The original
polygon model is replaced with a cube shape model. In
this way, we can obtain a 3D composite object whose

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

each element has a simple, typical shape and excludes
any noises.

component from the shapes of its child components.
Currently we have been implementing such an approach.

6. Experiments and discussions

(a)

(b)

We implemented the segmentation method based
on the watershed method and the shape matching by the
D2 method explained in Sections 3 and 4. In this section,
we show some experimental results and discuss about
those results.

6.1. Segmentation results

(c)
(d)
Figure 3: Histograms of typical shaped models, a cube
(a), a cylinder (b), a sphere (c), and a torus model (d).

(a)
(b)
Figure 4: A polygon model as a calculator’s button (a)
and its histogram (b).

Figure 5 shows screen images of our segmentation
tool. Figures (a), (c), and (e) are respectively a calculator
polygon model, a scissors polygon model and a keyboard
polygon model obtained by a 3D scanner. Figures (b), (d)
and (f) are the results after the segmentation process.
Results of the segmentation by the watershed method are
very sensitive to a threshold value specified at Step 6 of
Section 3.1. Therefore, we prepared an interface to make
it possible to specify a threshold value with checking
results interactively.
Moreover, we added a lock
functionality which allows the user to lock appropriately
segmented regions where the merge should not be
applied any more even if a threshold value is changed
after that. By these additional functionalities, our
segmentation tool can be used to divide polygonal
models obtained by a 3D scanner into their small
elements adequately as shown in Figure 5.

5. Functionality assignment
Finally, we assign any functionality to elements of
a composite object generated at Section 4. There are
typical functional components, boxes of IntelligentBox,
i.e., PushButtonBox, ToggleSwitchBox, RotationBox
ExpandBox and StringBox. As the first step, we can
assign one of these functionalities to each element of a
composite object randomly. And then, if there are
inadequate assignments, we can reassign different
functionality to such elements interactively.
For
example, if a composite object is generated from the
range data of a calculator, we should assign the
functionality of PushButtonBox to each button element
of the composite object.
We have already many composite components,
boxes of IntelligentBox. If we have the informant that
which functional component, box has which shape, it
would be possible that the system automatically chooses
adequate functionality from the shape of an element and
assign it to the element. Furthermore, if we have the
information that which functional component, box is a
parent of its child components that have the shape
concerned, it would be possible that the system
automatically chooses adequate functionality for a parent

(a)

(b)

(c)

(d)

(e)
(f)
Figure 5: Screen images of a calculator polygon model, a
scissors polygon model and a keyboard polygonal model,
and their segmentation results.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

6.2. Shape matching results
Figure 6 shows screen images of our shape
matching tool. Figures (b), (c) and (d) show the shape
matching results of a calculator model, a scissors model
and a keyboard model respectively. Figure (a) is a
screen image of the calculator composite model under
the shape matching process. For these examples, a cube,
a torus, a cylinder and a sphere shape model are prepared
as candidate typical shape models.

(a)

(b)

Pentium 4, 2.54GHz processor, 512MB memory. The
CPU time consumed for the shape matching of each of
the three models is around 40 sec., 12 sec. and 75 sec.
respectively.

Figure 7: Screen image of a calculator composite
component.

(c)
(d)
Figure 6: Screen images of composite objects after the
shape matching.

6.3. Functionality assignment results
Figures 7 and 8 show screen images of final results
after the functionality assignment. Figures 7 and 8 mean
a calculator composite component and a scissors
composite component, i.e., two composite boxes of
IntelligentBox. Already each element of the composite
components has certain functionality so you can use the
components in the IntelligentBox system.
About the calculator, one of the operations such as
add, subtract, multiply, and so on, is assigned to a
corresponding button. Figure 7 shows a screen image
after pushing “1” button. Next, about the scissors,
rotation functionality is assigned to the pivot, a cylinder
shape element located at the center. Figure 8 shows a
screen image of the scissors whose two blades are made
to open.

6.4. Performance
Here, we show performances, i.e., the execution
time for each of the segmentation process and the shape
matching process, and the number of polygons actually
used in the above experiments. We obtained three
unified surface models, a calculator, a scissors and a
keyboard from the range data. The number of polygonal
faces for each of the three models is respectively 115,562,
61,366 and 230,546. The CPU time consumed for the
segmentation of each of the three models is around 607
sec., 221 sec. and 442 sec. respectively on a standard PC,

Figure 8: Screen image of a scissors composite
component.

6.5. Discussions
As we showed in Figure 6, the segmentation process
of the calculator and the scissors can divide them to their
adequate elements by specifying an appropriate threshold
value interactively. But the keyboard cannot be divided
correctly. One reason for this is that a keyboard has
many keys and each key is too small and located too
closely to others. Execution times for the segmentation
process are all long because the number of polygons of
each model is large. As for the shape matching process,
the D2 method works enough for the replacement of an
original element after the segmentation with one of the
already prepared typical shaped components. Execution
times for the shape matching process are all short enough.
Finally, as for the functionality assignment process, of
course, the interactive functionality assignment causes
satisfactory results. However, the random assignment is
not enough. Furthermore, as explained in Section 5, the
analogy of functionality to be assigned to each

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

component by the information of its position, shape, size,
parent-child relationship and composition pattern etc.
would be useful so that currently we have been
implementing such an approach.

[5] Alan P Mangan and Ross T.Whitaker, Partitioning
3D Surface Meshes Using Watershed Segmentation,
IEEE Trans. on Visualization and Computer
Graphics, 5(4), 308-321, 1999.

7. Concluding remarks

[6] Robert Osada, Thomas Funkhouser, Bernard
Chazelle, and David Dobkin, Shape Distributions,
ACM Trans. on graphics, 21(4), 807-832,2002.

In this paper, we proposed an automatic construction
method of 3D composite objects from range data of
artifacts existing in the real world. We implemented a
3D object construction system based on this method.
This would reduce drastically the time consumed to
develop 3D graphics applications using a componentbased development system such as IntelligentBox. The
system decomposes a unified surface model obtained
from range data of a certain artifact to several elements
by segmenting it.
This segmentation process is
performed based on the watershed method. Next the
system automatically replaces each element with its
similar shaped model, which is already prepared as a
functional component of IntelligentBox through the
shape matching process. Finally the system composes
from these models one functional composite component
that looks like the original artifact. In this way, the user
obtains functional composite 3D objects from range data
of artifacts existing in the real world.
Through some experiments, we showed the
usefulness of our proposed system. However, our
system has some problems that should be solved. We
will improve the system to solve such problems. And
also, we have to experiment using more and more
artifacts to clarify other problems and to improve the
system. These are our future works.

[7] Mizoguchi, T., Date, H., Kanai, S., and Kishinami,
T., Feature Edge Extraction from Mesh Model based
on Wide Range Normal Evaluation and Modified
Watershed Method, (8th Joint Conference on
Information Sciences, pp.1610-1613, 2005.)

References
[1] Okada,Y.
and
Tanaka,Y.,
IntelligentBox:A
Constructive Visual Software Development System
for Interactive 3D Graphic Applications, Proc. of
Computer Animation ’'95, IEEE CS Press, pp. 114125, 1995.
[2] Okada, Y. and Tanaka, Y., Collaborative
Environments of lIntelligetnBox for Distributed 3D
Graphics Applications, The Visual Computer (CGS
special issue), Vol. 14, No. 4, pp. 140-152, 1998.
[3] Akazawa, Y., Okada, Y., and Niijima, K. :
AUTOMATIC 3D SCENE GENERATION BASED
ON CONTACT CONSTRAINTS, Proc. of the
Eighth International Conference on Computer
Graphics and Artificial Intelligence (3IA’2005), pp.
51-62, Limoges, France, May, 2005.
[4] Angel Domingo Sappa, Surface Model Generation
from Range Images of Industrial Environments, 2nd
International Symposium on 3D Data Processing,
Visualization and Transmission (3DPVT 2004),
IEEE CS Press, pp. 868-871, 2004.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006


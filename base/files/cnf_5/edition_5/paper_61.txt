GPU Based Real-time Shadow Research in Large Ship-handling Simulator
Yang Xiao, Jin Yicheng
(Navigation Science & Technology Institute, Dalian Maritime University, China)
(yangxiao8080@sohu.com, jycdmu@dlmu.edu.cn )
HT

TH

Abstract: Shadow can strengthen the reality of 3D

how to navigate, avoid collision, go in or off port, go

virtual scene and provide important visual information

alongside or off levee. In the train of gong in or off port

for the objects’ spacial relationship in the scene. This

and going alongside or off levee, the shadow of levee,

paper presents a GPU based method for all the process of

facilitations on levee and the ship can help officers to

shadow volume algorithm. It can achieve greater shadow

gain accurate station information and provides important

performance in Ship-handling simulator than previous

evidence for the ship handling.

methods by migrating the silhouette extraction and

But it is very complicate to draw shadow in the

shadow volume rending to GPU, and applying a series of

way of real time in computer, especially for the

techniques for culling, clipping, and simplifying shadow

ship-handling simulator. Because of the wide visual

volume geometry. We make a series of optimization for

range and complicate scene, it is very difficult to realize

the visual system of the ship-handling simulator such as

the shadow drawing of the whole scene. This paper

limit the range of illumination, the alternation of z-pass

makes a series of optimization for the ship handling

and z-fail algorithm, using the ultra shadow technology

simulator on the basis of shadow generation algorithm,

and two sided stencil buffer to accelerate the rending of

Shadow Mapping and Shadow Volume, and puts forth

shadow.

optimal algorithm and affirms all visual channels satisfy

Keywords: virtual environment; shadow; GPU method;

the request of refreshing velocity.

ultra-shadow; stencil buffer

1 Introduction
It’s very common in real world that the shadow

2 Visual
Simulator

System

of

Ship-handling

2.1 Light Source in Visual System

will appear as long as an object is in front of the light

Shadow depends on light. The light source in the

source. Importing shadows in the 3D virtual scene plays

simulator visual system includes the sun light, the moon

an important role in strengthening the reality of 3D

light, the deck light, the searchlight and the light from

virtual scene. Several simple shadows can give people

the building on share. We use light beam at infinity to

realer feeling than complicate models and colorful

simulate the sun light, and the position of this light beam

textures.

changes with time. The realization of the moon light is

The large ship-handling simulator researched by
Dalian maritime university is a 3D visual system with

similar as the sun light, except the lower lightness.
2.2 Graphic System Disposition in Visual System

seven channels and a horizon angle of 270 degrees. The

Current graphic system can be divided into two big

3D visual system includes water surface, land, island,

classes basically. One is high-end graphic workstation

humanity landscape (bridge, dock, and buildings),

that combines the calculation capacity of super computer

objective ship, auxiliary navigation equipment, light

with the powerful graphic technology, such as Ongx of

house, the ship’s structure and so on. It’s a simulation

SGI, which is very expensive. The other graphic system

system of training modem ship officers and can train

is windows 2000 PC with high performance graphic

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

acceleration card. Such as all kinds of different

3.1.3 Advantages and Disadvantages

performance graphic acceleration card or graphic

Advantage: Depth Map rending is only involved in

subsystem produced by NVIDIA, ATI or SiS. The visual

the position of light source and the object in the

system

+

scene .No matter how the viewpoint moves, as long as

high-performance graphic card, the graphic card has

the position relationship of light source and object

selected Geforce6800 of NVIDIA Company for use.

uncharged, shadow map can be reused. So shadow

2.3 The Scene Driver of the Visual System

mapping is suitable for the static light source.

of

the

simulator

adapts

the

PC

The scene driver of the simulator is written with the
high-layer

real-time

scene

management

software

OpenGVS. OpenGVS offers the high-layer scene

Disadvantage:
(1) Unable to meet the need of the dynamic light
source

management API for users and at the same time offers

(2) Fail to solve the problem of view in shadow

the support of such primitives as point, line plane etc.

3.2 Shadow volume algorithm

The developers import the 3Dgeometry model that has
been already built up in other standard modeling tools

Shadowing object

(such as MultiGen, 3D Studio /Max) with the object
Light source

importing tools that is offered by the system. The scene
tool, light source tool, fog tool, camera tool, channel tool

shadow volume

and frame buffer tool etc that is offered by the system
create the scene and control the movement of the objects
in the scene. The shadow algorithm of this paper is
Object A

written through bottom functions that OpenGVS offers.

Figure 1: shadow volume

3 Analysis of Shadow Algorithm

3.2 Shadow volume algorithm
3.1Shadow Mapping Algorithm

Shadow volume algorithm is proposed for the first

3.1.1 principle: Because there is shadowing object

time in the thesis “SHADOW ALGORITHMS FOR

between light source and shadowed object , the

COMPUTER GRAPHICS”, which was written by

shadowed object will exist in the shadow[T. Lokovic. et

Franklin C. Crow in 1977. Its basic principle is to

al. 2000]

calculate the shadow volume in the scene according to

3.1.2 Algorithm:

the position relation of light source and shadowing

Step1: Rending the whole scene under the light

object, then gauge all objects to confirm whether it will

source coordinate system, the purpose is to get the depth

be affected by the shadow. As shown in the figure 1, the

map (shadow map) of all objects relative to light source.

gray area is shadow volume, object A in the gray area

Because we are only interested in the depth value of

will be influenced by shadow [Franklin C. Crow al.

pixel, so we can close all illumination calculating and

1977].

open the rending states of z-test and z-unite.

3.2.1 Z-pass Algorithm:

Step2: Recuperate the viewpoint to the original

Step1: enable z-buffer write, rend the whole scene,

normal position, rending the whole scene, calculate the

and get depth map of all objects. Notice the difference

distance of each pixel and light source, then compare the

inside depth map and shadow mapping here is that depth

value with the corresponding value in depth map to

map inside shadow volume regards true viewpoint as the

confirm whether the pixel exists in the shadow. we can

viewpoint, but depth map is shadow mapping regards

get the shadow effective by calculating different

light source as the viewpoint.

illumination calculate to shadowed fragment and lighted
fragment according to the result compared.

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

Step2: Disable z-buffer write, enable stencil buffer
write, and rend all shadow volume. To the front face, if

the result of depth test is pass, the corresponding stencil
value added. If the result of depth test is fail, stencil
value doesn’t change. To the back face of shadow

Shadowing object

Light source

volume, if the result of depth test is fail, stencil value is
reduced, otherwise keeps intact.
Step3: After the second step fulfill, decide whether
each pixel is in the shadow according to its stencil value,
draw shadow effect in view of the above.
As shown in figure 2, the sight from viewpoint to

Viewpoint

object A enters into the shadow volume twice and come
out once, then stencil value is +1+1-1=1,so the object is

A

in shadow volume, and the shadow appears. Z-pass
algorithm refers to the circumstance that the viewpoint

Figure 3: z-fail algorithm

outside the shadow volume. Z-pass algorithm works well
under this situation, otherwise, it will invalid at once. In
order to solve the problem, z-fail algorithm is
introduced.

twice, so the stencil volume is +1+1-1=1,so the
object is in shadow volume. The shadow appears.
Because z-fail algorithm confirms the stencil buffer

Light source

Shadowing

value depending on calculating the part of z-test that

object

shadow volume can’t pass. So require the shadow
volume is closed. Comparing with z-pass algorithm, the
z-fail algorithm is slower.

Viewpoint

4 Implementation on GPU
4.1 GPU Based Programming
A

Figure 2: z-pass algorithm
3.2.2 Z-fail Algorithm
Step 1: enable z-write /z-test, rend the whole scene,
and get depth map.
Step 2: Disable z-write, enable z-test /stencil-write.
Draw shadow volume, To its back face, if the result of
Z-test is fail, stencil value added, if the result of Z-test is
pass, stencil value unchanged. To front face, if the result
of z-test is fail, stencil value reduced. If the result is pass,
stencil value unchanged.
Step 3: After finishing the second step, judge
whether each pixel is in the shadow according to its
stencil value, then draw shadow effect in view of the
above.
As figure 3 shows, the sight from viewpoint to
object A enters shadow volume once and comes out

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

Figure 4: GPU programming model
Modern programmable graphics accelerators such
as the ATI X800XT and the NVIDIA GeForce 6800
feature

programmable

vertex

and

fragment

assembly-level shader program consisting of 4-way
SIMD instructions [Lindholm et al. 2001]. These
instructions include standard math operations, such as 3or 4-component dot products, texture-fetch instructions,

and a few specialpurpose instructions. The basic
execution model of a GPU is shown in figure 4.For

source (dot3>0) or not (dot<0) by the calculated
result.

every vertex or fragment to be processed, the GPU

zTo the triangles faced to light source, push all

places a graphics primitive in the read-only input

three borders to a stack, and compare with the

registers. The shader is then executed and the results
written to the output registers. During execution, the
shader has access to a number of temporary registers as

border in stack. Delete repeated borders.
zAfter having visited all triangles, the borders left
in the stack is the silhouette edge.

well as constants set by the host application. It can be

zCast these silhouette edges through vertex shader

written using a variety of high-level, C-like languages

to get the shadow volume according to light

such as Cg, HLSL, and GLslang. However, even with

source direction.

these languages, applications must still execute explicit

4.3 Rendering Silhouettes

graphics API calls to organize data into streams and

For a closed manifold (mesh without boundary

invoke kernels. For example, stream management is

edges), the silhouette between the rendered mesh and the

performed by the programmer, requiring data to be

background is a subset of the contour edges [Morgan et

manually packed into textures, transferred to and from

al. 2004]. The silhouette cannot be geometrically

the hardware. Kernel invocation requires the loading and

distinguished on the vertex processor. We therefore use

binding of shader programs and the rendering of

the traditional approach: render a write mask to the

geometry.

stencil and suppress the internal contour edges that are

As a result, computation is not expressed as a set of

not on the silhouette with a per-pixel test against that

kernels acting upon streams, but rather as a sequence of

mask. To avoid the expense of clearing the stencil buffer

shading operations on graphics primitives. Even for

between each mesh, we extend the stencil buffer method

those proficient in graphics programming, expressing

with an incrementing test value as follows.

algorithms in this way can be an arduous task. These
languages also fail to virtualize constraints of the

Before rendering the frame, initialize a variable S
to 0 and clear the stencil buffer to 255. For each model:

underlying hardware. For example, stream elements are

1. Set S := (S + 1) mod 255

limited to natively-supported float, float2, float3, and

2. If S == 0 then clear stencil buffer to 255

float4 types, rather than allowing more complex userde

3. Render the model, setting stencil to S wherever

defined structures. In addition, programmers must

the depth test passes

always be aware of hardware limitations such as shader

4. Set the stencil test to pass where stencil == S

instruction count, number of shader outputs, and texture

5. Render contour edges

sizes. There has been some work in shading languages to

For a scene with many objects, this reduces the

alleviate some of these constraints. In general, code

number of times the stencil buffer must be cleared by a

written today to perform computation on GPUs is

factor of 254. The thin contours are rendered as

developed in a highly graphics-centric environment,

previously described; thick boundary strokes on the

posing difficulties for those attempting to map other

silhouette were then added in a separate rendering pass

applications onto graphics hardware.

with this method.

4.2 Silhouette Detection
We get shadow volumes by casting the silhouette

5 Optimized Algorithm

edge to some distance. The principle to detect silhouette
edge is finding these borders in triangles with different

5.1 Optimization 1: the Alternative Use of Z-pass and

direction.

Z-fail Algorithm

zVisit all triangles in the mesh.

Z-pass algorithm is faster than Z-fail algorithm in

zCalculate dot3 (light_direction, triangle_normal),

speed by preceding analysis, so we can use Z-pass

and detect whether this triangle is faced to light

algorithm to improve performance under the properly

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

occasion.

of the shadow area that needs calculating.

Light source

depth bounds

Shadowing object
z min

zmax

viewpoint
Viewpoint
B

B

Figure 5: test method
The main reason that z-pass algorithm is invalid is

A1

A

that the viewpoint enters shadow volume. Such as figure

Figure 6: 'HSWKERXQGVWHVW

5, make a line between viewpoint and light source, if this
line crosses shadowing object, we can affirm the

The function that depth bounds test is to compare z

viewpoint is in shadow volume, then switch to Z-fail

value of depth buffer designated by the screen coordinate

algorithm.

(xw, yw) of present fragment with [zmin,zmax]

The ship navigate on the sea surface under most

designated

by

users

through

glDepthBounds

situations in the simulator, and there are few chances to

NV(Glclampcl zmin, Glclampd zmax). If z value is

enter the shadow area, so we can improve the speed of

outside the range, the present fragment from the will be

rending effectively by this method.

deleted from the pipeline, and it will not carry on stencil

5.2 Optimization 2:Restrict the Range of Illumination

buffer operation here. We should pay more attention to

What we are interested in is the part above sea level

the z value. Notice what compared here is not the Z

in the simulator, that is to say we only consider the

value of fragment(shadows volume),but the Z value of

shadow above sea level. We can utilize scissor test to the

shadow receiver drawn already in the former path. As is

range drawn on the above sea level, because there is no

shown in figure 6.

shadow after going beyond the range. We needn’t go to

It can be seen that although point B is shadowed,

draw shadow volume of that part naturally. The so-called

still the z value of point B is outside the range [Zmin,

scissor test is to define a rectangle in the coordinate

Zmax]. So the fragment of point B can be deleted. But Z

system of the screen artificially. The fragment can pass

value of point A is inside the range [Zminx, Zmax] , so

the test only when its coordinate is within the range of

the fragment of point A must carry on the stencil buffer

the rectangle, and its content can be written into the

operation.

frame buffer.

5.3.2 Realize Ultra Shadow through OpenGL

5.3 Optimization 3: Use Ultra Shadow Technology to

OpenGL realizes the support of ultra shadow

Accelerate the Rending of the Shadow

through depth_bound_text. It adds a new per-fragment

5.3.1 Ultra Shadow Technology

test between scissor test and the alpha test.

Ultra shadow technology begins to be applied in

OpenGL setup the value of depth bounds through

NV35 of NVIDIA. Ultra shadow allows define an area in

the function of Depth Bounds. Notice this value should

the scene, which is used for restricting the calculation

be set in the range [0,1]. Functions GlEnable

from light source to the shadow of the object in a

(DEPTH_BOUNDS_TEST)

specific range (depth band, depth range). So this

(DEPTH_BOUNDS_TEST) are used to switch on and

technology can accelerate the calculating speed of

switch off the shadow acceleration.

shadow and save packing rate and hand width. After

5.4 Optimization 4 Use Two Sided Stencil Buffer to

NV40, ultra shadow 2 issues, which reduces the quantity

Accelerate the Rending of Shadow

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

and

glDisable

We will use stencil buffer when drawing shadow

There are many avenues for future work, we would

volume. The usual operation is to draw shadow volume

Like to further improve the performance and use our

to stencil buffer at twice, at first draw clockwise polygon,

method for other applications, including real time ocean

then draw counter-clockwise polygon.

wave, collision detection etc.

Double stencil Buffer can draw clockwise and

References

counter-clockwise polygon at the same time. So it can

[1]. T. Lokovic, E. Veach. Deep Shadow Maps. Pixar.

reduce the operation times and accelerate the speed of

Acm Siggraph, Addison-Wesley, August 2000.

shadow rending. When using double stencil Buffer, we

[2]. Franklin C. Crow ĀSHADOW ALGORITHMS

can setup clockwise and counter-clockwise polygonal

FOR COMPUTER GRAPHICS ā International

stencil test operation to realize different disposition of

Conference on Computer Graphics and Interactive

clockwise polygon and counter-clockwise polygon
rending process at the same time as using two sided

Techniques 1977
[3]. Harlen Costa Batagelo and Ilaim Costa Junior,
“Real-Time Shadow Generation Using BSP Trees

stencil buffer.

and Stencil Buffers,” XII Brazilian Symposium on

6 Results

Computer

Figure 7 shows part shadow performance of the
trestle dock in ship-handling simulator generated using

Graphics

and

Image

Processing,

Campinas, Brazil, Oct. 1999, pp. 93-102.
[4]. Michael

Mc

Cool,

“Shadow

Volume

our GPU based method. We obtain frame rates about 35

Reconstruction

fps, it satisfies with the STCW pact 24 fps demand. The

Transactions on Graphics, Jan. 2001, pp. 1-25.2002.

results were rendered on P4 2.4GHz machine equipped
with 512M RAM, and NVDIA GeForce FX 6800 card.

from

Depth

Maps,”

ACM

SIGGRAPH2002
[5]. Morgan McGuire, Mark J. Kilgard “Fast, Practical
and Robust Shadows” SIGGRAPH 2003. 2000.9.
[6]. Ashu Rege “Shadow Considerations “ NVIDIA
Developer Technology Group
[7]. Lindholm, E., Kligard, M. J., and Moreton, H.
2001.A user-programmable vertex engine. In
Proceedings of SIGGRAPH 2001, ACM
Press/Addison-Wesley Publishing Co., 149-158.
[8]. Morgan McGuire and John F. Hughes
Hardware-Determined Feature Edges 2004 Brown

Figure 7: part shadow performance of the
trestle dock in ship-handling simulator

7 Conclusions and Future Work
This paper has shown a new method for rendering
shadow by moving edge feature determination from the
CPU to the GPU. We make a further analysis of
traditional shadow generation algorithm and make a
series of optimization for the scene system in the
ship-handling simulator. We take many measures to
accelerate the rending of shadow, such as the alternation
of z-pass algorithm and z-fail algorithm, the limitation of
the illumination range, ultra shadow technology and
double stencil buffer etc.

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

University


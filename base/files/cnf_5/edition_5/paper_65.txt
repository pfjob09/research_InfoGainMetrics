Incremental Voxel Colouring by Ray Traversal
O. Batchelor, R. Mukundan, R. Green
University of Canterbury, Dept. Computer Science& Software Engineering.
owb13@student.canterbury.ac.nz, {Mukundan, Richard.Green}@canterbury.ac.nz
Abstract
Image based reconstruction from multiple views is an
interesting challenge. Recently methods of optimisation
based voxel colouring have appeared, which make use of
incremental visibility updates.
We present an alternative incremental voxel colouring
algorithm in the mould of GVC-LDI [2] which directly associates each visible voxel with the set of rays in it‚Äôs visible
projection, using ray-voxel traversal as a mechanism for
updates.
We make some time comparisons using calibrated photographs and synthetic images, as well looking at optimisation based voxel colouring and level of detail. Results
show that our method compares favourably to GVC-LDI.
Keywords‚Äî Voxel Colouring, Ray Tracing, Reconstruction, Computer Vision

1

Introduction

We introduce a derivative method of using ray traversal for determining visibility incrementally. Like Voxel
Colouring [6], Space Carving [4] and GVC-LDI [2], the
algorithm works on reconstructing a volumetric scene using colour consistency primarily.
Unlike earlier works, we have looked at using ray
traversal as the primary method of updating visibility. Our
algorithm works on an arbitrary collection of rays rather
than a set of images. Though we convert calibrated images
to a set of rays for input. Our primary reasons for looking
into ray traversal are the potential of optimisation colour
consistency and beneÔ¨Åts associated with incremental visibility ‚Äì fast convergence and Ô¨Çexible carving order.
Due to the nature of the problem we refer to rays and
pixels interchangeably, where a ray can be generated from
the inverse projection (of the calibrated image‚Äôs projection
matrix).

2

Background

Voxel Colouring [6] and derivatives are methods for reconstructing a scene from a set of calibrated images. A
scene is represented by voxels, which are deÔ¨Åned to be a

unit of volume, in our case a cube. The primary characteristics of voxel colouring are it‚Äôs explicit handling of visibility and it‚Äôs local decision function for opaqueness, colour
consistency.
Space carving [4] introduced the idea of conservative
carving and deÔ¨Åned the photo hull. This entails progressively carving from an estimate of the true scene, while
using the estimate as an approximation for visibility. The
space carving algorithm performs reconstruction with arbitrary view conÔ¨Ågurations by using a plane sweep method
where a mask is used in each image to mark occlusion.

2.1

Generalised Voxel Colouring

Generalised Voxel Colouring [2] built on this idea, extending it to support full use of all scene views symmetrically, with arbitrary view placement. The key data structure used by GVC is an item buffer which stores the closest
visible voxel for every pixel in an image (shown in 1).
The second (GVC-LDI) uses layered depth images of
surface voxels as item buffers, as the voxel model is updated the layered depth images are updated incrementally.
A LDI consists of surface voxel intersections, shown in Ô¨Ågure 1).
The basic GVC algorithm performs updates in parallel across surface (SVL) voxels, and suffers from recalculation as the algorithm becomes close to converging,
where as GVC-LDI is a serial process.

2.2

Reprojection error

A useful measure for evaluating the results of reconstructions, as well as a measure of colour consistency is the
reprojection error. Where the output image of voxels are
reprojected and the difference taken with input images on a
pixel by pixel basis. A common distance used is the square
of differences per component, equation 1, where C1Œ± correspond to a colour component, Œ± = {r, g, b} for a RGB
image.
(C1Œ± ‚àí C2Œ± )2

dist(C1, C2) =

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 ¬© 2006

Œ±=1

(1)

2.3

Colour consistency

A colour consistency function is a binary function to determine if a voxel is opaque. It‚Äôs purpose is to determine
if it is possible for rays emitted from a scene point to form
the colours which exist in the input images. For a scene
of purely diffuse reÔ¨Çectors, this amounts to ensuring the
colours of the scene point are approximately equal.
One consistancy function is testing the reprojection error of a voxel (equation 2) against a threshold. proj(V) is
the set of pixels in the projection of a voxel (to all images),
vis(V) is a subset of proj(V) where each pixel is visible.
Cp is the colour of pixel P, and Cv is the colour of voxel V.
dist(Cp , Cv )

error(V ) =

(2)

P ‚ààvis(V )

Another simple function involves a threshold on (mean)
differences between groups (where groups are the set of
pixels projected to each image). We have used this simple
test extensively for purposes of comparison, it is shown in
equation 3. rays(V, i) is a subset of vis(V) for rays from image i, nrays refers to the number of rays. Ci and Cv are the
mean colour of rays(V, i), and the mean colour of vis(V).
between(V ) =

2.4

i=1

dist(Ci , Cv ) ‚àó rays(V, i)
i=1 nrays(V, i)

(3)

Voxel colouring as optimisation

Optimisation based colour consistency involves minimising some global function (such as the global reprojection error). Two approaches are minimising reprojection error [7], and maximising probability with a statistical
model [3]. Both methods use GVC-LDI to evaluate visibility.
Carving a voxel V changes the colour of a set of voxels, the Changed Visibility Set CVS(V). The pixels/rays
for which the reprojection error may change is the union
of vis(U) for each voxel U in CVS(V), we term this the
Changed Visibility Ray Set CVRS(V) shown in 4.
vis(U )

CV RS(V ) =
U ‚ààCV S(V )

Figure 1: An item buffer, and a LDI

(4)

A binary colour consistancy function can be found by
assuming the pixels in projections of each voxel are independent, deÔ¨Åned as comparing the total sum of reprojection errors in CVSR(V) before and after carving. Equation
6 describes such a function for reprojection error.
distSq(Cv , Cp )

reproj(V ) =

(5)

P ‚ààCV RS(V )

consist(V ) = reproj(V ) ‚â§ carved(reproj(V ))

(6)

One of the problems with this approach is that it contains many local minima. Far from the global minimum
reprojection error is rather noisy, on it‚Äôs own no reasonable
output is produced. Slabaugh et al. [7] treat optimisation
as a post process from an existing voxel colouring algorithm, as well as looking at simulated annealing with an
adding/removing process.

2.5

Voxel traversal

Voxel traversal on a regular grid consists of line drawing. The voxel traversal algorithm of Amanatides and Woo
[1] computes exactly the intersections of all voxels along
the path of a ray which is precisely the information required for our purposes. It is particularly efÔ¨Åcient, it involves just 2 Ô¨Çoating point comparisons, one addition and
an integer comparison.
We use ray traversal to Ô¨Ånd the next solid voxel along a
ray, this is shown in Ô¨Ågure 2, where voxels [A, B, C, D, E,
F, G] are traversed and the algorithm stops at voxel H.

3

Approach

The common factor required for colour consistency
tests is vis(V). Generalised Voxel Colouring [2] uses rasterization to determine proj(V) and vis(V) contains each
element proj(V) equal to it‚Äôs corresponding entry in an item
buffer.
Instead of looking to efÔ¨Åciently evaluate vis(V), we
look at an approach where vis(V) is updated incrementally

Figure 2: Ray traversal.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 ¬© 2006

      
)$+%# "'








)*$# "%#'


















! "
,
   



#$#%%&'
(
$#%%&'
(


$#%%&'





Figure 3: The major data structures and their connections.
for all visible voxels (we call this the Visible Voxel list
(VVL)), as a result when a voxel is to be evaluated Vis(V)
is available immediately to pass to a colour consistency
function. The VVL is a subset of the SVL from [2], as
there may be surface voxels which are not visible.

3.1

Initialisation

Initialisation is performed by accumulating all generated onto the initial voxel volume. In practice this occurs
by generating one ray image at a time, pairing it with an
input image and extracting each ray one by one then accumulating it to the VVL hashtable. This is done image
by image so that only a small part of the dataset need be
in memory twice at any one time. Afterwards the images
needn‚Äôt remain in memory as the information (colour, image number etc.) has been stored with each ray.

3.2

Carving process

Voxel ray traversal is used to update the VVL structure. Each ray stored (each member of vis(V)) also stores
ray stepping information. When a voxel is carved, rays in
Vis(V) are accumulated to other voxels which are or will
become members of the VVL, the particular voxels is the
CVS(V), the set of voxels found by ray traversal for rays
from vis(V).
A queue is used to maintain the voxels which require
evaluation, only those which change visibility during a
carving operation require re-evaluation. This is the same
role as Changed Visible Surface Voxel List from GVC-LDI
[2]. The data structures used are outlined in Ô¨Ågure 3.
The VVL is implemented as a hashtable mapping Voxel
IDs to a structure containing vis(V). We use the term bucket
for this structure, as it behaves as water poured into a
bucket, when the voxel is carved the water is tipped out
and ‚Äùfalls‚Äù into other buckets. The bucket may also be

used to update useful statistics, for example current reprojection error of a voxel.

3.3

Algorithm

At the top level, the process involves iterating the following steps:
1. Remove a voxel from the carving queue (CVSVL)
2. Evaluating the visibility change of carving voxel
3. Evaluate colour consistency
4. If inconsistent then make visibility changes from (2)
5. Add changed visibility voxels to the carver queue
The algorithm given makes the update process more explicit. A set of ‚Äùcandidates‚Äù are generated at each iteration
which are voxels which change visibility given the carving
of the voxel in question. The structure used for Candidates(U) is the same ‚Äùbucket‚Äù structure of that used in the
VVL(V).
When candidates are committed to the main VVL, their
priority is also updated in the carving queue - we use a heap
which is doubly linked into the VVL hashtable, when priorities are updated elements in the heap are moved about
and links are updated.
initialise Solid
Generate rays from input images
For each ray R {
Find first solid voxel V
Accumulate R to VVL(V)
}
Set CVSVL to voxels in VVL
while(CVSVL is not empty) {
remove voxel V from head of CVSVL
lookup vis(V) from VVL
for ray R in Vis(V) {

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 ¬© 2006

Teapot test set
7e+10

Bucket carver, most visible first
Bucket carver, semi-random order
GVC table carver
GVC
Ray Image
GVC-LDI

Reprojection error

6e+10
5e+10
4e+10
3e+10
2e+10
1e+10
0
0

10

20

30

40
50
60
Time (seconds)

70

80

90

Figure 4: Reprojection vs. time for several algorithms

step ray R
U = next Solid voxel on ray R
if not null(U)
add R to Candidates(U)
}

for each Voxel U in Candidates {
Accumulate rays in
Candidates(U) to VVL(U)
Update priority of U in CVSVL
}
}
}

Consistency Inputs

Different colour consistency functions require different
input parameters, of the two classes (threshold based, optimisation based) threshold based functions (equations 3,
2) require primarily vis(V) as inputs. Optimisation based
colour consistency (equations 4, 5), requires the changed
visibility (voxel) set CVS(V), and changed visibility ray
set CVRS(V) (equation 4).
For a threshold based colour consistency function, the
generation of candidates and evaluation of colour consistency may be swapped without changing the result (to
improve efÔ¨Åciency).

4

Athlon 2600+, with 768MB of RAM and a Geforce FX
5200 graphics card.

4.1

if(not Consist(vis(V), Candidates) {
carve V from Solid
remove V from VVL

3.4

Figure 5: Reconstructed teapot scene.

Comparisons

We perform three comparisons. We evaluate time and
space complexity between various voxel colouring algorithms and our buckets algorithm with the teapot dataset
using threshold colour consistency. We then evaluate it‚Äôs
use for level of detail and for optimisation colour consistency. We make use of three datasets, ‚ÄùTeapot‚Äù a set
of rasterized images, calibrated photo sets of Cactus and
Gargoyle, courtesy of Pr. Kyros Kutulakos (University of
Toronto). We use one system throughout comparisons, an

Threshold colour consistency

We have compared our algorithm to several others (at a
common level) using threshold colour consistency test using equation 3. We compare time vs. reprojection error,
as well as runtime statistics of memory use. The implementations we compare are our implementations of GVC,
GVC-LDI, an version of optimised GVC using OpenGL
for rasterization (GVC table), and earlier work using ray
traversal with item buffers (Ray‚Äìimage). We endeavoured
to use optimised versions of each algorithm, most sharing
signiÔ¨Åcant common code for rasterization and volume representation.
The Ô¨Årst test set consists of a teapot scene with 15
800 √ó 600 generated images (by rasterization). The reconstructed resolution of the teapot scene was at 1203 .
All six methods successfully reconstruct the teapot to
a similar quality shown in Ô¨Ågure 5, there are minor differences due to carving order. In addition vis(V) differs
slightly between rasterization, OpenGL rasterization and
ray traversal. Figure 4 shows that the GVC table method
faster than the others (though converges slowly), followed
closely by the Bucket method, GVC and GVC-LDI significantly slower.
To show the differences resulting from ordering we have
shown two carving orders for the Bucket carver, the reason for the hashtable ordering (Also used by GVC-LDI and
Ray‚Äìimage) being faster is simply that it creates more surface noise and uses less rays per voxel.
Of the two classes of algorithm, it can be seen that incremental methods {GVC-LDI, Ray‚Äìimage, Bucket} carve at
a nearly constant rate, but GVC based methods trail off
rapidly towards convergence. All algorithms have a total

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 ¬© 2006

Figure 6: Original.

Figure 7: Threshold.

Figure 8: Reprojection error.

running time approximately on the order of voxels √ó rays
per voxel. For each voxel, calculating vis(V), stepping
rays and evaluating colour consistency are all O(n) for the
number or rays.
Method
Memory use (MB)
Images alone
54.5
GVC table
70.7
GVC
87.6
Bucket
225.0
Ray‚Äìimage
311.8
GVC-LDI
538.3
Memory use was signiÔ¨Åcantly higher for incremental
methods. Memory use for the Buckets method is dominated by an order of the number of rays, which diminishes
as carving proceeds. GVC-LDI has a problem where memory use is not entirely deterministic throughout the process.
A surface with more noise creates more surface intersections which increases the list size per pixel. This could be
resolved by using a priority queue for ordering.

4.2

Optimisation colour consistency

We looked at application of the bucket method to optimisation voxel colouring as [7, 3]. We have looked only
at a carving method as opposed to [7] which involved a
process both adding and removing voxels. Adding voxels
would complicate the bucket algorithm because it would
involve removing rays from existing buckets, as well as
forcing a mapping from images back to rays. This is one
area where GVC-LDI is more Ô¨Çexible.
We have tested both implementations on the cactus test
set, a set of calibrated photos of a complex cactus plant
with very Ô¨Åne needles in places. We Ô¨Årst ran a thresholding carver over the data set to reduce time taken, though
using level of detail is also equally useful for this purpose.
We used a combination of threshold and optimisation to
reduce local minima which seem to be the main problem
with this type of consistency function.
Method
Time (s) Reduced reproj.
Reprojection error
82.0
39.7%
Probabilistic
221.7
28.1%
Both reduced reprojection error without destroying the
integrity of the model as happens by directly reducing the

Figure 9: Probabilistic.

threshold. Noisy voxels are not greatly reduced, in fact
they both seem to make a considerably noiser surface - as
there are no surface constraints. Results of each are shown
in Ô¨Ågures (8, 9). Both take considerably longer than threshold consistency functions, but show a small improvement
in reconstruction quality.

4.3

Level of detail

We have looked at the applicability of using level of detail to reduce the large reconstruction period at high resolutions, for both GVC and the bucket method. We have
used the method Ô¨Årst shown by Proc and Dyer in [5]. It begins with a low resolution voxel volume and repeats steps
outlined below.
1. Carve voxels.
2. Augment voxel model.
3. Double resolution (along each axis)
We anticipated that the bucket method may be particularly suited to this technique because it is fast when convergence is close. We ran a comparison between GVC
with LOD, the bucket method with LOD, and the bucket
method without LOD as a control. Resolution began at
303 and increased in resolution 4 times to reach 2403 . A
sequence of the intermediate reconstructions at each resolution is shown in Ô¨Ågure 12, the original image from the
same view 11, and a graph of reprojection error 10.
Results show that the technique worked better with
GVC, the bucket method proved somewhat slower because
of the extremely slow re-initialisation period involving raytracing the intermediate voxel model. This could be solved
by using additional spacial acceleration structures. Clearly
LOD pays off for both methods however, as they are much
faster than the control. The only disadvantage is a possible
loss of Ô¨Åne detail, however this also helps reduce noise.

Conclusions
Using ray traversal for updating global scene visibility
for a voxel carving process seems to compare favourably
with GVC-LDI greatly in time and space use. It also compares well with GVC, however the use of hardware rasterization is clearly beneÔ¨Åcial resulting in faster running times

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 ¬© 2006

Level of detail, gargoyle data set

Reprojection error

1e+11

Bucket carver, with LOD
GVC table carver, with LOD
Bucket carver

1e+10

1e+09
0

10

20

30
40
Time (seconds)

50

60

Figure 10: Reprojection vs. time for LOD sequence

Figure 11: Input image of gargoyle data set.

Figure 12: Level of detail sequence 303 to 2403 .
with GVC, in future perhaps a similar ray traversal algorithm can be accelerated using parallel graphics hardware.
In terms of Ô¨Çexibility it is tricker to implement a scheme
allowing adding of voxels than GVC-LDI, however it has
been shown that optimisation based colour consistency are
feasible with the buckets method. It‚Äôs use with level of detail is hampered by a slow initialisation period, though this
could be solved by using spacial acceleration structures for
initialisation.

Acknowledgements
We would like to thank Pr. Kyros Kutulakos for making
the ‚ÄùGargoyle‚Äù and ‚ÄùCactus‚Äù datasets available for comparisons.

References
[1] John Amanatides and Andrew Woo. A fast voxel
traversal algorithm for ray tracing. In Eurographics
‚Äô87, pages 3‚Äì10. Elsevier Science Publishers, Amsterdam, North-Holland, 1987.
[2] W. B. Culbertson and T. Malzbender. Generalized
voxel coloring. In Proceedings of the ICCV Work-

shop, volume Vision Algorithms Theory and Practice,
September 1999.
[3] Ho-Won Kim and In So Kweon. Optimal photo hull
recovery for the image-based modeling. In The 6th
Asian Conference on Computer Vision (ACCV), Jeju,
Korea, January 2004.
[4] K. N. Kutulakos and S. M. Seitz. What do n photographs tell us about 3d shape?, January 1998. Computer Science Dept. U. Rochester.
[5] Andrew C. Prock and Charles R. Dyer. Towards realtime voxel coloring. In Proc. Image Understanding
Workshop, pages 315‚Äì321, 1998.
[6] Steven M. Seitz and Charles R. Dyer. Photorealistic
scene reconstruction by voxel coloring. In CVPR ‚Äô97:
Proceedings of the 1997 Conference on Computer Vision and Pattern Recognition (CVPR ‚Äô97), page 1067.
IEEE Computer Society, 1997.
[7] G. Slabaugh, B. Culbertson, T. Malzbender, and
R. Schafer. Improved voxel coloring via volumetric
optimization, 2000.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 ¬© 2006


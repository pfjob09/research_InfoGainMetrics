Traversal on DAG-based Multiresolution Mesh Hierarchy
Zhi Zheng
School of Computer Engineering
Nanyang Technological University, Singapore
zenat@pmail.ntu.edu.sg

Abstract
Traversal algorithm on the multiresolution hierarchy is
critical for the view-dependent level of detail system. In
this paper, we study multiresolution hierarchy traversal for
a DAG hierarchy of vertex-split/edge-collapse operations,
in the context of a client-server based system. We present a
general traversal management strategy that is beneﬁcial for
interactive frame rate and triangle-budget control, and is
also favorable for the client-server based system. We adapt
two commonly used traversal algorithms, linear traversal
and priority-oriented traversal, to work under the management strategy. And we also propose a constant-time traversal algorithm. Extensive experiments on these three traversal algorithms are done and the comparison results can be
used as a guide to choose the most appropriate traversal
algorithm for different system requirements.

1

Introduction

Level of Detail (LOD) is an important technique for
real-time rendering of complex geometric models. Viewdependent LOD [13] has been studied in many research
works to select the most appropriate level of detail according to the current view parameters so as to optimize the distribution of the triangles over the selectively reﬁned mesh
for better ﬁdelity. The core structure of view-dependent
LOD is the multiresolution hierarchy, where splitting a
node means performing a reﬁnement operation on the selectively reﬁned mesh and collapsing the node means performing the reverse simpliﬁcation operation on the selectively reﬁned mesh. The set of boundary nodes between
the split nodes and the collapsed nodes form the front [9],
which corresponds to the current selectively reﬁned mesh
and also is the set of the candidate nodes for further reﬁnement/simpliﬁcation operations. The view-dependent reﬁnement/simpliﬁcation is achieved by moving the front up and
down throughout the multiresolution hierarchy.
Multiresolution hierarchy traversal is the process of vis-

Tony K.Y. Chan
School of Computer Engineering
Nanyang Technological University, Singapore
askychan@ntu.edu.sg

iting the dynamic set of front nodes and selecting the appropriate reﬁnement/simpliﬁcation operations from them according to the current view and certain evaluation criteria
to update the selectively reﬁned mesh before each frame is
rendered. The traversal algorithm is critical to the viewdependent rendering system, as it affects both the frame
time and the view-dependent rendering result.
In this paper, we study the traversal on a Directed
Acyclic Graph (DAG) hierarchy of vertex-splits/edgecollapses [8], which is similar to the implicit MultiTriangulation (MT) [3] structure, but is built from a Progressive Mesh (PM) [8] presentation. We focus on the
traversal problems faced by the interactive client-server
based view-dependent rendering, where the server stores
the multiresolution hierarchy and performs the traversal,
and the client maintains and renders the selectively reﬁned
mesh. In such system, the server can not easily get the information of the selectively reﬁned mesh during the hierarchy traversal, and not only the ﬁdelity constraint and the
triangle budget should be considered but also the service
time. We propose a general traversal management strategy
to address the problems. Instead of making the server consult the client for the information of the selectively reﬁned
mesh during the traversal, we let the client decide certain
control parameters according to its selectively reﬁned mesh
and send them to the server to control the traversal.
This traversal management strategy also offers ﬂexibility of choosing different traversal algorithms as needed.
We present a comprehensive analysis and comparison of
three different traversal algorithms that can be used under
the traversal management strategy. Two of them, the linear
traversal and the priority-oriented traversal, have been used
in previous works, and we adapt them to our traversal management strategy. We also propose a third traversal algorithm, the constant-time traversal that can provide the minimum and constant traversal time. Extensive experiments
are carried out to compare the performances of the three algorithms in terms of the traversal time and the accuracy of
the view-dependent reﬁnement/simpliﬁcation.
The rest of the paper is organized as follows. Section

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

2 reviews the related works. Section 3 brieﬂy reviews the
DAG hierarchy of vertex-splits/edge-collapses. Section 4
presents the traversal constraints and the traversal management strategy. In Section 5 we compare the three different
traversal algorithms and Section 6 discusses the results of
the comparative experiments. Section 7 concludes the paper.

A

B

D

Fc
Fs

G

C

2

E

0

Related work

View-dependent level of detail has been well studied in
the previous research works. Also some research works
explored view-dependent rendering in networked environment [16, 6, 2, 4, 11]. A majority of the previous viewdependent LOD schemes use vertex trees as the multiresolution hierarchy, including the generalized framework of
vertex hierarchies by Luebke and Erikson [12], the merge
tree by Xia et al. [18], the view-dependent progressive
mesh by Hoppe [9], the view-dependence tree by El-Sana
et al. [5, 4], and the truly selective reﬁnement scheme by
Kim and Lee [10, 11]. The FastMesh [14, 15] introduced
by Pajarola and DeCoro is, instead of vertex trees, a binary
hierarchy of half-edge collapses.
The DAG structure has also been proposed as the multiresolution hierarchy. The MT representation demonstrated
by De Floriani et al. [3, 2] was a DAG of mesh updates
for general geometric replacement operators. Gueziec et
al. [7, 6] presented a DAG representation where each node
represents an edge-collapse and vertex-split pair. In this paper, we also use a similar DAG of vertex-split/edge-collapse
operations.
The traversal algorithms used in the above viewdependent LOD schemes can be summarized as two types.
One is the linear traversal, used in [9, 18, 15], which traverses the front nodes sequentially as in an FIFO queue.
The other is priority-oriented traversal, proposed in [12, 7,
2], which ﬁrst puts all the front nodes into a priority queue
according to certain evaluation criteria and then selects the
split or collapse operations in the prioritized order. Although these two algorithms have already been used in practice, their performances have never been compared under
the constraints of ﬁdelity, triangle-budget and the amount
of mesh changes.

3

Brief review of the DAG hierarchy

We presented the algorithm to build a DAG hierarchy of
vertex-splits/edge-collapses from a PM [8] presentation in
our earlier work [19]. Here we brieﬂy review the basic elements for this DAG hierarchy. Each node of the DAG hierarchy is a vertex-split operation or its reverse edge-collapse
operation, depending on whether the node is to be split or

B

1

F

0

I

D

0

0

Fc
H

2

A

2

1

1

I

2

(a)

E

0

H

0

1

F

0

0

Fs
J

C

2

1

G

2

1

J

2

(b)

split node

cut

collapsed node

Fc and Fs

Figure 1. An example of maintenance of the
front Fc and the front Fs . The counters are
labelled beside the nodes. (a)Before node G
is split. (b)After node G is split.

collapsed. The edges deﬁne the dependencies among the
nodes. A node is legal to be split only when it is in collapsed status and all its parents are split. A node is legal to
be collapsed only when it is in split status and all its children are collapsed. At any point of the run-time traversal,
the split nodes and the collapsed nodes are separated by a
cut into two continuous sub-graphs. The leaf nodes of the
sub-graph above the cut form the front of the split nodes Fc ,
and the root nodes of the sub-graph below the cut form the
front of the collapsed nodes Fs . Fs is traversed to select
vertex-splits and Fc is traversed to select edge-collapses.
The fronts are dynamically maintained during the traversal by keeping a counter with each node of the DAG. The
counter indicates the number of dependencies that have to
be released before this node becomes legal to be split or
collapsed. In other words, the counter for a split node is the
number of its split children and the counter for a collapsed
node is the number of its collapsed parents. The legal front
nodes are identiﬁed by their counters being zero. Figure 1
shows an example of the fronts before and after splitting a
node.
Compared to the vertex trees hierarchy, the DAG hierarchy of vertex-splits/edge-collapses has several favorable characteristics. First, unlike the vertex trees, which
rely on the condition of the current selectively reﬁned
mesh to check the dependencies of the split/collapse operations [18, 9] during the traversal, the DAG hierarchy can
encode all the dependencies among the nodes [1], which
makes the hierarchy traversal independent of the selectively
reﬁned mesh. This feature is especially desirable for the

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

client-server based view-dependent LOD system, where the
multiresolution hierarchy and the selectively reﬁned mesh
are stored separately on the server and the client.
Second, the DAG hierarchy has a much smaller number of front nodes than the vertex trees. In the vertex trees,
the front nodes include all the vertices of the current selectively reﬁned mesh, which is about half the number of the
triangles. While in the DAG hierarchy, the front nodes are
composed of only the nodes that are legal to be split or collapsed, and the size is only about 1/4 to 1/3 the number of
the triangles of the selectively reﬁned mesh (shown in Section 6).
The third, unlike the vertex trees that use one front for
both split operations and collapse operations, the DAG hierarchy has two separate fronts, Fc for simpliﬁcation traversal
to generate collapse operations and Fs for reﬁnement traversal to generate split operations. This feature provides the
ﬂexibility to control the reﬁnement traversal and the simpliﬁcation traversal individually.

4

Traversal constraints and control

In the literature of view-dependent LOD, multiresolution hierarchy traversal is performed under either the ﬁdelity
constraint or the triangle-budget constraint. Under the ﬁdelity constraint, all nodes with view-dependent ﬁdelity errors larger than the constraint should be split [9, 18]. Under the triangle-budget constraint, the goal is to keep a constant number of triangles and the traversal stops when further reﬁnement operations would exceed the triangle budget [12, 17]. However, sometimes we need to consider both
the ﬁdelity constraint and the triangle-budget constraint.
More speciﬁcally, if given a ﬁdelity constraint, the selectively reﬁned mesh is smaller than the triangle budget, we
do not need to perform further unnecessary reﬁnement operations to reach the triangle budget. On the other hand, we
can not exceed the triangle budget even if the given ﬁdelity
constraint can not be satisﬁed within the triangle budget.
Besides the ﬁdelity constraint and the triangle-budget
constraint, we ﬁnd that the constraint on the amount of
mesh changes is also very important. The amount of mesh
changes corresponding to the view changes can vary greatly
from frame to frame, leading to high variability in frame
time, since the traversal time, the mesh updating time and
the network transmission time for a client-server system are
closely correlated to the amount of changes per frame. So
the large amount of mesh changes for one frame should be
amortized over several consecutive frames for frame-rate
regulation. Also the predictable and controllable amount of
mesh changes for each frame is a useful feature for trianglebudget control. An efﬁcient way of controlling the amount
of mesh changes per frame is to specify the maximum number of mesh update operations and stop the traversal when

the maximum number of vertex-splits or edge-collapses
have been generated.
In Figure 2 we construct a generic traversal management
strategy that considers the ﬁdelity constraint deﬁned by
the view parameters vp, the triangle-budget constraint controlled by the traversal mode mode and the mesh-change
constraint deﬁned by the maximum number of mesh updates N . A presumption here is that all the mesh update
operations are manifold, which means that all vertex-splits
add two new triangles to the mesh and all edge-collapses
delete two triangles from the mesh.
M ANAGE - TRAVERSAL(vp, mode, N )
1: num collapsed ← T RAVERSE - COLLAPSE(vp, N )
2: if mode = BUDGET- MODE then
3:
T RAVERSE - SPLIT(vp, num collapsed)
4: else if mode = FREE - MODE then
5:
T RAVERSE - SPLIT(vp, N )
6: end if
Figure 2. Management of the DAG hierarchy
traversal.
First, function T RAVERSE - COLLAPSE traverses the front
Fc to select edge-collapses. Then T RAVERSE - SPLIT traverses Fs for vertex-splits. Both functions are controlled
by the ﬁdelity constraint and the mesh-change constraint.
The triangle-budget control is required if the traversal mode
mode is BUDGET- MODE, and it can be achieved by setting
the mesh-change constraint for T RAVERSE - SPLIT to the
number of actual edge-collapses (num collapsed in line 1)
generated by T RAVERSE - COLLAPSE, because the number
of triangles deleted by the edge-collapses determines the
amount of room to accommodate the new triangles introduced by the the vertex-splits.
This method is especially useful for the client-server
based system, where the hierarchy traversal on the server
can not access the information of the selectively reﬁned
mesh on the client. It gives the client the capability to control the traversal on the server. The arguments N and mode
for the process M ANAGE - TRAVERSAL are set by the client
according to the current condition of its selectively reﬁned
mesh and sent to the server with the view parameters vp
to instruct the server to perform the controlled traversal.
The FREE - MODE is used when there is no budget control
or the size of the selectively reﬁned mesh is below the triangle budget, and the BUDGET- MODE is used if the size of
the selectively reﬁned mesh is likely to exceed the triangle
budget. The client knows when to set the traversal mode
to BUDGET- MODE since the maximum number of possible
new triangles is predicable to the client due to the meshchange constraint. In this manner, the traversal on the server
can comply with the triangle-budget of the client without

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

knowing the detailed information of the selectively reﬁned
mesh.
Even if not all the vertex-splits or edge-collapses are
manifold operations, which means that the same number of
edge-collapses and vertex-splits do not necessarily delete
and add equal number of triangles, we can still use a similar method as in Figure 2 for triangle-budget control. Just
change the constraint on the number of mesh updates to the
constraint directly on the number of triangles to be deleted
or added by the selected mesh updates. Thus, the triangles that can be added by function T RAVERSE - SPLIT will
be restricted by the number of triangles that are deleted in
T RAVERSE - COLLAPSE.
Functions T RAVERSE - COLLAPSE and T RAVERSE can be implemented in different traversal algorithms,
which are discussed in the next section.
SPLIT

P RIORITY- ORIENTED - TRAVERSAL(vp, N )
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:

5

for all front node node do
E RROR - EVALUATE(node, vp)
QP RIO .insert(node)
end for
num ← 0
while QP RIO is not empty and num < N do
node ← QP RIO .pop()
if N EED - APPLY(node) then
num ← num + 1
A PPLY- OP(node)
new f ront nodes ← A DJUST- FRONTS(node)
E RROR - EVALUATE(new f ront nodes, vp)
QP RIO .insert(new f ront nodes)
else
break
end if
end while

Comparison of three traversal algorithms
Figure 3. Priority-oriented traversal algorithm.

Conventionally, the linear traversal is used in ﬁdelitybased view-dependent LOD [18, 9, 5] and the budget-based
view-dependent LOD depends on the priority-oriented
traversal [12, 2, 17]. The traversal management strategy
in Figure 2 provides an alternative way for triangle-budget
control with the ﬂexibility of using different traversal algorithms. In this section, we ﬁrst adapt the linear traversal and
the priority-oriented traversal to work under the traversal
management strategy, and then we propose a third traversal algorithm with the motivation of providing small and
constant traversal cost for the time-critical rendering. All
three algorithms perform with the ﬁdelity constraint and the
mesh-change constraint, deﬁned by the view parameters vp
and the maximum number of mesh updates N .
The traversal algorithms detailed in the following subsections are applicable to both the simpliﬁcation traversal and the reﬁnement traversal, or function T RAVERSE COLLAPSE and T RAVERSE - SPLIT in Section 4. The same
function notations are used in the following subsections.
Function E RROR - EVALUATE is a combined representation
for ﬁdelity evaluation of various error criteria, which can
include out-of-view, back-facing, screen-space error, etc.
Function N EED - APPLY determines if the node needs to be
split or collapsed by comparing the evaluated error of the
node and the error threshold of the ﬁdelity constraint. Function A PPLY- OP performs the application-dependent action
on the selected node. It might be applying the vertex-split
or edge-collapse to the selectively reﬁned mesh, or packing
the operation for network transmission. Function A DJUSTFRONTS maintains the two fronts on the DAG hierarchy after each node is split or collapsed, as described in Section 3.

5.1

Priority-oriented traversal

In the priority-oriented traversal, all the front nodes have
to be ﬁrst evaluated by E RROR - EVALUATE and inserted into
a priority queue sorted by their evaluated errors. The priorities of Fc are in increasing order so that the node with the
smallest estimated error can be collapsed ﬁrst. And the priorities of Fs are in decreasing order so that the node with
the largest estimated error can be split ﬁrst. The traversal
of the priority queue stops when the speciﬁed number of
mesh updates are generated or the ﬁrst node that does not
need to be split or collapsed according to the ﬁdelity constraint is met. The new front nodes introduced during the
traversal also need to be evaluated and inserted into the priority queue. The priority-oriented traversal is summarized
in Figure 3.
This algorithm can produce good view-dependent reﬁnement/simpliﬁcation results, because the N vertex-splits and
edge-collapses applied to the mesh are the most appropriate
selected from all the front nodes. However, due to the cost
for all the front nodes to go through E RROR - EVALUATE and
the cost for rebuilding and maintaining the priority queue,
the priority-oriented traversal is rather expensive. The time
complexity for this algorithm is O(n), where n is the number of front nodes.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

5.2

Linear traversal

The linear traversal algorithm keeps the fronts Fc and Fs
as two FIFO queues. The front nodes are evaluated for collapse or split in the FIFO order. The traversal continues until the speciﬁed number of split or collapse operations have
been generated or no further split or collapse operations are
possible according to the current view parameters and the
ﬁdelity constraint. The new front nodes introduced during
the traversal are appended to the end of the queue. The statuses of the FIFO queues are retainable from one frame to
the next, therefore the traversal for the next frame can continue traversing the front from where the last traversal left,
so that all the front nodes have the opportunity to be visited.
The linear traversal algorithm is detailed in Figure 4.
L INEAR - TRAVERSAL(vp, N )
1: num ← 0
2: while QF IF O is not empty and num < N do
3:
node ← QF IF O .pop()
4:
E RROR - EVALUATE(node, vp)
5:
if N EED - APPLY(node) then
6:
num ← num + 1
7:
A PPLY- OP(node)
8:
new f ront nodes ← A DJUST- FRONTS(node)
9:
QF IF O .push back(new f ront nodes)
10:
end if
11:
if no split or collapse in current front then
12:
break
13:
end if
14: end while
Figure 4. Linear traversal algorithm.
Since the time for E RROR - EVALUATE dominates the
while loop, the worst time complexity of the linear traversal
is also O(n), where n is the number of front nodes. If all
the front nodes have been traversed and none of them can
be split or collapsed according to the ﬁdelity constraint, the
traversal can stop since no further split or collapse operations are possible for the current view parameters. This is
checked in line 11 of Figure 4.

5.3

Constant-time traversal

Like the linear traversal, the constant-time traversal algorithm also keeps the front Fc and Fs as two FIFO queues,
and the statuses of the queues are retainable from one traversal to the next. However, instead of measuring the number of mesh updates generated, constant-time traversal is
controlled by the number of nodes visited. The goal is to
achieve an almost constant traversal time by controlling the
times the function E RROR - EVALUATE is performed. Figure 5 shows the constant-time traversal algorithm.

C ONSTANT- TIME - TRAVERSAL(vp, N )
1: num ← 0
2: while QF IF O is not empty and num < N do
3:
node ← QF IF O .pop()
4:
num ← num + 1
5:
E RROR - EVALUATE(node, vp)
6:
if N EED - APPLY(node) then
7:
A PPLY- OP(node)
8:
new f ront nodes ← A DJUST- FRONTS(node)
9:
QF IF O .push back(new f ront nodes)
10:
end if
11: end while
Figure 5. Constant-time traversal algorithm.
In this algorithm, the parameter N is used differently
from that of the other two algorithms. It restricts the number
of front nodes to be traversed and evaluated in one traversal.
Each node that goes through E RROR - EVALUATE is counted
in line 4, no matter whether this node will be selected to
apply or not. Hence the time complexity for constant-time
traversal is O(N ).

6

Experimental results

To compare the traversal times and view-dependent rendering results, we carry out extensive experiments for these
three traversal algorithms on various models, including the
Bunny(69451 triangles), the Hand(654666 triangles), the
Dragon(871414 triangles) and the Happy Buddha(1087716
triangles). We get consistent experimental results from all
the models, so here we only show the results from the Buddha model as an example. The experiment platform is implemented as a client-server based view-dependent rendering system, where the server that performs the hierarchy
traversal is a Pentium4 3.6GHz PC, and the client that maintains and renders the the selectively reﬁned mesh is a Pentium4 1.6GHz PC with an ATI 64MB graphics card.
We test each traversal algorithm on all the models over
two scripted interaction routes. The ﬁrst route has 180
frames, in which the view point is moving close to the
model and scanning the model from the bottom to the top.
The second route has 194 frames, in which the view point
is moving close to the model and rotating around the model
with increasing speed. In this paper, we only report the results from the ﬁrst route, since the experiments on the second route have similar results. All three traversal algorithms
are performed under the constraints and the management
strategy discussed in Section 4. For the ﬁdelity constraint,
the out-of-view simpliﬁcation and the back-facing simpliﬁcation are considered and the screen-space error threshold
is 0.1%. The mesh-change constraint is 300 for all three

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

0.018

0.014

Traversal time (sec)

Linear traversal
Constant−time traversal

95
90
85
80
75
70
65
60
55
50

0

20

40

60

80

100

120

140

160

180

Frames

Figure 7. The accuracies of the linear traversal and the constant-time traversal on the
Buddha model.

Priority−oriented traversal
Linear traversal
Constant−time traversal

0.016

100

Accuracy (%)

traversal algorithms. More speciﬁcally, for the priorityoriented and linear traversals, the maximum numbers of
vertex-splits and edge-collapses per frame are both 300, and
for the constant-time traversal the number of front nodes to
be traversed is 300. Also the triangle budget on the client is
60000.
Figure 6 compares the traversal times of the three traversal algorithms on the Buddha model throughout the interaction route.

0.012

0.01

0.008

0.006

0.004

0.002

0

0

20

40

60

80

100

120

140

160

180

Frames

Figure 6. The traversal times of the three
traversal algorithms on the Buddha model.

Another important aspect of the performance of a traversal algorithms is how precisely the resultant mesh is reﬁned/simpliﬁed to the current view. Since the priorityoriented traversal always selects the most appropriate
vertex-splits and edge-collapses, we assume the selectively
reﬁned mesh from the priority-oriented traversal has all and
only the correct triangles according to current view parameters. We test the accuracies of the linear traversal and the
constant-time traversal by measuring the percentage of the
correct triangles they can achieve in their selectively reﬁned
meshes for every 5 frames. The accuracies of the two algorithms on the Buddha model throughtout the interaction
route are compared in Figure 7.
To visually show the differences of the selectively reﬁned meshes from the three traversal algorithms, Figure 8
compares the rendering results of the three algorithms on
the Buddha model.
Our results show that the priority-oriented traversal can
provide the best view-dependent rendering quality, but the
traversal time is the longest among the three algorithms. In
our experiment settings, it can easily be more than 10ms,
which is rather expensive for a rendering system targeted
at interactive frame rate. Linear traversal has the next best
view-dependent rendering quality. It can achieve about

70% accuracy of the selectively reﬁned mesh compared
with the priority-oriented traversal, but only takes less than
half traversal time. The constant-time traversal can provide very short and almost constant traversal time, with
lesser accuracy of the selectively reﬁned mesh. Compared
to the priority-oriented traversal, the constant-time traversal achieves more than 60% accuracy most of the time,
and its traversal time is only a small fraction of that of the
priority-oriented traversal. Compared to the linear traversal,
the constant-time traversal loses at most 10% accuracy, but
saves more than half of the traversal time.
The constant-time traversal is preferred when the interactivity has a higher priority. The not-so-precise rendering
quality can be compensated by the high interaction speed,
since the human vision system can not resolve much detail
in fast moving object [13]. Also if there are several consecutive frames without much change of the view parameters,
the rendering quality will catch up. The priority-oriented
traversal is best used in the systems where the rendering
quality is more emphasized than the interactivity. And the
linear traversal is a compromised solution.
Another interesting fact we ﬁnd through our experiments
is that for all three traversal algorithms, the size of the
fronts in the DAG hierarchy of vertex-splits/edge-collapses
is always about 1/4 to 1/3 the number of triangles of the
selectively reﬁned mesh. As an example, we show the
sizes of the selectively reﬁned meshes and the sizes of
the fronts in the priority-oriented traversal for the Buddha
model throughout the interaction route in Figure 9. This
feature proves that the DAG hierarchy has a smaller number of front nodes than the vertex trees (Section 3). It also
implies that once the triangle budget for the selectively reﬁned mesh is speciﬁed, the overall traversal time will be
under control even for the priority-oriented traversal and the
linear traversal, since the time complexity of the two traversal algorithms is O(n), where n is the number of the front
nodes.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

(a)

(b)

(c)

Figure 8. Rendering results of the 110th frame in the 180-frame interaction route. (a)Using the
priority-oriented traversal. (b)Using the linear traversal. (c)Using the constant-time traversal.

4

6

x 10

Mesh
Fronts

5

Size

4

3

2

1

0

0

20

40

60

80

100

120

140

160

180

Frames

Figure 9. The size of the front nodes and the
size of the selectively reﬁned mesh throughout the interaction route on the Buddha
model, using the priority-oriented traversal.

7

Conclusions

In this paper, we have studied the problem of traversal on a DAG multiresolution hierarchy for view-dependent
LOD. Three important constraints for the traversal, ﬁdelity
constraint, triangle-budget constraint and the mesh-change
constraint, have been discussed. A general traversal management strategy has been proposed that considers all three
constraints and is especially useful for the client-server
based view-dependent LOD system. We compared three

different traversal algorithms that can be used under this
management strategy. The linear traversal and the priorityoriented traversal are adapted from previous works and
we proposed the constant-time traversal. The advantages
and disadvantages of the three algorithms are demonstrated
through a series of experiments. The comparison results can
be used as a guide to choose the most appropriate traversal
algorithm for different system requirements.
A possible area for future work is a mechanism to automatically and dynamically determine the mesh-change control parameter N at run-time, so as to achieve the best tradeoff between frame rate and ﬁdelity.

References
[1] L. DeFloriani and P. Magillo. Multiresolution mesh representation: Models and data structures. In M.Floater, A.Iske,
and E.Qwak, editors, Multiresolution in Geometric Modelling, pages 363–418. Springer-Verlag, 2002.
[2] L. DeFloriani, P. Magillo, F. Morando, and E. Puppo. Dynamic view-dependent multiresolution on a client-server architecture. Computer-Aided Design, 32(13):905–823, 2000.
[3] L. DeFloriani, P. Magillo, and E. Puppo. Efﬁcient implementation of multi-triangulations. In Proceedings IEEE Visualization’98, pages 43–50, 1998.
[4] J. El-Sana and N. Sokolovsky. View-dependent rendering on
large polygonal models over networks. International Journal of Image and Graphics, 3(2):265–290, 2003.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

[5] J. El-Sana and A. Varshney. Generalized view-dependent
simpliﬁcation. In Proceedings of EUROGRAPHICS’99,
pages 83–94, 1999.
[6] A. Gueziec, G. Taubin, B. Horn, and F. Lazarus. A framework for streaming geometry in VRML. IEEE Computer
Graphics and Applications, 19(2):68–78, 1999.
[7] A. Gueziec, G. Taubin, F. Lazarus, and W. Horn. Simplicial
maps for progressive transmission of polygonal surfaces. In
VRML 98: Third Symposium on the Virtual Reality Modeling Language, pages 25–31, 1998.
[8] H. Hoppe. Progressive meshes. In Proceedings of SIGGRAPH 96, pages 99–198, 1996.
[9] H. Hoppe. View-dependent reﬁnement of progressive
meshes. In Proceedings of SIGGRAPH 97, pages 189–198,
1997.
[10] J. Kim and S. Lee. Truly selective reﬁnement of progressive
meshes. In Proceedings of Graphics Interface 2001, pages
101–110, 2001.
[11] J. Kim, S. Lee, and L. Kobbelt. View-dependent streaming
of progressive meshes. In Proceedings of the Shape Modeling International 2004(SMI’04), pages 209–220, 2004.
[12] D. Luebke and C. Erikson. View-dependent simpliﬁcation
of arbitrary polygonal environments. In Proceedings of SIGGRAPH’97, pages 199–208, 1997.
[13] D. Luebke, M. Reddy, J. Cohen, A. Varshney, B. Watson,
and R. Heubner. Level of Detail for 3D Graphics. Morgan
Kaufmann Publishers, 2002.
[14] R. Pajarola. FastMesh: Efﬁcient view-dependent meshing. In Proceedings of Paciﬁc Graphics 2001, pages 22–30,
2001.
[15] R. Pajarola and C. DeCoro. Efﬁcient implementation of
real-time view-dependent multiresolution meshing. IEEE
Transactions on Visualization and Computer Graphics,
10(3):353–368, May/June 2004.
[16] D. S. To, R. W. Lau, and M. Green. A method for progressive and selective transmission of multi-resolution models. In Proceedings of the ACM symposium on Virtual reality
software and technology, pages 88–95, London, UK, 1999.
[17] N. Williams, D. Luebke, J. Cohen, M. Kelley, and B. Schubert. Perceptually guided simpliﬁcation of lit, textured
meshes. In Proceedings of the 2003 ACM SIGGRAPH Symposium on Interactive 3D Graphics, Monterey, pages 113–
121, 2003.
[18] J. C. Xia, J. El-Sana, and A. Varshney. Adaptive realtime level-of-detail-based rendering for polygonal models.
IEEE Transactions on Visualization and Computer Graphics, 3(2):171–183, June 1997.
[19] Z. Zheng and T. K. Chan. View-dependent progressive mesh
using non-redundant dag hierarchy. In Proceedings of ACM
GRAPHITE 2005, pages 417–420, 2005.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006


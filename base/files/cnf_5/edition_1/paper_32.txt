2011 Eighth International Conference Computer Graphics, Imaging and Visualization

Improving Electrical Power Grid Visualization using Geometry Shaders
Javier Novo Rodr´ıguez, Mariano Cabrero Canosa, Elena Hern´andez Pereira
Department of Computer Science, University of A Coru˜na, Spain
javier.novo@udc.es, mariano.cabrero@udc.es, elena.hernandez@udc.es
Abstract

shaders are used to generate quads from unitary-width lines
entirely on the GPU in the fastest possible way. Two different implementations are presented: one generating the
quads on every draw and other generating them only one
time – when the grid data is loaded into video memory.
Furthermore, adjacency information is used to simplify
multi-lines composed by three or more points and generate different levels of detail. The performance and video
memory requirements of both implementations have been
tested drawing real power grids and compared to the previous graphics engine which used vertex shaders.
This paper is organized as follows: Section 2 introduces the different versions of the Direct3D programmable
graphics pipeline. Section 3 shows how vertex shaders in
Direct3D 9 and geometry shaders in Direct3D 11 can be
used for quad generation. Section 4 studies the potential of
geometry shaders to generate levels of detail. The results
of tests carried over the different quad generation implementations are exposed in Section 5 before presenting the
final conclusions of this work.

The graphics engine of a Power Grids Computer-AidedDesign application was upgraded from Direct3D 9 to Direct3D 11, allowing the use of new features such as the
Geometry Shader and Stream Output stages of the graphics
pipeline to improve the performance of power grids visualization. Geometry shaders have been used to generate two
triangles forming a quadrangle (quad) for each power line,
giving it a width as a function of the power load carried by
the line. Two implementations were tested: one generating
the quads in every draw and other which only generates
them once, saving the results to video memory for subsequent draws. Both have been compared with the previous
implementation which used vertex shaders. The possibility
of using the mentioned pipeline stages to generate levels of
detail for the power grids was also studied.

1 Introduction
The design and planning of power grids requires
Computer-Aided-Design (CAD) applications that allow
electrical engineers to perform different tasks such as visualizing grid topologies or simulating how the grid copes
with different power loads. Several power grids visualization techniques are available. A simple and yet widely used
one for the mentioned tasks, consists on drawing the power
lines on top of a geographical map, giving different widths
to the segments as a function of the power load they carry.
The volume of data involved depends on the type of power
grid being visualized. In the case of the transport networks,
the data volume is low since their topology is simple with
the power lines covering long distances. However, in the
case of distribution grids, the networks are more complex,
with hundreds of thousands or even millions of power lines
covering distances that can comprise a mere few meters in
the case of low voltage networks. In order to offer the engineers a seamless interaction with the visualization in the
application, the rendering of all this information must be
performed as fast as possible.
In a previous work, authors used vertex shaders in a
Power Grids CAD application to speed up grids visualization [1]. In this work, its graphics engine is upgraded to
Direct3D 11, where geometry shaders are available. These
978-0-7695-4484-7/11 $26.00 © 2011 IEEE
DOI 10.1109/CGIV.2011.10

2 Direct3D programmable graphics pipeline
Essentially, a graphics pipeline takes vertex and texture information and processes it, generating a bidimensional image [2]. Prior to Direct3D 8, only a fixed-function
pipeline was available which would not allow the developer to change the operations performed by the pipeline –
only to parametrize them and control the different states of
the pipeline. In Direct3D 8, vertex and pixel shaders could
be programmed using an assembly-language level, allowing the developer to program the operations performed
both per-vertex and per-pixel fragment. Direct3D 9 further enhanced this functionality and introduced the HighLevel Shader Language (HLSL). The assembly language
is not longer supported since version 10. While there is
still a fixed-function pipeline available in Direct3D 9, both
vertex and pixel operations must be always handled by the
developer using shaders since version 10 [3]. Direct3D 10
also introduced geometry shaders and in Direct3D 11 three
new stages are available for tessellation.
Figure 2 shows the different stages and resources involved in the Direct3D 11 graphics pipeline. Shader stages
177

• Geometry Shader: introduced in Direct3D 10, it is
executed for each primitive, receiving the vertices
that compose it as input. Unlike the vertex shaders,
the primitive can be modified, deleting vertices or
generating new ones.

are fully programmable. Resources like textures and constant buffers which are available to all the shaders are omitted for convenience. The existing pipeline stages are:

• Stream Output: saves the primitive data generated
by the geometry shader to video memory. This optional stage can either be the last one or work along
the rasterizer. The data is written to a vertex buffer
that can either be passed to the input assembler or
read-back by the CPU.
• Rasterizer: among other operations, this fixedfunction stage interpolates the vertices to produce
fragments covering the whole primitive – process
known as fragment generation.
• Pixel Shader: executed for every single fragment
produced by the rasterizer, generates per-pixel data
such as color.
• Output Merger: performs traditional depth and stencil tests over the fragments outputted by pixel shader
and combines the results with the contents of the render target to generate the final result. Since version
10, up to 8 simultaneous render targets can be used.

Figure 1: Direct3D pipeline up to version 11.
• Input Assembler: sets up the input primitives using
the data located in the vertex and index buffers. Vertex buffers are read in parallel or sequentially, depending on whenever an index buffer is being used
or not. Since Direct3D 10.1, up to 32 input buffers
can be used. In addition to traditional point, line and
triangle primitives, Direct3D 10 added line and triangle primitives with adjacency data which comprise
3 vertices plus 3 adjacent vertices for triangles and
2 vertices with 2 adjacent vertices for lines. These
extra vertices correspond to the adjacent lines or triangles of the primitive and are only visible to the
geometry shaders – the vertex shaders are only executed over the vertices forming primitives.

3 Using the GPU for quad generation
Our goal is to visualize the power lines that compose
power grids as wide lines whose width is a function of the
carried power load. These wide lines can be formed by two
adjacent triangles which form a parallelogram also known
as a quadrangle or quad. The quad generation process consists on taking two points forming a line plus the desired
width as input, and generating as output two adjacent triangles with the given width and the length defined by input
line. The original line equals to the bisector line of the two
opposite segments that give the width to the quad. The
width is passed as a part of the vertex information along
the coordinates of the point and its color. Therefore, a different width can be specified for each point of the original
line and thus, not only rectangles but also rhomboids can
be generated.
The previous version of the graphics engine used vertex
shaders in Direct3D 9 to perform the quad generation. For
each line, the four vertices that will compose the quad must
be declared, one pair having the position of the beginning
point of the line and the other pair having the position of
the end point. The vertex shader will change their positions
so that each one of the vertices correspond to one corner of
the quad. The corner coordinates are calculated obtaining
the normalized vector for the line, calculating its normals
and adding the desired width for the quad in their directions

• Vertex Shader: executed for every vertex passed
to the input assembler. Substitutes the traditional
transform and lighting operations of fixed-function
pipelines. It always receives a single input vertex
and produces a single output vertex.
• Hull Shader, Tessellator and Domain Shader: introduced in Direct3D 11, these three stages allow
to perform computations over low-resolution models and then subdivide the high-ordered surfaces into
points, lines or triangles. As a result, different levels
of detail can be generated for a mesh while minimizing memory, bandwidth and computational costs.

178

to each one of the vertex coordinates [4]. Each vertex must
hold not only the coordinates of its corresponding point of
the line but also the coordinates of the other point as well
as the desired width for the quad and color information. As
a result, the vertex shader will be executed four times per
line and all the coordinates will be duplicated in the vertex
buffer.
Introduced in Direct3D 10, geometry shaders operate
over primitives as a whole – either points, lines or triangles
– and can modify the input primitive or generate new primitives, even of a different type. Receiving the two vertices
composing a line as input, the geometry shader outputs the
four vertices composing two adjacent triangles that form
the quad. The computations are exactly the same described
in the previous paragraph, but now they are performed only
once per line instead of four times. Furthermore, the coordinates of the opposite point of the line no longer need to be
stored among the vertex information – eliminating the information duplicity – and only two vertex – instead of four
– need to be declared per line, saving not only video memory but also GPU processing time since the vertex shader
will be invoked half as many times.
The output of a geometry shader can be passed to the
next stage of the pipeline – the rasterizer – and/or stored in
a buffer in video memory using the Stream Output stage.
Using the latter capability, the quads can be generated from
the lines just once and then be stored in a vertex buffer that
will be used as the input for the renderings. Hence, all
the processing does not need to be repeated every time the
quads are rendered.
Two different versions of the quad generation geometry
shader have been implemented: one which generates the
quads from the lines on every draw – per-draw generation
– and other that after generating the quads the first time
saves them to video memory, allowing to use them as input
in subsequent draws – one-time quad generation.

This imposes quite a limitation on what can be done when
streaming to several buffers. Given the one element per
write limitation, it is more likely to split one buffer holding
different kinds of data into specialized buffers holding only
one kind of data – for instance, vertex coordinates may be
written to one output buffer and the color data to another.
Initially, the Stream Output capabilities to generate one
level of detail per output buffer entirely in the GPU was
considered. Altogether with the original vertex buffer, this
would yield a total of five different levels of detail stored in
video memory. In order to do so, we would need to write
the same data structures used in the vertex buffer to the
output buffers which is not possible due to the explained
limitation. Furthermore, we would need to be able to skip
write operations to certain buffers based on the level of detail criteria. While we could overcome the single-output
element limitation using buffers containing only vertex position data, it is not possible to work around the limitation
of always having to write to all the buffers. As a result, a
multi-pass simplification approach must be used.
A basic form of detail simplification consists on programming the geometry shader to discard those lines
whose length is too small to be perceived in the visualization. This can be extended to multi-lines with the use
of adjacency information. Using lines with adjacency data
as primitives, the geometry shader will not only receive the
line to be processed but also its two adjacent lines – i.e. it
receives four vertices instead of just two. This can be used
to perform multi-line simplification before generating the
quads, discarding segments whose length is too small to be
perceptible in the final render. It must be noted that the
geometry shader behaves different when using adjacency
information with line lists than with line strips. In the latter case, two extra vertices are required for the whole line
strip – one adjacent to the first and the other one to the
last vertex – and the geometry shader is invoked for all the
overlapping consecutive groups of 4 vertices in the strip –
i.e. for a strip formed by 4 vertices plus the two adjacent
ones, it is invoked 4 times. On the other hand, when using
line lists, the geometry shader is invoked just once per line,
receiving as input the two vertices that compose it plus two
vertices for its two adjacent lines.
The fact that the geometry shader receives four vertices
as input can be used to simplify multi-lines composed by
two or three segments – i.e. three or four points. In this
work, we split the multi-lines into as many smaller ones
formed by four points as possible by setting the indices
properly in the index buffer. When only three points are
available, the middle point is duplicated so that the geometry shader receives four vertices. Only an index is wasted
on this duplicity, not a vertex.
Upon invocation, the geometry shader discards those

4 Levels of detail with geometry shaders
Using the Stream Output, it is possible to write to a
maximum of four buffers simultaneously. However, there
are two important limitations in Direct3D 11. On the one
hand, every time data is streamed-out, all the buffers defined as output get written. This means that all the output
buffers will have the same number of elements. On the
other hand, only one element formed by a maximum of
four floats or integers can be written to each output buffer
per write operation. The structure of the data being output
to the stream-out buffers is declared in the geometry shader
signature. Therefore, even though the size of the element
being written can vary from one output buffer to another
– between 4, 8, 12 or 16 bytes –, it is fixed since the geometry shader declaration and can not change dynamically.

179

vertices which are only part of segments smaller than a
certain threshold. If the sum of the three segments of
the multi-line is smaller than that threshold all the vertices are discarded and the geometry shader outputs nothing for those four vertices. It must be noted that for the
case when only three points were available, the duplicated
middle point gets automatically discarded because of these
conditions. One example of a threshold would be the meters per pixel relation between the power grid area being
visualized and the amount of pixels available to show it on
the screen. Any segment with a length smaller than that,
could be discarded since it would not be perceptible in the
visualization.
Since several vertex buffers can be passed to the input
assembler as the source from where to read when drawing,
there is no need to duplicate the data in the different buffers
holding the levels of detail. Instead, the buffers can store
the data incrementally, using data contained in the lesser
detailed buffers and adding increasingly detailed one on
top of it.
Analysis of the medium voltage datasets presented in
the following section, revealed that the average percentage
of branches composed by either 3 or 4 nodes is 16.52%,
suggesting that the power grid visualization could benefit
from performing this kind of multi-line simplification in
the geometry shader.

which are composed by branches – analogous to multilines – formed by nodes and lines linking those nodes.
All the datasets correspond to medium-voltage networks
except for Other which corresponds to a low-voltage network.
The performance and video memory requirements of
both per-draw and one-time quad generation implementations are compared with the previous implementation
using Direct3D 9 through the Managed DirectX API.

5.1 Drawing performance
A comparison of the rendering times of the different implementations is presented in this section. The measured
time to draw a single quad was 16 milliseconds using either Direct3D 9 or 11.
Since the Direct3D runtime defers the actual API calls
grouping them for optimization, we create the vertex
buffers, load the vertex data into them and perform a draw
in order to accurately measure the time involved. Table
2 shows the times required for the different datasets using Direct3D 9 (D3D 9) and Direct3D 11. For the latter,
the column D3D 11 SO shows the times when using the
one-time quad generation and D3D 11 shows the times for
the per-draw quad generation. Figure 2(a) shows a graphical comparison of those times. As it can be seen, both
Direct3D 11 implementations perform better than the Direct3D 9 one. As expected, the version using the Stream
Output (SO) stage requires more time since the data must
be written to a vertex buffer in video memory. As the
amount of data to be processed and written increases, the
streaming implementation ends up performing even worse
than the Direct3D 9 version.

5 Results
Tests were performed on a Intel Core2 Q6600 2.4 GHz
CPU machine with 2 GBs of memory, a nVidia GeForce
8500 GT GPU with 512 MBs of DDR2 video memory and
Windows 7. While that GPU is not Direct3D 11 fully compatible hardware, it does support the Direct3D 10 feature
level which suffices this work.

Table 2: Create and first draw times (in milliseconds).
Region
D3D 9 D3D 11 SO
D3D 11

Table 1: Distribution networks datasets.
Region
Branches
Nodes
Lines
Moldova

43,769

160,717

116,948

Nicaragua

95,770

245,135

149,365

Panama

85,319

262,319

177,000

Galicia

91,959

301,118

209,159

Guatemala

142,507

345,645

203,138

Central

147,651

493,121

345,470

1,475,445

2,950,890

1,475,445

Other

Moldova

342.45

151.10

140.30

Nicaragua

339.84

244.85

225.06

Panama

385.09

224.02

228.19

Galicia

407.23

359.44

237.04

Guatemala

482.42

427.15

307.35

Central

641.36

567.77

388.08

2,719.48

3,661.52

2,859.44

Other

Times required to redraw the datasets are shown in
Table 3. Again, both Direct3D 11 per-draw and onetime quad generation implementations were tested. Figure 2(b) shows a graphical comparison of those drawing
times. While both Direct3D 11 implementations clearly
outperform the Direct3D 9 one, surprisingly using stream-

Real data from electrical power lines conforming power
grids were used as datasets, rendering those lines over geographic maps and giving them widths as a function of
the power loads they carry. Table 1 shows these datasets,

180

4000
3500

1800
D3D 9
D3D 11 SO
D3D 11

1600

D3D 9
D3D 11 SO
D3D 11

1400

3000

Milliseconds

Milliseconds

1200
2500
2000

1000
800

1500
600
1000

400

500
0
Moldova

200

Nicaragua

Panama

Galicia

Guatemala

Central

0
Moldova

Other

(a) Create and first draw.

Nicaragua

Panama

Galicia

Guatemala

Central

Other

(b) Subsequent draws.

Figure 2: Rendering time comparison for the different datasets.
ing yielded a worse redraw performance for almost all the
datasets. Generating the quads per-draw takes less time,
suggesting that the time penalty from processing more
vertices is bigger than that from executing the geometry
shader over each line. For instance, for the Guatemala
dataset, this difference accounts for processing 1,218,828
vertices – composing the generated triangles – instead of
just 345,645 – the number of vertices required using an index list – vertex shader invocations plus 203,138 geometry
shader invocations – one per line. On average, the implementation using the Stream Output yielded 3.85 times as
many vertices for the given datasets.

tex buffer where the quads are saved is shown – Streamed
Vertices column. When using the Stream Output, both the
original vertex and index buffers can be freed, only requiring the streamed vertex buffer to stay in video memory.
The results show that when generating the quads perdraw, Direct3D 11 uses a 44% of the video memory required by Direct3D 9. Even while it no longer requires the
original vertex and index buffer after the quad generation,
the implementation using streaming always requires a 60%
more video memory than the Direct3D 9 one and an average of 2.71 times the amount required by the Direct3D 11
implementation not using it.
In order to save the video memory required to store the
index buffers, line strips can be used as the topology for
the primitives instead of indexed line lists. A simple array holding the length of each strip can be stored in main
memory and used to perform a draw call per strip to the
runtime. Experiments have shown that the overhead from
drawing the primitives this way is negligible since the runtime will usually group the individual draw calls into a
single request to the GPU.

Table 3: Average rendering times (in milliseconds).
Region
D3D 9 D3D 11 SO D3D 11
Moldova

148.93

31.31

31.31

Nicaragua

179.20

39.13

46.94

Panama

192.38

46.94

39.13

Galicia

232.42

70.38

46.94

Guatemala

265.14

70.38

54.75

Central

364.75

93.81

62.56

1659.66

281.31

132.88

Other

5.3 Levels of detail generation performance
In order to test the levels of detail generation, the implementation using Stream Output was modified to use two
geometry shaders: a new geometry shader simplifying single lines and the one-time quad generation shader, modified to perform the multi-line simplification. These two
shaders operate over different types of primitives – lines
and lines with adjacency – and as a result, two passes over
the data must be executed per desired level of detail.
Using these geometry shaders to generate one level of
detail holding only those segments having a length equal or
larger than the meters per pixel relation, yielded an average

5.2 Memory consumption
Another important consideration is the video memory
required by the different implementations. Even though
many modern graphics cards include 1 GB of video memory, it should be used sparingly. Table 4, shows the size
of the vertex and index buffers used by each implementation for the different datasets. In the case of the one-time
quad generation implementation, only the size of the ver-

181

Region

Table 4: Video memory consumption (in megabytes).
D3D 9
D3D 11

D3D 11 SO

Vertices

Indices

Total

Vertices

Indices

Total

Streamed Vertices

Moldova

11.23

2.81

14.03

4.50

0.94

5.44

22.45

Nicaragua

14.34

3.58

17.92

6.86

1.19

8.06

28.68

Panama

16.99

4.25

21.24

7.34

1.42

8.76

33.98

Galicia

20.08

5.02

25.01

8.43

1.67

10.10

40.16

Guatemala

19.50

4.88

24.38

9.68

1.63

11.30

39.00

Central

33.17

8.29

41.46

13.81

2.76

16.57

66.33

141.64

35.41

177.05

82.62

11.80

94.43

283.29

Other

12.22% reduction in both the number of lines and memory
usage. Although this reduction produced no significant
improvement of the subsequent draw times because of the
relatively small size of the datasets, the time required for
the quad generation increased almost twofold – 1.91 times
exactly – which gives an idea of the considerable computational costs of performing the level of detail generation
in the geometry shaders.

cessed by a geometry shader. Instead, the adjacency information supplied to the geometry shader allows to simplify those segments of multi-lines too short to be visually
perceptible in the final image. Based on this imperceptibility consideration, several passes of the geometry shader
over the lines can be carried out to generate vertex buffers
holding different degrees of simplification for the multilines. Since the input assembler can read from several vertex buffers in a draw call, the different simplification results
can be combined as needed, effectively resulting in different levels of detail. However, the computational costs are
considerable and must be taken into account.
Current work is focused on improving the simplification
technique, using line strips with adjacency topologies and
taking advantage of the primitive overlapping to simplify
one segment per geometry shader invocation. Another
interesting line of future work is the use of tessellation,
considering the whole power grid as a mesh, in order to
generate the levels of detail.

Conclusions
The graphics engine of a Power Grids CAD application
was upgraded to use geometry shaders in order to visualize
the power lines as quads formed by two triangles generated
from two points and a given width. This quad generation
can be done per-draw or just once and saved into video
memory using the optional Stream Output stage of the Direct3D graphics pipeline – one-time quad generation. Results have shown that except for a small number of lines,
using the latter approach incurs into considerably slower
rendering times than when generating the quads in every
draw. This is due to the large amount of new vertices emitted by the geometry shader that must be processed by the
vertex shader when reusing its output in subsequent draws.
When the quads are generated per-draw, only two vertices
per line must be processed by the vertex shader as opposed
to the six vertices of the two triangles generated by the geometry shader per line. Furthermore, the storage of the
generated vertices increases the video memory needs of the
application substantially. Not only does the one-time generation implementation perform worse than the per-draw
generation one; indeed, as the number of lines grows, it
performs worse than the old Direct3D 9 implementation
too both in terms of speed and memory consumption.
The potential of geometry shaders to generate levels of
detail was also studied. While promising, existing limitations on the how the Stream Output stage can simultaneously write to up to four buffers, made it impossible to
generate different detailed versions of each primitive pro-

References
[1] J. Novo Rodr´ıguez, M. Cabrero Canosa and E.
Hern´andez Pereira. Electrical Distribution Grid Visualization using Programmable GPUs. International
Conference on Electrical Engineering/Electronics
Computer Telecommunications and Information
Technology (ECTI-CON), pp. 1231–1235, IEEE,
2010.
[2] D. Luebke and G. Humphreys. How GPUs Work.
Computer-IEEE Computer Society, vol. 40, pp. 96100, IEEE, 2007.
[3] D. Blythe. The Direct3D 10 System. ACM SIGGRAPH 2006 Papers, pp. 724–734, ACM, 2006.
[4] T. Lorach. Fake Volumetric Lines. NVIDIA Corporation, 2005, unpublished.

182


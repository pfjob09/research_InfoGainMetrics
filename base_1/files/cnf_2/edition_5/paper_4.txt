DOI: 10.1111/j.1467-8659.2010.01829.x

COMPUTER GRAPHICS

forum

Volume 30 (2011), number 1 pp. 61–73

Experimental Feedback on Prog&Play: A Serious Game
for Programming Practice
M. Muratet1 , P. Torguet1 , F. Viallet2 and J.P. Jessel1

1 IRIT/VORTEX, Universit´
e Paul Sabatier, Toulouse, France
{mathieu.muratet, patrice.torguet, jean-pierre.jessel}@irit.fr
2 CREFI-T/DiDiST, Universit´
e Paul Sabatier, Toulouse, France
fabienne.viallet@iut-tlse3.fr

Abstract
This paper presents an experimental feedback on a serious game dedicated to strengthening programming skills.
This serious game, called Prog&Play, is built on an open source real-time strategy game. Its goal is to be compatible
with different students, teachers and institutions. We based its evaluation on an iterative process that allows to
implement the game and carry out experimentations in several contexts. Through this assessment, we define a
framework which has been tested by third parties and we analyse both positive and negative points to improve
the project. Evaluation is indeed beneficial and enables you to establish communication about the implemented
practices.
Keywords: serious game, video game, RTS, programming, Prog&Play
Categories and Subject Descriptors (according to ACM CCS): K.3.2 [Computer and Education]: Computer
and Information Science Education–Computer science education I.3.0 [Computer Graphics]: General—

1. Introduction

U.S. movie market [Num] ($10 billion in 2008). Students currently in universities were born in the video games era. Thus,
those games are as much a part of their culture as TV, movies
or books. We think that the use of video games technologies
in a serious game context to practice programming could be
a solution to attract and retain students in computer science.
Currently, serious games exist in several fields such as education, government, health, defence, industry, civil security
and science. Let us first define a serious game.

In many countries, students are becoming less and less interested in science. In computer science, for example, according to Crenshaw et al. [CCMT08] and Kelleher [Kel06], the
number of students has been shrinking. Moreover, ‘colleges
and universities routinely report that 50% or more of those
students who initially choose computer science study soon
decide to abandon it’ [ACM05, p. 39]. Our university has
been experiencing the same phenomenon with a decrease of
16.6% over the last 4 years in students studying computer
science.

For Zyda [Zyd05], a serious game is ‘a mental contest,
played with a computer in accordance with specific rules,
that uses entertainment to further government or corporate
training, education, health, public policy, and strategic communication objectives’. Serious games use entertainment to
pursue different learning objectives. For example: ‘Darfur
is dying’ [Dar] tries to raise public awareness; ‘Tactical
Language & Culture’ [Tac] aims to teach foreign languages
and cultures; ‘America’s Army’ [Ame] tries to recruit young

To find a solution to this problem, we bet on serious games.
Since the first boom in video games in the 1980s, the gaming
industry has held an important place in the world market.
According to the Entertainment Software Association figures [Ent09], in 2008 the market of U.S. computer and video
games amounted to $11.5 billion. This has overwhelmed the
c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics
Association and Blackwell Publishing Ltd. Published by
Blackwell Publishing, 9600 Garsington Road, Oxford OX4
2DQ, UK and 350 Main Street, Malden, MA 02148, USA.

61

62

M. Muratet et al. / Experimental Feedback on Prog&Play

people for the U.S. Army. Serious games should be created
according to the needs and expectations of different sectors,
and within the available resources (physical and financial)
for their implementation.

1.1. Related work
Learning programming is the basis of computer science training and an important topic in many scientific courses. However, programming fundamentals are hard to learn, especially
for novices. Several approaches exist to motivate students.
For example, Stevenson and Wagner [SW06] analyse assignments from textbooks and historical usage to look for students’ problems and propose a ‘good programming assignment’ in computer science. These exercises could be completed by using block-based graphical languages like Scratch
[MBK*04], StarLogo [KY05] or Alice2 [KCC*02]. Indeed,
these novice-programming environments allow students to
forget syntax and directly experiment with programming.
Another approach uses video games to hook the player
and bring him/her into programming. Two uses have been
experimented: implementing new video games and playing video games. For example, Chen and Cheng [CC07]
asked students to implement in C++, through a collaborative project, a small-to-medium scale interactive computer
game in one semester, using a game framework. Gestwicki
and Sun [GS08] based a case study on EEClone. This game
is an arcade-style computer game implemented in Java: students analyse various design patterns within EEClone, and
from this experiment, learn how to apply design patterns in
their own game software. Leutenegger and Edgington [LE07]
used a ‘Game First’ approach to teach introductory programming. These authors believe that game programming motivates most new students. They have used two-dimensional
game development as a unifying theme.

games are Marvin’s Arena [Mar] using any .NET compatible
language, Gun-Tactyx [Gun] using SMALL and Robot Battle
[Robb] using a specific script language.
Colobot [Col] is the only example we know of a complete video game which mixes interactivity, storytelling and
programming. In this game, the user must colonise a planet
using some robots that s/he is able to program in a specific
object-oriented programming language similar to C++.

1.2. Overview
Our approach consists in reusing existing games as the basis
of a serious game and making it compatible with a maximum of teaching contexts. There are many open source video
game projects available on the Internet. We think that reusing
them offers advantages in playing and robustness. To build
our serious game, we used an open source real-time strategy game. Building an efficient tool for a specific teaching
course is interesting, and it can often be reused in other contexts. Our approach consists in working on a serious game
compatible with different students, teachers and institutions.
This serious game is called Prog&Play and is introduced in
Section 2.
The evaluation of this type of tools in real contexts is a
complex task mainly because of the large number of uncontrollable parameters. An iterative evaluation is proposed
(Section 3) and results are presented in the context of several
experimentations.

2. Prog&Play

Another solution is to let students learn when they play
a game. Wireless Intelligent agent Simulation Environment
(WISE) [CHYH04] combines activities from virtual and
physical versions of the Wumpus World game. It enables
physically distributed agents to play an interactive game
and provides a dynamic learning environment that can enhance a number of computer science courses: it can be used
as a medium to demonstrate techniques in lectures; during
classes, students can carry out practical work that tests, expands, or modifies the simulator. The Wumpus World game
can be played cooperatively or competitively.

We consider Prog&Play as a serious game dedicated to programming practice. Prog&Play is based on an open source
real-time strategy (RTS) game called Kernel Panic [Ker].
Kernel Panic uses computer science metaphors, such as bits
and pointers, as units (i.e. graphical objects which are controlled by the player). It is a simplified RTS with the following features: there is no resource management except for time
and space; all units are free to create; it has a small technology improvement tree with fewer than 10 units; and it uses
low-end vectorial graphics which match the universe. Owing
to these characteristics, differences between two players are
about strategies and tactics used (and not about knowledge
of units features and relative advantages). Thus, the game is
action-oriented while always remaining user friendly.

Robocode [Roba] is a Java programming game, where
the goal is to develop a robot battle tank to fight against
other tanks programmed by other players. It is designed to
help people learn Java programming. The robot battles are
running in real time and on-screen. It is suitable for all kinds
of programmers from beginners (simple robot behaviour can
be written in just a few minutes) to experts (perfecting an
AI—Artificial Intelligence—can take months). Other such

Kernel Panic takes place inside a computer where players command one of the three available factions: ‘Systems’,
‘Hackers’ and ‘Networks’. Each of them offers units, such
as Bits, Bytes and Assemblers for the System side, Virus,
Bugs and Worms for the Hacker side and Ports, Firewalls
and Packets for the Network side. Figure 1 shows the hierarchy of unit development for System factions. The Kernel
(which is the main unit of Systems) can build Bits, Bytes,

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

63

M. Muratet et al. / Experimental Feedback on Prog&Play
Table 1: Specification of the Prog&Play API.

Operators
Open
Refresh
Close
Changeover
Map Size
StartPosition
NumSpecialAreas
SpecialAreaPosition
Resource
NumUnits

Figure 1: Units development hierarchy for system factions.
Pointers and Assemblers. The latter can build Sockets (which
can solely build Bits) and Terminals.
Starting with Kernel Panic, we designed an applicative
programming interface that enables students to interact with
the game through programming (Section 2.1). The functional
architecture of this library is detailed in Section 2.2. Following these technical details, we point out two solutions to map
learning objectives into the game and we detail the one we
used during experimentations in Section 2.3.

GetUnitAt
GetUnitCoalition
GetUnitType
GetUnitPosition
GetUnitHealth
GetUnitMaxHealth
GetUnitGroup
GetUnitNumPending
Commands
GetUnitPending
CommandAt
SetUnitGroup
SetUnitAction

Descriptions
Opens Prog&Play API
Loads the last state of the game
Shuts down and cleans up the Prog&Play
API
Indicates if the game is over or not
Returns the map size
Returns the player starting position on the
map
Returns the number of special areas on the
map
Returns the position of a specific special
area
Returns the level of a specific resource
Returns the number of visible units being a
member of a specific coalition
Returns a specific unit which is a member
of the indicated coalition
Returns the coalition of a specific unit
Returns the type of a specific unit
Returns the position of a specific unit
Returns the health of a specific unit
Returns the maximum health of a specific
unit
Returns the group of a specific unit
Returns the number of pending commands
of a specific unit
Returns a specific pending command
which is associated to the indicated unit
Defines the group of a specific unit
Defines an action for a specific unit

2.1. Applicative programming interface
In RTSes, a player gives orders to his/her units to carry out
operations (i.e. moving, building, and so forth). Typically,
these instructions are given by clicking on a map with the
mouse. We modified the game to allow the player to give these
instructions through a program. Thus, students interact with
the game using the Prog&Play Applicative Programming
Interface (API). This API simplifies programming as much
as possible. It hides the game synchronization complexity and
gives access to a subset of the game data. Table 1 details its
specification. Using this API, programs can load game data
such as unit features (such as number, position and type), map
size, etc. Using these data, the player program can create a
set of commands and send it to the game. When the game
receives these commands, it executes them, modifying the
game state.
The specification detailed in Table 1 uses concepts called
coalition and special areas. Three coalitions are available
to structure units: MY_COALITION representing units controlled by the player, ALLY_COALITION representing units
controlled by allies of the player and ENEMY_COALITION
representing units controlled by enemies of the player. Special areas allow transferring a set of positions through the

API. With Kernel Panic these special areas are used to specify zones where factory building is allowed.
The Prog&Play API is available in different programming
languages: C (Appendix gives a program example), C++,
Java, OCaml, Ada, Scratch and an interpreted language called
‘Compalgo’ (used in a specific course at our university).
Thus, the serious game is adaptable to teaching choices and
is usable in different teaching approaches (imperative, objectoriented, functional and graphical).

2.2. Functional architecture
From a technical point of view, communication between the
student program and the video game is carried out through a
shared memory. Figure 2 shows the functional architecture
of the Prog&Play API which is an interface to manage this
shared memory to simplify communication and synchronisation between student programs and Kernel Panic. Two interfaces are available: the ‘Client’ is used by the player to
code his/her programs and the ‘Supplier’ is integrated into

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

64

M. Muratet et al. / Experimental Feedback on Prog&Play

own AIs to use them in a multiplayer session (the student
motivation is maintained by competition between players).

Figure 2: Functional architecture of the Prog&Play API.

the game engine. On student’s program demand, pertinent
data of the game are copied into the shared memory. To
avoid incoherent situations, the student’s program works on
this copy. The student’s program reads data and writes commands through the ‘Client’ interface. The shared memory
is regularly checked by the game engine to carry out pending commands. With this solution, at any time, the player
can stop his/her program execution, modify it and execute
it again. Thus, the program is able to connect to the shared
memory without disturbing the game simulation.
The ‘Supplier’ is responsible for shared memory management. First, the ‘Supplier’ creates and initializes the shared
memory so that it is available to the ‘Client’. After this initialization, the game enters the simulation loop and for each
iteration consults the shared memory to know if an update
is required. If this is the case, the ‘Supplier’ computes the
update according to the current game state and copies this
update into the shared memory. Then, the ‘Supplier’ processes pending commands defined by the ‘Client’. Finally,
when the game is over, the ‘Supplier’ frees and cleans up the
shared memory.

Currently, we have only tested the first solution (i.e. the
campaign). As the original Kernel Panic was only a multiplayer game and did not provide campaigns, we had to build
one dedicated to our educational objectives. We have taken
advantage of the Kernel Panic universe and offered students
the following scenario: ‘For a certain number of years, a secret war has been rife inside computers. Steady attacks have
been led against innocent victims. Today is your turn. Your
aggressor captured your mouse controller. You must recover
it. Your only solution: programming’. To achieve this objective, five missions were created. During the first, the player
controls only one Bit and has to move it to a specific position to retrieve a lost Byte. In the second mission, the player
controls two units (one Bit and one Byte) and has to place
them in two different positions to find more units. Thus, in
this mission, the conditional control structure is introduced
to give a target position to each unit according to their types
(Bit or Byte). In the third mission, the player controls a weak
army which is made up of seven Bits and three Bytes. To
strengthen his/her army, the player has to move it to meet up
with an Assembler. To do this, the iterative control structure
is introduced to loop through each unit and move them towards the right position. In mission four, the player has to
use the Assembler capability to repair all the army. This is
the most complex mission and it requires overlapping iterative and conditional control structures. Finally, during the
last mission, the player launches an attack against opponents
to retrieve the mouse controller.
Thus, the serious game presented in this paper is a combination of three entities (Figure 3): the first one is a standard
video game (Kernel Panic); the second one, the Prog&Play
API, provides the programming facilities; the third one, the

On the ‘Client’ side, calling API’s operators can be carried
out after a first call to the Open and Refresh operators. If
there is a problem, API’s operators return an error code or an
exception depending on the language used. When the ‘Client’
asks for a refresh, this call is blocking until the ‘Supplier’
has detected and carried out the update.

2.3. Mapping learning objectives into the game
In our previous paper [MTJV09], we identified two solutions
to map learning objectives into the game. First a campaign
can be used, divided in missions (equivalent to exercises),
to gradually introduce learning topics and enable students to
learn how to play and program AIs (student motivation is
maintained by the campaign story). Second skirmishes can
be used as a project approach where students program their

Figure 3: Serious game composition.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

M. Muratet et al. / Experimental Feedback on Prog&Play

65

game mode (campaign or skirmish), transforms the programming game into a pedagogical artefact, that is a serious game.
As each entity can be changed as long as it interfaces with
the two others, new versions of the serious game can be
built. For example, we can replace Kernel Panic with another game, create new campaigns adapted to object-oriented
programming teaching or work with different programming
languages.

iment, the research team has to define a theoretical intent and
specify disciplinary ideas and forms of teaching which constitute the prospective goals or endpoints for student learning. The challenge is to formulate a design which embodies
testable conjectures about both significant shifts in student
learning and the specific means of supporting those shifts.
In our experiments, the theory we attempt to develop is the
process of learning programming through serious games.

3. Evaluation

3.2. Iterative evaluation

The conception of an evaluation to assess the positive or
negative impacts of our serious game on students is a complex task. This is due to the large number of uncontrollable
parameters inherent to experiments in a real context. Nevertheless, an evaluation is necessary for several reasons. First,
it allows defining a framework which will be tested by third
parties in different contexts. Secondly, results of evaluation
show negative points and mistakes and will be analysed to
improve pedagogical aspects of our serious game. Indeed,
evaluation is beneficial and allows communication about the
implemented practices.

The design experiment is based on an iterative process, which
allows the serious game and its evaluation to evolve. Each
iteration is made up of three stages: preparing for a design
experiment, conducting a design experiment and conducting
retrospective analysis. In the first stage, the theoretical intent
has first to be clarified (what is the point of this iteration?
What will be tested?). After this we need to select a course
to conduct experimentation corresponding to the objectives
of this iteration. Then, according to the conjectured starting
points (the environment where Prog&Play will be used), elements of trajectory (how the missions will be fulfilled) and
prospective endpoints (the improvement of students’ programming skills or motivation), an appropriate design experiment has to be formulated either by us, the teachers or both.
Finally, to adequately document the learning ecology, we
have to choose the evaluation criteria, associated indicators
and the way to support them. The second stage carries out
the experimentation and collects a maximum amount of data
to ensure that retrospective analyses will result in rigourous,
empirically grounded claims and assertions. Finally, the third
stage analyses experimentation data to verify the theoretical
intent and optionally proposes new experiments. Three iterations have so far been carried out with Prog&Play.

In Section 3.1, we define the methodology of design experiments that serves as theoretical framework. Then, we present
in Section 3.2 an iterative implementation of this framework.
Finally, we define evaluation criteria and we give experimentation results in Section 3.3.

3.1. Theoretical framework
We propose to study whether serious games could be useful
to teach programming, to attract and retain computer science
students. The question is: Is it interesting to use a serious
game to teach programming?
To achieve this goal, we propose to use the methodology of design experiments [CCD*03]: ‘prototypically, design experiments entail both “engineering” particular forms
of learning and systematically studying those forms of learning within the context defined by the means of supporting
them. This designed context is subject to test and revision,
and the successive iterations that result play a role similar
to that of systematic variation in experiment’. The aim of
this methodology in educational research is to investigate
the possibilities for educational improvement by bringing
about new forms of learning to study them. Because designs are typically test-beds for innovation, the nature of the
methodology is highly interventionist, involving a research
team, one or more teachers, at least one student and possibly
school administrators. Design contexts are conceptualized as
interacting systems and are implemented with a hypothesis
ed learning process and the means of supporting it. Design
experiments are conducted in a limited number of settings
and aim to develop a relatively humble theory which targets a
domain specific learning process. To prepare a design exper-

3.2.1. First iteration
The first iteration’s objective is to observe student behaviour
in relation to the serious game to determine its motivational potential and influence on teacher activity. To carry
out this first iteration, we have chosen to test the serious game in a familiar environment during some practical
work. The experimentation took place with first-year students learning computer science at an institute of technology
in Toulouse (IUT A). Among 196 students, we chose 15 students from 40 volunteers. Students were novices: at the time
of the experiment, they did not know any programming language, except ‘Compalgo’, an algorithmic language developed by teachers of IUT A. During five sessions of an hour
and a half each, students used Compalgo in the Windows
environment.
To select these students, we designed a questionnaire to
evaluate their motivation to play video games and learn
programming. We gave priority to students who were not

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

66

M. Muratet et al. / Experimental Feedback on Prog&Play

motivated by programming but very motivated by video
games. This questionnaire is based on the goals of Viau
[Via97]; the value and success expectation model of Bandura [Ban97]; and the causal model of Pintrich and Schunk
[PS96]. Each model suggests specific indicators which we
adapted to students’ motivation in learning programming
and practising video games. We drew inspiration from the
‘motivated strategies for learning’ questionnaire [PMB93].
For this experiment, we structured lessons in two phases.
In the first, students play the game in a multiplayer session
without programming. Thus, they become familiar with the
game universe and units. The second phase is a presentation
of the Prog&Play API which students learn to use through
mission solving. After these two phases, students should be
able to achieve small-scale programming compatible with
Kernel Panic.

The teaching team’s required condition to validate the
game’s integration into the curriculum concerns the ability
of the serious game to preserve basic knowledge processed
during standard teaching. Table 2 shows teaching objectives
of standard practical work (PW) sessions.
PW sessions one, three and four were modified. After
validation by the teaching team, modifications are as follows:

• PW 1: In addition to the working environment presentation, this first session presents the game universe. An
Appendix to the teaching documentation describes the
process of creating a multiplayer game. Students are invited to test the game by themselves before the third
session.

The second iteration’s objective is to study the implementation of our serious game on a large scale to evaluate its
influence on students’ results and teachers’ assessment. As a
matter of fact, teachers involved in this experiment were not
members of our research team and had no previous experience of serious games. To carry out this second iteration, we
introduced Prog&Play in the first semester of the computer
science core curriculum (bachelor’s degree—Paul Sabatier
University). In this course, computer programming is dealt
with a functional approach. Students apply basic knowledge
of this programming paradigm during six practical work sessions of two hours each using the ‘OCaml’ programming
language on Linux.

• PW 3: The third session is centred on library use. The
teaching documentation has been completely rewritten to
present the Prog&Play API and the campaign. To match
this with the original PW, a new mission (called 1a) has
been added to the campaign between the first and the second missions. Now, at the end of the first mission, the lost
Byte is not present at the indicated position. Thus, in this
new mission, additional information is supplied to find
the Byte. The player controls only one Bit (the same as
in the first mission) and knows the Byte’s direction (expressed in degrees, 0 being north) and relative distance.
The player has to compute the Byte position according
to the above information. During this session, students
have to complete missions 1, 1a, 2 and 3. Thus, students
learn how to use the library with mission 1, how to carry
out a trigonometrical exercise on mission 1a and how to
handle pattern matching with mission 2 and recursion in
mission 3.

The class is made up of more than 300 students structured
in practical work groups of about 15. Students’ distribution
into those groups is achieved randomly. About 20 teachers
work in this course. To evaluate the influence of the serious
game on students’ results, half the groups were reference
groups which followed the standard teaching whereas the
other half used the serious game.

• PW 4: Finally, the teaching aid of the fourth session has
also been rewritten. Here, students work on the fourth
mission. They start by creating functions to manage lists
of units and use them to solve the mission simply. With
sorting algorithms, students code a second, more efficient, solution and glimpse the optimization principles
which was removed from PW 3.

3.2.2. Second iteration

Table 2: Teaching objectives of the practical work sessions (PW).

PW
1
2
3
4
5 and 6

Objectives
Working environment presentation: operating system (Linux - Mandriva 2008), window manager (KDE), OCaml interactive
loop and word processor (Kate).
Arithmetical functions: pattern matching, n-tuple parameter, closure and recursion; introduction to dichotomy.
Use of the graphical library: definition of a library, trigonometrical arithmetic, optimisation and recursion.
Lists handling: list management and construction; pattern matching and recursion with lists; introduction to predicates;
sorting.
Data structures management: reuse of previous functions; projection, doublet removal, selection, update and sorting; user data
type manipulation.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

M. Muratet et al. / Experimental Feedback on Prog&Play

67

Owing to the number of teachers taking part in this experiment, a teacher training session took place to present the
serious game, the teaching aids modifications and solutions
to the new exercises.

3.2.3. Third iteration
Prog&Play can be seen as an artefact. We have built a Website
where teachers can have access to the serious game and
adapt it to their own pedagogy by themselves. The third
iteration aims to test the usability of this artefact by third
parties.
The first experimentation has been carried out in collaboration with J´er´emie Guiochet, teacher at the department of
electrical engineering, electronics and industrial informatics
at an institute of technology in Toulouse (IUT A). He chose to
use the game with students in difficulty. The teacher expected
this could motivate them to practice programming. Fifteen
students used the C++ language to complete the campaign
over nineteen hours.
The second experimentation has been carried out in
collaboration with Elisabeth Delozanne and Franc¸oise Le
Calvez from Pierre and Marie Curie university (Paris VI).
They have deployed the game in a transversal teaching
unit based on information and communication technologies
in education. In this teaching unit, teachers propose a set
of projects, one of which is based on our serious game.
Among volunteers, eight students who have followed introductory courses in imperative programming have been
retained. Teachers supervised two sessions of two hours to
introduce the game and programming concepts not studied
during lectures (library use and data structures). Following
this presentation, the first three missions have been completed using a pure algorithmic language and then coded
again using the C language. Then, students had two months
to complete the campaign and prepare a presentation of their
achievements.

3.3. Evaluation criteria and results
To define the evaluation criteria, we summarise objectives
revealed from iterations: determine the motivational potential
of the serious game; evaluate its influence on students’ results
and retrieve teachers’ views.
From these objectives, we define four evaluation criteria:
enhancement of programming skills; system usability; entertainment; and teachers’ assessment. The first and third
criteria evaluate the “serious game” concept. Indeed, it is
fundamental to check the “serious” side (enhancement of
programming skills) and the “game” side (entertainment) of
Prog&Play. The second criterion allows identifying bottlenecks which could hinder students (installation problems,
hardware requirements, software bugs, etc.). The last crite-

Figure 4: Synthesis of means used to collect data during
experimentations.
rion allows obtaining a qualitative evaluation of the serious
game by teachers.
Before presenting each criterion and associated results,
we synthesise all the means we have used during experimentations to collect data (Figure 4). The latter operation is
organised in three stages: before, during and after the use of
the serious game. For example, we massively used questionnaires instead of interviews to make data processing easier
and reuse them for several iterations. Please note that we did
not use all these solutions for each iteration.
3.3.1. Criterion 1: enhancement of programming skills
The learning evaluation is based on works of Chen and
Cheng [CC07], Gestwicki and Sun [GS08] and Leutenegger
and Edgington [LE07]. We define three indicators: quantity of work achieved, acquired knowledge and students’
future courses. Quantity of work achieved is evaluated using the game progress (number of missions completed). Acquired knowledge is evaluated with students’ results of midsemester and final examinations. These examinations are designed by teachers external to the research team and are the
same for all students.
During the first iteration, we analyse the first indicator
(quantity of work achieved) by processing data produced by
students during experiments. We count the number of missions completed by each student and for each mission the
number of compiling instances and executions necessary to
perfect their solution. These data have been collected thanks
to a software spy integrated into the development environment used during sessions. With these data, we can define a
difficulty ratio (noted ‘d m ’) for each mission ‘m’ shown in
Figure 5. This difficulty ratio is computed as indicated in

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

68

M. Muratet et al. / Experimental Feedback on Prog&Play

Figure 5: Difficulty ratio for each mission.

formula 1, where ‘nbStudents m ’ is the number of students who have completed mission ‘m’, ‘nbCompim ’ and
‘nbExecim ’ are, respectively, the number of compiling instances and the number of executions required for the student
‘i’ to complete mission ‘m’.

lable parameters. Nevertheless, we consider that the serious
game is partly responsible for this positive result.

nbStudentsm

dm =

nbCompim + nbExecim
i=1

nbStudentsm

Figure 6: Average marks for each examination by groups
(20 being the top mark).

(1)

Contrary to what we expected, the difficulty caused by the
various missions is not progressive. There is an important difference in difficulty between the first three missions and the
fourth. For future experiments, we plan to split mission 4 into
two new missions to propose a more progressive challenge.
The players getting familiar with the API seems to lessen the
difficulty between missions 1 and 3. Finally, we will update
mission 5 to offer a better challenge to end the campaign.
Indeed several students who reached this mission have been
frustrated by its simplicity. Johnson et al. [JVM05] argue
that story maintains user interest, encourages the player to
progress constantly and links actions and future objectives.
Challenges are introduced with the story and must match
players’ experience. Greitzer et al. [GKH07] highlight the
difficulty to build a suitable scenario which is neither too
easy nor too difficult to submit a challenge without discouraging the player.
The other indicators (acquired knowledge and students’ future courses) have been evaluated during the experimentation
of the second iteration. Concerning the ‘acquired knowledge’
indicator, we have collected students’ results of mid-semester
and final examinations. Figure 6 shows the average marks for
reference and serious game groups. Please note that we did
not have those marks when we started experimentation.
First, we notice a decline in marks between mid-semester
and final examinations whatever group we take. However,
this decline is less important for the serious game groups
(1.25 points) than reference groups (1.55 points). We cannot
link this result only to the serious game because experimentations have been carried out with a large number of uncontrol-

Concerning the ‘students’ future courses’ indicator, we
used students’ choices for their second semester. Indeed,
after the first semester, nine major courses are available, one
of which is dedicated to computer science. Among students
from the serious game groups 55% have chosen this major
course compared to 49% in the reference groups.
Thus, these results show that even if missions’ difficulty is
less progressive than it was expected, the campaign supplies
a sufficient difficulty to encourage work and stimulate students’ interest. From a statistical point of view, we note that
the serious game has contributed to reduce students’ failure
compared to reference groups and to recruit more students
for computer science for the second semester.
3.3.2. Criterion 2: system usability
System usability is based on a post-questionnaire. We ask
students to evaluate the serious game. Using works of Siang
and Rao [SR03], we define questions to evaluate the hierarchy of the players’ needs to identify which part of our
serious game needs improvement. This hierarchy is divided
into seven levels and lower levels are to be fulfilled before
moving on to the higher levels in the pyramid. The seven
levels by priority order are as follows: Rules need, players seek information to understand the basic rules of the
game; Safety need, players need guidance about the game
software; Belongingness need, players need to become familiar with the game to feel capable to achieve objectives;
Esteem need, players need to be motivated by the game (feedbacks, scores, competition, etc.); Need to know and understand, players need to understand and know more information about the game (e.g. different strategies or hidden items)
to reuse it during play time; Aesthetic need, players need good

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

69

M. Muratet et al. / Experimental Feedback on Prog&Play

• Q1: In your opinion, is it interesting to use a video game
to learn how to program? (1=“not at all”, 7=“essential”)

Table 3: Average and median answers of questions presented Figure 7 for the two first iterations (highest possible value being 7).

• Q2: Do you think that practical work sessions based on
a video game are adapted to this course? (1=“not at all”,
7=“perfectly adapted”)

Figure 7: Opinion-related
questionnaire.

questions

in

the

post-

1st iteration

Average
Median

2nd iteration

Q1

Q2

Q1

Q2

6.17
6.83

6
7

5.05
5

5.18
5

• Q3: Do you appreciate the campaign story (missions)?
(1=“not at all”, 7=“a lot”)
• Q4: Do you think that using programming in Kernel Panic
increases entertainment?
Reduces entertainment
Do not change entertainment
Enhances entertainment
I don’t know

Figure 9: Questions
questionnaire.

Figure 8: Students’ satisfaction for the hierarchy of the players’ needs.

graphics and visual effects, appropriate music, sound effects,
etc; Self actualization need players need to be able to transfer
their creativity and imagination into the game as long as it
conforms to the game rules.
In addition, we ask students to express their criticisms,
remarks and suggestions about the serious game as well as
their point of view about the interest of a serious game to
learn computer programming. Questions are presented in
Figure 7.
During the first two iterations, we evaluate the hierarchy
of players’ needs. Figure 8 shows students’ satisfaction for
each level of this hierarchy.
Concerning the first iteration, the lowest satisfaction level
concerns the aesthetic need with an average value of 47%.
The low-end vectorial graphics of Kernel Panic seem disturbing to our students. Nevertheless, this simplified RTS allows
a quick learning curve which takes part in the positive satisfaction of lower needs. Therefore, we still think that Kernel
Panic is not a bad choice to support Prog&Play.
For the second iteration, we observe lower satisfaction
rates although the serious game is the same except for the new
mission (1a). To explain differences with the first iteration,
we analyse remarks and criticisms expressed by students.

for

the

entertainment

post-

The main criticisms are levelled at the teaching aids that are
considered too descriptive and over-prescriptive. We suggest
that this feeling has counterbalanced the game understanding.
Thus, this experiment highlights that results obtained depend
not only on the serious game but also on the implementation,
supervision, teaching aids, etc.
Nevertheless, whatever iteration, students have appreciated the initiative and are interested in this kind of pedagogy.
The average and median answers to the two additional questions are presented in Table 3 for the first two iterations.
In conclusion about this criterion, the game is functional
because no critical bugs were revealed during experimentations. The only issue is that some teachers have encountered
difficulties to configure their operating system to use the serious game correctly. The analysis of the hierarchy of players’
needs shows that students’ satisfaction heavily depends on
implementation. This confirms the importance of supervision
for our serious game.

3.3.3. Criterion 3: entertainment
This criterion has been evaluated with a questionnaire distributed to students at the end of experiments. Questions are
presented in Figure 9.
The fourth question (Q4, Figure 9) was crucial for us.
Introducing algorithmic concepts into the game should not
make it any less entertaining. This requirement is due to
our vision of serious games which have to be, above all,
entertaining.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

70

M. Muratet et al. / Experimental Feedback on Prog&Play

Concerning the first iteration, the average and median answers to the third question (Q3, Figure 9) are, respectively,
5.85 and 6. These results show that students liked playing
the campaign. We think that missions’ interest is partly due
to the first phase of the experimentation. The multiplayer
session allows students to become familiar with the universe
of the game and makes students’ immersion into the story
easier.
For the fourth question (Q4, Figure 9), 100% of students
found that using programming in the game enhances entertainment. We found out during this first experiment that
the game is fun and rewarding: it is fun because all students found that programming enhances entertainment; and
it is rewarding because even though we initially planned, for
the final session, to let students play a normal multiplayer
game, more than half of the students preferred to continue
programming.
Concerning the second iteration, results are slightly lower.
The average and median answers to the third question (Q3,
Figure 9) are, respectively, 4.14 and 4. This is the same for the
answers to the fourth question (Q4, Figure 9). Fifteenth percent of students found that the introduction of programming
into the game reduces entertainment, 22% indicate there is
no change, 42% identify an enhancement and 21% do not
give their opinions. We attribute these results to the same
reason identified in criterion 2 analysis: the teaching aids
were perceived as too descriptive and over-prescriptive, they
have counterbalanced the entertainment.
Thus, the campaign is entertaining and it is a real success
from this point of view. Moreover, students appreciate using
their programming knowledge in a real context.

3.3.4. Criterion 4: teachers’ assessment
To observe teachers’ activities during experiments, we propose to film sessions. Particular emphasis has been laid on
activities dedicated to game usability and teaching contents.
The activity called ‘game usability’ concerns explanations
on the game’s control (how to launch the game? How to
move the camera?) and on the game’s interaction with students’ programs (how to select or command units? How to
check if programs are correct?). The activity called ‘teaching
contents’ deals with explanations on programming obstacles like variables (types, assignments, records), functions
(call, argument passing) and control structure (conditional,
iterative). The activity called ‘other tasks’ concerns administrative tasks (e.g. welcoming students, roll call), explanations
on operating system usability, etc.
Furthermore, we submit a questionnaire to teachers about
their perception of video games and serious games before experimentation. Then, each teacher has to file a report, which
enables us to collect their points of view about the past experimentation. On this occasion, we ask them if they encountered

Table 4: Time spent by the teacher on each activity during one
session.

Activity

Time spent

Game usability
Teaching contents
Other tasks

22 m 13 s
1 h 3 m 42 s
41 m 27 s

difficulties with the serious game and what they would advise
regarding a possible renewal of the experiment.
The observation of the teacher’s activities has been carried out during the second practical work session of the first
iteration. The time spent by the teacher on each activity is detailed in Table 4 (please note that some activities are counted
in several categories, which explains why the amount of time
spent is higher than the duration of a session).
As can be seen in the table, the longest activity deals
with ‘teaching contents’. This distribution is appropriate, because, the game’s explanations should not excessively reduce
teaching activities. Moreover, the time spent on game-related
activities diminishes when students become expert in game
handling. Nevertheless, ‘game usability’ is an important activity mainly for the first sessions. Indeed, the second level
of the hierarchy of players’ needs (safety need) has been resolved, in a large part, by teachers. Currently, Prog&Play is
a serious game for programming practice; information about
programming, learning contents and game usability are not
included in the game and must be added through teachers’
speeches or teaching aids.
Concerning the second iteration, we take advantage of the
important number of teachers by asking them about their
perception of video games and serious games before the experimentation. Three women and 12 men answered our questions. Nine people said they played video games. Teachers
have mainly pointed out three qualities of such games: they
encourage thinking through strategic developments, they are
entertaining and allow immersion into virtual worlds. To a
lesser extent, competition with multiplayer sessions, storytelling and creativity are identified as intrinsic qualities of
video games. The main drawback is addiction. Some teachers find video games too complex and associate them with
a waste of time. Concerning serious games, seven teachers
who have a positive perception think that they can motivate students to practice computer science activities. Moreover, they consider serious games as concrete tools close to
students’ interests. The two teachers who have a negative
perception fear that serious games misrepresent computer
science as only made of video games, give an advantage to
boys, are a waste of time (i.e. explaining the game instead of
the teaching content) and that playing distracts students from
basic knowledge acquisition. The six teachers who had no

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

M. Muratet et al. / Experimental Feedback on Prog&Play

opinion said they would consider results before expressing
their convictions.
Again from the second iteration, teachers’ reports are
mixed. On the performance side, they thought that sessions
based on the serious game have been counter-productive for
several students. They do not attribute this consequence to
the serious game but to the teaching aids. Like students, they
felt this documentation was too descriptive. On the plus side,
most teachers have noticed a positive influence of the serious
game on students.
Concerning the third iteration, teachers, who have carried
out experimentations by themselves, give positive reports.
First, Mr Guiochet said that the serious game campaign was
well adapted to his students (they needed basic programming practice and had a lot of time for this course). Indeed,
students have shown their interest through some personal
work which was not required. Secondly, Mrs Delozanne and
Mrs Le Calvez have been impressed by the wide range of
strategies planned and the quality of presentations prepared
by students. They report that students have appreciated the
projects because they have programmed something concrete.
Mrs Delozanne and Mrs Le Calvez added that their sessions
preparation time was quite long due to their inexperience
of video games. In both instances, teachers plan to use our
serious game again next year.
In conclusion about teachers’ assessment, we can say that
globally they are positive about the influence of the serious
game on students’ work. Indeed, in the second iteration the
negative evaluations are mainly attributed to the teaching
aids and not to Prog&Play. This is very encouraging for
us.

4. Conclusion and future work

71

campaign story which has a twofold objective. First, it motivates the player by making him/her protagonist in the story
development. Secondly, it gradually introduces the pedagogical contents of the serious game. At the end of the story,
students master the programming interface and are able to
program their own AIs.
For pedagogical reasons, we made the Prog&Play API
available in different programming languages. Specifically,
Scratch compatibility opens up new research vistas. Indeed, it
will be interesting to study the impact of these two technologies (block-based graphical languages and serious games)
on students’ motivation. Another future project consists in
adapting the serious game to other RTSes. Indeed, with the
quick evolution of video games engines, its integration into
new RTSes is essential to continue entertaining students. It
would also be interesting to evaluate this approach with another video game genre and to compare it with our RTS-based
serious game.
The Prog&Play system with Kernel Panic and compatible interfaces are downloadable at http://www.irit.fr/∼
Mathieu.Muratet/progAndPlay_en.php. If you are interested
in our serious game, please do not hesitate to get in touch
with us!

Acknowledgements
This work would not have been possible without the collaboration of several learning institutions. The authors thank
the following people and institutions: Christian Percebois
and Max Chevalier (department of computer science) and
J´er´emie Guiochet and Andr´e Lozes (department of electrical
engineering, electronics and industrial informatics) at IUT A
in Toulouse; Mathias Paulin, V´eronique Gaildrat and all Paul
Sabatier university teachers who took part in our experimentation; and Elisabeth Delozanne and Franc¸oise Le Calvez at
Pierre and Marie Curie university in Paris.

This paper describes Prog&Play, a serious game aiming to encourage students to persevere in computer science. Through
a theoretical framework, we designed an iterative evaluation
based on several experiments. During the first iteration, we
observed the serious game used by students in a real context. On this occasion, we identified that Prog&Play is really
appreciated by students. Following this first iteration, the
portability of the game was questioned. Thus, a second iteration was designed to study the game’s implementation on
a large scale. Despite poor teaching aids, the serious game
has helped reduce students’ failure compared to reference
groups. Then, the last iteration was meant to let teachers implement the game by themselves in their courses. Reports
of these teachers are positive because they plan to continue
using Prog&Play.

[Ban97] BANDURA A.: Self-efficacy: The Exercise of Control.
Worth Publishers, New York, 1997.

Thus, the serious game is functional and motivates students. We attribute this success to the original approach of
Prog&Play which allows the use of programs to interact with
a RTS. The second element taking part in this success is the

[CC07] CHEN W.-K., CHENG Y. C.: Teaching objectoriented programming laboratory with computer game
programming. IEEE Transactions on Education, 50, 3
(Aug. 2007), 197–203.

References
[ACM05] ACM/IEEE-CURRICULUM 2005 TASK FORCE (Ed.):
Computing Curricula 2005, The Overview Report. IEEE
Computer Society Press and ACM Press, New York,
2005.
[Ame] AMERICA’S ARMY: http://www.americasarmy.com/.
Accessed 26 August 2010.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

72

M. Muratet et al. / Experimental Feedback on Prog&Play

[CCD*03] COBB P., CONFREY J., DISESSA A., LEHRER R.,
SCHAUBLE L.: Design experiments in educational research.
Educational Researcher, 32, 1 (Jan. 2003), 9–13.
[CCMT08] CRENSHAW T. L., CHAMBERS E. W., METCALF H.,
THAKKAR U.: A case study of retention practices at the
university of illinois at urbana-champaign. In Proceedings
of the 39th ACM Technical Symposium on Computer Science Education (New York, NY, USA, 2008), ACM Press,
pp. 412–416.
[CHYH04] COOK D. J., HUBER M., YERRABALLI R., HOLDER L.
B.: Enhancing computer science education with a wireless
intelligent simulation environment. Journal of Computing
in Higher Education, 16, 1 (2004), 106–127.
http://www.ceebot.com/colobot/index-e.
[Col] COLOBOT:
php. Accessed 26 August 2010.
[Dar] DARFUR IS DYING: http://www.darfurisdying.com/. Accessed 26 August 2010.
[Ent09] ENTERTAINMENT SOFTWARE ASSOCIATION: Essential
facts about the computer and video game industry. http://
www.theesa.com/facts/pdfs/ESA_EF_2009.pdf (2009).
Accessed on 30 September 2010.
[GKH07] GREITZER F. L., KUCHAR O. A., HUSTON K.: Cognitive science implications for enhancing training effectiveness in a serious gaming context. Journal Education
Resource Computation, 7, 3 (2007), Article No. 2.
[GS08] GESTWICKI P., SUN F.-S.: Teaching design patterns
through computer game development. ACM Journal on
Educational Resources in Computing, 8, 1 (2008), 1–22.
http://apocalyx.sourceforge.net/gun
[Gun] GUN-TACTYX:
tactyx/. Accessed 26 August 2010.
[JVM05] JOHNSON W. L., VILHJALMSSON H., MARSELLA S.:
Serious games for language learning: How much game,
how much AI?. In Proceeding of the 2005 conference
on Artificial Intelligence in Education (Amsterdam, The
Netherlands, The Netherlands, 2005), IOS Press, pp. 306–
313.
[KCC*02] KELLEHER C., COSGROVE D., CULYBA D., FORLINES
C., PRATT J., PAUSCH R.: Alice2: Programming without
syntax errors. In Proceedings of the 15th Annual Symposium on the User Interface Software and Technology
(Paris, France, Oct. 2002).

[KY05] KLOPFER E., YOON S.: Developing games and simulations for today and tomorrow’s tech savvy youth.
TechTrends: Linking Research and Practice to Improve
Learning, 49, 3 (2005), 33–41.
[LE07] LEUTENEGGER S., EDGINGTON J.: A games first approach to teaching introductory programming. SIGCSE
’07: Proceedings of the 38th SIGCSE Technical Symposium on Computer Science Education, 39, 1 (Mar. 2007),
115–118.
[Mar] MARVIN’S ARENA: http://www.marvinsarena.com/.
Accessed 26 August 2010.
[MBK*04] MALONEY J., BURD L., KAFAI Y., RUSK N.,
SILVERMAN B., RESNICK M.: Scratch: A sneak preview. In
Proceedings of the 2nd International Conference on Creating Connecting, and Collaborating through Computing (Keihanna-Plaza, Kyoto, Japan, Jan. 2004), pp. 104–
109.
[MTJV09] MURATET M., TORGUET P., JESSEL J.-P., VIALLET
F.: Towards a serious game to help students learn computer programming. International Journal of Computerised Games Technology 2009 (2009), 1–12.
[Num] THE NUMBERS: http://www.the-numbers.com/mark
et/. Accessed 26 August 2010.
[PMB93] PINTRICH P., MARX R. W., BOYLE R. A.: Beyond
cold conceptual change: The role of motivational beliefs
and classroom contextual factors in the process of contextual change. Educational Research, 630, 2 (1993), 167–
199.
[PS96] PINTRICH P. R., SCHUNK D. H.: Motivation in Education: Theory, Research and Applications. Prentice Hall,
Englewood Cliffs, 1996.
[Roba] ROBOCODE: http://robocode.sourceforge.net/. Accessed 26 August 2010.
[Robb] ROBOT BATTLE: http://www.robotbattle.com/. Accessed 26 August 2010.
[SR03] SIANG A., RAO R. K.: Theories of learning: A computer game perspective. In Multimedia Software Engineering, 2003. Proceedings of the Fifth International Symposium (Dec. 2003), pp. 239–245.

[Kel06] KELLEHER C.: Alice and the sims: the story from
the alice side of the fence. In The Annual Serious Games
Summit DC Washington (DC, USA, Oct. 30–31, 2006).

[SW06] STEVENSON D. E., WAGNER P. J.: Developing realworld programming assignments for cs1. In ITICSE ’06:
Proceedings of the 11th Annual SIGCSE Conference on
Innovation and Technology in Computer science Education (Bologna, Italy, June 2006), pp. 158–162.

[Ker] KERNEL PANIC: http://springrts.com/wiki/Kernel_Panic.
Accessed 26 August 2010.

[Tac] TACTICAL LANGUAGE AND CULTURE: http://www.tactical
language.com/. Accessed 26 August 2010.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

M. Muratet et al. / Experimental Feedback on Prog&Play

73

[Via97] VIAU R.: La motivation en contexte scolaire. De
Boeck, Bruxelles, 1997. (in French).
[Zyd05] ZYDA M.: From visual simulation to virtual reality
to games. IEEE Computer, 38, 9 (2005), 25–32.
Appendix: Example solution
We present in Figure 10 a solution (in C) to the following scenario: ‘You need to find an allied unit near to the position of
your unit. Tracks indicate that it has moved away at a distance
of 1060 units and an orientation of 209 degrees’. In this context, we have used the native Prog&Play API. In ‘C’, a unit is
an abstract type that can be consulted with a set of functions.
For example, the function PP_Unit_GetPosition(u) allows
getting the position of a unit. With the assistance of teachers,
students have to find in the documentation which function is
useful to complete this exercise.

Figure 10: A solution written in C.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.


DOI: 10.1111/j.1467-8659.2011.02016.x
Volume 30 (2011), Number 5

Eurographics Symposium on Geometry Processing 2011
Mario Botsch and Scott Schaefer
(Guest Editors)

Localized Delaunay Refinement for Volumes
Tamal K Dey†1 and Andrew G Slatton‡1
1 The

Ohio State University, Computer Science and Engineering

Abstract
Delaunay refinement, recognized as a versatile tool for meshing a variety of geometries, has the deficiency that
it does not scale well with increasing mesh size. The bottleneck can be traced down to the memory usage of 3D
Delaunay triangulations. Recently an approach has been suggested to tackle this problem for the specific case
of smooth surfaces by subdividing the sample set in an octree and then refining each subset individually while
ensuring termination and consistency. We extend this to localized refinement of volumes, which brings about some
new challenges. We show how these challenges can be met with simple steps while retaining provable guarantees,
and that our algorithm scales many folds better than a state-of-the-art meshing tool provided by CGAL.
Categories and Subject Descriptors (according to ACM CCS): I.3.5 [Computer Graphics]: Computational Geometry
and Object Modeling—Curve, Surface, Solid, and Object Representations

1. Introduction
Delaunay refinement is accomplished by iteratively sampling an input geometry at points locally farthest from the
current sample set whenever a condition is violated [Che89,
Rup95]. It has been recognized as an effective tool for
sampling and meshing a variety of geometries including
polyhedra [She98], smooth surfaces [BO05, CDRR07] and
volumes [ORY05], piecewise smooth surfaces [BO06] and
complexes [CDR08]. The popularity of the technique can
be attributed to its ability to equip algorithms with provable
guarantees and also to generate good quality meshes in conjunction with optimizations [ACSYD05, TWAD09].
One shortcoming of such an otherwise excellent tool is
its lack of scalability. Since traditional Delaunay refinement
maintains a complete three dimensional Delaunay triangulation of a growing sample, its time and memory usages are
determined by those of the Delaunay triangulation algorithm
being employed. Although considerable progress has been
made to speed up Delaunay triangulations [ACR03,ILSS06],
still the state-of-the art does not scale well for computing
3D meshes with simplices in the range of a few million. Parallel algorithms could be a solution to this problem, but to

† e-mail: dey.8@osu.edu
‡ e-mail: slatton.2@buckeyemail.osu.edu
c 2011 The Author(s)
Computer Graphics Forum c 2011 The Eurographics Association and Blackwell Publishing Ltd. Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK
and 350 Main Street, Malden, MA 02148, USA.

date they are limited only to Delaunay refinement of polyhedra [NCC04].
Recognizing the gap, very recently Dey, Levine, and Slatton [DLS10] proposed an algorithm that can sample and
mesh a smooth surface using localized Delaunay refinement.
The localization is obtained by maintaining the current sample in an octree and then refining each leaf node separately.
The obvious problems this solution faces are how to maintain a lower bound on inter-point distances over the global
set and how to fit individual meshes consistently. Dey et al.
showed that these two concerns can be alleviated by careful
point insertion and a re-processing technique, while ensuring quality guarantees. The algorithm improved the memory usage by an order of magnitude and therefore prevented
memory thrashing–a culprit of scaling.
In this paper, we extend the technique of Dey et
al. [DLS10] to volumes bounded by smooth surfaces. Since
volume meshing with quality tetrahedra is an important requirement for many scientific simulations, extension of a
successful technique for surface meshing to this domain is
an important undertaking. It turns out that this extension
from surface to volume is non-trivial, bringing new challenges and requiring additional observations and results. In
this discourse, we reveal theoretical results which guarantee some qualities for the output, as well as practical results
which show that our method surpasses the performance of a
CGAL [cga] volume meshing tool by many folds; these are

1418

Tamal K Dey & Andrew G Slatton / Localized Delaunay Refinement for Volumes

the two main contributions of this investigation. It should
be noted that our method does not address sliver removal,
a nontrivial problem commonly faced by Delaunay refinements in general.
1.1. Definitions and Notations
Our algorithm and the analysis thereof make use of
Voronoi/Delaunay tessellations and their restrictions to a
volume O and its boundary ∂ O, as well as the idea of "locally farthest points". For completeness, we recapitulate the
definitions of these here.
For a set of points P ⊂ R3 , we denote its Voronoi diagram and Delaunay triangulation as Vor P and Del P respectively. Each k-dimensional Delaunay simplex σ (vertex, edge, triangle, and tetrahedron) is dual to a (3 − k)dimensional Voronoi face Vσ (cell, facet, edge, vertex respectively).
The point set P in our case will be from a volume O
bounded by a smooth boundary ∂ O in R3 often approximated by a polygonal surface in practice. The set of Delaunay simplices whose dual Voronoi faces intersect O or
∂ O will be of special interest to us. We use special subcomplexes of Del P called the restricted Delaunay complexes with respect to O and ∂ O. They are defined as:
Del P|O = {σ ∈ Del P : Vσ ∩ O = ∅}
Del P|∂ O = {σ ∈ Del P : Vσ ∩ ∂ O = ∅}.

p

Figure 1: A restricted triangle in Del P|∂ O : its dual Voronoi
edge intersects the surface. One such intersection point is p
which is the center of a surface Delaunay ball of the triangle.

The complex Del P|O consists of tetrahedra, triangles,
edges, and vertices whose dual Voronoi faces intersect O.
Similarly, Del P|∂ O consists of triangles, edges, and vertices
whose duals intersect ∂ O. The dual Voronoi edge of a restricted Delaunay triangle f may intersect ∂ O at multiple
points. Each of these intersection points is the center of a
three dimensional ball that does not contain any point of P
inside, but contains the vertices of f on its boundary (Figure 1). They are called the surface Delaunay balls of f .
The locally farthest point in a Delaunay refinement is a

point where a Voronoi face such as a Voronoi edge or a
Voronoi vertex intersects the input geometry.
2. Overview
Usually, the Delaunay refinement is accomplished by maintaining the Delaunay triangulation of the entire sample set in
memory because any refinement based on proper subsets of
the sample incurs two questions, namely:
1. How can one ensure that the meshes of these subsets fit
together consistently?
2. How can one guarantee termination of such an algorithm?
The first of these arises because, given two arbitrary subsets of a sample, some points in one may lie inside some
Delaunay balls of the other; therefore, some simplices that
are restricted with respect to the subset may then not be restricted (or may not exist at all) with respect to the entire
point set. The solution to this problem lies in choosing subsets carefully, and appropriately selecting from the triangulations of these subsets those simplices which will comprise
the final output.
The second problem arises because an added point that
is locally farthest in a subsample may not remain so in the
full sample. This means that there is no lower bound on
inter-point distances within the sample, and therefore no upper bound on the number of point-insertions. This problem
is solved by a point-insertion scheme that can guarantee a
lower bound on inter-point distances.
In this paper, we draw upon the approach of Dey et
al. [DLS10] to mesh the volume O bounded by a smooth
2-manifold input ∂ O, a problem for which the questions
and general solutions mentioned above remain valid. However, there are additional difficulties that arise during volume
meshing – one pertaining to termination and another to the
topology of the output.
We prove termination via a packing argument; therefore we must show that we only insert points inside some
bounded domain. This can be troublesome when we refine
tetrahedra because, though O is bounded, the dual Voronoi
vertex of an arbitrarily chosen Delaunay tetrahedron may not
lie in O. So, we must take some measures to ensure that we
refine only those tetrahedra whose dual Voronoi vertices lie
in O. We discuss our solution to this problem at the end of
our algorithm description and in our argument for termination.
We aim to guarantee the topological equivalence of the
output mesh to the input volume. This assurance requires all
restricted triangles to have all their vertices on ∂ O. To meet
this condition, Oudot et al. [ORY05] force a triangle refinement, and we follow suit; however, this strategy faces the
following problem in localized refinement: a Voronoi vertex may be inserted arbitrarily close to ∂ O as it is not completely protected by surface Delaunay balls in the partial set;
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

Tamal K Dey & Andrew G Slatton / Localized Delaunay Refinement for Volumes

1419

Figure 2: Cut away views show some tetrahedra in meshes produced by our algorithm. Surface colors signify decomposition
with octree leaf nodes.

3. Algorithm

Figure 3: The black Voronoi vertex, if inserted as a circumcenter, would be very close to the curve (surface). Even
though the restricted Delaunay edges (triangles) with samples on the curve (surface) form a manifold, the curve (surface) near the vertex may not yet be meshed properly to prevent volume triangulation introducing the Voronoi vertex in
a local refinement.

see Figure 3 for an illustration. Then to get rid of restricted
triangles incident to such an interior vertex the refinement
could be arbitrarily dense, jeopardizing termination. Our solution: when a surface vertex is inserted, all volume vertices
close to it are deleted. Our proof of termination leverages
this action.
We prove that the algorithm terminates, outputting a 3D
mesh which is always a manifold and is close to the input
volume with respect to λ , a user supplied parameter. The
guarantee remains valid no matter what value of the parameter λ is supplied. Furthermore, when λ is sufficiently small,
the output becomes isotopic to the input volume.
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

Our algorithm computes and refines the surface and volume
mesh simultaneously. It divides the sample set P using an
octree, and processes only one leaf node of the octree at a
time. During the processing of a node ν , six conditions are
checked. When one of these conditions is violated, the algorithm refines the node’s local triangulation accordingly.
When there are no more violations in ν , it begins processing another node of the octree. When none of the refinement
criteria are violated in any of the nodes, a final output is generated. Throughout the algorithm, we utilize a point insertion strategy that is necessary for our proof of termination,
and we may select some nodes for reprocessing in order to
maintain a global consistency across meshes. Details follow.
3.1. Node Processing
The nodes of the octree requiring processing are maintained
in a queue Q, and each node is processed when it reaches the
head of Q. A node may be processed by one of two actions:
split or refine. Each node ν of the octree maintains a set of
points Pν = P ∩ ν . When the number of points in ν exceeds a
user-defined parameter κ , that is, |Pν |>κ , we invoke a split;
if |Pν | ≤ κ when ν reaches the head of Q, we invoke a refine.
In a split, ν is divided into eight children of equal size,
each of which is geometrically similar to ν . The points of
Pν are then divided among these children, with each child
taking the points that lie within its volume, and then these
children are enqueued in Q.
When a node ν is refined, we begin by computing its local
triangulation Del Rν , where Rν is a superset of Pν . Specifically, we initialize Rν := Nν Pν , where Nν ⊆ P contains
the points of P that lie within a distance 2λ of the boundary
of ν (Figure 4); the value of 2λ is chosen in order to prove
our claims regarding the output. While violations of our refinement criteria persist, we refine the local triangulation of
ν . Detailed descriptions of the refinement criteria are given

Tamal K Dey & Andrew G Slatton / Localized Delaunay Refinement for Volumes

1420

Nν

2λ

Pν

Figure 4: Rν := Nν Pν . The solid rectangle shows the
boundary of node ν . Solid points are in the initial Rν ; hollow
points are not.

later. If |Pν | > κ at any point during the refinement of the
local triangulation, we invoke a split of ν .
When a node ν is not being processed we clear its local
Delaunay triangulation (along with all the data structures associated with it) in order to save memory, maintaining only
its Pν ⊆ P and a list of restricted tetrahedra inside ν . The list
of tetrahedra can be stored on disk to reduce memory footprint, as it will not be required again until the output step;
however, Pν should be kept in memory because it may be
accessed often by our point-insertion method.
3.2. Localized Refinement
For each point p in a node ν , we want the local triangulation
around p be nice, that is, surface triangles around p form a
topological disk, and tetrahedra around p form a topological ball. Our ultimate goal is to fit all these individual local
triangulations seamlessly in a global one. Toward that goal,
we define the surface star Fp of a point p ∈ Pν as the set
of triangles incident on p that are restricted to ∂ O in the local triangulation, and the sub-simplices of all such triangles.
Formally,
Fp = { f | f ∈ Del Rν |∂ O is either a triangle incident to p

3. (C3) ∀p ∈ Pν , if p ∂ O = p then Fp is a topological disk
with each edge e ∈ Fp that is incident on p being also
incident on exactly two triangles in Fp ;
4. (C4) ∀ f ∈ Fp , where f is a triangle and p ∈ Rν , the
Voronoi edge dual to f intersects ∂ O only once;
5. (C5) ∀t ∈ Tp , where t is a tetrahedron and p ∈ Pν , t has
circumradius less than λ ;
6. (C6) ∀t ∈ Tp , where t is a tetrahedron and p ∈ Pν , the
radius-edge ratio is at most 2.
In the event of a violation, a tuple (p, q) is returned, where
q is a candidate for insertion and p is the closest point to
q in Rν . If C1, C2, or C4 is violated, q is the center of the
largest surface Delaunay ball of the culprit f . In the case of
C3, q is the center of the largest surface Delaunay ball of all
triangles in Fp . For violations of C5, q is the circumcenter of
the culprit t. For violations of C6, let c be the circumcenter
of the culprit t. If c lies inside some surface Delaunay ball,
then q is the center of that surface Delaunay ball; otherwise,
q := c. When no violations remain, we return a null tuple.
p

q
p=s

λ

p q

q

λ

s

s

ν
q

λ

ν

ν
2λ

Figure 5: (top) shows some examples of point insertion
(solid points are in Rν ; hollow points are not). In the rightmost image, s is added to Rν ; in the other two images q is
added to both Rν and P. (bottom) depicts an example of reprocessing: when ν inserts q, ν and ν are enqueued for
reprocessing.

or a sub-simplex of such a triangle}.

Similarly, we define the volume star Tp of a point p ∈ Pν
as the set of tetrahedra incident on p that are restricted to O
in the local triangulation, and the sub-simplices of all such
tetrahedra. Formally,
Tp = {t |t ∈ Del Rν |O is either a tetrahedron incident to p
or a sub-simplex of such a tetrahedron}.
3.2.1. Refinement
During the refinement phase we check six conditions in a
priority order which gives priority to CI over CJ if I<J:
1. (C1) ∀ f ∈ Fp , where f is a triangle and p ∈ Pν , the surface
Delaunay ball of f has radius less than λ ;
2. (C2) ∀ f ∈ Fp , where f is a triangle and p ∈ Pν , all vertices
of f lie on ∂ O

3.3. Point Insertion and Deletion
Algorithm 1 InsertDelete(ν , p, q, λ )
1: s := argminu∈P d(q, u)
2: if d(q, s) ≤ λ and s ∈ Rν then
3:
Rν := Rν ∪ {s}; return s
4: else
5:
if q ∈ ∂ O then
6:
delete any p ∈ P \ ∂ O with d(p, q) ≤ λ
7:
end if
8:
P := P ∪ {q}; update Rν ; return q
9: end if
Let (p, q) be a tuple returned by some violation during
refinement. Then q is a candidate for insertion, but it may
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

Tamal K Dey & Andrew G Slatton / Localized Delaunay Refinement for Volumes

lie arbitrarily close to some point in P despite being locally
far in Rν . In order to disallow arbitrarily close insertions in
our sample, we find the closest point s ∈ P to q. If s lies
within distance λ of q, and s ∈ Rν (recall that p is the nearest
point to q in Rν ), then we throw away q and insert s into Rν ;
otherwise, we insert q into Rν and add it to P. Note that Rν
is augmented in both cases, and P is augmented in only the
latter case. Figure 5(top) illustrates different cases.
Sometimes we also require point deletions in response to
the insertion of a surface point, that is, a point in ∂ O. Deleted
points are always volume points, that is, points that are in
P but not in ∂ O. If the new point q is a surface point, we
delete all volume points that are within λ distance of q. We
remark that deletions happen rarely in practice and only at
the beginning when the surface ∂ O is not yet completely
covered with surface Delaunay balls.
Furthermore, when a new point is added to or deleted from
P it is possible that some nodes are enqueued for reprocessing. At the onset, it may seem that insertion, deletion, and
reprocessing may cause an endless cycle, preventing termination. We prove that this never happens.
3.4. Reprocessing Nodes
Algorithm 2 NodeEnqueue(ν , s, λ )
1: Compute W := {ν = ν |d(s, ν ) ≤ 2λ }
2: for each ν ∈ W do
3:
E nqueue(ν , Q)
4: end for

1421

from Q for processing, we compute Del Rν which is also updated with each insertion and deletion of point(s). To check
violations C1-C4, we compute and maintain the restricted
surface triangulation Del Rν |∂ O . To check violations C5-C6,
we also need the restricted volume triangulation Del Rν |O .
We initially identify the tetrahedra of Del Rν |O by walking
from a dummy tetrahedron in Del Rν which is assumed to
be at infinity, and marking tetrahedra appropriately by making a note each time we pass through a restricted triangle.
After the initial marking, subsequent markings (due to point
insertion/deletion) can be handled locally.
We prove that LocVol terminates. At termination we output p∈P Tp . Figures 2,6, and 7 show some examples.
Algorithm 3 LocVol(∂ O, κ , λ )
1: Initialize P and Initialize Q with a bounding box;
2: while Q is not empty do
3:
ν := Dequeue(Q);
4:
while (p, q) := Violation(∂ O, ν , λ ) is not null do
5:
s := InsertDelete(ν , p, q, λ )
6:
if s ∈ P then
7:
NodeEnqueue(ν , s, λ )
8:
end if
9:
if |Pν | ≥ κ then
10:
Split ν and enqueue its eight children to Q
11:
end if
12:
end while
13: end while
14: Return P and ∪ p Tp .

Each node in the octree represents a well-defined subset
of P, specifically a node represents its Rν = Pν Nν . It is
possible that when a point q ∈
/ P is inserted during the refinement of node ν , it changes the content of some Rν , ν = ν
through insertion or deletion, and so may affect the part of
the final output generated by ν . Then in order to maintain
consistency between the meshes of ν and others we must
/ P is inserted by
reprocess ν . Therefore, whenever some q ∈
node ν , we enqueue all nodes ν = ν within distance 2λ of
q. See Figure 5(bottom).
3.5. Algorithm LocVol
Our algorithm LocVol first encloses the input surface ∂ O
into a bounding box which becomes the root of the octree
subdivision. As in [DLS10], some points sampled from ∂ O
initialize P. The inner while loop (4-12) processes a node
ν assuming a routine Violation that checks for respective
violations of conditions in the priority order C1-C6.
When a node ν is not being processed, we maintain its
sample set Pν = P ν ⊆ P and a list of tetrahedra p∈Pν Tp .
This list is maintained to avoid recomputing the mesh in a
node while finalizing the output mesh. When ν is extracted
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

Figure 6: Buddha and Bimba with 718K and 661K tetrahedra respectively.

1422

Tamal K Dey & Andrew G Slatton / Localized Delaunay Refinement for Volumes

4. Guarantees
4.1. Termination
We use a standard packing argument that only finitely many
points can be inserted in a bounded domain with a fixed
lower bound on inter-point distances. The points inserted on
the boundary ∂ O satisfy the boundedness condition automatically. However, the circumcenters of tetrahedra that are inserted may lie outside the volume O, and hence potentially
threaten to populate an unbounded domain. Condition C4
prevents this by recalling a result from [ORY05, Lemma 1]:
If each Voronoi edge in Vor Rν either intersects ∂ O in a single point (transversally) or does not intersect it at all, then
∂ (Del Rν |O ) = Del Rν |∂ O . The conclusion means that the
surface triangulation Del Rν |∂ O also bounds the restricted
volume triangulation Del Rν |O whose tetrahedra necessarily
have their circumcenters in O by definition. Therefore, if we
access only those tetrahedra that lie in a volume bounded
by the restricted surface triangulation, we are ensured that
their circumcenters are in O. The algorithm LocVol precisely finds these tetrahedra at a time when condition C4 is
satisfied. Therefore, all points inserted by LocVol lie in a
bounded domain, namely in O.
The points inserted by LocVol are distinguished into two
classes, the surface points which lie on ∂ O and the volume
points which lie in the interior O \ ∂ O. Now we argue that
the algorithm terminates.
Assume that the algorithm does not terminate. Then we
have either an infinite number of deletions or an infinite
number of insertions; however, because we only delete when
we insert a surface point, one must have an infinite number
of surface insertions in order to have an infinite number of
deletions. Because we never delete surface points, an infinite
number of surface insertions implies that there is no fixed
lower bound on the distance between pairs of surface points.
We show that this is not the case. To facilitate discussion,
let us divide point pairs into three main classes: surfacesurface pairs (ss), surface-volume pairs (sv), and volumevolume pairs (vv). Each refinement criterion, directly or indirectly, implies a lower bound for the interpoint distances of
one or more of the above pair types, and this is the premise
of the proof of termination. Let dss , dsv , and dvv denote the
smallest inter-point distances in the current pair classes. Furthermore, let d¯ss , d¯sv , and d¯vv denote the new such distances
after a point insertion or deletion in any of the violations C1C6.
First, we argue the following implications:
• (C1) ⇒ d¯ss ≥ min{dss , λ }, d¯sv ≥ min{dsv , λ }
• (C2) ⇒ d¯ss ≥ min{dss , dsv /2, dvv /2} and d¯sv ≥
min{dsv , λ }
• (C3) ⇒ d¯ss ≥ min{dss , λ∂ O } and d¯sv ≥ min{dsv , λ }
• (C4) ⇒ d¯ss ≥ min{dss , λ ∗ } and d¯sv ≥ min{dsv , λ }
• (C5) ⇒ d¯sv ≥ min{dsv , λ } and d¯vv ≥ min{dvv , λ }.

• (C6) ⇒ d¯sv , d¯vv ≥ min{2dss , dsv , dvv }
min{dss , dsv , dvv }.

or

d¯ss ≥

Notice that during insertion InsertDelete either augments
Rν with an existing point s from P, or inserts a new point
q. When a new point q is inserted, its closest point p over
the global point set P lies in Rν . Also, because insertion
of a surface point causes the removal of all volume points
within a distance of λ of the inserted point, we have
d¯sv ≥ min{dsv , λ } for C1...C4. We argue for the other
implications in the following.
(C1): In this case we consider q because t has circumradius more than λ . The distance d(q, p) = d(q, P) is at least
λ providing the implication.
(C2): Consider the case where C2 is violated by a restricted triangle having at least one surface sample as a vertex. Then the inserted point q must be at least dsv /2 away
from all other points. If C2 is violated by a triangle having
no surface samples as vertices, then the inserted point must
be at least dvv /2 away from all other points. This leads to
d¯ss ≥ min{dss , dsv /2, dvv /2}.
(C3): Here we can argue as in [DLS10] that d(q, p) =
d(q, P) is at least a surface dependent constant λ∂ O .
(C4): When C4 is considered, condition C2 ensures that
f has all vertices on ∂ O. We can safely assume that f
has a circumradius smaller than any fixed positive constant,
say λ ∗ , since otherwise d(q, p) = d(q, P) > λ ∗ , and we are
done. Therefore, assume in particular that d(p, q) ≤ λ ∗ for
λ ∗ = 0.06lfsmin (p) where lfsmin (p) = min p lfs(p) is the minimum local feature size of ∂ O at p [AB99], and thus a surface dependent constant. The furthest intersection point of
the dual Voronoi edge of such a small triangle f with the
surface must lie at least lfs(p) away from p; see [Dey06,
Lemma 3.7]. It follows that d(q, P) > λ ∗ > lfsmin .
(C5): Since q in this case is the circumcenter of a tetrahedron with circumradius at least λ , d(p, q) = d(q, P) ≥ λ .
(C6): Recall that for a violation of C6, we insert the
Voronoi vertex q if it is not inside any surface Delaunay ball, and insert a surface point otherwise. In the former case, the circumradius r of the tetrahedron t being
split is more than 2 times its smallest edge. Then, r >
2 min{dss , dsv , dvv }. Since r = d(q, p) = d(q, P), we have
{d¯sv , d¯vv } ≥ min{2dss , dsv , dvv }. In the other case, when a
surface point is inserted, the surface Delaunay ball containing the circumcenter of t has a radius at least r/2. Then, we
have d¯ss ≥ r/2 ≥ 2 min{dss , dsv , dvv }/2 = min{dss , dsv , dvv }.
Theorem 1 LocVol terminates.
Proof. As we argued earlier, we need to show that finitely
many surface and volume points are inserted, or dss and dvv
have a positive lower bound. Observe that all steps maintain
a positive lower bound on dss except possibly C2 and C6.
In C2, it may decrease to half of dsv or dvv . But, dsv and
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

Tamal K Dey & Andrew G Slatton / Localized Delaunay Refinement for Volumes

dvv maintain a positive lower bound through all steps except
possibly in C6 where it may decrease to 2dss . But, then, a
possible cycle through C2 and C6 cannot decrease dss . This
implies a positive lower bound on dss through all steps. Since
dvv has a positive lower bound in every step except possibly
in C6 where it can be 2dss , we have the desired result.
4.2. Geometric and Topological Guarantees
Theorem 2 The output mesh of LocVol(∂ O,κ ,λ ) satisfies
the following two properties:
(i) The output mesh T = ∪ p Tp is a subcomplex of the
restricted Delaunay complex Del P|O with ∂ T a 2manifold. Each point in the output is at a distance λ from
O and each tetrahedron has radius-edge ratio at most 2.
(ii) There exists a λ ∗ > 0 so that if λ < λ ∗ , the output mesh
becomes isotopic to O with a Hausdorff distance O(λ 2 ).

1423

the global triangulation restricted to the surface, that is, S ⊂
Del P|∂ O . Let P denote the vertex set of S. Since P ⊆ P, we
have S ⊂ Del P |∂ O . Now consider a triangle f ∈ Del P |∂ O \
S. We claim that no such f exists when λ ≤ 0.06 f min proving that S = Del P |∂ O . When λ ≤ 0.06lfsmin , the restricted
triangles in Del P |∂ O around any point p ∈ P must make
a topological disk [BO05, CDRR07]. This disk is already
made by the triangles in S and there is no room for any extra
triangle such as f proving the claim.
Since S = ∂ T coincides with a restricted surface triangulation, the underlying space of ∂ T is isotopic to ∂ O when
λ ≤ 0.06lfsmin [BO05]. It follows from standard results in
piecewise linear topology that the underlying space of T
is isotopic to the volume O bounded by ∂ O. The bound of
O(λ 2 ) on Hausdorff distances between S and ∂ O also follows from the result in [BO05]. This completes the proof.

Proof. (i) We show that each tetrahedron t ∈ ∪ p Tp is a
restricted Delaunay tetrahedron in the global triangulation
Del P. Let t belong to Tp , where p is in the node ν . When ν
is processed for the last time, the circumscribing ball B of t
is empty of points in Rν since it is a Delaunay tetrahedron in
Del Rν . No points of P can lie inside B either. Since B has a
radius less than λ (condition C5), any such point would be
within 2λ distance of p ∈ ν and thus would be in Rν by definition. We claim that no point of P can be inserted in B after
the last time ν is processed because, assuming the contrary,
the point inserted inside B has to be generated by processing
another node ν after ν . In that case, ν would have a point
inserted within 2λ distance, as the B has radius at most λ .
This would cause ν to be enqueued and reprocessed. But,
this would contradict that ν had already been processed for
the last time.
Now we argue that S = ∂ T is a 2-manifold. Notice that
any triangle which is in ∂ T is a restricted Delaunay triangle f in Del Rν |∂ O for some node ν when ν is processed
for the last time. The restricted triangles incident to a point
p ∈ ν form a topological disk (condition C3). By an argument similar to the one used for tetrahedra, we can show
that these triangles remain restricted in the global triangulation Del P. Furthermore, they remain so when no volume
point is considered. Now we can argue as in [DLS10] to establish that triangles in S are consistent, that is, if a triangle
f ∈ S has vertices a, b, c, it appears in each surface star Fa ,
Fb , and Fc . In sum, the triangles incident to each vertex in S
form a topological disk (with each edge having exactly two
triangles). By a standard result in PL topology S must be a
2-manifold.
Since all tetrahedra in ∪ p Tp have circumcenters in O and
have radii no larger than λ , all points in ∪ p Tp lie within λ
distance of O. Condition C6 ensures that all tetrahedra in this
set have radius-edge ratio no more than 2. This completes the
proof of (i).
(ii) We have already shown that S is a subcomplex of
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

Figure 7: Lucy with 729K tetrahedra.

5. Experiments and Results
We have implemented LocVol using the Delaunay triangulation of CGAL [cga]. A number of experiments were conducted on a PC with 2.0GB of 667MHz RAM, 1.5GB swap
space, and a 2.8GHz processor running with Ubuntu 9.04.
In all tables, the parameter λ is expressed as a factor of the
smallest dimension of the bounding box of O. Its effect on
mesh size is illustrated in Figure 10.
It is worth noting that the times recorded herein are not
CPU times, but rather the total time elapsed from the beginning of the experiment to the end. We have elected to

Tamal K Dey & Andrew G Slatton / Localized Delaunay Refinement for Volumes

1424
model
Buddha
Buddha
Buddha
Buddha
Buddha
Buddha
Buddha
Buddha
Bimba
Bimba
Bimba
Bimba

λ
0.0075
0.0075
0.0075
0.0075
0.007
0.007
0.007
0.007
0.0065
0.0065
0.0065
0.0065

κ
2M
1M
500k
250k
2M
1M
500k
250k
2M
1M
500k
250k

#tets
7.90M
7.90M
7.91M
7.91M
*Abort
9.72M
9.72M
9.72M
7.75M
7.75M
7.75M
7.75M

mem
2616
1936
1001
730
*Abort
1945
1127
760
2616
1968
1330
766

time
12:25
3:30
5:30
5:35
*Abort
7:00
8:10
7:50
11:05
2:30
4:55
3:50

Table 1: Time(hr:min) and memory(MB) usage while varying κ . All experiments for κ ≤1M had 8 nodes except Buddha for λ = 0.007, κ = 250k, which had 36.

present this timing instead of CPU timing because the main
purpose of our algorithm is to scale better by avoiding memory thrashing.
5.1. Tuning κ
The parameter κ is the maximum number of points that any
one node is permitted to contain, and as such the number of
nodes required to maintain a given triangulation in LocVol
is heavily dependent on its value. There is a time-overhead
associated with the processing of each node; specifically, for
each node ν we must find its Nν , construct its Del(Nν Pν ),
and possibly check whether some simplices satisfy the refinement criteria that were already known to satisfy these
criteria at the end of some previous visit to ν or one of its
ancestors.

never significantly exceeds the capacity of main memory.
Such a selection minimizes overhead while avoiding frequent page swaps. The experimental data in Table 1 supports this hypothesis, showing κ = 1M to be the optimum
(from among the values tested) on our platform for various
input models. We also see that a change in 2M tetrahedra
(approx. 0.3M vertices) causes only a very small change in
peak memory. This indicates that the optimal κ is ‘nearly’
independent of mesh size (which is governed by λ ). But, of
course, as huge meshes occupy more memory even to store
only the vertex data structures, less memory becomes available for other purposes affecting the optimal κ value.
5.2. Scaling
Table 2 shows the experimental results of three comparable experiments (two using LocVol, one using CGAL’s
“mesh_polyhedral_domain" from CGAL 3.8, in release
mode with -O3 optimization) run on several input models.
One may notice that the LocVol experiments with κ = 2M
have only a single node, and thus they do not leverage the localization techniques of our algorithm, whereas the κ = 1M
shown here do make use of localization. A comparison of the
results of these two types of experiments then reveals something about the effects of incorporating localization into Delaunay refinements in general: namely that localization of an
implementation of Delaunay refinement conserves memory
and thereby attains a speedup (at least for large refinements)
over a non-localized implementation that is otherwise the
same.
The memory recorded for each experiment is the peak
memory footprint observed. We observe that the memory
requirements for our localized algorithm are lower than
those required by our non-localized implementation and the
CGAL demo for comparable experiments.

Buddha
60

LocVol (k=1M)
CGAL

Time (h)

50

Figure 8: 3Holes: Mesh quality is mostly impervious to κ
(κ = 4000, 500 from left to right).
This overhead favors the single-node case where κ ≥ |P|;
however, as the size of the triangulation increases so does
memory consumption, and when memory consumption significantly exceeds the available space in main memory, the
single-node case begins to slow due to frequent page swapping. It is reasonable to hypothesize that LocVol performs
optimally when κ is chosen maximally such that LocVol

40
30
20
10
0

4

6

8

10

12

Millions of Tetrahedra

14

16

Figure 9: Time plots to illustrate scaling.
5.2.1. Comparison to CGAL volume meshing
We selected CGAL’s “mesh_polyhedral_domain" demo for
comparison to LocVol for two reasons. First, we wanted to
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

Tamal K Dey & Andrew G Slatton / Localized Delaunay Refinement for Volumes

model
9HandleTorus
OctaHandles
Bracelet3
HoledRing
3Holes
Homer
Lucy
Bimba
Buddha

model
Buddha
Buddha
3Holes

λ
0.028
0.028
0.028
0.0032
0.0032
0.0032
0.0105
0.0105
0.00105
0.0042
0.0042
0.0042
0.0115
0.0115
0.00115
0.0085
0.0085
0.0085
0.007
0.007
0.007
0.0065
0.0065
0.0065
0.0075
0.0075
0.0075
λ
0.006
0.0065
0.0105

Version
LocVol: κ = 2M
LocVol: κ = 1M
CGAL
LocVol: κ = 2M
LocVol: κ = 1M
CGAL
LocVol: κ = 2M
LocVol: κ = 1M
CGAL
LocVol: κ = 2M
LocVol: κ = 1M
CGAL
LocVol: κ = 2M
LocVol: κ = 1M
CGAL
LocVol: κ = 2M
LocVol: κ = 1M
CGAL
LocVol: κ = 2M
LocVol: κ = 1M
CGAL
LocVol: κ = 2M
LocVol: κ = 1M
CGAL
LocVol: κ = 2M
LocVol: κ = 1M
CGAL

Version
LocVol: κ = 1M
LocVol: κ = 1M
LocVol: κ = 1M

#leaf nodes
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
1
8
-

#leaf nodes
8
8
8

#tets
7.65M
7.65M
7.14M
7.32M
7.32M
6.82M
7.46M
7.46M
6.95M
6.91M
6.90M
6.43M
7.80M
7.80M
7.26M
8.02M
8.02M
7.45M
7.50M
7.50M
6.98M
7.75M
7.75M
7.20M
7.90M
7.90M
7.33M

#tets
15.43M
12.14M
10.25M

#verts
1.26M
1.26M
1.18M
1.22M
1.22M
1.14M
1.25M
1.25M
1.17M
1.19M
1.19M
1.11M
1.26M
1.26M
1.18M
1.30M
1.30M
1.22M
1.25M
1.25M
1.16M
1.25M
1.25M
1.17M
1.27M
1.27M
1.19M
#verts
2.47M
1.95M
1.66M

mem (MB)
2598
1921
2240
2545
1943
2185
2592
1923
2213
2483
1941
2119
2574
1889
2241
2658
1914
2315
2576
1920
2212
2616
1968
2287
2616
1936
2292
mem (MB)
2005
1961
1912

1425
time (hr:min)
14:30
5:10
13:55
11:40
2:30
8:10
14:50
3:10
12:00
10:15
1:30
3:10
11:40
3:00
15:30
16:25
4:25
20:00
12:15
4:05
9:15
12:05
2:35
18:10
12:25
3:35
12:30
time (hr:min)
18:40
11:20
6:30

Table 2: Top table: Time and memory usage for different models for CGAL (CGAL 3.8, release mode, -O3 optimization) and
single- and multi-node mesh generation with LocVol. Bottom table: aborted CGAL experiments for which a comparable LocVol
terminates.

compare to a reputable meshing tool. Second, the method
employed by CGAL’s volume meshing tools is readily applicable to meshing volumes bounded by smooth surfaces,
and therefore appropriate for comparison to methods such
as LocVol that are geared toward meshing volumes bounded
by smooth surfaces.
We find that our implementation of the algorithm described herein achieves a considerable speedup over CGAL’s
“mesh_polyhedral_domain" demo. This is mainly due to
the memory swapping that occurs during the CGAL experiments, as they average 320 swaps/second while our localized
experiments average 10 swaps/second. Furthermore, we find
that there are some experiments that CGAL cannot complete
because the OS aborts them due to their memory requirements, but LocVol is able to complete comparable experic 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

ments (even with 15M tetrahedra) because its memory footprint for a reasonable value of κ is smaller. Bottom table
of Table 2 shows some examples of this. Figure 9 shows
the time plots comparing CGAL and LocVol, where one
may observe that after 5.5M, though the slope (which corresponds to the number of hours per tetrahedron) of LocVol’s
plot increases, its increase in slope is considerably less than
that of CGAL’s plot, showing that LocVol does indeed scale
better than CGAL.
6. Discussions
Our volume meshing algorithm has many notable features:
(i) it always guarantees a manifold output irrespective of the
choice of the scale parameter while ensuring shape quality
(radius-edge ratio) for all tetrahedra, (ii) it captures the input

1426

Tamal K Dey & Andrew G Slatton / Localized Delaunay Refinement for Volumes
[ACR03] A MENTA N., C HOI S., ROTE G.: Incremental constructions con BRIO. In Proceedings of the 19th Annual Symposium
on Computational Geometry (2003), pp. 211–219. 1
[ACSYD05] A LLIEZ P., C OHEN -S TEINER D., Y VINEC M.,
D ESBRUN M.: Variational tetrahedral meshing. ACM Transactions on Graphics 24, 3 (July 2005), 617–625. 1
[BO05] B OISSONNAT J.-D., O UDOT S.: Provably good surface
sampling and meshing of surfaces. Graphical Models 67 (2005),
405–451. 1, 7

Figure 10: Lion: Meshes with different resolutions and approximation quality can be produced by changing λ (λ =
0.2, 0.1, 0.025 from left to right).

topology and geometry when the scale parameter is sufficiently small, (iii) it scales well, (iv) it can lead to a possible
parallelization of the Delaunay refinements for smooth surfaces and volumes, and above all (v) it beats a state-of-the
art meshing tool by many folds for large meshes while not
sacrificing the mesh quality.
There is one limitation of our algorithm worth mentioning: the method cannot get rid of slivers, a notorious problem known for Delaunay refinement. Recently, optimization
techniques have been combined with Delaunay refinement
to suppress the occurrence of slivers in practice [TWAD09].
It would be an interesting exercise to investigate whether our
localized Delaunay refinement technique can be extended to
this approach.
Our algorithm is geared toward meshing volumes
bounded by smooth surfaces. Non-smooth volumes bounded
with piecewise smooth surfaces is a well known challenge in the meshing community. The algorithms proposed
in [CDR08,DL09] which leverage weighted Delaunay triangulations to protect non-smooth features have provable guarantees in meshing. We plan to investigate whether this approach can be adapted to incorporate our localized Delaunay
refinement framework.
Acknowledgments.
Most of the models used in this paper are taken from the
AIM@SHAPE repository. We acknowledge CGAL consortium for making the Delaunay triangulation code available
for experiments. The work on this research is partially supported by NSF grants CCF-0830467 and CCF-0915996.

[BO06] B OISSONNAT J.-D., O UDOT S.: Provably good sampling and meshing of Lipschitz surfaces. In Proceedings of the
22nd Annual Symposium on Computational Geometry (2006),
pp. 337–346. 1
[CDR08] C HENG S.-W., D EY T. K., R AMOS E. A.: Delaunay
refinement for piecewise smooth complexes. Discrete & Computational Geometry (2008). 1, 10
[CDRR07] C HENG S.-W., D EY T., R AMOS E., R AY T.: Sampling and meshing a surface with guaranteed topology and geometry. SIAM Journal on Computing 37 (2007), 1199–1227. 1,
7
[cga]

http://www.cgal.org. 1, 7

[Che89] C HEW L. P.: Guaranteed-quality triangular meshes.
Tech. Rep. Report TR-98-983, Department of Computer Science,
Cornell University, Ithaca, New York, 1989. 1
[Dey06] D EY T. K.: Curve and surface reconstruction : algorithms with mathematical analysis. Cambridge University Press,
New York, 2006. 6
[DL09] D EY T. K., L EVINE J. A.: Delaunay meshing of piecewise smooth complexes without expensive predicates. Algorithms 2 (2009), 1327–1349. 10
[DLS10] D EY T. K., L EVINE J. A., S LATTON A. G.: Localized Delaunay refinement for sampling and meshing. Computer
Graphics Forum 29 (2010), 1723–1732. 1, 2, 5, 6, 7
[ILSS06] I SENBURG M., L IU Y., S HEWCHUK J., S NOEYINK J.:
Streaming computation of Delaunay triangulations. ACM Trans.
Graphics 25, 3 (2006), 1049–1056. 1
[NCC04] NAVE D., C HRISOCHOIDES N., C HEW L.:
Guaranteed-quality parallel Delaunay refinement for restricted
polyhedral domains. Computational Geometry: Theory and
Applications 28 (2004), 191–215. 1
[ORY05] O UDOT S., R INEAU L., Y VINEC M.: Meshing volumes bounded by smooth surfaces. In Proceedings of the 14th
International Meshing Roundtable (2005), pp. 203–219. 1, 2, 6
[Rup95] RUPPERT J.: A Delaunay refinement algorithm for quality 2-dimensional mesh generation. Journal of Algorithms 18
(1995), 548–585. 1
[She98] S HEWCHUK J. R.: Tetrahedral mesh generation by Delaunay refinement. In Proceedings of the 14th Annual Symposium
on Computational Geometry (1998), pp. 86–95. 1
[TWAD09] T OURNOIS J., W ORMSTER C., A LLIEZ P., D ES BRUN M.: Interleaving Delaunay refinement and optimization
for practical isotroic tetrahedron mesh generation. ACM Trans.
Graphics 28 (2009). 1, 10

References
[AB99] A MENTA N., B ERN M.: Surface reconstruction by
voronoi filtering. Discrete & Computational Geometry 22
(1999), 481–504. 6
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.


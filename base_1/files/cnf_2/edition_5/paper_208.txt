DOI: 10.1111/j.1467-8659.2011.02056.x
Pacific Graphics 2011
Bing-Yu Chen, Jan Kautz, Tong-Yee Lee, and Ming C. Lin
(Guest Editors)

Volume 30 (2011), Number 7

Computing 3D Shape Guarding and Star Decomposition
W. Yu1 and X. Li ∗2
2

1 Department of Automation, Xiamen University, China
Department of Electrical and Computer Engineering, and Center for Computation and Technology,
Louisiana State University, USA. Email: xinli@lsu.edu

Abstract
This paper proposes an effective framework to compute the visibility guarding and star decomposition of 3D solid
shapes. We propose a progressive integer linear programming algorithm to solve the guarding points that can
visibility cover the entire shape; we also develop a constrained region growing scheme seeded on these guarding
points to get the star decomposition. We demonstrate this guarding/decomposition framework can benefit graphics
tasks such as shape interpolation and shape matching/retrieval.
Categories and Subject Descriptors (according to ACM CCS): I.3.3 [Computer Graphics]: Modeling—Geometric
Modeling

1. Introduction
The rapid advancement of 3D scanning techniques provides
massive geometric data sets nowadays with great ease. When
a geometric model has very big size, its direct computation
can be expensive; and when it has complex topology and
geometry, directly processing the entire model can be infeasible. A common strategy to tackle these difficulties is by
divide-and-conquer, which partitions the problem into solvable sub-domains. Effectively partitioning complex models
can benefit many computer graphics applications relying on
computationally expensive geometric processing.
This paper studies the shape partitioning based on visibility, i.e. star decomposition. It segments a 3D volumetric shape to a set of subregions, each of which is visible
from a guarding point (such a subregion is called a star
shape). It can be shown that a star-shaped subregion has
some good properties. For example, harmonic volumetric
parameterization can be constructed bijectively upon such
domain [XHH∗ 10]. In computer graphics and animation,
star decomposition can benefit many tasks such as shape
matching/retrieval, and morphing.
Surface segmentation, generally based on specific local
geometric properties of surface patches, has been thoroughly
examined (see survey papers [Sha08, APP∗ 07]). Partitioning 3D objects based on their volumetric properties, such as
convexity, symmetry, etc. have also been studied; however,
c 2011 The Author(s)
Computer Graphics Forum c 2011 The Eurographics Association and Blackwell Publishing Ltd. Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK
and 350 Main Street, Malden, MA 02148, USA.

less study has been conducted to the decomposition based
on visibility. Star-decomposition is closely related to a well
known art-gallery guarding problem. The gallery guarding
problem has been studied in computational geometry community on 2D planar domains and in 2.5D for terrain guarding. But “Very little is known about gallery guarding in three
dimensions” [BMKM05], especially for 3D free-form models, due to their much higher complexity.
The main contributions of this paper include:
• We develop an effective progressive integer linear programming (PILP) optimization paradigm to compute approximate optimal guarding of complex 3D free-form
domains;
• We present a region-growing algorithm to compute the
star-decomposition of a given 3D model, seeded from
guarding points computed in the PILP;
• We explore two direct applications of our proposed
guarding/decomposition framework: shape morphing
and shape matching.
2. Background and Related Work
2.1. Shape Guarding
We consider the following shape guarding problem in 3D.
A point g ∈ M is visible to another point p ∈ M if the line
segment gp entirely locates inside M. A region (shape) M is

2088

W. Yu & X. Li / Computing 3D Shape Guarding and Star Decomposition

called a star region (star shape) if there exists a point g ∈ M
that any point p ∈ M is visible to g; we call such a point g a
guarding point. All convex shapes are star shapes; but more
complicated shapes usually can not be visually covered by
a single guard so these regions are not star shapes. Given a
general solid shape M whose boundary ∂M is a closed surface, usually tessellated by a triangle mesh, we want to find
a smallest set of points G = {gi } inside M that every point
p ∈ ∂M is visible to at least one point in G.

regions become nice in a few steps. On the other hand,
popular surface segmentation techniques such as region
growing ([LHMR09],[CSAD04]), watershed ([MW99]), or
clustering ([STK02],[GG04]) algorithms are bottom-up approaches. These approaches start from a set of seeds, then
expand to include neighboring primitives (vertices, faces,
tetrahedra) until their unions cover the entire region.

Various versions of this problem are generally called art
gallery problems, which are known to be a famous difficult problem. Finding minimal guards has been shown to
be NP-hard for 2D polygons with holes [OS83], 2D simple polygons [LL86], and even 2D simple orthogonal polygons [SH95], using either vertex or point guards. Approximation algorithms have been studied in 1.5 ([BMKM05])
and 2D ([EHP06]) to get an close-to-optimal result in polynomial time complexity. Lien [Lie07] computes guarding for
3D point cloud data, approximating visibility using ε-view.
The algorithm is based on a randomized greedy approach.

Given a solid shape M, whose boundary is discretized by a
triangle mesh ∂M = {V, F}, where V = {v1 , v2 , . . ., vNV } are
vertices and F = { f 1 , f2 . . ., fNF } are triangle facets. Seeking
fewest necessary guarding points is challenging. Our algorithm is based on the following two intuitions. (1) As demonstrated in medical visualization, medial axes (skeletons) usually have desirable visibility to the shape (referred as the “reliability” of skeletons). The skeleton can guide camera navigation and ensure full examination of the organ. (2) Hierarchical skeletons can be effectively computed, progressively
reducing the size of the optimization problem and improving computation’s numerical efficiency and stability against
boundary perturbations or noise.

2.2. Shape Decomposition
Given a solid model M, represented by a tetrahedral mesh
{T,V }, where T is the set of tetrahedra and V is the set of all
the vertices, a decomposition is a partitioning of T into a set
of subregions Mi = {Ti ,Vi }, so that (1) Ti ⊂ T , (2) i Ti = T ,
and (3) Ti T j = ∅, i = j. If each subregion Ti is a star shape,
we call this partitioning a star decomposition.
Shape decomposition has been widely studied in computation geometry and graphics. In computation geometry,
different decomposition methods (e.g. Voronoi decomposition, convex decomposition, etc.) have been proposed; while
a thorough review on other types of decompositions is beyond the scope of this work, we refer readers to surveys
[CP94] and [Kei00]. In computer graphics and visualization,
surface segmentation has been studied for different applications such as object recognition, meshing, skeleton extraction. Two thorough surface segmentation surveys were given
in [APP∗ 07] and [Sha08], in both of which, segmentation
techniques are classified as surface-based methods (segmentation guided by surface properties of sub-surface-patches)
and part-based methods (segmentation guided by volumetric properties of sub-solid-regions).
General approaches for decomposition can also be classified into two categories: top-down methods, by iteratively
segmenting sub-parts to finer components; and bottom-up
methods, by iteratively gluing small elements/components
to larger parts. For example, the Approximate Convex Decomposition [LA06] is a top-down approach. It iteratively
measures the convexity of each (sub-)region M; if it fails to
satisfy the convexity criterion, we shall further cut it into
two sub parts M1 and M2 . The algorithm continues until all
sub-regions are convex enough. A difficult issue in top-down
methods is to find the suitable cut so that shapes of smaller

3. 3D Shape Guarding

Many effective skeletonization algorithms (see a great
survey [CSM07]) have been developed for 3D shapes. We
use the algorithm/software of [DS06] since it efficiently generates skeletons on medial-axis surfaces of the 3D shapes.
For the boundary triangle mesh ∂M with NF triangles and
the extracted skeleton with NK nodes, the guarding problem
can be converted to finding a minimal-size point set G from
this NK points, such that all NF boundary faces are visible to
G. Note that here we require each boundary triangle face is
visible to G. We define the visibility of a face as follows:
• Vertex Visibility: A point p ∈ M is visible to another point
q ∈ ∂M if the line segment pq connecting p and q is inside
M, namely, it only intersects ∂M on q: pq ∂M = {q}.
• Face Visibility: A triangle face f ∈ F is visible to a point
p if all its three vertices are visible to p.
The shape guarding problem can be approximated as finding G to guard all the boundary vertices, in which we will
only need the concept of vertex visibility. For the subsequent star decomposition purpose, to make each triangle of
the boundary surface on the sub-region fully visible, we shall
use the face visibility. Guarding all the faces of a region is
stronger (i.e. can require more guards) than guarding all the
vertices. When the triangle mesh is dense enough, face visibility well approximates the visibility in the continuous case.
3.1. Visibility Detection
A basic operation is to detect the visible region of a (skeleton) point p. Specifically, on the boundary surface ∂M =
{F,V}, we define the visibility region V (p) of an interior
point p to be the collection of all visible boundary triangles: V (p) = { f | f ∈ F, f is visible to p}. To compute V (p),
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

W. Yu & X. Li / Computing 3D Shape Guarding and Star Decomposition

one should check intersection between each line segment pvi
and ∂M, where vi ∈ V is a vertex. If intersection is detected
on a point q ∈ ∂M other than vi and the Euclidean distance
|pq| < |pvi |, then vi is not visible from p. Simply enumerating every pvi then detecting its intersections with every
triangle f ∈ F is time consuming: for a single skeleton point
p, it costs O(NV · NF ) = O(NV2 ) time to check its visibility
on NV vertices. We develop the following sweep algorithm
to improve the efficiency.
We create a spherical coordinate system originated at p. Each vertex vi ∈ V is represented as
pvi = (r(vi ), θ(vi ), ϕ(vi )), where r(vi ) ≥ 0, −π/2 <
θ(vi ) ≤ π/2, −π < ϕ(vi ) ≤ π. For every triangle
fi = (vi,1 , vi,2 , vi,3 ) ∈ F, 1 ≤ i ≤ NF , its max θ( fi ) can
be defined as θmax ( fi ) = max{θ(vi, j )}, 1 ≤ j ≤ 3, the
θmin ( fi ), ϕmax ( fi ), ϕmin ( fi ) can be defined similarly.
The segment ovk cannot intersect with a triangle f unless
θmin ( f ) ≤ θ(vk ) ≤ θmax ( f )
ϕmin ( f ) ≤ ϕ(vk ) ≤ ϕmax ( f ),

(1)

therefore we ignore triangles outside this range and only
check ones that satisfy this condition (denoted as active triangles).
The angle functions θ and ϕ are not continuously defined on a sphere. When a triangle f spans θ = π, we duplicate it to ensure that each θ of the original f is between
[θmin ( f ), θmin ( f ) + 2π) and θ of its duplicate is between
[θmax ( f ), θmax ( f ) + 2π), by adding or subtracting θ by 2π.
For each triangle f spans ϕ = π, we duplicate it in the same
way. Using θ(vi ) as the primary key and ϕ(vi ) as the secondary key, we then sort all line segments pvi . Then we
sweep all segments following the angle functions one by one
in an ascending order and check intersection between the
sweep line and all active triangles satisfying condition (1).
Specifically, we define a counter ci on every triangle f i .
Initially, ci = 0; when the segment pv, v ∈ f i is being processed, ci ← ci + 1. The following two cases indicate that
the sweep has not reached the neighborhood of the triangle
fi , and we do not need to check its intersection with line
segment pv:
ci = 0 →
ci > 3 →

θmin ( fi ) > θ(ov), or ϕmin ( fi ) > ϕ(ov);
θmax ( fi ) < θ(ov), or ϕmax ( fi ) < ϕ(ov).

Therefore we maintain a list L of active triangles { f i } whose
counters have 1 ≤ ci ≤ 3. When the sweep segment hits a
new triangle t j , we have c j = 1 and add t j into L; when a
counter c j = 3, we remove t j from L after processing the
current segment.
Given a skeleton point p, for a boundary triangle mesh
with NV vertices it takes O(NV log NV ) to compute and sort
angles of all segments. For each segment, if the size of
the active triangle list L is m, it takes O(m) intersectiondetecting operations. Therefore, the total complexity is
O(log NV + mNV ). The incident triangles around a vertex vi
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

2089

is usually very small: m < log NV . Therefore the algorithm
finishes visibility detection of p in O(NV log NV ) time. On a
skeleton containing NK nodes, it takes O(NK NV log NV ) precomputation time to know the visibility region for all nodes.
3.2. Greedy and Optimal Guarding
Once visibility regions for all skeletal nodes are computed,
the guarding problem can be converted into a set-covering
problem. Consider a set in which each element corresponds
to a face on the boundary; a skeleton node can see many
faces so it covers a subset of elements. We want to pick several skeleton nodes so that the union of their covered subsets is the entire set. The set-covering problem, shown to
be NP-complete [KKK83], can be formally defined as follows: given the universe V = {vi } and a family S of subsets
S j = {s j,k }, s j,k ∈ V , a cover is a subfamily C ⊂ S of sets
whose union is V . We want to find a covering C that uses the
fewest subsets in S. C indicates an optimal subset of skeletal
nodes that can guard the entire region. Skeletons generated
using medial-axis based methods with dense enough nodes
usually ensure S itself is a covering. This holds in all our experiments. If a coarsely sampled skeleton can not cover the
entire V , we further include all those invisible vertices into
the skeleton point set.
A greedy strategy for the set covering is as follows: iteratively pick the skeletal nodes that can cover the most
faces in V , then remove all guarded faces from V (and update S accordingly since the universe becomes smaller), until
V = ∅. Such a greedy strategy is quite effective and it yields
O(log n) approximation [Joh73] to the set covering problem.
An optimal selection can be computed by 0 − 1 programming, also called Integer Linear Programming (ILP). We assign a variable xi on each skeleton node pi : xi = 1 if pi is
chosen, and xi = 0 otherwise. The objective function to minimize is then ∑m
i=1 xi .
Every element should be visible, for ∀ f i ∈ F visible to
some skeletal nodes Pi = {p(i,1) , . . ., p(i,k)}, at least one node
in Pi should be chosen to ensure f i guarded. Thus we solve:
m

min ∑ xi , subject to

(2)

i=1

xi = 0, 1, and

∑

x j ≥ 1, ∀i ∈ {1, . . ., n},

(3)

j∈J(i)

where J(i) is the index set of nodes p j visible to fi .
The above optimization can be solved using branch-andbound algorithms. When the dimension is small (e.g. a few
hundreds to a few thousands), we can use the TomLab Optimization package [Hol98] to solve it efficiently.
3.3. Progressive Guarding
Directly solving optimal guarding is expensive, or prohibitive for big models. In contrast, greedy algorithm generates many unnecessary guards and is sensitive to local

2090

W. Yu & X. Li / Computing 3D Shape Guarding and Star Decomposition

Figure 1: Greedy (left) and PILP (right) Guarding of Centaur.
boundary geometric perturbations. Therefore, we propose
a progressive integer linear programming (PILP) framework using progressive mesh simplification and refinement [Hop96], adaptively combining ILP and multiresolutional refinement.
We progressively simplify the boundary mesh ∂M into
several resolutions ∂M i = {T i ,V i }, i = 0, . . ., m. On each
level we keep the problem size within the scale that ILP can
solve. The finest skeleton is re-sampled with joints preserved
and used for computation. In the coarsest level i = 0, we
solve the optimal guarding using ILP. Then we progressively
move to finer levels with more details. On each finer level i,
we greedily remove regions covered by existing guards computed in level i − 1, then again use ILP to find necessary new
guards. With we move toward finer level with increased details, new guards are added until the finest resolution ∂M m
is covered. On every new level, we also resolve a few least
significant existing guards (whose visibility region covers a
small area Area(V (p)) < εArea(M i )). We do not directly insert them into the current level’s guarding set Gi and do not
remove their covered boundary faces from the universe.
On each level, we also conduct four reduction operations
before ILP computation. These reductions significantly reduce the optimization problem size. Suppose we store the
visibility information in an incidence matrix A: ai j = 1 if the
skeletal node pi can see the face f j , and ai j = 0 otherwise.
Originally the A is |NK | × |NF |, and we apply the following
four rules to reduce the size of A:
1. If column j has only one non-zero element at row i, we
must pick pi in order to see v j . Therefore, add pi into
G, remove column j. Also, for all non-zero element aik ,
remove column k (since all vertices visible to pi are now
covered, and can be removed).
2. If row i1 has all its non-zero elements non-zero in row i2 ,
i.e. ai1 , j = 1 → ai2 , j = 1, then pi2 sees all vertices that pi1
can see, and we can remove the entire row i1 .
3. If column j1 has all its non-zero elements non-zero in
column j2 , i.e. ai, j1 = 1 → ai, j2 = 1, then guarding v j1
guarantees the guarding of v j2 , and we can remove the
entire column j2 .
4. If the matrix A is composed of several blocks, we partition A to several small matrixes {Ak }.
In step 4, since we remove faces that have been covered

Figure 2: Greedy vs PILP on 48 models in TOSCA dataset [TOS].
The x-axis lists the 48 models, the y axis indicates the necessary
guards computed. The blue bar indicates the PILP result and red
is the greedy result. PILP has similar computational performance
with the greedy approach, but generate better guarding (on average,
using 20% less guards).

by existing guards, remaining boundary faces could be partitioned to several connected-components far away from each
other. And these sub-components may be optimized separately, which significantly reduces optimization size.
This PILP scheme can efficiently compute the guarding
for large size 3D volumetric regions and generate a hierarchical guarding graph. The pipeline is fully automatic, and
furthermore, it has the following important advantages over
both the pure greedy strategy and global ILP optimization
(more statistical results are shown in Table 1 and Fig. 2).
Note that the tP in Table 1 does not include the progressive
mesh computation time. However, progressive mesh can be
computed efficiently. Simplifying a 10k mesh takes roughly
10 seconds. From our experiments, we can see that
• PILP is much faster than global ILP. Its computational
efficiency is improved for several orders of magnitude
over ILP on large-size geometric models, and can therefore handle massive data.
• With comparable speed to the greedy approach, PILP usually provides much better guarding solutions. Firstly, the
PILP guards number is smaller than the greedy approach;
secondly, the PILP guarding is hierarchical and therefore
is robust against geometric noise (Figure 1 shows an example. In PILP, global structure from coarser levels is stable under local refinement to new details).
In our experiments, we simplify the boundary mesh to the
coarsest level with 5k vertices for the first round ILP optimization. On each iteration, we refine to next level with additional 10k vertices. When the size of constraints is around
5k, and the size of variables (skeletal nodes) is around 1k,
the optimization takes 10-30 seconds to solve. We set the
significance threshold parameter to be ε = 10%.
Figures 1 shows an example of guarding the Centaur
model, where we can see the PILP guarding provides a stable
hierarchial guarding. The guards added in the finest level are
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

2091

W. Yu & X. Li / Computing 3D Shape Guarding and Star Decomposition

Figure 3: Visualizing Guarding of Models in TOSCA dataset.
Table 1: Guarding Statistics. NV is the boundary surface vertex

number. NI , NG , NP indicate the number of necessary guards computed by ILP, Greedy, and PILP approaches, respectively. t shows
the computational time in seconds. Guarding of big models cannot
be solved directly using ILP, so their statistics are not applicable.
Models (NV )
Greek (9,994)
David (9,996)
Female (10,002)
Male (10,002)
Cat (10,004)
Wolf (10,005)
Dog (15,002)
Victoria (15,000)
Horse (20,002)
Michael (20,002)
Gorilla (30,004)
Centaur (30,002)

NI
15
16
13
14
14
13
–
–
–
–
–
–

NG
22
22
18
16
19
18
39
35
38
46
60
52

NP
18
17
14
15
15
15
27
27
29
31
46
32

tI
4,122.4
107,391.2
2,046.2
3,074.3
3173
8044
–
–
–
–
–
–

tG
290.2
233.9
264.2
298.6
375.4
328.1
412.3
408.7
376.1
321.0
462.4
488.1

tP
293.1
235.2
281.1
310.2
393.1
349.9
433.2
421.2
384.2
332.9
490.1
514.5

colorized in green while the one computed on coarser level
are rendered in red. We perform extensive experiments on
our new algorithm. And it demonstrates great effectiveness.
More guarding results are visualized in Figure 3. Statistical
comparison is shown in Table 1; a more thorough comparison chart between greedy and PILP approaches on 48 models from the TOSCA dataset is depicted in Figure 2. As we
can see in this table and the chart, PILP has similar optimality as the ILP solution, but is much faster; while compared
with greedy approach, PILP has similar efficiency, but provides the guarding 20% better than that of greedy method on
average. Considering that the greedy approach is generally a
nice approximation for this problem, the guarding generated
by PILP is very nice.
Discussion. It should be noted that theoretically our algorithm solves an approximate optimal solution. In our current
computational framework, two aspects need to be considered on the approximation of the optimal guarding problem.
(1) We enforce the face visibility of the guarding. This can
be considered as an approximation to guarding all points on
the boundary. However, when the boundary surface mesh is
dense enough with respect to the geometry of the model,
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

Table 2: Skeletal-Nodes Guarding versus Tetrahedral-Vertices
Guarding. |V∂M | and |VM | are numbers of boundary vertices and
tetrahedral vertices, respectively; |S| is the number of nodes on extracted skeletons; |GVM | and |GS | are the sizes of computed guarding sets (solved by ILP) when using all tetrahedral vertices as candidates and using only skeletal nodes as candidates, respectively.
Models
Kitten
Beethoven
Bimba
Buddha
Bunny

|V∂M |
400
502
752
502
998

|VM |
1,682
2,895
5,115
3,002
8,320

|S|
122
88
139
155
270

|GVM |
3
2
2
2
5

|GS |
3
2
2
2
5

we usually can assume this guarding is accurate enough because it is unlikely to have a branch that blocks the interior
region of a face while leaving its all three vertices visible.
(2) We compute the guarding points from the curve skeleton. Because of this, our simplified problem setting is not
guaranteed to get the optimal solution. We perform experiments to evaluate whether using guarding candidates from
the skeleton leads to larger guarding point set. Table 2 shows
results of these experiments: guarding using skeletal candidates produces the same optimality compared with guarding
computed using all tetrahedral vertices. Therefore, our intuition of choosing guards from skeleton is experimentally
justified; our approximation is close to the optimal solution.
4. Star Decomposition
Guarding points are natural seeds to start region growing for
the star decomposition. The sweep algorithm (Section 3.1)
can be generalized to tetrahedral mesh vertices so that visibility among vertices and guards can be efficiently precomputed. We start region growing from all guards while
simultaneously preserving star-property on all subregions.
Given the tetrahedral mesh M = {T,V } where T and V are
the sets of tetrahedra and vertices, we start from the guarding
points G = {gi }, i = 1, . . ., Kg , and assign a specific colorvalue ci on each guard gi . We then grow the subregion surrounding gi , denoted as Mi , composed of tetrahedra assigned

2092

W. Yu & X. Li / Computing 3D Shape Guarding and Star Decomposition

with the unique color ci . At the end, the connected component Mi in color ci is a star shape guarded by gi . We can grow
sub-regions on the dual graph of the tetrahedral mesh using
the following notations and operations.
4.1. Definitions
Visibly Dependent Tetrahedral (VDT) Set. Similar to the
face visibility, we say that a tetrahedron is visible from a
guard gi if all its four vertices are visible from gi . Given
a guarding point gi and a tetrahedron t ∈ T , we define the
visibly dependent tetrahedral (VDT) set Tv (gi ,t) = {ti } as
the set that contains all the tetrahedra that one of the four ray
segments gi v j , ∀v j ∈ t passes through. When the tessellation
is dense and uniform enough, in the subregion Mi , t is visible
to gi if ∀t ∈ Tv (gi ,t) is visible to gi .
Neighboring VDT Set. We denote the one-ring faces surrounding a vertex v as Fn (v): Fn (v) = { f |∀t ∈ T, v ⊂ t, f ⊂
t, v ⊂ f }; and denote the neighboring tetrahedra of t as
Tn (t) = {t |t ∈ T, ∀v ⊂ t, Fn (v) ⊂ t }. Then we can define
the neighboring dependent tetrahedral set as the intersection
of Tv (gi ,t) and Tn (t): Tv (gi ,t) = Tv (gi ,t) ∩ Tn (t). Intuitively,
if we include all the tetrahedra in Tv (gi ,t) into the sub-region
Mi (i.e. subregion guarded by gi ), then all the triangles in
Fn (v j ) are in the interior of Mi , which guarantees the visibility of t from gi in Mi . It is not difficult to further show
that
a) t is visible if ∀t ∈ Tv (gi ,t) are visible.
b) t can be safely added into Mi while preserving Mi ’s starproperty, if all t ∈ Tv (gi ,t) are in Mi .
Directed Color-encoded Dual Graph. A directed dual
graph D of the given tetrahedral mesh can be defined in the
following way: (1) a node ni ∈ D is defined for each tetrahedron ti . (2) For a node ni visible from gk (with the color
ck ), we create a directed edge [n j , ni ] in color ck from a node
n j to ni if t j ∈ Tv (gk ,ti ); and we call n j a color-ck predecessor of ni . Since recursively, Tv (gk ,ti ) = Tv (gk ,ti ) ∪ Tv (gk ,t j ),
we only need to store each node’s Neighboring VDT set.
T˜v (gk ,ti ) can be computed in O(1) time by checking the intersections of gk , v and Fn (v) for each v ∈ ti . Finally, for each
guard gk we generate a virtual node in D and connect it to
nodes corresponding to all its one-ring tetrahedra. Then each
guard gk and its visible region defines a direct acyclic graph
Rk . The entire 3D region guarded by Kg points {gi } corresponds to a connected graph with Kg sources. Each source gi
has an individual color ci , the region growing assigns each
node a unique color. A node n j can be assigned by a color
c only when all its color-c predecessors are already assigned
by color-c.
Cost Function. For each node ni , we can compute how
many nodes are directly or indirectly visually dependent
on ni with respect to gk . This can be pre-computed in linear time: after the dependency graph Rk is created from the

(A) Rocker Arm

(C) Cat

(F) David

(B) Torus_Cone

(D) Centaur

(G) Greek

(H) Male

(E) Horse

(I) Female

Figure 4: Star Decomposition of Solid Models. Different subparts
are rendered in different colors.

source gk to leafs, inversely the dependency cost can be accumulated and stored as f (gk , ni ).
4.2. Star Decomposition through Region Growing
Region Growing. The region growing on the dual graph can
be applied using the node-merging. When there is a color-c
edge from a color-c node ni to an uncolored node n j , and
all edges entering n j are leaving from color-c nodes, then n j
can be safely colored by c. Therefore we can merge them
together to one node in color-c, preserving all distinct outgoing edges. The region growing procedure is converted to
iteratively merging each uncolored node to one of the Kg
growing colored nodes.
Nodes Merging. We merge uncolored nodes with colored
region based on the cost function f (g, n). A node shall merge
into a growing region that can see it and has biggest corresponding cost. This repeats until all nodes are colorized or
no node can be further merged. If a node cannot be given
the color of its any entering edges, it is left unclassified after the region growing. We collect each uncolored connected
components, and respectively compute their guarding and
re-apply the region growing until all tetrahedra are colored.
4.3. Discussion on Complexity and Implementations
For each guard, the preprocessing step computes the visibility dependency in O(mV log mV ), where mV is the numc 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

W. Yu & X. Li / Computing 3D Shape Guarding and Star Decomposition

2093

5.1. Shape Matching and Retrieval
We define a descriptor for a shape based on its guarding. The
descriptor has two parts: the guarding skeleton (or guarding
graph) G and histograms H defined on nodes.
The guarding graph G is a graph extracted following
the skeletal graph, whose nodes are the guarding point set
G = {gi }. At each guard gi , we compute a histogram H(gi )
storing the distances from gi to the object boundary surface
towards a set of sampling directions. Specifically, the histogram is constructed as follows. From each guarding point
p, we shoot rays {ri } towards all spatial directions defined
on a unit sphere. Each ray ri intersects with ∂M on a point
qi . The length of the line segment pqi is stored in the histogram Hp . This histogram captures the geometry near this
point. Fig. 5 illustrates the descriptor of the Greek sculpture.
Figure 5: Shape Descriptor of Greek Sculpture. Each histogram
stores distances from each guarding point to the boundary surface
along sampling directions.

ber of tetrahedral vertices. Computing the visibility dependency of one tetrahedral vertex v takes O(Kn ), where Kn
is v’s one-ring tetrahedra. Since Kn < log mV , the preprocessing time for each guard is O(mV log mV ). The region
growing can be finished in O(mT ), where mT is the number of tetrahedra. So the total decomposition complexity is
O(Kg mV log mV + mT ), where Kg is the number of guards.
For example, it takes about 550 seconds to perform the
star decomposition on solid David (175,079 tetrahedra, 17
guards), including 400 seconds in guarding computation.
Figure 4 illustrates our decomposition results on many solid
models.
The visibility dependency relationship is the sufficient
condition to guarantee the tetrahedron visibility. A tetrahedral sub-region that grows following this dependency relationship is guaranteed to be star-shaped. However, this constraint is stronger than necessary, especially when tetrahedral mesh is sparse, and some tetrahedra near inner partitioning boundary may not be considered acceptable during the
region growing. In practice, in order to include these tetrahedra, we release this constraint by accepting a tetrahedron
if two to three of its vertices are visible. Finally, we perform a Laplacian smoothing step on the inner-border of subregions after the region growing. This further moves these
interior tetrahedral vertices, and the smoothed boundary improves the decomposition result: more than 99% tetrahedral
vertices are visible from their corresponding guards.
5. Applications
Our proposed guarding and decomposition framework can
benefit many geometric processing tasks. In this section, we
demonstrate two direct applications in computer graphics:
shape matching and shape morphing.
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

The proposed descriptor has two good properties:
• Completeness. The geometry of the original shape can be
completely reconstructed from its descriptor. Distanceto-boundary distributions nicely capture geometry characteristic of the solid shape and are suitable for the
matching purpose. The guarding graph can visibly covers the entire region, so the shape descriptor is complete.
• Conciseness. The graph structure G has fewest necessary
nodes because the guarding is optimized. Therefore, descriptor matching is efficient.
5.1.1. Matching Shape Descriptors
To compare two 3D models M and M , we match their guarding graphs G = {G, EG } and G = {G , EG }, where vertex
sets G, G are guarding point set and edge sets EG , EG following the adjacency of the decomposition. We match them
by solving a deformation of one skeleton to fit the other. The
deformation is guided by a weighted energy EG (G, G ) composed of three terms: (1) the matching error EM on each
node, (2) the smoothness error ES on the deviation of the
transformations of two adjacent nodes, and (3) the lengthpreserving error EL on each edge. Formally, suppose we define the affine transformation φi on each node gi of the guarding graph G, then these three terms are:
EM = ∑gi ∈G D(φi (gi ), G )2 ,
ES = ∑[gi ,g j ]∈EG ||φi − φ j ||2 ,
EL = ∑[gi ,g j ]∈EG (||φi (gi ) − φ j (g j )|| − ||gi − g j ||)2 ,

(4)

where D(φi (gi ), G ) denotes the distance from the transformed point φi (gi ) to the guarding skeleton. In practice,
we integrate two costs: (1) geometric distance, approximated using the distance from φi (gi ) to its closest point
in G , and (2) topology distance, represented by the valence information of gi . Therefore each node is represented
as a 4-dimensional vector and the distance between two
nodes is computed using the L2 norm. During the optimization, this shortest distance can be efficiently recomputed using a k-d tree data structure. In ES , the ||φi − φ j ||2 is the

2094

W. Yu & X. Li / Computing 3D Shape Guarding and Star Decomposition

Figure 6: Shape retrieval experiment conducted in the TOSCA dataset of 48 models. Black indicates better similarity. Those blocks of black
regions indicate the following groups are more similar: {cats, dogs, wolves}, {David,Michael,Victoria}, {horses,centaurs}, and ect.

L2 norm of the transformation matrix φi − φ j . In EL , the
||gi −g j ||, ||φi (gi )−φ j (g j )|| denote the distance between adjacent points before and after the transformation.
The final objective function EG (G, G ) is a quadratic
weighted sum of these cost functions:
EG (G, G ) = α1 EM + α2 ES + α3 EL ,

(5)

where in our experiments we set α1 = 0.1, α2 = 1, α3 = 1.
We compute transformations defined on all the nodes by
minimizing EG (G, G ); the solution is a non-rigid mapping
between G and G . The quadratic optimization can be solved
efficiently.
After the transformation is computed, we add in the histogram matching error
EH =

∑

gi ∈G

||H(gi ) − H(g j )||2 ,

where we set α4 = 0.5.

5.1.2. Shape Retrieval
For all the shapes in the database we can pre-compute their
guarding graphs and node histograms as their descriptors.
Given a new object we compute its descriptor, then match
it with existing descriptors following the above approach.
The descriptor with the smallest matching error indicates
the most similar object in the database. We perform shape
matching and comparison on the TOSCA dataset. The comparison results are illustrated in Fig. 6, where black indicates
small difference. The black blocks in this figure indicates
several groups of models, although in different postures,
share better similarity. For examples, cats−dogs−wolves,
David−Michael−Victoria, horses−centaurs, and ect.
5.2. Shape Morphing

where g j denotes the closest point in G under the previous
matching. The difference between two histograms is again
measured using the L2 norm. The shape matching energy is
E(M, M ) = EG + α4 EH ,

Finally, we use the symmetric energy (E(M, M ) +
E(M , M))/2 as the shape distance between M and M .

(6)

Given the source surface M1 and target M2 , we want to compute an interpolation M(t), 0 ≤ t ≤ 1, M(0) = M1 , M(1) =
M2 . Interpolation between M1 and M2 can be generated
through the consistent guarding. Consistent guarding of M1
and M2 are two isomorphic graphs G1 and G2 , such that G1
(G2 ) guards M1 (M2 ) respectively. The consistent guarding
{G1 , G2 } can be computed in three steps:
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

2095

W. Yu & X. Li / Computing 3D Shape Guarding and Star Decomposition

compute the Jacobian of the affine transformation AT :
 x
−1
y
y
p1 − gxS1 p1 − gS1 pz1 − gzS1
y
y
AT =  px2 − gxS1 p2 − gS1 pz2 − gzS1 
y
y
x
x
p −g
p3 − gS1 pz3 − gzS1
 3x Sx1

y
q1 − gS2 q1 − gyS2 qz1 − gzS2
y
y
·  qx2 − gxS2 q2 − gS2 qz2 − gzS2 
y
x
x
q3 − gS2 q3 − gyS2 qz3 − gzS2
y

Figure 7: Shape Morphing. The top row shows the source and target shapes. The lower row shows the 50% shape interpolation.

1) Compute cross-surface parameterization
fM :
M1 → M2 using surface mapping techniques (e.g.
[LBG∗ 08][LGQ09]);
2) Extracting compatible skeletons (e.g. [ZST∗ 10]) that bijectively corresponds the first curve skeleton C1 (of M1 )
to the second skeleton C2 (of M2 ), fC : C1 → C2 ;
3) Solve PILP simultaneously. We say vi ∈ M1 and
fM (vi ) ∈ M2 are simultaneously visible to p j ∈ C1 and
fC (p j ) ∈ C2 , if both vi is visible to p j and f1 (vi ) is visible to f2 (p j ).
The solution found in Step-3 is two consistent guarding
sets {G1 , G2 }. Gi may contain more guards than necessary
to cover Mi , but the guarding points and their images consistently cover both models. This consistent guarding can generate consistent star decomposition which can benefit many
applications. An example is shape interpolation.
Conventionally, shape morphing can be generated by linear interpolation: given inter-surface mapping f M : M1 →
M2 , the morphing for each vertex is generated by linear interpolation between v1 ∈ M1 and its image fM (v1 ) ∈ M2 :
v(t) = (1 − t)v1 + tv2 .
With star decomposition, we can interpolate the corresponding regions to generate the morphing. A similar idea
in 2D, based on star decomposition for 2D polygons and the
interpolation of polar coordinates, is introduced in [SR95].
However, directly generalizing this to 3D by interpolating
the spherical coordinates does not work well. We break the
interpolation into the rigid part and the non-rigid part.
Rigid part. After the consistent star decomposition, we
get the consistent surface segmentation {S1 , S2 }, for each
subregion with m triangles {P1 , P2, P3 , . . ., Pm} in S1 , there
is a corresponding triangle set in S2 , {Q1 , Q2 , Q3 , . . ., Qm },
y
y
their guards are gS1 = (gxS1 , gS1 , gzS1 ) and gS2 = (gxS2 , gS2 , gzS2 )
respectively, for each corresponding triangle pair P, Q, we
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

where P = {p1 , p2 , p3 }, pi = (pxi , pi , pzi ), i = 1, 2, 3 is the
the coordinates of the ith vertex of triangle P. Given a
t, 0 < t < 1, we interpolate the Jacobian by polar decomposition [ACOL00]. Since a vertex may be shared by several triangle pairs, each triangle pair has a transformation, to
keep the mesh consistent during the interpolation, we compute the interpolation vertex i position vir (t) by minimizing
the quadratic error between the actual Jacobian and the desired ones, as stated in [BBA08].
Non-rigid part. Excluding the rigid part transformation,
we use a linear interpolation to blend the non-rigid deformation. For vertex i we compute the vin (1) = viM2 − vir (1),
where viM2 is the target position, vir (1) is the rigid transformed position. Then we compute the non-rigid position
vin (t) = tvin (1). So the final interpolated position of vertex
i is vi (t) = vir (t) + vin (t).
Compared with linear interpolation and the as-rigid-aspossible interpolation [BBA08] directly computed globally,
our morphing based on star-decomposition could lead to less
self-intersection and therefore generate more natural interpolation: A comparative example is shown in Figure 7. The
source and target models are shown in the first row. In the
second row, from left to right, the 50% morphing generated by linear interpolation, global center-driven as-rigid-aspossible interpolation, and our as-rigid-as-possible interpolation based on star decomposition are illustrated. Our result
is natural, especially can be seen at regions in red circles.
6. Conclusion and Future Work
In this paper we present an efficient progressive integer linear programming scheme to compute 3D shape guarding and
star-decomposition. The proposed method is efficient and robust, which is demonstrated by extensive experiments. We
also explore its effective computer graphics applications in
shape retrieval and shape morphing.
Skeleton shape and skeletal nodes sampling are important
for our guarding compaction. We will develop greedy or optimization strategies to further adjust them during the guarding computation. We will also improve our shape matching
algorithm, and explore new applications of guarding and star
decomposition.
7. Acknowledgements
This work is partially supported by Louisiana Board of
Regents Research Competitiveness Subprogram (RCS)

2096

W. Yu & X. Li / Computing 3D Shape Guarding and Star Decomposition

LEQSF(2009-12)-RD-A-06, LA Board of Regents
PFund:NSF(2011)-PFund-236, and LSU Faculty Research Grant 2010. Part of the work was done when the first
author was a visiting student at Center for Computation and
Technology, LSU.
References
[ACOL00] A LEXA M., C OHEN -O R D., L EVIN D.: As-rigid-aspossible shape interpolation. In Proceedings of the 27th annual
conference on Computer graphics and interactive techniques
(2000), SIGGRAPH ’00, pp. 157–164. 9
[APP∗ 07] A GATHOS A., P RATIKAKIS I., P ERANTONIS S., S A PIDIS N., A ZARIADIS P.: 3d mesh segmentation methodologies
for cad applications. Computer-Aided Design 4, 6 (2007), 827–
841. 1, 2

[LBG∗ 08] L I X., B AO Y., G UO X., J IN M., G U X., Q IN H.:
Globally optimal surface mapping for surfaces with arbitrary
topology. IEEE Trans. on Visualization and Computer Graphics 14, 4 (2008), 805–819. 9
[LGQ09] L I X., G U X., Q IN H.: Surface mapping using consistent pants decomposition. IEEE Transactions on Visualization
and Computer Graphics 15, 4 (2009), 558–571. 9
[LHMR09] L AI Y.-K., H U S.-M., M ARTIN R. R., R OSIN P. L.:
Rapid and effective segmentation of 3d models using random
walks. Comput. Aided Geom. Des. 26, 6 (2009), 665–679. 2
[Lie07] L IEN J.-M.: Approximate star-shaped decomposition
of point set data. In Eurographics Symposium on Point-Based
Graphics (2007). 2
[LL86] L EE D. T., L IN A. K.: Computational complexity of art
gallery problems. IEEE Trans. Inf. Theor. 32, 2 (1986), 276–282.
2

[BBA08] BAXTER W., B ARLA P., A NJYO K.: Rigid shape interpolation using normal equations. In Proc. Non-Photorealistic
Animation and Rendering (2008). 9

[MW99] M ANGAN A. P., W HITAKER R. T.: Partitioning 3D surface meshes using watershed segmentation. IEEE Transactions
on Visualization and Computer Graphics 5, 4 (1999), 308–321.
2

[BMKM05] B EN -M OSHE B., K ATZ M. J., M ITCHELL J. S. B.:
A constant-factor approximation algorithm for optimal terrain
guarding. In Proceedings of the sixteenth annual ACM-SIAM
symposium on Discrete algorithms (2005), pp. 515–524. 1, 2

[OS83] O’R OURKE J., S UPOWIT K.: Some np-hard polygon decomposition problems. Information Theory, IEEE Transactions
on 29, 2 (mar 1983), 181 – 190. 2

[CP94] C HAZELLE B., PALIOS L.: Decomposition algorithms
in geometry. Algebraic Geometry and Its Applications (1994),
419–447. 2
[CSAD04] C OHEN -S TEINER D., A LLIEZ P., D ESBRUN M.:
Variational shape approximation. In ACM SIGGRAPH (2004),
pp. 905–914. 2
[CSM07] C ORNEA N., S ILVER D., M IN P.: Curve-skeleton
properties, applications, and algorithms. Visualization and Computer Graphics, IEEE Transactions on 13, 3 (may. 2007), 530
–548. 2
[DS06] D EY T., S UN J.: Defining and computing curve-skeletons
with medial geodesic function. In Proc. Eurographics Symp. on
Geometry Processing (2006), pp. 143–152. 2
[EHP06] E FRAT A., H AR -P ELED S.: Guarding galleries and terrains. Inf. Process. Lett. 100, 6 (2006), 238–245. 2
[GG04] G ELFAND N., G UIBAS L. J.: Shape segmentation using
local slippage analysis. In Proc. Symposium on Geometry processing (2004), pp. 214–223. 2
[Hol98] H OLMSTROM K.: Tomlab – a general purpose, open matlab environment for research and teaching in optimization, 1998.
3

[SH95] S CHUCHARDT D., H ECKER H.-D.: Two np-hard artgallery problems for ortho-polygons. Mathematical Logic Quarterly 41, 2 (1995), 261–267. 2
[Sha08] S HAMIR A.: A survey on mesh segmentation techniques.
Computer Graphics Forum 27, 6 (2008), 1539–1556. 1, 2
[SR95] S HAPIRA M., R APPOPORT A.: Shape blending using the
star-skeleton representation. Computer Graphics and Applications, IEEE 15, 2 (mar 1995), 44 –50. 9
[STK02] S HLAFMAN S., TAL A., K ATZ S.: Metamorphosis of
polyhedral surfaces using decomposition. In Computer Graphics
Forum (2002), pp. 219–228. 2
[TOS]

TOSCA(T OOLS

SHAPE
COM 3D D ATASETS :
http://tosca.cs.technion.ac.il/book/resources_data.html. 4
PARISON

AND

FOR
ANALYSIS )

NON - RIGID
P ROJECT

[XHH∗ 10] X IA J., H E Y., H AN S., F U C.-W., L UO F., G U X.:
Parameterization of star-shaped volumes using green’s functions.
In Geometric Modeling and Processing (2010), pp. 219–235. 1
[ZST∗ 10] Z HENG Q., S HARF A., TAGLIASACCHI A., C HEN B.,
Z HANG H., S HEFFER A., C OHEN -O R D.: Consensus skeleton
for non-rigid space-time registration. Computer Graphics Forum
29, 2 (2010), 635–644. 9

[Hop96] H OPPE H.: Progressive meshes. In SIGGRAPH (1996),
pp. 99–108. 4
[Joh73] J OHNSON D. S.: Approximation algorithms for combinatorial problems. In STOC ’73: Proceedings of the fifth annual
ACM symposium on Theory of computing (New York, NY, USA,
1973), ACM, pp. 38–49. 3
[Kei00] K EIL J. M.: Polygon decomposition. Handbook of Computational Geometry (2000). 2
[KKK83] K AHN J., K LAWE M., K LEITMAN D.: Traditional galleries require fewer watchmen. SIAM Journal on Algebraic and
Discrete Methods 4, 2 (1983), 194–206. 3
[LA06] L IEN J.-M., A MATO N. M.: Approximate convex decomposition of polygons. Computational Geometry 35, 1-2
(2006), 100–123. Special Issue on the 20th ACM Symposium
on Computational Geometry. 2
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.


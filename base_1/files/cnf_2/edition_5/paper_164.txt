DOI: 10.1111/j.1467-8659.2011.02031.x
Eurographics Symposium on Geometry Processing 2011
Mario Botsch and Scott Schaefer
(Guest Editors)

Volume 30 (2011), Number 5

Skeleton computation of orthogonal polyhedra
J. Martinez1 , M. Vigo1,2 and N. Pla-Garcia1,2
1 Polytechnical

University of Catalonia (UPC). Barcelona. Spain
Institute of Catalonia (IBEC). Barcelona. Spain

2 Bioengineering

Abstract
Skeletons are powerful geometric abstractions that provide useful representations for a number of geometric operations. The straight skeleton has a lower combinatorial complexity compared with the medial axis. Moreover,
while the medial axis of a polyhedron is composed of quadric surfaces the straight skeleton just consist of planar
faces. Although there exist several methods to compute the straight skeleton of a polygon, the straight skeleton of
polyhedra has been paid much less attention. We require to compute the skeleton of very large datasets storing
orthogonal polyhedra. Furthermore, we need to treat geometric degeneracies that usually arise when dealing with
orthogonal polyhedra. We present a new approach so as to robustly compute the straight skeleton of orthogonal
polyhedra. We follow a geometric technique that works directly with the boundary of an orthogonal polyhedron.
Our approach is output sensitive with respect to the number of vertices of the skeleton and solves geometric degeneracies. Unlike the existing straight skeleton algorithms that shrink the object boundary to obtain the skeleton,
our algorithm relies on the plane sweep paradigm. The resulting skeleton is only composed of axis-aligned and
45◦ rotated planar faces and edges.
Categories and Subject Descriptors (according to ACM CCS): Computer graphics [I.3.5]: Computational Geometry
and Object Modeling—

1. Introduction
One of the challenges of the BioCAD field is to understand
the morphology of the pore space of bone, biomaterials,
rocks, etc. There exist several approaches that obtain a network with pores and connections between them [VAGT08]
or that characterize plate and rod elements [SM06], which
rely on a previous computation of a surface skeleton.
In this work we follow a geometric approach to compute
the skeleton of orthogonal polyhedra. We have chosen this
approach because geometric methods perform fewer steps
compared to thinning methods, as they do not need to work
at voxel level. As real datasets obtained from µCT tend to
be very large, computing their skeleton with thinning approaches is very time consuming. We require a robust and
fast algorithm that extracts a skeletal representation with low
combinatorial complexity.
We compute the Voronoi Diagram [Aur91] with the L∞
distance (V D∞ ) of the input orthogonal polyhedron that coincides with the straight skeleton [AAAG95]. Our method
relies on a sweep-line scheme applied to orthogonal polygons [MVPGA10] that we extend to three dimensions. Furc 2011 The Author(s)
Computer Graphics Forum c 2011 The Eurographics Association and Blackwell Publishing Ltd. Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ,
UK and 350 Main Street, Malden, MA 02148, USA.

thermore, our algorithm is capable of dealing with any kind
of geometric degeneracies that commonly arise in orthogonal polyhedra.
2. Related work
The most well-known skeletal representation is the medial
axis introduced by Blum [Blu67]. One way to define the medial axis is as the locus of centres of maximally inscribed
balls. The medial axis is a subset of the Voronoi diagram under the Euclidean metric [Kir79]. The combinatorial complexity of the Voronoi diagram of a polyhedron is high. The
best known upper bound on the combinatorial complexity
is O n3+ε for any positive ε, where n is the number of
faces, edges and vertices of the polyhedron [SA95]. The medial axis of an object is homotopically equivalent to the object [Lie03]. The medial axis of a polyhedron is a piecewise
algebraic surface composed of quadric surfaces.
Methods to compute the medial axis can be classified into
three main families: thinning, distance field and geometric
methods [CS07]. Most of them that apply to discretized data,
e.g., images or volumes, are based on thinning and distance

1574

J. Martinez, M. Vigo & N. Pla-Garcia / Skeleton computation of orthogonal polyhedra

field approaches. Thinning methods consist of iteratively removing points from the object boundary without changing
its topology [LLS92]. Distance field approaches rely on the
previous computation of the distance field [JBS06]. These
methods are linear in the number of voxels. Geometric methods are generally applied to polygons and polyhedra and are
commonly based on the Voronoi diagram.
Several geometric algorithms have been proposed to compute the medial axis of a polyhedron. In [Mil93] a calculation of all the points equidistant to four features allows to
reconstruct the Voronoi diagram of polyhedra. Held [Hel94]
propose a wavefront propagation algorithm only suitable for
convex polyhedra. Sherbrooke et al. [SPB96] uses a tracing classification scheme. The vertices of the medial axis are
connected by tracing the adjacent edges, and the faces of
the medial axis are found by traversing closed loops of vertices and edges. A similar approach uses exact arithmetic and
works using algebraic curves and surfaces [CKM04]. A divide and conquer approach is described in [SRX07]. As the
computation proceeds a dual structure of the shape is broken
up into pieces each representing a simpler part of the medial
axis.
The medial axis is highly sensitive to small changes in
shape boundary [ABE09]. Geometric algorithms for computing approximate representations of the medial axis try
to reduce this instability to noise and high combinatorial
complexity. Brandt and Algazi [BA91] showed that the Delaunay triangulation of a sufficiently dense set of samples
contains a reconstruction of the boundary as a subset of its
edges. Attali and Montavert [AM97] showed that a three dimensional shape can be approximated by a finite union of
balls. Amenta and Kolluri [AK01] noticed that, given a sample of points on boundary shape, the union of a subset of
the Voronoi balls approximates the original shape. The medial axis can also be approximated directly from the Voronoi
diagram [DZ02]. The use of the Delaunay triangulation to
obtain the skeleton was also explored [SAR95]. Etzion and
Rappoport [ER99] construct the Voronoi diagram of a polyhedron by separating the computation of the symbolic and
geometric parts of the Voronoi diagram. In some applications, an approximated skeleton with only one dimensional
geometry is required [DS06]. Foskey et al. [FLM03] and
Sud et al. [SFM05] compute a simplified medial axis that
rely on the angle formed by the medial axis and its closest
neighbours on the surface. Chazal and Lieutier [CL05] proposed the λ-medial axis, that contains the set of medial axis
points whose closest neighbours on the boundary cannot be
enclosed in a ball smaller than a global threshold parameter
λ. Recently, Giesen et al. [GMPW09] introduced the scale
axis transform that is based on the medial axis transform and
the simplification of the shape under multiplicative scaling in
order to capture the relevant features.
An alternative skeletal representation to the medial axis
is the straight skeleton [AAAG95]. While the medial axis is

defined using a distance function, the straight skeleton relies
on a shrinking process in which the edges of the polygon are
moved inwards, parallel to themselves at a constant speed.
Each vertex moves along the angular bisector of its incident
edges. The straight skeleton of a polygon is only composed
of straight line segments, while the medial axis of a polygon
may involve parabolic curves. Eppstein and Erickson [EE99]
propose an algorithm to compute the straight skeleton that
simulates a sequence of collisions between edges and vertices during the shrinking process, using a complex technique for maintaining extrema of binary functions [Epp98].
Recently Das et al. [DMN∗ 10] introduced a deterministic
algorithm for computing the straight skeleton of monotone
polygons in O (n log n).
The straight skeleton formulation can be extended to polyhedra. It can be defined in terms of an offset process in which
the faces move inward at a constant speed. The sequence
of collisions between features of the polyhedron define the
skeleton. In three dimensions, the straight skeleton is composed of points, edges and planar faces. The combinatorial
complexity of the straight skeleton of orthogonal polyhedra
is O n2 , where n is the number of vertices [BEGV08].
Note that the straight skeleton has a lower combinatorial
complexity compared with the medial axis.
Definition 1 The L∞ distance between two points (p, q),
with coordinates pi and qi , is D∞ (p, q) = max (|pi − qi |).
i

In three dimensions the L∞ distance corresponds to the side
length of the smallest isothetic cube touching p and q.
Definition 2 The Voronoi diagram of polyhedron P under
the L∞ metric (V D∞ ) is a subdivision of the space into
cells, such that the cell associated with a face f ∈ P comprises the points in space for which f is closer under the L∞
metric than all other faces of P. The V D∞ of a polyhedron
in general position decomposes the space in a set of planar
faces, edges and vertices L∞ equidistant to two, three and
four features of the polyhedron respectively.
Property 1 The straight skeleton of an orthogonal polyhedron P coincides with the V D∞ of the interior of P.
To the best of our knowledge the only algorithm that addresses the construction of straight skeletons of polyhedra
was presented by Barequet et al. [BEGV08]. Their method
relies on a shrinking of the object boundary and it is restricted to polyhedra in general position. In the case of orthogonal polyhedra, they compute for each pair of features
the time at which the interaction would happen. The algorithm has O n2 log n time complexity, where n is the
number of vertices of the polyhedron. A more complex output sensitive algorithm that uses orthogonal range searching
techniques is outlined in their paper.
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

J. Martinez, M. Vigo & N. Pla-Garcia / Skeleton computation of orthogonal polyhedra

3. Algorithm overview
Sweep-line algorithms move a line across the plane, stopping at certain event points. Geometric operations are restricted to geometric objects that either intersect or are in the
immediate vicinity of the sweep line whenever it stops, and
the complete solution is available once the line has passed
over all objects. A sweep-line algorithm used to extract the
Voronoi diagram of a set of points under the Euclidean metric was introduced by Fortune [For87]. Papadopoulou and
Lee [PL01] presented a sweep-line approach to compute
the V D∞ of planar straight graphs that is strongly connected with our algorithm. We extend to three dimensions
the sweep-line approach by considering a sweeping plane instead of a line. Our technique involves extracting the V D∞
of orthogonal polyhedra by a sweeping process.
Let P be an orthogonal polyhedron with axis-aligned
faces. Let L be the sweep plane perpendicular to the z-axis
(z = t). Our sweep process is done by decreasing the value
of t.
Definition 3 At any moment t of the sweeping process, L
partitions the set of faces, edges and vertices of P into three
subsets: At corresponds to those that lie fully above of L, It
corresponds to those that intersect L, and Bt corresponds to
those that lie fully below of L. Ct is composed of the portion
of It that lies above L. Lt is the set of faces of P contained in
L plus the portion of L that belongs to the interior of P.
The invariant is that at every instant t of the sweeping process the V D∞ of At ∪Ct ∪ Lt is computed.
Definition 4 A ray is a half-line that corresponds to a
Voronoi edge e of the V D∞ , with its origin in a Voronoi
vertex or a vertex of P. The end of the Voronoi edge e remains to be calculated. We say that a ray is closed when the
remaining vertex of e is calculated. A ray is the bisector defined by three oriented faces of P. We consider that two rays
are equivalent if they are defined by the same three faces.
Property 2 Four axis-aligned faces define a cube if two of
them share the same orthogonal direction, have opposed orientation, define a bisector, and the other two faces correspond to the two remaining orthogonal directions.
The sweep plane L stops whenever a new event is found. The
events are ordered according its priority. The priority of an
event is given by the lexicographical order of its position.
Two different types of events may occur during the sweep
(see Figure 1):
• Vertex event: Corresponds to a vertex v of P and a ray
associated to v. There can be more than one vertex event
per vertex, because more than one ray may emanate from
a vertex (see Section 4). The priority of a vertex event is
defined by the position of the vertex.
• Junction event: Corresponds to the centre of a cube
touching four faces of P (see Property 2). A junction
event is valid if it corresponds to a Voronoi vertex of
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

1575

V D∞ . The priority of a junction event is given by the vertex of its cube that have the lowest lexicographic priority.

Vertex
Junction
Wavefront
Ray
z

Figure 1: Straight skeleton computation of a rectangular box.
L shown in grey and moving down.
If the priority of a vertex event and a junction event coincide, the vertex event is processed first. If two junction events
have the same priority, the junction event whose cube has the
bigger side length is processed first. If two vertex events have
the same priority or the input polyhedron is not in a general
position this criterion will fail to sort the events. We propose a technique to treat geometric degeneracies based on
a simulated perturbation that produces a valid sequence of
events (see Section 9). Our approach has certain connection
with the simulation of simplicity proposed by Edelsbrunner
et al. [EM90].
Definition 5 The wavefront is the portion of the V D∞ , at an
instant t, induced by Lt .
Proposition 1 The wavefront of an orthogonal polyhedron
is composed of a set of planar faces that give a singlevalued linear piecewise function defined by the sweep plane
L. Thus, the wavefront is monotone in the z-axis direction.
Proof Let p = (x, y, z) be a point in Lt , in face f of Lt , and
let p = x, y, z be the point with maximal z value in the
Voronoi cell of f . The maximal cube centered at p is empty,
and contains every cube centered at a point on the segment
p, p , hence all of those are empty as well, and must belong
to the Voronoi cell of f . So there can be no other point of
wavefront between p and p .
An overview of our technique is shown in the Algorithm 1. The straight skeleton is progressively computed by
processing a sequence of events that correspond to its vertices. Initially, E is the ordered set of events induced by the
vertices of the input object. We process the events of E until
it is empty. Every time we process a junction event we have
to check if it is valid. Otherwise, we discard the junction
event. The criterion used to check the validity of a junction
event is discussed in the Section 5. A valid event may generate new events that will be inserted in E.
We maintain the set of rays R, that represent the set of
Voronoi edges that remain to be closed. We also maintain

1576

J. Martinez, M. Vigo & N. Pla-Garcia / Skeleton computation of orthogonal polyhedra

Algorithm 1 Algorithm overview
R←∅
E ← All the vertex events induced by P
while E = ∅ do
e ← pop(E)
if e is valid then
Update the straight skeleton according to e
Insert in R new ray/s induced by e
Remove from R closed ray/s of e
Update wavefront (see Section 6 )
Compute nearest junction of new ray/s (see Section 7) and insert in E the new induced junction
events
end if
end while

a graph storing the wavefront, that is induced by the subset
of rays Rw ∈ R that define a cube with L (see Property 2).
We have to update the wavefront each time an event is processed. A main step of our algorithm is to determine the
nearest junction event induced by a ray (see Section 7).
The straight skeleton is stored as a graph. Every vertex
is L∞ -equidistant to four faces of P or, in the case of the
vertices of P, to three faces. An edge is defined by the three
faces shared by its two endpoint vertices. By traversing the
edges of the graph that share a common face we can extract
the associated skeleton face.
In the following sections, we first characterise each event
and describe how they are processed. Then, we introduce the
properties of the evolving wavefront and describe how it is
updated. We also explain how to retrieve the nearest junction
event of a ray in order to obtain new junction events. Finally,
we illustrate how to cope with geometric degeneracies in order to achieve algorithm robustness.

The vertices of a two-manifold orthogonal polyhedron can
be classified into three types depending on the number of
incident edges and faces [Agu98] (see Figure 2). A vertex
with three incident faces and edges is called V 3. In order
to simplify the algorithm we follow the approach proposed
in [BEGV08], where the vertices with more than three incident faces are split into V 3 vertices. A vertex with four incident edges and faces is called V 4. A V 4 vertex has two coplanar incident faces with opposite orientation. By combining
those coplanar incident faces with the remaining two faces
we obtain two distinct rays that induce two vertex events. Finally, a vertex with six incident faces and edges is called V 6.
A V 6 vertex has three pairs of coplanar faces for each orthogonal direction. We arbitrarily select two coplanar faces
and merge them into a single face. By combining the merged
face and its two pairs of neighbouring faces we obtain two
different rays that induce two vertex events.
5. Junction event
A junction event corresponds to the centre of the cube defined by four faces (see Property 2). A valid junction event
coincides with a Voronoi vertex of V D∞ . The priority of
a junction event represents the point where the junction is
valid. A junction event may be invalidated before we reach
its priority point. Every valid junction event generates a set
of new rays to be inserted in R, and each new ray can generate new junction events. We distinguish two types of junction
events depending on the kind of ray junction:
• Ray-ray junction: Two rays of R may define a Voronoi
vertex. Two new rays emanate from the junction point (see
Figure 3).
• Ray-face junction: A ray of R and a face of P may define a Voronoi vertex. Three new rays emanate from the
junction point (see Figure 4).
5.1. Ray-ray junction events

4. Vertex event
If a vertex of P has more than three incident oriented faces
it produces more than one ray. The orientation of the vertex
ray is defined by its three oriented faces. We consider that
every polyhedron face is oriented inwards since we want to
compute the interior skeleton.

A valid ray-ray junction event involves two rays that define a
cube (see Property 2) whose centre is a Voronoi vertex, and
that have two shared and two unshared faces between them
(see Figure 3). We must check the validity of the junction.
A ray-ray junction event is valid if the two rays exist in R.
The two shared faces may represent a collapsed edge to zero
length of the input polyhedron. If the ray-ray junction event
is valid we generate two new rays by combining the pair of
unshared faces with each shared face. We also add two edges
in the skeleton graph between the origin of each ray and the
junction vertex.
5.2. Ray-face junction events

(a) V 3 Vertex

(b) V 4 Vertex

(c) V 6 Vertex

Figure 2: Type of vertices of an orthogonal polyhedron.

A valid ray-face junction event corresponds to a Voronoi vertex defined by a ray and a face (see Figure 4). A ray-face
junction event is valid if the ray exists in R. A ray-face junction event is not valid if any three of its four faces defining
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

J. Martinez, M. Vigo & N. Pla-Garcia / Skeleton computation of orthogonal polyhedra

f3

( f1 , f2 , f3 )
f2

f1

( f1 , f2 , f4 )
( f1 , f3 , f4 )
f4

( f2 , f3 , f4 )
Figure 3: Ray-ray junction. The rays shown in red define
a cube whose centre is a Voronoi vertex. The edge ( f1 , f2 )
collapses to zero length and two new rays shown in blue are
created.

a ray correspond to a equivalent ray erased from R. We only
check for ray-face junctions if the ray contains any pair of
faces bounding a reflex edge. If the ray-face junction is valid
we generate three new rays by combining the three pairs of
faces from the ray and the face. We also add an edge in the
skeleton graph between the ray origin and the junction vertex.

( f1 , f3 , f4 )
f3

( f1 , f2 , f3 )
f1

( f1 , f2 , f4 )

the cube defined by its associated ray and the sweep plane
L. By traversing the graph vertices that share a common face
we obtain the associated Voronoi cell. We may insert or remove graph vertices and locally update the connectivity of
the wavefront graph when a new event occurs. In the two
dimensional case two bisectors, each one defined by a pair
of edges, are neighbours in the wavefront if they share one
edge. In this case, it suffices to classify the bisectors by its
coordinate in a single orthogonal direction in order to know
its upper and lower neighbour bisector. However, in three dimensions a ray may have more than two neighbours and it is
not sufficient to classify them only by using its origin on a
single orthogonal direction.
Lemma 1 The wavefront update of a ray-ray junction can be
done in O (1) time.
Proof After processing an event we have a set of new rays
and a set of closed rays. There are at most three new rays and
three closed rays. The graph vertices and edges associated to
the set of closed rays are removed from the wavefront graph.
The wavefront graph connectivity of the new rays inserted in
R must be updated. We retrieve the set of neighbouring rays
of all the rays that participated in the new event and try to
connect them with the new rays. We connect two rays if they
share two faces. There are at most six rays associated to the
event that have at most eighteen neighbouring rays.
Lemma 2 The wavefront update of a ray-face junction can
be done in O (logc n) time.

f4

( f2 , f3 , f4 )

1577

f2

Figure 4: Ray-face junction. The ray shown in red defines a
cube with the face f4 and generates three new rays shown in
blue. Note that the edge bounded by faces f1 and f2 is reflex
and that all the rays are oriented downwards or horizontal.

6. Wavefront update
The wavefront is stored as a graph, where each vertex corresponds to a ray from Rw or to edges or vertices of P. An edge
in the wavefront connecting two rays indicates that both rays
share two of their three inducing faces (see Figure 5). This
leads to a maximum number of three possible neighbours
per ray. Every time an event is processed, the wavefront is
updated by removing from the graph the vertices associated
to rays which have been closed and adding new rays created
by the event. The position of a graph vertex is the centre of
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

Proof If we process a ray-face junction event some wavefront graph edges may be divided by the newly created
rays. Let a new ray be represented by the faces ( fa , fb , fc )
with origin in the junction event defined by the faces F =
( fa , fb , fc , fd ). If the pair of faces ( fi , fd ), with i ∈ {a, b, c},
corresponds to a reflex edge and the pair of faces F \ ( fi , fd ),
correspond to an existing edge graph of the wavefront, then
the new ray may split the edge graph. We retrieve the wavefront edge F \ ( fi , fd ) that contains the origin of the ray and
split it. This update can be done in O (logc n) by storing the
wavefront in a spatial data structure as proposed in Section 7.
Consider the Figure 5 where the ray ( f1 , f5 , f6 ) will define a
junction with the face f2 as the sweep plane descend along
the z-axis. In the case of the new rays ( f1 , f5 , f2 ), ( f5 , f6 , f2 ),
( f1 , f6 , f2 ) that will be created from the junction, the pair
of faces ( f5 , f6 ) correspond to a reflex edge and the pair of
faces ( f1 , f2 ) correspond to a graph edge that must be split.

7. Computation of the nearest junction event of a ray
A fundamental step of our algorithm is the computation of
the nearest junction event of a ray. Given the current set of
rays R we have to retrieve the nearest junction event of a ray
and insert it in E.
If a ray already exists in R we remove both rays, defined

1578

J. Martinez, M. Vigo & N. Pla-Garcia / Skeleton computation of orthogonal polyhedra

f2
f7
f3

f6

f1
f5
f4

Figure 5: Wavefront graph. On the left a 3D view of an object. On the right the status of its wavefront graph shown in
red. The rays inducing the wavefront are shown in blue.

by the same three faces and with opposed orientation, and
add to the skeleton graph the Voronoi edge bounded by their
origins. Otherwise, we have to compute its nearest junction
and insert it in E. The total number of feasible ray-ray junctions of a ray is bounded by the number of neighbouring
wavefront rays. There are at most three wavefront ray neighbours, so we have to check at the most three possible ray-ray
junctions. Consider the example of the Figure 5. To retrieve
the possible ray-ray junctions of the ray defined by the faces
( f1 , f2 , f3 ) we just check for its neighbouring vertices in the
wavefront graph ( f1 , f3 , f4 ) and ( f1 , f2 , f7 ).
The most time consuming step of the nearest ray junction
computation is the detection of ray-face junctions. We search
for this kind of junctions only if the ray is defined by any
pair of faces bounding a reflex edge. First we consider a ray
that have a negative orientation in the z-axis direction. We
have to check the subset of edges of the wavefront graph that
are neighbouring to the three ray faces. This problem can be
reduced to two dimensions, because there is one common
face between the ray and the neighbouring edges. Let a ray
be defined by the faces ( fa , fb , fc ) and ( fa , fi ) be and edge
adjacent to the region corresponding to fa in the wavefront
graph. We can check in a greedy form if the bisector bounded
by the faces ( fb , fc ) intersects any edge fi . However, we are
able to retrieve the intersection in O(log n) by using a sweepline algorithm to compute the straight skeleton of orthogonal
polygons as proposed by Martinez et al. [MVPGA10]. We
will explain this step more fully and establish the O(log n)
query time in a longer journal version of this paper. Consider
the Figure 5 where the ray that has a negative orientation
in the z-axis ( f1 , f5 , f6 ) also has a reflex edge bounded by
the faces ( f5 , f6 ). We may have to check in a greedy form
for ray-face junction with the neighbouring graph edges of
faces f3 and f2 . This problem is reduced to two dimensions
by checking if the bisector of two edges ( f5 , f6 ) defines a
Voronoi vertex with the segments f3 and f2 contained in the
face f1 .
In case a ray has a positive orientation in the z-axis direction, we have to obtain the face of the wavefront that is being
intersected. A greedy way is to check the ray intersection for
all the wavefront faces. However, this problem is analogous
to planar point location. Thanks to the Property 1 it is pos-

sible to project the wavefront into a two dimensional space.
If we consider the two dimensional projection of the wavefront in the direction of the ray, we have to find in which
wavefront face lies the origin of the ray in order to compute
the nearest junction point.
An additional check must be done in case we have faces
with holes in order to detect possible ray-face junction
events. If we have holes in a face the wavefront connectivity
between vertex rays is lost. Let fb be face with holes. When
a new Voronoi face defined by the bisector faces fa and fb
is created we obtain the set of rays belonging to any hole
of fb , that intersect the bisector between fa and fb , and update if necessary their nearest junction event. We will show
in longer journal version of this paper that this query can be
done in O (log n) by using planar point location data structure.
8. Computational complexity
We have to process k events that correspond to the number
of vertices of the straight skeleton.
Lemma 3 The straight skeleton of orthogonal polyhedra can
be straightforwardly computed in O (kn) time.
Proof The ray-ray junction detection is done in constant
time. The ray-face junction detection of a ray that has a negative orientation in the z-axis is done in O (n) by checking
all the neighbouring wavefront faces of the ray. The ray-face
junction detection of a ray that has a positive orientation in
the z-axis can be done in O (n) using a greedy search along
all the wavefront faces.
Lemma 4 The straight skeleton of orthogonal polyhedra can
be computed in O (klogc n).
Proof The ray-face junction detection of a ray that has a negative orientation in the z-axis is done in O (log n) by reducing the problem to two dimensions and using a sweep-line
algorithm. By storing the wavefront in a planar point location data structure we can accelerate the junction detection
of a ray that has a positive orientation in the z-axis, yielding
O (log n) time per ray and O (logc n) time per update of the
wavefront, for a constant c [ABG06].
9. Handling geometric degeneracies
Geometrical degeneracies commonly arise in case of orthogonal polyhedra. A robust algorithm must consider them. We
provide a technique to treat degeneracies that relies on simple geometric comparisons. Unlike other approaches we do
not perturb directly the input polyhedron in order to eliminate degeneracies. The computation of the straight skeleton
is always based on its original coordinates.
The number of degenerate cases that have to be distinguished in the computation of the straight skeleton of polyhedra is high. However, in two dimensions a deterministic
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

J. Martinez, M. Vigo & N. Pla-Garcia / Skeleton computation of orthogonal polyhedra

criterion is enough to overcome all the cases [MVPGA10].
When we detect a geometrical degeneracy we simulate a
perturbation that removes the degeneracy. For simplicity, we
will consider that we displace every face of the polyhedron
by an infinitesimal amount. However, our approach only requires to make comparisons between the displacement values assigned to each face and does not directly rely on the
coordinates of the polyhedron. We assume that it is possible
to displace by an infinitesimal amount each face of an orthogonal polyhedron such that the polyhedron is still valid.
We distinguish between two kind of degeneracies: the induced by coplanar elements and by coincident geometric elements (see Figure 6). If a coplanar or coincident degeneracy
is detected, the appropriate simulated perturbation is applied.
The simulation is done by defining a total order between degenerate events that have the same priority and by avoiding
unfeasible ray junctions when a degeneracy is detected. We
assign two offsets to every face of the polyhedron. Those offsets represent a symbolical infinitesimal displacement of the
face and help to break coplanar and coincident degeneracies
respectively.
f1

f1

f2

f2
f4

f5
f5

f3
f4

1579

Proposition 2 It is possible to perturb a set of coplanar faces
such that the degeneracy is removed.
Proof Let a coplanar face belong to a set F of coplanar faces.
By enumerating every face of F we define its offset. This
implies that F is totally ordered. We do not use the offset of
coplanar faces to directly perturb them. This is because we
may have a large collection of coplanar faces. A subset of
faces of F that is going to be perturbed is still totally ordered.
The new ordering of the subset defines the offset values used
for the perturbation. The coplanar faces associated to a vertex V 6 require an additional restriction. When we merge an
arbitrary selected pair of coplanar faces meeting at the V 6
we have to ensure that the other four coplanar faces have
an offset such the perturbed result is still valid. One pair of
faces defines a reflex edge and the other pair defines a convex one after the merging. We have to ensure that the offset
of faces bounding the reflex edge is less than the offset of
faces bounding the convex edge. Otherwise, the faces may
intersect between them and lead to an incorrect result. Note
that the set F still remains totally ordered after introducing
these restrictions.
A singular case of coplanar degeneracy may be caused by
the hole of a face. Imagine the hole of a face being extruded
outwards. When two rays emanating from the face hole collide a coplanar degeneracy is induced by the entire hole face.
We erase the emanating rays from this junction and add the
bisector induced by the face hole in a post-processing step
(see Section 9.4).
9.2. Coincident elements

f3
(a) Coplanar. The junction between the ray ( f1 , f2 , f5 ) and
( f3 , f4 , f5 ) is degenerate due to
the presence of the coplanar
faces f1 and f4 .

(b) Coincident. The junction between the ray ( f1 , f2 , f5 ) and
( f3 , f4 , f5 ) is degenerate because they coincide in a point.

Figure 6: Type of degeneracies.

9.1. Coplanar elements
In two dimensions, when two elements are collinear along
an orthogonal direction, the induced bisector under the L∞
distance is an entire bisector area [PL01]. By choosing the
boundary of that area we solve the ambiguity: an equidistant region is assigned to one of the two points or segments
arbitrarily. In three dimensions, the equidistant set of points
between a set of coplanar elements may define a bisector volume. Every time we detect a coplanar degeneracy, we simulate a perturbation of the coplanar faces. The perturbation
arbitrarily selects a portion of the bisector volume boundary
equidistant to the coplanar elements.
Definition 6 A set of faces F ∈ P are coplanar if they lie in
the same oriented plane.
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

Definition 7 Let α be a constant positive value. A set of faces
F ∈ P are coincident if |F| > 4 and if for every pair of faces
f1 , f2 ∈ F, that have the same orthogonal direction, opposed
orientation and define a bisector, we have D∞ ( f1 , f2 ) = α.
Proposition 3 It is possible to perturb a set of coincident
faces such that the degeneracy is removed.
Proof It is enough to define an offset based on the orthogonal direction of each face in order to break the degeneracy.
We assign a different prime number for every orthogonal direction (e.g. 2, 3, 5). The uniform perturbation of each face
according to its direction and orientation eliminates the coincidence. As an example, consider the Figure 6b where five
faces meet in a single point. If we displace the faces ( f1 , f4 )
two infinitesimal units inwards and the faces ( f2 , f3 ) three
units, the coincidence is broken.
9.3. Simulating the perturbation
A pair of events in E may have the same priority if they are
degenerated. Note that two vertex events associated to a V 4
or V 6 vertex are considered to be degenerate after we break
them into two V 3 vertices. We need to decide which event is
processed before the other one. We introduce an additional

1580

J. Martinez, M. Vigo & N. Pla-Garcia / Skeleton computation of orthogonal polyhedra

comparison to avoid the ordering ambiguity. If two events
have the same priority in an orthogonal direction we further
check if they still have the same priority after the simulated
perturbation.
When we compute the intersection of a ray with a face
(see Section 7) it may intersect more than one face. We have
to decide if the intersection is feasible according to the offsets. We proceed in a similar manner as when ordering degenerate events. Let F be the set of coincident faces at the
intersection point. If two or more faces of F are coplanar
we have to check for coplanar intersection perturbation. If
the degeneracy is still unsolved we have to check for coincident intersection perturbation. The intersection perturbation
consists in moving the origin of the ray and the intersected
face conforming to their offsets. We have to check if the ray
still intersects the face after the perturbation. If we intersect
an edge or vertex, we will displace it according to the offset
and check if the ray still intersects the face.

Figure 8: Reparation of a coplanar ambiguity induced by a
hole. Straight skeleton graph is shown in red. The blue arrows correspond to the central bisector induced by the hole.

9.4. Repairing coplanar ambiguities
We select a portion of the boundary of the volume equidistant to a set of coplanar faces. This arbitrary selection causes
that the computed straight skeleton may not be a unique solution, indeed it is correct in the sense of the L∞ metric. The
selected part of the boundary depends on the offsets assigned
to resolve coplanar degeneracies. We select the central area
of the volume in a post-processing step in order to obtain a
unique solution (see Figure 7).

f1

of Fc \ Fv until we reach an edge that contains the projection
of the central bisector bounded by Fc . We also have to repair
the coplanar degeneracy that may be implicitly generated by
a hole of a face. For every vertex of the skeleton graph that
belongs to the intersection of a rays emanating from the hole
we consider a ray emanating from it in the same orientation
of the face containing the hole. We have to retrieve the intersection of this new ray with the unconnected skeleton generated by the face containing the hole (see Figure 8).

f2

10. Results
We computed the straight skeleton of some representative
objects in order to check the algorithm robustness. We implemented the algorithm with O (kn) time complexity (see
Section 8). The algorithm has been implemented in C++ and
the source code consists of about 3000 lines of code. Table 1
shows the results on a PC Intel E6600 2.40 Ghz with 3.2 GB
RAM for seven sample objects that are shown in Figure 9.
We previously remove the Voronoi edges that emanate from
the vertices of P. We also have compared the presented approach with an optimized thinning approach [AVV07]. Our
technique obtained better results.
Object

Figure 7: Reparation of a coplanar ambiguity induced by two
coplanar faces. Straight skeleton is shown in red. The blue
arrow is the central bisector induced by f1 and f2 .
Lemma 5 The straight skeleton coplanar ambiguities can be
repaired in O (k) time, where k is the number vertices of the
skeleton.
Proof We repair the vertices associated to two or more
coplanar faces, where an arbitrary selection of the volume
boundary has been done and locally repair the graph by selecting the central area. A set of skeleton graph vertices may
induce an ambiguity if all the vertices coincide in a point, are
connected between them, and contain more than one coplanar face. Let Fv be the set of faces associated to all the coincident vertices and Fc ⊂ Fv a subset of coplanar faces. We traverse the neighbouring edges that contain at least two faces

(a)
(b)
(c)
(d)
(e)
(f)
(g)

Skeleton

Time

V

F

V

F

Ours

[AVV07]

24
24
20
32
981
4617
3399

14
14
13
30
571
2743
2016

6
10
10
7
1581
8120
5171

0
3
3
0
863
6415
2787

0.02
0.02
0.02
0.04
5.32
31.69
28.18

0.03
0.04
0.04
0.06
10.28
80.23
57.29

Table 1: Values shown are number of faces F and vertices
V of the object and its straight skeleton. Running time of the
skeleton computation in seconds.

11. Conclusions and future work
We have presented a new algorithm to compute the straight
skeleton of an orthogonal polyhedron. Although the medial
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

J. Martinez, M. Vigo & N. Pla-Garcia / Skeleton computation of orthogonal polyhedra

axis of polyhedra has been extensively explored, the straight
skeleton of polyhedra has devised less interest. However, the
combinatorial complexity of the straight skeleton is much
lower compared with the medial axis and is just composed
of planar faces. We proposed a geometric approach that
works directly with the boundary of the object. As a consequence, the time complexity of our algorithm is constrained
by the size of its boundary. On the contrary, the time complexity of thinning and distance field approaches is bounded
by the volume of the discretized object. Unlike the existing
straight skeleton approaches that simulate a shrink of the object boundary, we have used a plane-sweep algorithm. Furthermore, our algorithm is output sensitive with respect to
the number of features of the output skeleton.
As our algorithm is designed for practical purposes, we
were concerned about its robustness. We developed a technique to treat geometric degeneracies based on a simulated
perturbation of the input polyhedron. Moreover, we solved
the ambiguity induced by coplanar elements, which are common in orthogonal polyhedra. As an immediate result of our
work, we want to compute the skeleton of large datasets in
order to show the performance of our method. In addition,
our approach may be extended to handle non-manifold orthogonal polyhedra that arise in voxel datasets.
The straight skeleton of orthogonal polyhedra skeleton is
still highly sensitive to shape noise and it is not comparable
with prior approximate approaches (see Section 2). For this
reason, an interesting avenue for future work would be to
develop and approximate approach starting from the formulation of the straight skeleton. Furthermore, we may be able
to approximate the skeleton of non-orthogonal polyhedra by
approximating it with orthogonal polyhedra.
12. Acknowledgements
This work has been partially supported by the project
TIN2008-02903 of the Spanish government and by the IBEC
(Bioengineering Institute of Catalonia). We would like to
thank the anonymous reviewers for their valuable suggestions.
References
[AAAG95] A ICHHOLZER O., AURENHAMMER F., A LBERTS
D., G ÄRTNER B.: A novel type of skeleton for polygons. Journal of Universal Computer Science 1 (1995), 752–761. 1, 2
[ABE09] ATTALI D., B OISSONNAT J. D., E DELSBRUNNER H.:
Stability and computation of medial axes - a state-of-the-art
report. In Mathematical Foundations of Scientific Visualization, Computer Graphics, and Massive Data Exploration, Mathematics and Visualization. Springer Berlin / Heidelberg, 2009,
pp. 109–125. 2
[ABG06] A RGE L., B RODAL G. S., G EORGIADIS L.: Improved
dynamic planar point location. In Proceedings of the 47th Annual
IEEE Symposium on Foundations of Computer Science (2006),
IEEE Computer Society, pp. 305–314. 6
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.

1581

[Agu98] AGUILERA A.: Orthogonal Polyhedra: Study and Application. PhD thesis, Universitat Politecnica de Catalunya, 1998.
4
[AK01] A MENTA N., KOLLURI R. K.: The medial axis of a
union of balls. Computational Geometry Theory and Applications 20 (2001), 25–37. 2
[AM97] ATTALI D., M ONTANVERT A.: Computing and simplifying 2D and 3D continuous skeletons. Computer Vision and
Image Understanding 67 (1997), 261–273. 2
[Aur91] AURENHAMMER F.: Voronoi diagrams. a survey of a
fundamental geometric data structure. ACM Computing Surveys
23 (1991), 345–405. 1
[AVV07] AYALA D., V ERGARA E., V ERGÉS E.: Improved
skeleton computation of an encoded volume. In Proceedings of
Eurographics (2007), pp. 33–36. 8
[BA91] B RANDT J. W., A LGAZI V. R.: Continuous skeleton
computation by Voronoi diagram. CVGIP: Image Understanding
55 (1991), 329–338. 2
[BEGV08] BAREQUET G., E PPSTEIN D., G OODRICH M. T.,
VAXMAN A.: Straight skeletons of three-dimensional polyhedra. Lecture Notes in Computer Science 5193 (2008), 148 – 160.
2, 4
[Blu67] B LUM H.: A transformation for extracting new descriptors of shape. In Models for the Perception of Speech and Visual
Form. MIT Press, 1967, pp. 362–380. 1
[CKM04] C ULVER T., K EYSER J., M ANOCHA D.: Exact computation of the medial axis of a polyhedron. Computer Aided
Geometric Design 21 (2004), 65–98. 2
[CL05] C HAZAL F., L IEUTIER A.: The λ medial axis. Graphical
Models 67 (2005), 304–331. 2
[CS07] C ORNEA N. D., S ILVER D.: Curve-skeleton properties,
applications, and algorithms. IEEE Transactions on Visualization
and Computer Graphics 13 (2007), 530–548. 1
[DMN∗ 10] DAS G. K., M UKHOPADHYAY A., NANDY S. C.,
PATIL S., R AO S. V.: Computing the straight skeleton of a monotone polygon in O (n log n) time. In Canadian Conference on
Computational Geometry (2010), pp. 207–210. 2
[DS06] D EY T., S UN J.: Defining and computing curve-skeletons
with medial geodesic function. In Proceedings of the fourth Eurographics symposium on Geometry processing (2006), pp. 143–
152. 2
[DZ02] D EY T. K., Z HAO W.: Approximate medial axis as a
Voronoi subcomplex. In Proceedings of the seventh ACM symposium on Solid modeling and applications (2002), pp. 356–366.
2
[EE99] E PPSTEIN D., E RICKSON J.: Raising roofs, crashing cycles, and playing pool: Applications of a data structure for finding
pairwise interactions. In Proceedings of the 14th Annual ACM
Symposium on Computational Geometry (1999), pp. 58–67. 2
[EM90] E DELSBRUNNER H., M ÜCKE E. P.: Simulation of simplicity: a technique to cope with degenerate cases in geometric
algorithms. ACM Transactions on Graphics 9 (1990), 66–104. 3
[Epp98] E PPSTEIN D.: Fast hiearchical clustering and other applications of dynamic closet pairs. In Proceedings of the ninth
annual ACM-SIAM symposium on Discrete algorithms (1998),
pp. 619–628. 2
[ER99] E TZION M., R APPOPORT A.: Computing the Voronoi
diagram of a 3D polyhedron by separate computation of its symbolic and geometric parts. In Proceedings of the fifth ACM symposium on Solid modeling and applications (1999), pp. 167–178.
2

1582

J. Martinez, M. Vigo & N. Pla-Garcia / Skeleton computation of orthogonal polyhedra

[FLM03] F OSKEY M., L IN M. C., M ANOCHA D.: Efficient
computation of a simplified medial axis. In Proceedings of
the eighth ACM symposium on Solid modeling and applications
(2003), pp. 96–107. 2
[For87] F ORTUNE S.: A sweepline algorithm for Voronoi diagrams. Algorithmica 2, 1 (1987), 153–174. 3
[GMPW09] G IESEN J., M IKLOS B., PAULY M., W ORMSER C.:
The scale axis transform. In Proceedings of the 25th annual symposium on Computational geometry (2009), pp. 106–115. 2
[Hel94] H ELD M.: On computing Voronoi diagrams of convex
polyhedra by means of wavefront propagation. In Canadian Conference on Computational Geometry (1994), pp. 128–133. 2

(a)

(b)

(c)

(d)

(e)

(f)

[JBS06] J ONES M., BAERENTZEN J., S RAMEK M.: 3D distance
fields: a survey of techniques and applications. IEEE Transactions on Visualization and Computer Graphics 12 (2006), 581
–599. 2
[Kir79] K IRKPATRICK D. G.: Efficient computation of continuous skeletons. In Proceedings of the 20th annual Symposium on
Foundations of Computer Science (1979), pp. 18–27. 1
[Lie03] L IEUTIER A.: Any open bounded subset of Rn has the
same homotopy type than its medial axis. In Proceedings of
the eighth ACM symposium on Solid modeling and applications
(2003), pp. 65–75. 1
Thinning
[LLS92] L AM L., L EE S.-W., S UEN C.:
methodologies-a comprehensive survey.
IEEE Transactions on Pattern Analysis and Machine Intelligence 14 (1992),
869 –885. 2
[Mil93] M ILENKOVIC V.: Robust construction of the Voronoi
diagram of a polyhedron. In Canadian Conference on Computational Geometry (1993), pp. 473–478. 2
[MVPGA10] M ARTINEZ J., V IGO M., P LA -G ARCIA N., AYALA D.: Skeleton computation of an image using a geometric
approach. In Proceedings of Eurographics (2010), pp. 13–16. 1,
6
[PL01] PAPADOPOULOU E., L EE D. T.: The L∞ Voronoi diagram of segments and VLSI applications. International Journal
of Computational Geometry and Applications 11 (2001), 503 –
508. 3, 7
[SA95] S HARIR M., AGARWAL P.: Davenport-Schinzel sequences and their geometric applications. Cambridge University
Press, 1995. 1
[SAR95] S HEEHY D. J., A RMSTRONG C. G., ROBINSON D. J.:
Computing the medial surface of a solid from a domain Delaunay
triangulation. In Proceedings of the third ACM symposium on
Solid modeling and applications (1995), pp. 201–212. 2
[SFM05] S UD A., F OSKEY M., M ANOCHA D.: Homotopypreserving medial axis simplification. In Proceedings of the 2005
ACM symposium on Solid and physical modeling (2005), pp. 39–
50. 2
[SM06] S TAUBER M., M ÜLLER R.: Volumetric spatial decomposition of trabecular bone into rods and plates: A new method
for local bone morphometry. Bone 38, 4 (2006), 475 – 484. 1
[SPB96] S HERBROOKE E. C., PATRIKALAKIS N. M., B RISSON
E.: An algorithm for the medial axis transform of 3D polyhedral solids. IEEE Transactions on Visualization and Computer
Graphics 2 (1996), 44 – 61. 2
[SRX07] S TROUD I., R ENNER G., X IROUCHAKIS P.: A divide
and conquer algorithm for medial surface calculation of planar
polyhedra. Computer-Aided Design 39 (2007), 794–817. 2

(g)

Figure 9: Sample objects. Input orthogonal polyhedron
shown in gray. Straight skeleton shown in red. (a) Two coincident V4 vertices. (b) Repairing of a coplanar degeneracy induced by two pairs of coplanar faces. (c) Repairing of
coplanar degeneracy induced by an extruded hole. (d) Eight
coincident V6 vertices. (e) Hand. (f) Binzilla. (g) Camel and
head detail. Note that only the Voronoi edges are drawn in
objects (e), (f) and (g).

[VAGT08] V ERGÉS E., AYALA D., G RAU S., T OST D.: Virtual
porosimeter. Computer-Aided Design and Applications 5 (2008),
557–564. 1
c 2011 The Author(s)
c 2011 The Eurographics Association and Blackwell Publishing Ltd.


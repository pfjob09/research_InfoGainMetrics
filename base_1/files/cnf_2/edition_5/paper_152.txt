DOI: 10.1111/j.1467-8659.2011.02019.x
Eurographics Symposium on Geometry Processing 2011
Mario Botsch and Scott Schaefer
(Guest Editors)

Volume 30 (2011), Number 5

A Hierarchical Grid Based Framework for Fast Collision
Detection
Wenshan Fan1,2,3,4,5 , Bin Wang1,4,5 , Jean-Claude Paul6 and Jiaguang Sun1,4,5
1 School

of Software, Tsinghua University, Beijing, China
Aerospace Control Center, Beijing, China
3 Department of Computer Science and Technology, Tsinghua University, Beijing, China
4 Key Laboratory for Information System Security, Ministry of Education of China, Beijing, China
5 Tsinghua National Laboratory for Information Science and Technology, Beijing, China
6 INRIA, Nancy, France
2 Beijing

Abstract
We present a novel hierarchical grid based method for fast collision detection (CD) for deformable models on
GPU architecture. A two-level grid is employed to accommodate the non-uniform distribution of practical scene
geometry. A bottom-to-top method is implemented to assign the triangles into the hierarchical grid without any
iteration while a deferred scheme is introduced to efficiently update the data structure. To address the issue of load
balancing, which greatly influences the performance in SIMD parallelism, a propagation scheme which utilizes a
parallel scan and a segmented scan is presented, distributing workloads evenly across all concurrent threads. The
proposed method supports both discrete collision detection (DCD) and continuous collision detection (CCD) with
self-collision. Some typical benchmarks are tested to verify the effectiveness of our method. The results highlight
our speedups over prior algorithms on different commodity GPUs.
Categories and Subject Descriptors (according to ACM CCS): I.3.5 [Computer Graphics]: Computational Geometry
and Object Modeling—Geometric algorithms, languages, and systems

1. Introduction
Collision detection for deformable models has long been
a topic of research and has many applications, such as
physically-based simulation, CAD/CAM, virtual reality, surgical simulation and video games.
Although great progress has been made, the huge amount
of processing required for complex models, especially when
self-collision is involved, means that the performance of collision detection is still a bottleneck for many real-time or interactive applications.
As modern off-the-shelf GPUs support thousands of concurrent threads, more and more research has focused on
enhancing the performance of collision detection by exploiting parallel processing. While bounding volume hierarchies (BVHs) are usually used as the acceleration structure for many of these algorithms [KHH∗ 09] [LMD10]
[TMLT11], the inherent memory architecture and SIMD parallelism of GPU constrain efficient implementation of traversal and update operations for such complex hierarchical data
c 2011 The Author(s)
⃝
c 2011 The Eurographics Association and Blackwell PublishComputer Graphics Forum ⃝
ing Ltd. Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ,
UK and 350 Main Street, Malden, MA 02148, USA.

structures. Some uniform 3D grid based schemes [Gra07]
[SAW10] have recently shown potential for fast collision detection for deformable surfaces. Compared with BVH, the
advantages of a uniform grid include good scalability across
parallel threads and low cost of update and traversal, making
it ideal for implementation in the SIMD context. However,
existing methods typically fall into a dilemma between uniform grid subdivision and arbitrary distribution of triangles
in the scene.
In this paper, a two-level hierarchical grid based framework is proposed to accommodate the non-uniform distribution of triangles in practical scenes. A parallel bottom-to-top
method is introduced to distribute triangles into the hierarchical grid without any iteration. A deferred update scheme
is implemented by exploiting the spatial and temporal coherence to efficiently renew the hierarchical grid. The proposed
two-level approach possesses both the parallel efficiency of
a uniform grid and much of the flexibility of a many-level
hierarchical structure.

1452

Wenshan Fan / A Hierarchical Grid Based Framework for Fast Collision Detection

Load balancing is essential to the efficient collision detection on SIMD architecture. We propose a propagation
scheme that utilizes a parallel scan (or prefix sum) and a
segmented scan, assuring that workloads are evenly assigned
across concurrent threads without any suspensions.
2. Related Work

Due to its efficient update and access, uniform grid was
exploited by Grand [Gra07] to perform a broad-phase collision test for particles. Simon et al. [SAW10] employed the
above uniform grid based method and presented a hybrid
CPU/GPU framework for deformable surfaces with selfcollision. They proposed a load balancing scheme by reconstructing and traversing an auxiliary 16-degree tree at each
frame to build the array of triangle pairs.

In this section, we briefly summarize previous work on collision detection and introduce some basic data-parallel primitives relevant to our work.

2.2. Data-Parallel Primitives

2.1. Collision Detection

Data-parallel primitives, such as parallel scan [SHG08], segmented scan [SHZO07] and parallel sort [HSO07], are important building blocks in implementing a wide variety of
parallel algorithms.

CPU Based Collision Detection: The algorithms proposed
by Cohen et al. [CLMP95] and Hudson et al. [HLC∗ 97]
used a sweep-and-prune approach to detect collision between rigid models.
Bounding volume hierarchies (BVHs) are widely used
to accelerate the detection. Typical bounding volumes
include axis-aligned bounding boxes (AABB) [BFA02]
[BWK03], spheres [PR95] [Hub96], oriented bounding
boxes (OBB) [GLM96], k-discrete oriented polytopes (kDOP) [KHM∗ 98] [FF03] and so on.
The parallelism of multi-core CPUs is exploited by Kim
et al. [KHY08] and Tang et al. [TMT09] to further accelerate
the computation.
GPU Based Collision Detection: Govindaraju et al.
[GRLM03] [GRLM05] [GLM06] proposed several GPU
based methods for collision detection in image space.
Object space based methods remove the limit imposed
by image resolution. Horn [Hor05] proposed a method for
rigid models by using reduction stream operation. Zhang and
Kim [ZK07] proposed to apply a streaming AABB tree to
accelerate calculation for deformable models without selfcollision.

A parallel scan performs an operation on the input array
with a binary associative operator (such as add or max) and
places the results in an output array such that, the ith element
is the result of the operator applied to all previous elements
of the input array (the ith element is included in an inclusive scan and excluded in an exclusive scan). A segmented
scan is almost the same as a parallel scan, except that its operation is within each segment in the input array. An array
of mask values is needed for the segmented scan to specify
these segments. All of the above primitives are implemented
efficiently in CUDPP [CUD09].
3. A Hierarchical Grid Subdivision Scheme
A 3D grid is naturally amenable to parallel processing due
to its scalability. For the task of collision detection, however,
a uniform grid combined with arbitrary scene geometry may
result in too many triangle pairs in cells with dense distribution, causing many false positives during collision detection
testing. While this effect can be ameliorated by increasing
the grid resolution, the resulting increase in the length of the
cell list and the overlapping of triangles across many small
cells will increase the total computation cost.

Kim et al. [KHH∗ 09] performed complex reconstruction
and traversal of BVH on multi-core CPUs and computed expensive elementary tests of collision detection on GPU.
Lauterbach et al. [LMD10] presented a complete GPU
based framework to perform inter-object and intra-object
collision detection for deformable models. A lightweight
load balancing scheme with the support of atomic operations
was introduced to parallelize the hierarchy operations. Tang
et al. [TMLT11] also presented a BVH based streaming algorithm. A private array with empirically defined fixed length
was assigned for each thread or thread block to compute the
potentially colliding pairs.
Contrasting to hierarchical data structures, Alcantara et
al. [ASA∗ 09] proposed to use a two-level hash table, which
can be built with data-parallel algorithm in real-time, to efficiently perform collision detection for dynamic models.

Figure 1: A two-level grid is proposed to adaptively subdivide the scene geometry according to the distribution of triangles, reducing the number of both triangle-cell pairs and
triangle-triangle pairs.
Motivated by this fact, we present a scheme whereby a
uniform grid is adaptively refined into a second level by
c 2011 The Author(s)
⃝
c 2011 The Eurographics Association and Blackwell Publishing Ltd.
⃝

Wenshan Fan / A Hierarchical Grid Based Framework for Fast Collision Detection

halving the parent cell at each dimension according to the
distribution of triangles, reducing the number of false positives, as shown in Figure 1.
Algorithm 1 shows a high level overview of the construction of the proposed hierarchical grid.
Algorithm 1: Construction of hierarchical grid
Update resolution and hierarchy of the hierarchical grid
for each triangle in parallel do
Calculate AABB
Map AABB into bottom-level grid
end for
Build array of triangle-cell pairs in the bottom-level grid
for each triangle-cell pair in parallel do
Map the pair into their actual level
end for
Sort to gather the triangles for all non-empty cells
Since the proposed deferred update scheme depends on
the knowledge of the assignment procedure, we first introduce our bottom-to-top assignment method.
3.1. Assigning the Scene Geometry in Bottom-to-Top
Order
In order to assign all the triangles into their associated cells
for the proposed two-level grid, a two-pass iteration is usually necessary. However, this would be inefficient on GPU
architecture because of divergent branches, variant-number
memory accesses and additional overlapping tests between
the triangles and the grid. Instead, we propose a bottom-totop process, performing the assignment without iteration.
We first define the proposed hierarchical grid in the context of this paper. The basic parameter is resolution. We
record the resolution of the top-level grid as Xtres , Ytres and
Ztres at three dimensions, and the resolution of bottom-level
grid is determined by simply doubling each value. Another
parameter is hierarchy that indicates how the two-level subdivision is applied on the space. We employ a hierarchy table
in which each item corresponds to a cell in the top level-grid,
to label whether the area corresponding to the cell is subdivided into eight sub-cells or not.
We also generate a unique ID for each cell in the hierarchical grid by Equation 1.

CellID = x ∗Yres ∗ Zres + y ∗ Zres + z + o f f set,

(1)

where x, y and z are the coordinates of cells in the corresponding level of grid. Yres and Zres are the y-component
and z-component of the resolution of the corresponding level
of grid. offset is set to 0 and Xtres ∗ Ytres ∗ Ztres for the toplevel grid and the bottom-level grid respectively, shifting the
c 2011 The Author(s)
⃝
c 2011 The Eurographics Association and Blackwell Publishing Ltd.
⃝

1453

cellID in different levels of grids into nonoverlapping intervals.
Now we can perform the bottom-to-top assignment. The
first step is updating the bounding boxes of triangles in parallel. For DCD, the bounding box is determined by the position of the triangle at the current time. For CCD, the swept
volume between the adjacent time steps is used to calculate
the bounding box. Considering its simplicity and efficiency,
the AABB is employed in our calculation.
A lightweight map from the AABB of each triangle to the
bottom-level grid is then carried out and calculated a subgrid. We record the resolution and the ID of the most leftbottom cell, which is with the lowest coordinates at x, y and
z axes, for each sub-grid.
The kernel with load balancing scheme as described in
Section 4.1 is performed in the next step to generate the array
of triangle-cell pairs.
Because those pairs are built according to the bottom-level
grid, we must map the bottom-level cell of each pair to the
actual hierarchical grid it corresponds to. We first reversely
solve Equation 1 (using modular and divide operations) on
its ID to calculate the coordinates in the bottom-level grid.
Then by dividing each component by 2, another set of coordinates for its parent cell are obtained, which are used to retrieve the corresponding item in the hierarchy table to determine the type of subdivision applied on that area. If it shows
that the bottom-level grid is used, no translation of the ID is
needed. Otherwise, the ID of the parent cell is chosen as a
valid ID.

Figure 2: Removing the redundancy when building trianglecell pairs. The minimum vertex of the overlapped AABB of
the triangle and the parent cell (in orange) is selected as a
token position (in red) to identify a unique cell (in grey), in
which the mapping is processed, removing the redundancy.
However, since multiple cells in the bottom-level grid will
map to the same parent cell, redundant triangle-cell pairs
may be generated. To remove the redundancy, we use the
minimal vertex of the overlapped AABB of the triangle and
the parent cell as a token position (see Figure 2), and the ID
of the cell that contains the token position in the bottom-level
is calculated. Only the thread holding the same cell ID builds
a triangle-cell pair and sets a valid flag. Other threads just
output an invalid flag, which will be used by a compaction
operation [HSO07] to remove those invalid items.
A sort based method [Gra07] is applied as the last step to

1454

Wenshan Fan / A Hierarchical Grid Based Framework for Fast Collision Detection

complete the assignment. The main idea is that the array of
triangle-cell pairs is sorted by cell ID. Then by checking for
a transition in the adjacent cell ID in the sorted array, the list
of triangles belonging to the associated cell is collected.
3.2. Updating the Hierarchical Grid with a Deferred
Scheme
The resolution and the hierarchy of the hierarchical grid need
to be updated as the models undergo deformation. We use
Equation 2 proposed by Wald et al. [WIK∗ 06] to define the
resolution of the top-level grid:
√
Xtres = dx

3

λN
,Ytres = dy
V

√
3

λN
, Ztres = dz
V

√
3

λN
,
V

(2)

where d⃗ is the diagonal and V is the volume of the bounding
box of the scene, which is calculated by performing a parallel scan on the stream of vertices with min and max operator.
N is the number of triangles in the scene and λ is grid density. As recommend by Wald et al., we set it to 5 in all the
tests.
The issue of updating the hierarchy is more complex,
since the statistics indicating how the triangles are distributed in the scene must be gathered, which essentially
means another assignment procedure. However, there exists
plenty of temporal and spatial coherence between adjacent
time steps in deformable models. In addition, because the
two-level hierarchy can subdivide cells, the data structure is
less sensitive to the resolution settings.

Although our proposed update process is computed in a
deferred way, temporal and spatial coherence ensures the effectiveness of the generated grid, and overall performance
benefits from the reduced overhead on the updating procedure. We observed an average improvement of 30% on the
overall performance with the deferred update compared with
that of complete update at each frame.
4. Load Balancing with a Propagation Scheme
For a practical scene, it is almost impossible to guarantee an
equal number of triangles in all cells with a grid based subdivision, even using a hierarchical grid. Hence performing
varying workload in each cell with the SIMD parallelism,
which forces all the threads to wait for the worst-case runtime, becomes the major challenge for implementing an efficient collision detection algorithm. Although some load balancing schemes [LMD10] [SAW10] have been presented,
they either depend on expensive atomic operations to distribute roughly equal workload to each thread, or suffer from
reconstructing and accessing a complex hierarchical tree.
In order to avoid the mutable or sophisticated operations
and guarantee to distribute even workload across concurrent
threads, we proposed a new load balancing scheme by employing efficient parallel scan and segmented scan.
The main idea of our method can be summarized into two
stages and illustrated in Figure 3.
Propagation

S0

As a result, we employ a deferred updating method. Only
when the change of the resolution of the grid is more than a
customized threshold is a complete update performed. Otherwise, the statistics gathered from the previous frame are
used to heuristically update just the hierarchy.
Now the issue of updating the hierarchy is reduced to how
to subdivide the scene according to the gathered data. We use
a simple but effective implementation. We first calculate the
number of triangles that overlap the area of each potential
cell in top-level grid by employing the data computed in the
assignment in the previous frame. If the cell was subdivided
by the bottom-level grid, the sum of the numbers of triangles
in its eight sub-cells is used.
The numbers of triangles in all non-empty cells in the toplevel grid are then averaged and compared with the resulting
average value. If it shows that the number in a certain cell
is smaller than the average value, no further subdividing is
needed; otherwise the refined grid is employed on the associated area. The hierarchy table is updated correspondingly.
The routine for the complete update is similar except that
the resolution of the grid is renewed and the hierarchy is
updated according to the statistics at current frame provided
by an additional assignment process.

Segment n

Segment 1 Segment 2

Segment 0

......

S2

S1

Sn

Parallel Scan

0

0

0

0

0

1

0

0

0

1

0

0

0

...... 1

0

0

0

0

D0 0

0

0

0

0

D1 0

0

0

D2 0

0

0

...... D 3 0

0

0

0

D3

D3

1

Segmented Scan

D0

D0

D0

D0

D0

D0

D1

D1

D1

D1

D2

D2

D2

D2

P0

P1

P2

P3

P4

P5

P6

P7

P8

P9

P 10 P 11 P 12 P 13

...... D 3

D3

D3

...... P m-5 P m-4 P m-3 P m-2 P m-1

Parsing and Building

Figure 3: Two stages of the propagation scheme for load
balancing. The descriptive data is propagated into its associated segment by employing a parallel scan and a segmented scan in the first stage. The concurrent work threads
take over the generated stream of workloads and complete
the final calculation by parsing the propagated descriptive
data.
∙ Propagation A task to be performed is considered as consisting of independent segments whose sizes are generally
unequal to each other. An exclusive parallel scan with the
add operator first runs on the stream of sizes to determine the beginning position of each segment in the array of workloads. The above operation also has a useful
c 2011 The Author(s)
⃝
c 2011 The Eurographics Association and Blackwell Publishing Ltd.
⃝

1455

Wenshan Fan / A Hierarchical Grid Based Framework for Fast Collision Detection

4.1. Building Triangle-Cell Pairs
The pairs related to each triangle are organized as a single
segment, whose size is determined by the associated subgrid (which is defined in section 3.1) by multiplying three
components of the resolution. A parallel scan runs first on
the array of sizes to calculate the head position of each segment in the array of workloads. The triangle ID, the sub-grid
and the beginning position are used as descriptive data and
propagated by a segmented scan in the first stage.
In the second stage, we first compute a global beginning
coordinates for the current sub-grid by reversely solving
Equation 1 with its most left-bottom cell ID as input. We
then retrieve a local cell ID within the current sub-grid by
comparing the current thread ID (which is a default variable in parallel computing environment, such as CUDA and
OpenCL, and equal to the position of current item in the array of workloads) to the beginning position of the current
segment. Then the local coordinates of the cell within the
sub-grid are calculated similarly to the above method by employing instead the local cell ID and the resolution of the
sub-grid as input. We finally add the local coordinates to the
beginning ones and calculate a global cell ID with Equation
1. The resulting cell ID along with the propagated triangle
ID constitutes the triangle-cell pair.
4.2. Building Triangle Pairs
The kernel for building the array of triangle pairs is invoked
just after the construction of the hierarchical grid. The triangle pairs belonging to each cell are processed as a segment
in the array of workloads. We record the number of triangles in each cell as n, hence the number of triangle pairs is
n(n − 1)/2. A parallel scan runs on the stream of sizes to
c 2011 The Author(s)
⃝
c 2011 The Eurographics Association and Blackwell Publishing Ltd.
⃝

In the building stage, a local ID of a triangle pair within
the segment is computed by comparing the current thread
ID with the beginning position of the segment. The order
defined in Figure 4 is taken for parsing the ID of triangles.
The partial sum method [SAW10] is employed to retrieve the
IDs of both triangles by utilizing the local ID, the descriptive
data n and the defined order.
T1

T2

T3

......

T4

Tn

T0

(T0,T1) (T0,T2) (T0,T3) (T0,T4)

...... (T0,Tn)

T1

(T1,T2) (T1,T3) (T1,T4)

...... (T1,Tn)

T2

(T2,T3) (T2,T4)

...... (T2,Tn)

T3

(T3,T4)

...... (T3,Tn)
......

In the following sections we will describe the specific implementations of the various tasks in the CD pipeline which
use this load balancing scheme.

calculate the beginning position. The number n and the beginning position of each segment are used as descriptive data
and propagated within each segment.

......

side-effect that the data calculated by adding the size and
the beginning position of the last segment together can be
utilized to determine accurate memory for the forthcoming workloads. Descriptive data describing the segment is
then written at the head of each segment in the array of
workloads and all the other items in the array are set to
zero. A mask array is also initialized to specify these segments. Then, an inclusive segmented scan with the add
operator is applied on the array of workloads. Since only
the first item in each segment is set as descriptive data
while all the others are zero, every item in each segment
will be equal to the descriptive data after the operation,
resulting in the descriptive data being propagated within
the whole segment.
∙ Parsing and Building The work kernel, each instance of
which processes a single workload, is invoked to complete
the final calculation by parsing the propagated data.

T n-1

(Tn-1,Tn)

Figure 4: The customized order of triangle pairs in each
segment.

Before outputting the triangle pairs, we first test the
bounding boxes of both triangles to reduce the number of
false positives. Another consideration is the redundant pairs
across multiple cells, see Figure 5, which will harm the performance of CD. We use the minimal position of the overlapped AABB of both triangles as the token position to remove the redundancy. The ID of the cell containing the token
position is calculated according to the hierarchy table, only
the thread working in that cell outputs a valid pair.
A

B

C

D

Figure 5: The same triangle pairs exist in both B and C cells
due to the fact that triangles may overlap multiple cells in the
grid. The minimal vertex of the overlapped AABB of both
triangles is chosen as the token position (in red) and only
the thread processing the cell (C) that contains the token
position outputs the pair.
A compaction operation is performed as the last step to
remove those invalid items (corresponding to pairs that either fail to pass the bounding box test or are redundant) to
build the final array of triangle pairs.

1456

Wenshan Fan / A Hierarchical Grid Based Framework for Fast Collision Detection

4.3. Building Feature Pairs

5. Implementation and Performance

The array of triangle pairs can be used directly to test collisions for DCD. For more expensive CCD, up to 15 feature
pairs (6 vertex-face (VF) pairs and 9 edge-edge (EE) pairs)
are built per triangle pair to calculate the first contact time
by solving a cubic equation [Pro97].

We have implemented the proposed method using NVIDIA’s
CUDA toolkit 2.3 [NVI09] on two commodity graphics
cards: a GeForce GTX 295, which contains two 240-core
GPUs, and a GeForce GTX 480. Our tests used only one
GPU of the GTX 295. The specifications on both graphics
cards are listed in Figure 7, which also includes a GeForce
GTX 285 that was used by the papers we compare our
method with.

In our method, the VF and EE tests are processed separately. The feature pairs associated with each triangle pair are
regarded as a segment. Due to the fact that a feature may be
shared by more than one triangle, many feature pairs would
be calculated repeatedly. Hence we employ a randomized
masking scheme [WB06] to remove the redundancy. We first
calculate the exact number of effective feature pairs with the
masking scheme and use the bit mask to identify the feature
pairs related to each triangle pair according to a customized
order (see Figure 6). A parallel scan then runs on the stream
of numbers to compute the beginning position of each segment in the array of workloads as well as the total size of
that array. We use the later to allocate the memory for the effective feature pairs. Finally, the resulting beginning position
and the bit mask are used as descriptive data and propagated
by a segmented scan.
v0
e0
v0

e2
v2

e0
e1
A

v1

v1

v2

f0

vf0

f1

vf3 vf4 vf5

vf1 vf2

B

e0

e1

e2

ee0 ee1 ee2

e1

ee3 ee4 ee5

e2

ee6 ee7 ee8

C

Figure 6: The order of features, VF pairs and EE pairs are
defined from Figure A to C. A 6-bit mask and 9-bit mask are
used to identify the VF and EE pairs respectively according
to the defined order.

During the parsing stage, the local ID of the feature pair
in each segment and the bit mask are employed to retrieve
the features. The filter introduced by Tang et al. [TMT10]
is employed to reduce the number of the elementary tests
further. Only those that pass the culling are accurately solved
by the cubic equation.
Note that actual storage size of the effective feature pairs
is calculated in our method to allocate memory. In a naive
method, however, although not all the 6 VF pairs and 9 EE
pairs associated with each triangle pair are required for elementary tests, the 6 times and 9 times storage of that of triangle pairs must still be reserved because of inflexible memory system on GPU, making it inefficient or sometimes even
impossible to implement due to the large memory requirements. In the tested scenes, by combining our propagation
scheme with the masking approach, the storage for feature
pairs is reduced by 89%.

Graphics Card

GTX 295

GTX 285

GTX 480

CUDA Cores

480
(240 per GPU)

240

480

Graphics Clock (MHz)

576

648

700

Memory Clock (MHz)

999

1242

1848

Memory
Bandwidth(GB/sec)

223.8

159.0

177.4

Figure 7: The graphics cards that are relevant to our work.
Two GPUs, each of which equips with 240 CUDA cores, are
combined on a GTX 295 graphics card.
We tested several typical benchmarks (see Figure 8) with
different complexities and characteristics to verify the performance of our method.
∙ HR Funnel A high resolution version (18K triangles) of
a funnel model in which a cloth passes through a funnel
under the pressure of a ball.
∙ Flamenco This benchmark (49K triangles) has several
cloth layers which are very close to each other, making
it difficult to detect collisions.
∙ Cloth on Ball This benchmark (92K triangles) has a high
number of non-rigid self-collisions across the whole simulation.
∙ N-body The scene (146K triangles) consists of hundreds
of balls and other geometric primitives. The sizes of the
triangles vary greatly in this benchmark.
The timings of DCD and CCD for the benchmarks on different GPUs with our method are provided in Figure 9. The
threshold defining the change of resolution for invoking a
complete update is 10% in all the tests when performing the
deferred update scheme. The most important to note here is
the relative improvement of the same benchmark on different GPUs, which shows that our hierarchical grid based algorithm scales well with increasing parallelism of graphics
hardware.
Figure 10 shows the breakdown of time costs of the key
steps in our method for the Cloth on Ball benchmark running
on a single GPU of GTX 295 graphics card for CCD. The actual computation for testing collisions, such as EE tests, VF
tests and triangle-triangle tests, takes the most of the overall running time (75.1%), while the cost on constructing the
hierarchical grid, including assignment, deferred update and
c 2011 The Author(s)
⃝
c 2011 The Eurographics Association and Blackwell Publishing Ltd.
⃝

Wenshan Fan / A Hierarchical Grid Based Framework for Fast Collision Detection

(a) HR Funnel

(b) Flamenco

(c) Cloth on ball

(d) N-body

1457

Figure 8: The benchmarks tested for verifying the performance of our method.

Model

DCD(ms)

CCD(ms)

GTX 295

GTX 480

GTX 295

GTX 480

HR Funnel

5.6

4.2

11.1

7.2

Flamenco

15.7

8.4

27.6

15.4

Cloth on Ball

19.1

8.6

36.5

17.4

N-Body

24.1

16.5

58.3

46.3

Figure 9: The performance of our algorithm for CCD and
DCD as tested on a GTX 295 graphics card using a single
GPU and a GTX 480 graphics card. The timings are in millisecond and include all the operations of the CD pipeline.

bounding box calculation, just takes 24.9%. As a comparison, we also implemented a straightforward construction
method, which takes a usual top-to-bottom order and requires two-pass testing and variant-number of memory writing to output the triangle-cell pairs. We observed on average
6x speedups in the procedure.

Time ratio of main steps
28.2%

25.7%
21.2%

19.3%
5.6%

calculating EE

calculating VF

building
triangles pair

building
hierarchical grid

calculating
bounding box

Simon et al. [SAW10] first proposed a uniform grid based
method to detect collisions for deformable meshes, in which
the largest size of triangles is always used to determine the
resolution of grid. Their algorithm performs efficiently for
scenes containing triangles with relatively even size. However, their method leads to an inefficient subdivision for the
scenes consisting of triangles with non-uniform sizes, which
are common in the real world, due to the high number of
false positives caused by large cells. Our hierarchical grid
based method removes the limit and has better adaptivity for
practical applications.
Simon et al. tested their methods using one, two and four
GPUs of GTX 295. Due to the relatively even size of triangles in the scene and the low overhead on updating the
uniform grid, our result on a single GPU of GTX 295 is
slower than theirs on the Cloth on Ball benchmark (36.5ms
vs. their 23.3ms) for CCD. However, on the N-body benchmark where the ratio of size of triangles is large, our method
outperforms theirs (a speedup of 3.2x) and works even better than theirs on four GPUs of GTX 295 (58.3ms vs. their
77.7ms). Our method on a single GPU of GTX 295 is evidently faster than theirs on all the tested benchmarks for
DCD (a speedup of 5.3x is achieved for the N-body benchmark), and our results on GTX 480 are always faster than
their best results running on four GPUs of GTX 295. For example, they take 36.9ms and 77.7ms on the N-body benchmark for DCD and CCD respectively, as compared with our
16.5ms and 46.3ms.

Figure 10: The time ratios of the key steps in our method for
the Cloth on Ball benchmark.

BVH is extensively employed for hierarchical culling to
reduce the computation cost of collision detection.

6. Comparison

Kim et al. [KHH∗ 09] proposed a hybrid BVH based approach, in which the sophisticated reconstruction and hierarchy traversal are performed on the multi-core CPU, while
only the elementary tests are delivered to GPU to solve
cubic equation. They tested the Cloth on Ball and the N-

We compare our method with some of the state-of-the-art
GPU based collision detection algorithms in this section.
c 2011 The Author(s)
⃝
c 2011 The Eurographics Association and Blackwell Publishing Ltd.
⃝

1458

Wenshan Fan / A Hierarchical Grid Based Framework for Fast Collision Detection

body benchmarks on a machine equipped with a quad-core
Xeon CPU and two GTX285 GPUs and achieved 23.2ms and
53.8ms, which are faster than our method on a single GPU of
GTX 295 but consuming more computational resources, and
slower than our method on GTX480. Moreover, data transfer between CPU and GPU is still a bottleneck for any hybrid
approach.
Fast algorithms completely running on GPU have been
proposed by Lauterbach et al. [LMD10] and Tang et al.
[TMLT11] which employ refitting to reduce the cost of updating the hierarchy. Compared with grid based methods, the
traversals of BVH usually are required to build the collision
pairs on GPU, while parallelization of the traversal operations is a challenging task in the SIMD context. BVTT front
based approach is employed in both methods, effectively reducing the overhead on traversal. With the adaptivity for
non-uniform distribution of scene geometry, our hierarchical grid based technique can be employed as an alternate to
BVTT front based approach while possessing the simplicity
of uniform grid.
Lauterbach et al. provided timings on a GTX 285 graphics
card. Our method running on a single GPU of GTX 295 is
faster than theirs on all the same benchmarks for both DCD
and CCD (for example, the speedups of 2.9x and 1.3x are observed on the N-body, respectively) even though our graphics card is slower than theirs. Tang et al. reported their results
on GTX 285 and GTX 480 for just CCD. For the Flamenco
benchmark, a speedup of 2.5x is achieved in our method running on a single GPU of GTX 295 compared to theirs on
GTX 285 and a speedup of 2.1x is achieved on GTX 480.
For the N-body model, the speedups of 2.7x and 1.7x are
observed in our method.
Alcantara et al. [ASA∗ 09] recently proposed a new branch
for collision detection by employing parallel spatial hashing
which is efficiently built on GPU. They described the collision detection algorithm between two deformable voxelized
surfaces. Contrary to our accurate intersection, they compute
approximations that are limited by the resolution of the voxel
grid.
Limitations: Our method has some limitations. Firstly, a
two-level variant of the hierarchical grid [Mir96] with the
fixed ratio between the resolutions of different levels is used
in our work. Although the overhead on maintaining the simplified hierarchy is reduced, the subdivision is with less flexibility compared to a scheme with deeper hierarchy and variant ratio [Kal09]. Secondly, the simple axis-aligned bounding boxes (actually 6-DOP) are used in our work as a tradeoff between culling efficiency and memory access. However,
the culling efficiency of AABB is lower than that of some
delicate bounding boxes, such as oriented bounding boxes
and the more complex k-DOP. Future GPUs with enhanced
accessing capability could facilitate the employment of more
flexible bounding boxes.

7. Conclusion and Future Work
We have presented a novel framework for fast collision detection for deformable models with self-collision on GPU
architecture. A two-level grid is employed to adaptively subdivide the scene geometry to reduce the number of false positives. A bottom-to-top method is applied to efficiently assign triangles into the hierarchical grid without iteration. A
deferred update scheme is proposed by exploiting the spatial and temporary coherence in deformable models between
adjacent time steps. A propagation scheme for load balancing across concurrent threads is introduced to avoid mutable
accesses and suspensions. Experimental results highlight the
speedups of our method over prior algorithms.
We see many avenues for future work. Firstly, we will improve the performance further by using a system with multiple GPUs. Secondly, we will extend our method to perform
other proximity queries, such as separate distance queries.
We are also interested in considering some specific algorithms, such as [VMT94], for the processing of self-collision
to enhance overall performance.

Acknowledgments
We thank Simon Pabst and Artur Koch for constructive
discussions on the subject, Alec Rivers for his help on
editing the manuscript, and the anonymous reviewers for
their thoughtful and constructive comments. The Cloth on
Ball and N-body benchmarks are courtesy of the UNC Dynamic Scene Benchmarks collection. The Flamenco dancer
is courtesy of Walt Disney Animation Studios and provided by Rasmus Tamstorf. The HR Funnel is provided
by Simon Pabst. The research was supported by Chinese 973 Program (2010CB328001), the National Science
Foundation of China (61003096), NSFC-JST Key Joint
Funding Project(51021140004) and Chinese 863 Program
(2010AA186002).

References
[ASA∗ 09] A LCANTARA D. A., S HARF A., A BBASINEJAD F.,
S ENGUPTA S., M ITZENMACHER M., OWENS J. D., A MENTA
N.: Real-time parallel hashing on the GPU. In Proceedings of
ACM SIGGRAPH Asia 2009 (New York, NY, USA, 2009), ACM,
pp. 1–9. 2, 8
[BFA02] B RIDSON R., F EDKIW R., A NDERSON J.: Robust treatment of collisions, contact and friction for cloth animation. In
Proceedings of ACM SIGGRAPH (New York, NY, USA, 2002),
ACM, pp. 594–603. 2
[BWK03] BARAFF D., W ITKIN A., K ASS M.: Untangling cloth.
In Proceedings of ACM SIGGRAPH (New York, NY, USA,
2003), ACM, pp. 862–870. 2
[CLMP95] C OHEN J. D., L IN M. C., M ANOCHA D., P ONAMGI
M.: I-COLLIDE: an interactive and exact collision detection
system for large-scale environments. In Proceedings of the 1995
symposium on Interactive 3D graphics (New York, NY, USA,
1995), ACM, pp. 189–196. 2
c 2011 The Author(s)
⃝
c 2011 The Eurographics Association and Blackwell Publishing Ltd.
⃝

Wenshan Fan / A Hierarchical Grid Based Framework for Fast Collision Detection

1459

[CUD09] CUDPP: CUDA data parallel primitives library.
http://code.google.com/p/cudpp/, 2009. 2

[NVI09] NVIDIA:
NVIDIA CUDA programming guide.
http://developer.nvidia.com/cuda, June 2009. 6

[FF03] F UNFZIG C., F ELLNER D.: Easy realignment of k-DOP
bounding volumes. In Graphics Interface’03 (2003), pp. 257–
264. 2

[PR95] PALMER I., R.L. G.: Collision detection for animation
using sphere-trees. Computer Graphics Forum 14, 2 (1995), 105–
106. 2

[GLM96] G OTTSCHALK S., L IN M. C., M ANOCHA D.:
OBBTree: a hierarchical structure for rapid interference detection. In Proceedings of ACM SIGGRAPH (New York, NY, USA,
1996), ACM, pp. 171–180. 2

[Pro97] P ROVOT X.: Collision and self-collision handling in cloth
model dedicated to design garment. In Graphics Interface’97
(1997), pp. 177–189. 6

[GLM06] G OVINDARAJU N. K., L IN M. C., M ANOCHA D.:
Fast and reliable collision culling using graphics hardware. IEEE
Transactions on Visualization and Computer Graphics 12, 2
(2006), 143–154. 2
[Gra07] G RAND S.: Chapter 32: Broad-phase collision detection
with CUDA. In GPU Gems 3, Hubert N., (Ed.). Addison Wesley,
2007, pp. 697–721. 1, 2, 3
[GRLM03] G OVINDARAJU N. K., R EDON S., L IN M. C.,
M ANOCHA D.:
CULLIDE: interactive collision detection between complex models in large environments using graphics hardware. In Proceedings of the ACM SIGGRAPH/EUROGRAPHICS conference on Graphics hardware
(Aire-la-Ville, Switzerland, Switzerland, 2003), Eurographics
Association, pp. 25–32. 2
[GRLM05] G OVINDARAJU N. K., R EDON S., L IN M. C.,
M ANOCHA D.: Quick-CULLIDE: Efficient inter- and intraobject collision culling using graphics hardware. In IEEE Virtual
Reality (2005), pp. 59–66. 2
[HLC∗ 97] H UDSON T. C., L IN M. C., C OHEN J.,
G OTTSCHALK S., M ANOCHA D.: V-COLLIDE: accelerated collision detection for VRML. In Proceedings of the
second symposium on Virtual reality modeling language (New
York, NY, USA, 1997), ACM, pp. 117–125. 2
[Hor05] H ORN D.: Chapter 36: Stream reduction operations for
GPGPU applications. In GPU Gems 2, Pharr M., (Ed.). Addison
Wesley, 2005, pp. 573–589. 2
[HSO07] H ARRIS M., S ENGUPTA S., OWENS J. D.: Chapter 39:
Parallel prefix sum (scan) with CUDA. In GPU Gems 3, Hubert
N., (Ed.). Addison Wesley, 2007, pp. 851–876. 2, 3
[Hub96] H UBBARD P. M.:
Approximating polyhedra with
spheres for time-critical collision detection. ACM Trans. Graph.
15, 3 (July 1996), 179–210. 2
[Kal09] K ALOJANOV J.: Parallel and Lazy Construction of Grids
for Ray Tracing on Graphics Hardware. Master’s thesis, Universität des Saarlandes, September 2009. 8
[KHH∗ 09] K IM D., H EO J.-P., H UH J., K IM J., YOON S.- E .:
HPCCD: Hybrid parallel continuous collision detection using
CPUs and GPUs. Computer Graphics Forum 28, 7 (2009),
1791–1800. 1, 2, 7
[KHM∗ 98] K LOSOWSKI J. T., H ELD M., M ITCHELL J. S. B.,
S OWIZRAL H., Z IKAN K.: Efficient collision detection using
bounding volume hierarchies of k-DOPs. IEEE Transactions on
Visualization and Computer Graphics 4, 1 (January 1998), 21–
36. 2
[KHY08] K IM D., H EO J.-P., YOON S.-E.: PCCD: parallel
continuous collision detection. Technical Report CS-TR-2008298, KAIST, Korea, 2008. 2
[LMD10] L AUTERBACH C., M O Q., D. M.: gProximity: Hierarchical GPU-based operations for collision and distance queries.
Computer Graphics Forum 29, 2 (2010), 419–428. 1, 2, 4
[Mir96] M IRTICH B. V.: Impulse-based dynamic simulation of
rigid body systems. PhD thesis, 1996. 8
c 2011 The Author(s)
⃝
c 2011 The Eurographics Association and Blackwell Publishing Ltd.
⃝

[SAW10] S IMON P., A RTUR K., W OLFGANG S.: Fast and scalable CPU/GPU collision detection for rigid and deformable surfaces. Computer Graphics Forum 29, 5 (2010), 1605–1612. 1, 2,
4, 5, 7
[SHG08] S ENGUPTA S., H ARRIS M., G ARLAND M.: Efficient
parallel scan algorithms for GPUs. Technical Report NVR2008-003, NVIDIA, 2008. 2
[SHZO07] S ENGUPTA S., H ARRIS M., Z HANG Y., OWENS
J. D.: Scan primitives for GPU computing. In Proceedings of the 22nd ACM SIGGRAPH/EUROGRAPHICS symposium on Graphics hardware (Aire-la-Ville, Switzerland, Switzerland, 2007), Eurographics Association, pp. 97–106. 2
[TMLT11] TANG M., M ANOCHA D., L IN J., T ONG R.:
Collision-streams: Fast GPU-based collision detection for deformable models. In Proceedings of the 2011 ACM SIGGRAPH
symposium on Interactive 3D Graphics and Games (2011). 1, 2
[TMT09] TANG M., M ANOCHA D., T ONG R.: Multi-core collision detection between deformable models. In 2009 SIAM/ACM
Joint Conference on Geometric and Physical Modeling (New
York, NY, USA, 2009), ACM, pp. 355–360. 2
[TMT10] TANG M., M ANOCHA D., T ONG R.: Fast continuous
collision detection using deforming non-penetration filters. In
Proceedings of the 2010 ACM SIGGRAPH symposium on Interactive 3D Graphics and Games (New York, NY, USA, 2010),
ACM, pp. 7–13. 6
[VMT94] VOLINO P., M AGNENAT T HALMANN N.: Efficient
self-collision detection on smoothly discretized surface animations using geometrical shape regularity. Computer Graphics Forum 13, 3 (1994), 155–166. 8
[WB06] W ONG W. S.-K., BACIU G.: A randomized marking
scheme for continuous collision detection in simulation of deformable surfaces. In Proceedings of the 2006 ACM international conference on Virtual reality continuum and its applications (2006), pp. 181–188. 6
[WIK∗ 06] WALD I., I ZE T., K ENSLER A., K NOLL A., PARKER
S. G.: Ray tracing animated scenes using coherent grid traversal.
ACM Trans. Graph. 25, 3 (July 2006), 485–493. 4
[ZK07] Z HANG X., K IM Y. J.: Interactive collision detection for
deformable models using streaming AABBs. IEEE Transactions
on Visualization and Computer Graphics 13, 2 (March 2007),
318–329. 2


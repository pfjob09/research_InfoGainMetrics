DOI: 10.1111/j.1467-8659.2008.01173.x

COMPUTER GRAPHICS

forum

Volume 27 (2008), number 6 pp. 1632–1646

Improving Multipath Radiosity with Bundles of Parallel Lines
Roel Mart´ınez1 , Mateu Sbert1 and L´aszl´o Szirmay-Kalos2

2 Department

1 Institut d’Inform`
atica i Aplicacions, Universitat de Girona, Girona, Spain
of Control Engineering and Information Technology, Technical University of Budapest, Hungary

Abstract
Monte Carlo approaches use random lines to distribute the light power in the scene but the cost of creating a set
of random single lines is very costly. In this paper, we present several software and hardware techniques in order
to reduce the computational cost of the generation of random single lines by using bundles of parallel lines. The
bundle of parallel lines is simulated with a general purpose polygon filling algorithm, like the painter’s algorithm.
We also present two graphics hardware implementations. The first approach uses two depth buffers in order to
represent stochastically a bundle of parallel global lines. The second one uses multiple depth buffers and the aim
is to exploit coherence between projection planes for each iteration. All algorithms were implemented with the
multipath method.
Keywords: Monte Carlo methods, polygonfilling algorithms, multipath radiosity, depth buffer
ACM CCS: I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism

1. Introduction
Radiosity methods [Bek99, CW93, SP94] use a simplified
version of the rendering equation [Kaj86], where all surfaces
in the scene are discretized to patches and all the patches are
considered diffuse.
The Monte Carlo method [HH75, Sob76] allows to solve
the radiosity equation with sub-quadratic complexity in terms
of the number of patches. Stochastic radiosity methods establish an interaction between two random points/patches in
order to transfer power between them. They can be classified
according to the sampling of interacting point pairs, and we
can distinguish local and global methods. In local methods,
random lines are cast from an element of the polygonal mesh
(a patch) and only the first intersection of the lines is considered (see Figure 1(left)). This means that one interacting
patch is selected first then we find a communicating partner
for it.
On the other hand, in global Monte Carlo methods the
lines are global to the scene and all the intersections that a
line makes with the scene are used. In this case the source
and the receiver of the transfer are selected simultaneously.
c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and
Blackwell Publishing Ltd. Published by Blackwell Publishing,
9600 Garsington Road, Oxford OX4 2DQ, UK and 350 Main
Street, Malden, MA 02148, USA.

The advantage of global lines is that a single line helps to
exchange energy between all pairs of intersected face to face
patches (see Figure 1(right)). Thus the average computation
cost of finding a communicating pair is less in global methods than in local ones. However, when global sampling is applied, we cannot concentrate on the important sources. As we
know from Integral Geometry [San76, Sbe97], the number
of global lines that cross a planar patch is proportional to its
area, thus the probability that a global line intersects a small,
but intensive light source is very low. To avoid this problem,
a first shot algorithm is needed, which distributes the power
of small light sources, and global Monte Carlo method is
applied to compute the indirect illumination. Since indirect
illumination is usually much smoother, global sampling is
more efficient.
Another way to increase the efficiency of Monte Carlo
methods is to trace lines in bundles, which is much more
effective than tracing individual rays since we can exploit
incremental visibility algorithms and the graphics hardware.
The multipath algorithm for radiosity [SPNP96, Sbe97]
is one example of global line algorithms, which has seen
a further developing in [Bek99, BP97, SKP98, SK99]. In

1632

Submitted January 2007
Revised October 2007
Accepted December 2007

1633

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines
B
P3

P3
P4

P2

P1

P4

P2

A

P1

Figure 1: Left: a local line is cast from patch P1; we use only the first intersected patch (P2). Right: a global line is cast
between points A and B. Two pairs of intersected face to face patches [P1,P2] and [P3,P4] are selected to transfer energy.
[SK99] these methods were extended to handle non-diffuse
environments and it was shown that painter’s algorithm can
be used with advantage to generate the global lines in bundles.
Our purpose here is to reduce the computational cost of the
generation of random single global lines by using bundles of
parallel lines. We present several ways where the multipath
radiosity method was re-implemented using bundles of parallel lines. Also we introduce a new approach where we exploit
coherence on graphics hardware. We shall also demonstrate
that the global line algorithm is an effective alternative for
computing radiosity.
The paper is organized as follows. In Section 2, we present
the previous work on the subject. In Section 3, we review the
multipath implementation with bundles of parallel lines. In
Section 3.2, we obtain the optimal ratio pixel/patch and in
Section 3.4, we deal with small patches. In Section 4, we
introduce the adaptive algorithm. In Section 5, a hardwarebased implementation of the multipath method is presented.
In Section 6, we present a variant of the previous algorithm,
using several projection planes for the same random direction. In Section 7, we compare the classic multipath and the
painter’s and hardware-based implementations of the multipath method and finally we draw our conclusions.

2. Previous Work
Global lines were first used in rendering by Buckalew in
[BF89], then [Sbe93] showed the intimate relationship of
global lines to radiosity and used them to develop a full matrix radiosity method. The multipath algorithm for radiosity
[SPNP96, Sbe97] dropped the need for computing the form
factors explicitly. In [SPNP96, Sbe97], the multipath was
implemented with bundles of parallel rays, but the coherence was not exploited. Meanwhile, Neumann [Neu95] presented independently the transillumination algorithm, that
was further developed in [SKFNC97], [SKP98] and [SK99]
to handle non-diffuse environments, and it was shown that the
painter’s algorithm can be used with advantage to generate
the global lines in bundles. Pellegrini [Pel97] examined the

Source

Source

Figure 2: Random walk simulation with global lines. Top:
A global line (the thick continuous one) makes two paths
advance at once. Considering bidirectionality of the global
lines, two other paths will also advance in the reverse direction of the line. Bottom: Stressing the fact that the exit point
on each patch is at random.
error of form factor calculation with global lines. Hachisuka
[Hac04] implemented the tracing of parallel bundles on the
programmable graphics hardware using depth peeling and
demonstrated that this can also be used in final gathering of
global illumination solutions.

2.1. The multipath method
The multipath algorithm, described in [SPNP96, Sbe97], uses
segments of global lines to build random walks that mimic
classic random walks with infinite path length (see Figure 2).

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

1634

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines

The main differences between classical local random walk
and the multipath algorithm are that in multipath the source
probability is proportional to the area of the patch and in
a single step different paths are advanced simultaneously.
The first difference makes it efficient only in ‘smoothed’
scenes, with emittance occupying a large part of the scene
and more or less equilibrated. For this reason, as stated in
the introduction a first shot distributing direct illumination
before applying the algorithm is necessary.

B
N

S

The multipath algorithm works as follows: a predetermined number of random global lines are cast using, for
instance, pairs of random points on an enclosing sphere (that
confines the scene). Each line will produce an intersection
list, and the list is traversed taking into account each successive pair of patches. Each patch (if not emitter) stores two
quantities. One records the accumulated power, and the other
the unshot power. For every pair of face to face patches along
the intersection list, the first patch of the pair will transmit its
unsent power to the second patch of the pair. So the unshot
energy of the first patch is reset to zero, and the accumulated and the unsent energy are incremented at the second
patch. In the case of a source a third quantity is also kept,
the emitted power per line exiting the source. This power
is pre-computed in the following way. Given the number of
lines to cast, the forecast number of lines passing through
any source is found. For a planar patch, this number of lines
is proportional to the area of the patch and can be computed
using Integral Geometry methods [San76]. Thus, if a planar
patch is inside a sphere and a ray is casted using two random points on the sphere surface then the probability that the
ray intersects the patch is two times the patch area divided
by the sphere area [Sbe97]. The division of the total source
power by this number of forecast lines gives the predicted
power of one line. Then, if the first patch of a pair is a source
patch, the power transported to the second patch of the pair
will also include this predicted power portion. Considering
bi-directionality, the same process is applied for the second
patch of the pair of face to face patches.

3. Multipath with Bundles of Parallel Lines
Using bundles of parallel lines instead of single lines will
allow us to improve the line casting process, as is explained
in [SPNP96, Sbe97]. One way to get this improvement is the
use of ray-coherence acceleration.
Following the idea presented in [SPNP96, Sbe97], the
bundle of parallel lines is created as follows. First the scene
is enclosed in a sphere. Then a random point is selected on
the surface of the sphere, and a tangent plane to the sphere
is created. We call this plane the projection plane. The plane
defines the XY-axes and the Z-axis is defined by the normal
of the plane. The bundle of parallel lines is perpendicular to
the projection plane. Finally, all patches are projected onto

P

Figure 3: Bundle of parallel lines, where S is the sphere
that encloses the scene, B is the bundle of lines, P is the
projection plane tangent to S, and N is the normal to the
projection plane.
this plane, which is divided in n × m cells or pixels (see
Figure 3).
The main difference between the multipath algorithm of
this paper and the original multipath [SPNP96, Sbe97] is in
the use of the ray-coherence during the creation of a single
global parallel line. In [SPNP96, Sbe97], a single global line
is cast from every cell on the projection plane. In the new
approach, the bundle of parallel lines is simulated using a
general purpose polygon filling algorithm (in our implementation we have used the painter’s algorithm). Every pixel (on
the projection plane) simulates a global line because all the
patches that are projected in the same pixel are represented
in the list of intersected patches the line made with the scene
(see Figure 4).
The projection plane resolution is defined by the user and
is always a rectangular plane tessellated in n × m pixels. For
each iteration, the projection plane is the minimum rectangle
where it is possible to project all polygons.

3.1. Simulation of a bundle of parallel lines
The patch projection process is based on the painter’s algorithm (see [SKP98, SK99]). Before projecting, the patches
are sorted using the z value of the middle point of the patch.
Then every patch is projected onto the projection plane. If
the patch normal points in the same direction as the plane
normal, then the pixel is painted with the patch index, and is
labelled as back. If the patch normal and the plane normal

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines

P
[p1]
[p4,p1]
[p4,p3,p2,p1]
p4

p1
p3

[p3,p2]
[p3,p2]

1635

Note that sorting according to the z coordinate of the middle point of the patches does not always give the correct
order in which patches may hide each other. This problem
can be solved by applying the test and conditional clipping
presented in the original painter’s algorithm [NNS72]. On
the other hand, in scenes tessellated for radiosity, the error of
neglecting these tests is usually negligible. Another solution
is to store the complete list of patches in each pixel, together
with the z-values [Neu95].

[p2]
[p2]

p2
d

[]

Figure 4: Simulation of a bundle of global lines using
painter’s algorithm. Four polygons p1,p2,p3,p4 are projected
onto the projection plane P. On the right side of P (between
brackets), the list of projected polygons appears for every
pixel. The list simulates the intersection of all polygons the
global line made with the scene. d is the projection direction.
begin parallelRays
Read scene
Create the enclosing sphere
Compute a random point on the sphere
Create a projection plane(nxm pixels)
Clear pixels of the projection plane
//The plane defined XY-axes
//The normal of the plane defines the Z-axis
Sort all scene patches by their z value
For i=0 to total number of patches do
If patch i is front then
For j=0 to all pixels of patch i do
patch k= read pixel[j]
// between patches k and i
ExchangePower(k,i)
clean pixel j
endFor
else
write i onto the projection plane
endIf
endFor
end

Figure 5: Multipath with bundles of parallel lines using the
painter’s algorithm.
are opposite, then the exchange of power takes place and the
pixel is cleaned, and patch is labelled as front. Combining
this idea and the one presented in the previous section, the
algorithm that transfers power by a bundle of parallel lines
is in Figure 5. This algorithm was published in [MSKS00].
The exchange power process is the same as the multipath
single line implementation explained in Section 2.1. The
average time complexity of this algorithm is O(N log N )
due to the sorting step, where N is the number of patches.

3.2. Optimal patch/pixel size ratio
Line-bundle algorithms trace many parallel lines simultaneously. Obviously, if the computation time is limited, increasing the number of lines in a single bundle requires the
reduction of the number of bundles and vice versa. The question is how to find the optimal number of lines in a single
bundle. Note that the algorithm estimates the projected size
of the patches as the number of intersected lines multiplied
by the area of the pixels. Due to the Monte Carlo nature of
the algorithm, the expected value of this estimation should
give back the exact projected area. This requirement is met
until the projected area is not less than a single pixel. For
sub-pixel size patches, bias occurs, because those patches do
not appear on the projection plane. In order to increase efficiency after the projection process every patch has to appear,
at least, in one pixel. Then we have selected the heuristics of
using a average projected patch area/pixel size ratio of about
one.
Experimental evidence supports our heuristics. For instance, we fixed the total number of lines to 106 , and cast
bundles keeping this total (i.e., one bundle with 106 lines, 10
bundles with 105 lines, etc.). In Figure 6 (bottom), we can
see that when the pixel area increases, the execution time
also increases, because every bundle has a small number of
lines and then it is necessary to cast a lot of bundles (thus we
lose the benefit of coherence). In Figure 6 (top), we see the
error against the pixel area (square meters). From this figure,
we can determine that the executions with pixel area around
0.04, for the projection plane, are the best ones, because at
this point the error starts to keep more or less in the same
level. But this value 0.04 corresponds precisely to the average
patch area (square meters) for the test scene (we tested the
office scene in Figure 7, consisting of 1166 polygons divided
in 3818 patches, for seven different pixel area). Also the ‘big
room’ scene shows similar results.

3.3. Implementation details
We have implemented the presented algorithm in the SIR
rendering framework [MPP98] in C++. The standard configuration used for this implementation and also for all additional programs in this paper is a Linux Suse Pentium
IV 3GHz processor. A complete rendering consists of the

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

1636

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines
400

"pixelAreaMSE1"
"pixelAreaMSE2"
"pixelAreaMSE3"

350

300

MSE

250

200

150

100

50

0
0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1

Pixel area (square meters)
180

"pixelAreaTime"

160

140

Time (seconds)

120

100

80

60

40

20

0
0

0.1

0.2

0.3

0.4
0.5
0.6
Pixel area (square meters)

0.7

0.8

0.9

1

Figure 6: From top to bottom, pixel area versus error (MSE) for three different executions and pixel area versus time (seconds)
for 1 million global lines (100 bundles with 10000 parallel lines per bundle). These results are for the office scene (Figure 7)
consisting of 1166 polygons divided in 3818 patches.
computation of the first-shot, i.e. the determination of the
direct illumination, and the multipath step that computes the
indirect illumination. The first shot step was implemented
with local lines, although a hardware-based implementation
can also be used [SKSMT00]. In the second step, the user
defines the number of bundles and also can define the number
of lines per bundle (also it is possible to define a maximum
error). We evaluate here only the performance of the multipath step since the proposed algorithm does not alter the
first shot computation. We used two test scenes. The ‘office’

scene (Figure 7) contains 1166 polygons decomposed into
3818 patches. The ‘big room’ scene (Figure 8) consists of
1130 polygons that have been subdivided into 22718 patches.
In Figure 7 a test scene was rendered with different numbers of bundles, 30, 50, 70 and 100, and for each of them 105
local lines, were used for the first shot step. The big difference between the images is the ceiling illumination. With 30
and 50 bundles the ceiling looks still noisy, with 70 bundles
the noise starts to disappear and with 100 bundles the scene

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines

1637

Figure 8: A test scene rendered with different number of
bundles 80 (top) and 200 (bottom) with 10 thousand parallel
lines per bundle. The scene has 1130 polygons divided in
22718 patches. A first shot with 106 local lines was used and
took 10.03 seconds. The execution time (for the global step)
is 6.12 and 15.58 seconds respectively. Note that no Gouraud
shading was done.

looks acceptable. Figure 8 shows two images computed with
80 and 200 bundles and 106 lines for the first shot step.

3.4. Dealing with small patches
As stated, the algorithm correctly calculates the expected
projected patch size if the projected area is greater than pixel
area, i.e. sub-pixel size patches may introduce errors. This
problem could be solved by increasing the resolution, but
it would also increase the computational cost. Fortunately,
the correct expectation can also be obtained by a Russian
roulette like algorithm that considers small patches only randomly with a probability that is proportional to their size (see
Figure 9).
The algorithm checks if the projected area of the patch
is smaller than the pixel area. If this is true, then a random
value (between 0 and 1) is generated. If the random value
multiplied by the pixel area is smaller than the projected area
of the patch then it is considered that the pixel is covered by
the patch. In the other case the patch is discarded.
An image obtained with Russian-roulette like algorithm
is shown in Figure 10. The added cost of this improvement
is about 2%, which is a very small penalty for the increased
image quality.
Figure 7: A test scene rendered with different number of
bundles, from top to bottom 30, 50, 70 and 100, respectively.
The scene has 1166 polygons divided in 3818 patches. A first
shot with 105 local lines was used and took 0.99 seconds.
The execution time (for the global step) is 0.65, 1.08, 1.49
and 2.11 seconds, respectively. The differences are observed
on the indirect illumination.

4. Adaptive Algorithm
This section presents an adaptive approach where the directions are obtained with importance sampling according to the
transported power. The approach is applied after the first shot
and does not take into account the original sources because
they do not have energy any more.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

1638

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines
line

with
probability:
projected patch area / pixel area

line

pixel

pixel

projected area

Figure 9: If the projected patch area is smaller than the pixel area, then the patch is used with a probability given by the
projected patch area divided by the pixel area.
The hemisphere of directions is divided into regions of
area i . Each region i is given an initial weight φ i (2π r 2
divided by i , where r is 1) by sampling uniformly one direction in each, the weight is proportional to the transported
power. The transported power is the power per line multiplied by the number of lines crossing that area. Then the
regions are sampled according to the (normalized) weights
φ i and a direction is chosen randomly in the selected region. It means, more transported power per region more
directions per region. The transported power per line in
the bundle is corrected by dividing it with the quantity
2π φ i / i . The weights are corrected (the total transported
power for that region is divided by i ) after each bundle
transport.
In Figure 11, both images were obtained with a first shot
and 200 bundles. Compare the much superior quality of the
lower image obtained with the adaptive multipath algorithm
against the left one without adaptivity. This test scene, where
there is an important difference in the power transported
in different regions, is particularly well fitted to show the
benefits of the algorithm. Obviously the more equilibrium
between the different hemispherical regions, the less is the
obtained benefit. Note, however, that the extra cost incurred
by the adaptive algorithm is negligible, thus it could be used
for most of the cases.
5. Representative Projection

Figure 10: From top to bottom, the images were generated
with Multipath and Multipath dealing with small patches.

In this section, we present a hardware-based implementation
of the multipath method, using the OpenGL’s depth buffer.
In Section 5.1, we introduce a method that uses the depth
buffer once in each iteration step. The depth buffer represents
stochastically a bundle of parallel global lines crossing the
scene. The transfer of energy is done using two opposite depth
buffer planes with the projection of all scene patches onto
them.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines

1639

The discretized projection planes are represented by matrices with n × m pixels (n, the plane width, and m, the plane
height, are defined by the user) and they store the closest
patch IDs that are projected onto them. The two polygons
identified by the IDs in the corresponding positions (for the
two projection planes, see Figure 13) will exchange power.
The exchange power function is similar to the multipath
single line implementation [SPNP96, Sbe97], explained in
Section 2.1. The only difference is that now the power is
divided by the probability that the projected plane crosses
between two patches in order to compensate that we are simulating a segment of global lines. This probability is given by
the maximum distance in Z divided by the distance between
the pair of patches. Because all Z values on the OpenGL
depth buffer are between 0 and 1, the probability is given
by the subtraction of the two Z values as read out from the
z-buffer.
Note that the projection plane is a plane tessellated in n
× m pixels, defined by the user, and this resolution is fixed
because it is too expensive to change the resolution (using
OpenGL) at every iteration. Thus projection plane is the
minimum rectangle which can enclose the projection of all
patches of the scene for all directions. In addition, the pixel
area is defined by the hardware and usually is one.

Figure 11: The upper image was generated with Multipath
and the lower image by Adaptive Multipath. The light source
is pointing to the ceiling.

5.1. A single depth buffer implementation
The bundle of parallel lines is obtained as follows: First, a
random direction RD is sampled. This direction defines the
Z-axis. Using this direction all the scene patches are transformed into a new coordinate system. Second, the minimum
and maximum values of Z are computed. Then a random
point RP between this values is selected (see Figure 12(b)).
Third, two projection planes are defined incident to RP and
orthogonal to RD (see Figure 12(c)), and will be used with
two opposite viewing directions. All patches are projected
onto the projection planes from the two directions using the
OpenGL’s depth buffer. The two opposite depth buffers simulate a segment of a global line that intersects two patches.
Finally, the exchange of power is computed between the corresponding pixels of the two rendering steps (see Figure 13).
This is summarised in the algorithm presented in Figure 14.

For the implementation, we have used a NVidia GForce
6800GT card and OpenGL. A complete rendering consists of
the computation of the first shot and the multipath step that
computes the indirect illumination. The first shot step was
implemented with local lines. In this step, 4 million local
lines were used. For the two test scenes, ‘big room’ scene
(Figure 15) and ‘office’ scene (Figure 16), the time of the
first shot step is 40.15 and 31.91 seconds, respectively. The
resolution of the depth buffer is 100 × 100 pixels for both
test scenes. It means that every bundle of parallel lines has
10000 global lines. The new algorithm could render these
scenes in 0.91 and 0.89 seconds, respectively, while the
painter’s algorithm implementation (see previous section)
needed 8.06 and 7.41 seconds, respectively. The z-buffer implementation is 8.5 times faster than the painter’s algorithm.
In Figures 17 (bottom), we plotted the number of bundles
versus the time in seconds for the ‘big room’ scene. The performance of the depth buffer implementation is clearly better
than the painter’s implementation.
In Figure 17(top), we see that the errors for different numbers of bundles are practically the same in both depth buffer
and painter’s algorithms, with a very slight advantage in case
of small numbers of bundles for the painter’s implementation. This difference is due to the fact that the probability
that a plane crosses between two patches is very small when
the distance between them is small too. For example, in
Figure 15(top), the table patches near the wall (which is
not visible in the image) received almost no energy, and in
Figure 15(bottom), the same table patches have better illumination results.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

1640

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines

LS

LS

RD

RP

RD

D1

LS

P1

LS

RP

P2

P1

N1

P2

N2

D2

Figure 12: From left to right and top to bottom: We have a simple scene with two objects and a light source (LS). A random
direction RD and a random point RP are selected. Two planes with opposite normals (P1 and P2) are created incident to RP,
and are decomposed into n × m pixels. Projection directions (D1 and D2) are defined. D1 has the same direction as RD, while
D2 is opposite to D1.

LS

Figure 13: The patches of figure 12 are projected onto the projection planes. We obtain two images, where the corresponding
pixels identify those patches that see each other from the opposite side of the projection plane. The exchange of energy is done
between corresponding pixels of the two projection planes.

On the other hand, the depth buffer implementation shows
better results in open spaces. For example, in Figure 15(top)
the ceiling looks better than in Figure 15(bottom). Also in
Figure 16(top) and (bottom), we can see an improvement in
the ceilings’ illumination.

6. Multiple Representative Projections
The algorithm presented in [MSKS02] and explained in Section 5.1 uses one double projection plane for each random
direction. Here we present a variant using several projection

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines

1641

begin sendBundle
Compute a random direction RD
Transform all patches
Compute the minimum and maximum Z values
Compute a random Point RP
Create two opposite projection planes
Clear the projection planes
// between maximum Z and RP
Project patches onto projection plane 1
// between RP and minimum Z
Project patches onto projection plane 2
For i=0 to projectionPlaneWidth do
For j=0 to projectionPlaneHeight do
// for a mirror like pair of patches
// (see figure 13)
Exchange power
endFor
endFor
end sendBundle

Figure 14: Creation of a bundle of parallel lines using a
depth buffer.

Figure 15: Images of the “big room” scene, consisting of
1130 polygons that have been subdivided into 27282 patches,
obtained with Multipath with OpenGL depth buffer (top) and
with painter’s algorithm (bottom). Both images were generated with 4 million local rays and 100 bundles. The second
step took 0.91 seconds (top) and 8.06 seconds (bottom).
planes for the same random direction. The aim is to exploit
coherence between projection planes for each iteration where
just the patches that are part of a section are projected onto
the depth buffer.

6.1. A multiple depth buffer implementation
The bundles of parallel lines are obtained as follows: First,
a random direction RD is selected. This direction defines
the Z-axis. Using this direction all the scene patches are
transformed into a new coordinate system and all patches

Figure 16: Images of the ‘office’ scene, consisting of 547
polygons decomposed into 26322 patches, obtained with
Multipath with OpenGL depth buffer (upper) and with
painter’s algorithm (lower). Both images were generated
with 4 million local rays and 100 bundles. The second step
took 0.89 seconds (top) and 7.41 seconds (bottom).

are sorted using the z value of one of their vertices. Second, the minimum and maximum values of Z are computed.
With these values the scene is divided in N equal intervals
(where N is a user defined parameter, see Figure 18(topright)). Third, a random point RP between the minimum
and maximum values of Z for each interval is selected (see
Figure 18(top-right)). The window plane, i.e. the projection
plane, is defined incident to RP and orthogonal to RD (see
Figure 18(bottom-left)), and will be used two times with two
opposite viewing directions. This is repeated for all the intervals. Fourth, the projection of all scene patches is made in two
steps. In the first one, there is a traversal from the minimum

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

1642

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines
4

"painter"
"zBuffer"

3.5

MSE

3

2.5

2

1.5
0

200

400

600

800
1000
1200
Number of bundles

1400

180

1600

1800

2000

"painter"
"zBuffer"

160

140

Time (seconds)

120

100

80

60

40

20

0
0

200

400

600

800
1000
1200
Number of bundles

1400

1600

1800

2000

Figure 17. Comparison of the Multipath method using the painter’s algorithm with the OpenGL depth buffer implementation.
We plotted (top) the error vs the number of bundles and (bottom) the time in seconds vs the number of bundles, for the “big
room” scene (see Figure 15).
to the maximum value of Z for the whole scene. But only the
patches that are part of the first interval are projected onto
the projection plane using the OpenGL’s depth buffer. After the projection, a copy of this projection plane is made.
Here it is possible to exploit the coherence between projection planes. The projection plane for the second interval is the
sum of the first projected plane plus the projected patches that
are between this interval. For the rest of the intervals the same
operation is applied. In a second step the traversal is made
from the maximum to minimum value of Z. Finally, the exchange of power is done between the corresponding pixels of

the two projection planes of each interval (following the same
mirror like relation presented in Figure 13). Thus, for example, the first projection plane of the minimum-to-maximum
traversal step exchanges energy with the last projection plane
of the maximum-to-minimum traversal step.
In [MSKS03] the presented algorithm was implemented
using Mesa libraries. Here the algorithm is implemented in a
NVidia GForce 6800GT card using OpenGL in a Linux Suse
Pentium IV 3GHz. We show some results in Figures 19 and
20. es

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

1643

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines

RD
LS

LS

RP4

RP3

RP2

RP1

RD
P5

LS

N5

RP4

P5
N6

P4
P6

LS
N4

P4

N3

P3

P6
P3

RP3
N7
RP2

P7

P7

P2

N2

P2

N8
RP1

P8
P1

D1
P8
N1

P1
D2

Figure 18: From left to right and top to bottom: A scene with two objects and a light source (LS). A random direction RD is
created. The line is divided into four segments and for each segment a random point RP is selected. A pair of projection planes
P with two opposite normals are created for each segment incident to RP, and are decomposed into n × m pixels. Projection
directions (D1 and D2) are defined.

For the ‘tables room’ scene (Figure 19), consisting of 4840
polygons decomposed into 115932 patches, 15 million local
rays were cast (310 seconds) and 3000 iterations were used
for the indirect illumination (88 seconds). In each iteration
fou pairs of projection planes were computed.
For the ‘desks room’ scene (Figure 20), consisting of 2264
polygons decomposed into 126132 patches, 15 million local
rays were cast (155 seconds) and 3000 iterations were used
for the indirect illumination (93 seconds). In each iteration
four pairs of projection planes were computed.
The resolution of the depth buffer is now 128 × 128 pixels for both test scenes. For both executions four pairs of
projection planes were computed in every random direction.
Finally, a comparison between the implementations using
OpengGL libraries and Mesa libraries, and with and without
the use of coherence of the projection planes respectively,
showed that the first case reduces the computation time of
indirect illumination by 50%.

7. Comparison between the Implementations
In this section, we compare the classic multipath
([SPNP96,Sbe97]) explained in Section 2.1, the painter’s,
the single depth buffer and the multiple depth buffer implementations with bundles of parallel lines.
In Figure 21, we plotted the number of bundles versus the
error (top) and the number of bundles versus the time in seconds (bottom) for the ‘desks room’ scene (see Figure 20). In
the case of the classic multipath implementation the global
lines casted correspond to the number of bundles multiplied
by the number of lines per bundle. We see that the errors for
the different number of bundles are almost the same in both
hardware implementations. The classic multipath presents
the smallest errors, around 10% better than the painter’s and
depth buffer implementations. On the other hand, the performance of the multiple depth buffer implementation is slightly
better than the single depth buffer one. Both hardware implementations are between 8 and 10 times faster than the painter
multipath and more than 20 times faster than the classic

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

1644

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines

Figure 20: Images of the ‘desks room’ scene, consisting of
2264 polygons decomposed into 126132 patches, obtained
with the multiple OpenGL depth buffer implementation. The
radiosity solution was generated with 15 million local rays
for the first shot (155 seconds) and 3000 iterations for the
indirect illumination (93 seconds). In each iteration four
pairs of projection planes were computed.
multipath. Also the ‘tables room’ scene (Figure 19) shows
similar results.
8. Conclusions
In this paper, we have presented several techniques in order
to reduce the computational cost of the generation of global
lines in the context of global line Monte Carlo radiosity. The
global lines are used to transfer the energy between patches
in a tessellated scene.

Figure 19: Images of the ‘tables room’ scene, consisting of
4840 polygons decomposed into 115932 patches, obtained
with the multiple OpenGL depth buffer implementation. The
radiosity solution was generated with 15 million local rays
for the first shot (310 seconds) and 3000 iterations for the indirect illumination (88 seconds). In each iteration four pairs
of projection planes were computed. No Gouraud shading
was done.

In Section 3, we have introduced a variation of the multipath method based on bundles of parallel lines. The bundle
of parallel lines is simulated using a general purpose polygon
filling algorithm, like the painter’s algorithm. In Section 4,
we have presented an adaptive version.
In Section 5, we have introduced the representative projection algorithm with two different implementations of the
multipath method. This algorithm uses two depth buffers in
order to represent stochastically a bundle of parallel global
lines. Reading back the images, we have a set of mutually
visible pixels (patches), which can be used to exchange energy.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines
3.8

1645

"classic"
"painter"
"zBuffer"
"multipleZB"

3.6

3.4

MSE

3.2

3

2.8

2.6

2.4

2.2
0

500

1000

1500
Number of bundles

2000

2500

2500

3000

"classic"
"painter"
"zBuffer"
"multipleZB"

Time (seconds)

2000

1500

1000

500

0
0

500

1000

1500

2000

2500

3000

Number of bundles

Figure 21: Comparison of the classic Multipath method, Multipath using the painter’s algorithm, OpenGL depth buffer and
multiple OpenGL depth buffer implementations. We plotted (top) the error versus the number of bundles and (bottom) the time
in seconds versus the number of bundles for the ‘desks room’ scene (see Figure 20).
The first implementation presented in Section 5.1 uses two
depth buffers (implemented by the graphics hardware) in order to create a bundle of parallel lines. In Section 6.1, we
introduced a new improvement on the creation of bundles
of parallel lines implemented by the graphics hardware, that
uses multiple depth buffers and exploits coherence between
projection planes for each iteration. This multiple implementation is around 20% faster than the single one.

faster than the painter multipath and more than 20 times faster
than the classic multipath.

In Section 7, the classic multipath, the multipath with the
painter’s algorithm and the hardware implementations using
two depth buffers and multiple depth buffers were compared.
The hardware implementations were between 8 and 10 times

Acknowledgements

In this paper all algorithms were implemented with the
multipath method but we believe that all of them can be
easily applied to any Monte Carlo approach.

This project has been funded in part with grant number IST2-004363 (GameTools project) of the European Community
and TIN2004-07451-C03-01 of the Spanish Government.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

1646

R. Mart´ınez et al. /Improving Multipath Radiosity with Bundles of Parallel Lines

References
[Bek99] BEKAERT P.: Hierarchical and Stochastic Algorithms for Radiosity. PhD thesis, Department of Computer Science, Katholieke Universiteit Leuven, Leuven,
Belgium, 1999.
[BF89] BUCKALEW C., FUSSELL D.: Illumination networks:
Fast realistic rendering with general reflectance functions.
In Computer Graphics (ACM SIGGRAPH ’89 Proceedings) (July 1989), vol. 23, pp. 89–98.

[NNS72] NEWELL M., NEWELL R., SANCHA T.: New approach to the shaded picture problem. In Proceedings of
the ACM National Conference (1972), pp. 443–450.
[Pel97] PELLEGRINI M.: Monte Carlo approximation of form
factors with error bounded a priori. Discrete and Computational Geometry 17, 3 (April 1997), 319–338. Available
from www.imc.pi.cnr.it/ marcop.
[San76] SANTALO´ L. A.: Integral Geometry and Geometric
Probability. Addison-Wesley, New York, 1976.

[BP97] BESUIEVSKY G., PUEYO X.: Making global Monte
Carlo Methods useful: An adaptive approach for radiosity.
In Actas VII Congreso Espa˜nol de Inform´atica Gr´afica
(CEIG ’97) (Barcelona, Spain, June 1997).

[Sbe93] SBERT M.: An integral geometry based method
for fast form factor computation. In Computer Graphics
Forum (Eurographics ’93) (Barcelona, Spain, September
1993), vol. 12, pp. C409–C420.

[CW93] COHEN M. F., WALLACE J. R.: Radiosity and Realistic Image Synthesis. Academic Press Professional, Boston,
MA, 1993.

[Sbe97] SBERT M.: The Use of Global Random Directions to
Compute Radiosity: Global Monte Carlo Techniques. PhD
thesis, Universitat Polit`ecnica de Catalunya, Barcelona,
Spain, 1997. Available from http://ima.udg.es/mateu.

[Hac04] HACHISUKA T.: Final Gathering on GPU. In GP2,
ACM Workshop on General Purpose Computing on
Graphics Processors (August 2004).
[HH75] HAMMERSLEY J., HANDSCOMB D.: Monte Carlo
Methods. Methuen and Co. Ltd., London, UK, 1975.
[Kaj86] KAJIYA J. T.: The Rendering Equation. In Computer Graphics (ACM SIGGRAPH ’86 Proceedings)
(August 1986), vol. 20, pp. 143–150.
[MPP98] MARTIN I., PEREZ F., PUEYO X.: The SIR Rendering
Architecture. Computers & Graphics 22, 5 (1998), 601–
609.
[MSKS00] MART´INEZ R., SZIRMAY-KALOS L., SBERT M.:
Adaptive multipath with bundles of parallel lines. In Proceedings of 3rd International Conference on Visual Computing Visual2000 (Mexico D.F., September 2000).
[MSKS02] MART´INEZ R., SZIRMAY-KALOS L., SBERT M.: A
hardware-based implementation of the multipath method.
In Proceedings of Computer Graphics International (CGI
2002) (Berlin, Germany, July 2002), Springer.
[MSKS03] MART´INEZ R., SZIRMAY-KALOS L., SBERT M.: A
multiple depth buffer implementation for radiosity. In Proceedings of Computer Graphics and Geometric Modeling (CGGM 2003). Lectures Notes in Computer Graphics
(Montreal, Quebec, Canada, May 2003).
[Neu95] NEUMANN L.: Monte Carlo radiosity. Computing
55, 1 (1995), 23–42.

[SPNP96] SBERT M., PUEYO X., NEUMANN L., PURGATHOFER
W.: Global multipath Monte Carlo algorithms for radiosity. The Visual Computer 12, 2 (1996), 47–61.
[SK99] SZIRMAY-KALOS L.: Stochastic iteration for nondiffuse global illumination. In Computer Graphics Forum (Proceedings Eurographics ’99) (September 1999),
vol. 18, pp. C-233–C-244.
[SKFNC97] SZIRMAY-KALOS L., FORIS T., NEUMANN L.,
CSEBFALVI B.: An analysis of quasi-Monte Carlo integration applied to the transillumination radiosity method.
Computer Graphics Forum (Proceedings of Eurographics
’97) 16, 3 (1997), C271–C281.
[SKP98] SZIRMAY-KALOS L., PURGATHOFER W.: Global RayBundle Tracing with Hardware Acceleration. In Rendering Techniques ’98 (Proceedings of Eurographics Rendering Workshop ’98) (New York, NY, 1998), Drettakis G.,
Max N., (Eds.), Springer Wien, pp. 247–258.
[SKSMT00] SZIRMAY-KALOS L., SBERT M., MART´INEZ
R., TOBLER R. F.: Incoming first-shot for non-diffuse
global illumination. In Spring Conference on Computer
Graphics (Budmerice, Slovakia, 2000). Available from
http://www.fsz.bme.hu/∼szirmay/puba.htm.
[Sob76] SOBOL I.: M´etodo de Monte Carlo. Editorial MIR,
1976.
[SP94] SILLION F., PUECH C.: Radiosity and Global Illumination. Morgan Kaufmann, San Francisco, CA, 1994.

c 2008 The Authors
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.


Pacific Graphics 2008
T. Igarashi, N. Max, and F. Sillion
(Guest Editors)

Volume 27 (2008), Number 7

Simulating Inextensible Cloth Using Impulses
Juntao Ye
Institute of Automation, Chinese Academy of Sciences, Beijing, China

Abstract
Computer simulation of cloth is often plagued by springs being over-stretched. The evaluation of impulses to prevent over-stretching is explained step-by-step. Our impulse approach controls the length of springs by a nonlinear
system and then a novel linearization of it into a symmetric positive definite system. The cloth/solid collision
handling is integrated into the linearized system seamlessly. Some results based on this method are also presented.
Categories and Subject Descriptors (according to ACM CCS): I.3.5 [Computer Graphics]: Physically based modeling

1. Introduction
Due to the fact that woven fabric is a complex mechanical
network of interleaving yarn [BHW94], cloth simulation is
often based on a mass-spring model. The fabric is represented by a 2D array of nodes, each having a given mass,
and each being related to its neighbors by mutual stretching,
shearing and bending. An interesting aspect of cloth is the
way it stretches. Real woven fabric offers weak resistance to
stretching in the initial phase of extension, but strong resistance as the threads lengthen. Threads seldom stretch more
than 15% of their rest length. However, the springs in many
cloth solver often exceed that limit (Figure 1). Very high
stretching coefficients are seldom adopted to overcome the
excessive elongation, because the solvers suffer performance
loss as the material stiffness increases. The condition number of the resulted matrix grows with the increment of material stiffness, forcing an iterative solver to perform more
steps to converge.
In this paper we alleviate this issue by an impulse based
approach as a remedy for the cloth dynamics solver. We
are motivated by the work of Bridson et al. [BFA02], using
strain limits to filter velocities of the nodes as a second pass.
Our solution to this problem is to let each spring generate impulse, which is applied to both end-nodes. The impulses are
the unknowns of a linear system that approximate a nonlinear system of constraints on the velocities. In order to solve
the linear system efficiently, we first prove that the coefficient matrix is symmetric positive definite, thus solving the
system is done by sparse Cholesky decomposition with permutations. Our method also has solid/cloth collision seamc 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.
Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and
350 Main Street, Malden, MA 02148, USA.

Figure 1: Top-left: simulating cloth without the impulse method
over-stretches the corners; top-right: zoom-in of the over-stretched
corner. Bottom-left: simulating cloth with the impulse method does
not over-stretch the corners; bottom-right: zoom-in of the corner.

lessly integrated into one system, which has been largely ignored by existing methods.
2. Related Work
A number of researchers have worked on the stretch resistance problem. Provot [Pro95] was the first to try to

1902

Juntao Ye / PG Inextensible Cloth

give a solution by adjusting node positions. Over-stretched
springs were identified after each step, then their endpoints
were moved inward to keep the elongation to no more than
10%. This approach was also adopted by Desbrun et al.
[DSB99,MDDB01]. One problem with this method was that
the iteration could not be proved to converge. As a remedy,
sorting was performed before position adjustments. For example, Kang et al. [KCC00] sorted all springs according to
their elongated lengths, and Dochev and Vassilev [DV03]
sorted all unconstrained nodes according to their distances to
constrained ones. These position-adjusting methods moves
objects without reference to an underlying dynamics and
thus do not conserve physical properties such as momentum.
In addition to those position-adjusting methods, Vassilev et
al. [VSC01] and Bridson et al. [BFA02] tried to solve the
problem by velocity-adjusting. They applied impulses to the
nodes to adjust their velocities iteratively. Volino et al.’s momentum transfer method [VCM95] was believed to be similar to Bridson’s work. Recently, Tsiknis [TB06] extended
Bridson’s work and proposed triangle-based strain limiting.
An alternative is to use constrained dynamics [Wit01],
which directly calculates the constraint forces to meet the
requirement of constraints (constraining the spring length).
Lagrange multipliers are used to enforce the constraints. An
application of this method to cloth simulation was done by
[HD96]. Hong et al. [HCJ∗05] used a linearized implicit formulation in order to improve stability of constrained dynamics. Most recently, Goldenthal et al. [GHF∗ 07] adopted constrained Lagrangian Mechanics to prevent excessive extension and proposed a novel fast project for efficient computation. Their method outperforms all other methods in both
speed and stability. However, all works so far were silent on
how to deal with collision constraints when adjusting the velocities/positions.
We follow Bridson’s approach and restrict extension to
10% and compression to 2%. The advantage of enforcing
stronger resistance to compression is to introduce more outof-plane bending, creating more folds and wrinkles. Unlike
Bridson, who used Jacobin iterative approach to update node
velocities, we construct a linear system that approximates
a nonlinear system of constraints on the velocities of the
nodes. Our method deals with stretching springs only, because we believe that the over-extension of the stretching
springs is the most visible of the inaccuracies of the massspring model. Constraints are seamlessly incorporated into
our impulse method to handle cloth/solid collisions and user
interventions, which is one of the major contributions of this
paper.
3. Add Impulses to the Cloth Dynamics Model
Goldenthal et al. [GHF∗ 07] has pointed that imposing inextensibility on all edges of a triangle mesh is nearly impossible, as the system would quickly run into locking. Therefore, the cloth in our experiment is based on a rectangular

mesh, and linear springs are employed for stretching, shearing and bending. Our bending model follows Choi and Ko’s
setup [CK02] to enrich folds and wrinkles. The ordinary differential equations (ODEs) is solved numerically by backward Euler according to [BW98]. We adopt moderate stiffness value for the stretching springs, and rely on the impulse
mechanism to cure the excessive elongation.
Following Bridson [BFA02], the strain limits are set ahead
of time by the user to be a and b. A spring is neither allowed
to stretch beyond b, nor allowed to shrink shorter than a.
The spring tension is a linear function of the spring length
according to fi = k (|xi j | − li0j ) xˆ i j when |xi j | ∈ [a,b], where
x
xˆ i j = |xi j | . When |xi j | ∈ [a,b], impulses are generated and
ij
applied to the two end-nodes, so that the spring length after
one step of update will be within the limits. This method
works as if there was a massless string of length b passing
through the spring, as in Figure 2. The string becomes tight
and generates impulses when the spring is about to stretch
beyond b.
We favor impulse I over force f due to the fact I =
fδt = mδv, allowing us to relate impulse directly to velocity
change without having to compute forces explicitly. If force
were used, we would need to know not only the magnitude
of the force, but also the time during which the force is in
effect. How to compute the impulses (or velocity changes) is
our new task.

Figure

2:
Spring
with
an
imaginary
non-stretchable
string
inside.

Figure 3: Seven neighboring springs.

We suppose a spring xi j , connecting node xi and x j , generates impulse Ii j to xi and impulse −Ii j to x j , their directions being co-linear with that of xi j . We define Ii j = si j xˆ i j ,
where si j is the unknown scalar specifying the magnitude
of the impulse. All nodes are assumed to have equal mass,
s xˆ
i.e., mi = m j . Thus node xi receives velocity change of imj i i j ,
s xˆ

and node x j receives − imj ji j . To be consistent, we make an
assumption that the first index is always smaller than the
second (i.e., i < j), so the positive sign is assigned to the
smaller index. A node receives impulses from all its incident springs. For example, Figure 3 shows a graph of seven
springs connecting eight nodes labeled with the indexes satisfying f < g < h < i < j < k < l < n. The velocity changes
for nodes xi and x j are
δvi =

1
(si j xˆ i j + sil xˆ il − s f i xˆ f i − shixˆ hi),
mi

(1)

c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

1903

Juntao Ye / PG Inextensible Cloth

δv j =

1
(−si j xˆ i j − sg j xˆ g j + s jk xˆ jk + s jn xˆ jn ).
mj

(2)

Suppose at time t0 , the spring length is L(t0 ) = |x j − xi |.
Once the ODE solver computes the new velocities vi (t0 )
and v j (t0 ), the nodes is supposed to move to new positions
accordingly. We predict the spring length at time t0 + h to
˜ 0 + h) = |(x j (t0 ) + v j (t0 )h) − (xi (t0 ) + vi (t0 )h)|. If
be L(t
˜ 0 + h) ∈ [a,b], it means the spring will be over-stretched
L(t
or over-compressed. If so, we introduce impulses to further
change the node velocities so that the final spring length

and only its direction at the beginning of the time interval
is known. We make an approximation here and assume that
the direction of the in-line component is unchanged over the
whole time step. This approximation works like the forward
Euler’s method for solving an ODE in which the derivative
at the beginning of one time step is used to advance the integration for the whole time step. After the application of
the impulses, the in-line component of the velocity vnew
xi j has
magnitude (v j (t0 ) − vi(t0 ) + δv j − δvi ) · xˆ i j (t0 ). Now we set
z
(v j (t0 ) − vi (t0 ) + δv j − δvi ) · xˆ i j (t0 ) = ,
h

(4)

satisfies L(t0 + h) ∈ [a,b]. To solve for the unknowns si j contained in δvi and δv j , we could choose the value for L(t0 + h)
˜ 0 + h), i.e., we set
according to the predicted value of L(t
⎧
˜ 0 + h) > b;
if L(t
⎨ b
˜ 0 + h) < a;
a
if L(t
L(t0 + h) =
⎩ ˜
L(t0 + h) otherwise .

where z is the desired length change of the spring in one time
step. The value of z is determined according to the current
state of each spring:
⎧
b − L(t0 )
if L(t0 ) > b;
⎪
⎪
⎪
⎪
if L(t0 ) < a;
⎨ a − L(t0 )
z=
0
if L(t0 ) ∈ [a,b]
⎪
⎪
˜ 0 + h) ∈ [a,b];
but L(t
⎪
⎪
⎩
h (v j (t0 ) − vi(t0 )) · xˆ i j (t0 )
otherwise .

This way, we get a system of quadratic equations with each
stretching spring corresponding to one such equation and si j
being the unknowns.

We want to find impulses that will satisfy these constraints. By rewriting Equ. 4 as

L(t0 + h) = |L(t0 ) + (v j (t0 ) + δv j )h − (vi(t0 ) + δvi )h| (3)

However, such a nonlinear system is not easy to solve.
Considering the term δvi depends on xi j , which is a function of time t, solving the system can be even more complicated. We believe that formulating and solving such nonlinear system directly is more costly than the Lagrange Multiplier approach. However, since visual satisfactory, not physical accuracy, is pursued in computer animation, we approximate the above nonlinear system with a linear system of
equations. This approximation is not guaranteed to result in
every spring being within the limits at every step. But in
our experiments, it tends to produce springs that are within
the limits. Moreover, it greatly enhances the stability of the
underlying ODE solver because modest spring coefficients
are used. With this approximation, integrating collision constraints into the system becomes possible.
4. Linearization of the Impulse Method
Now we describe the linearized approximation of our impulse approach. Intuitively, a spring deforms due to the relative velocity of its two end-nodes. The relative velocity can
be split into two components, one is along the direction of
the spring (which we will call the in-line component hereafter) and the other is normal to the direction of the spring
(called the normal component). The in-line component is
the main source of the stretching/compression. Although the
normal component could also cause elongation, its contribution within one step is negligible if the time step is small.
The normal component makes a spring change its orientation within each time step, i.e., it undergoes a rotation. This
makes the in-line component keeps changing its direction,
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

z
(δvi − δv j ) · xˆ i j (t0 ) = (v j (t0 ) − vi (t0 )) · xˆ i j (t0 ) − ,
h

(5)

and using Equ. 1 and 2, we can construct a linear system
of equations As = b. The vector s ∈ |E| is the solution for
the unknowns si j , where E is the set of all stretching springs.
Then the spring xi j can also be indexed as the p-th element of
the set: e p ∈ E. The square matrix A ∈ |E|×|E| has one row
(or column) for each stretching spring e p (or the corresponding xi j ). Each stretching spring, if not on the border of the
mesh, has six neighboring stretching springs. Border springs
have fewer neighbors. Therefore, the maximum number of
nonzero elements in each row is seven, which means A is
a sparse matrix. The right-hand side of Equ. 5 is used to
form vector b, according to each of the four different cases
to which the spring belongs. The (p,q)-th element of A is
denoted by a pq . Suppose the q-th stretching spring eq (or
x jk ) is defined by nodes x j and xk , which corresponds the
q-th row of A. Since e p and eq share a common vertex, we
have
a pp = (

1
1
+
),
mi m j

a pq = aqp = −

(ˆxi j · xˆ jk )
,
mj

making A a symmetric matrix.
In a quadrilateral mesh of n nodes, the number of stretching springs is 2n, so the size of matrix A is ≈ 2n × 2n,
the same as the matrix constructed by Goldenthal et al.
[GHF∗ 07] from the fast projection. This system is considerably cheaper to evaluate, assemble and solve than the traditional Constrained Lagrange Mechanics system.

1904

Juntao Ye / PG Inextensible Cloth

5. Maintaining Constraints within the Impulse Method
In a cloth simulation system, collisions or user intervention
often restrict the motion of particles. A particle can be: (1)
completely unconstrained; (2) prevented from accelerating
along a specific direction; (3) prevented from accelerating
along a specific plane; or (4) completely constrained, i.e.,
not allowed to accelerate along any direction. An example
of (2) could be a particle in contact with the surface of a
rigid object and only sliding being allowed, thus acceleration
along the surface normal is prohibited. A situation for (3)
could be curtain simulation: cloth nodes fixed to gliders are
prohibited from moving along planes perpendicular to the
curtain rod.
We represent constraints using Baraff and Witkin’s
[BW98] constraint matrix. We use their notation ndof(xi ) to
indicate the number of degrees of freedom particle xi has.
Our way of constructing the constraint matrix is almost the
same as that of Baraff and Witkin, except for case 3 (ndof(xi )
= 1). Let particle xi ’s prohibited direction be pˆ i for case 2
(ndof(xi ) = 2), or the normal vector of the prohibited plane
be nˆ i for case 3 (ndof(xi ) = 1). A constraint matrix Ci ∈ 3×3
is defined as a matrix that when applied to the unconstrained
velocity of particle xi it produces the constrained velocity
δvci = Ci δvi . The matrix Ci is
⎧
I
if ndof(xi) = 3
⎪
⎪
⎨
I − pˆ i pˆ Ti if ndof(xi) = 2
Ci =
(6)
⎪
if ndof(xi) = 1
nˆ nˆ T
⎪
⎩ i i
0
if ndof(xi) = 0
where I is the 3 × 3 identity matrix. When ndof(xi) = 1,
Baraff and Witkin defined the plane using two orthogonal
unit vectors pˆ i and qˆ i in that plane: Ci = I − pˆ i pˆ Ti − qˆ i qˆ Ti .
Most of the time, pˆ i and qˆ i have to be determined from the
plane normal vector nˆ i, which is more readily available and
thus allowing us to compute the result in fewer operations.
Actually, it is not difficult to verify that I − pˆ ipˆ Ti − qˆ i qˆ Ti =
nˆ i nˆ Ti .
If node xi is constrained, its velocity change δvci should
be along the allowed direction(s) only: δvci = Ci δvi . Thus
Equ. 1 and Equ. 2 change to
δvci =

Ci
(si j xˆ i j (t0 ) + sil xˆ il (t0 ) − s f i xˆ f i (t0 ) − shixˆ hi (t0 ))
mi
(7)

6. Symmetry and Positive Definiteness of the Coefficient
Matrix Ac
A nice thing about our way of linearization and applying
constraints is that the resulted matrix is symmetric and positive definite. In this section we give a brief proof.
From Equ. 7 and Equ. 8, elements of constrained impulse
matrix Ac are
acpp = (

acpq = −

Cj
(−si j xˆ i j (t0 )−sg j xˆ g j (t0 )+s jk xˆ jk (t0 )+s jn xˆ jn (t0 )) .
mj
(8)
The component of δvi along the prohibited direction is
(I − Ci)δvi , which is canceled by the constraint forces. Note
that our impulse method conserves both linear and angular
momentum when no constraints is exerted onto the system.
With the constraints, the system is no longer conservative.
It is not a surprise since the constraints introduce external
forces into the system, changing the momentum.

C j xˆ jk · xˆ i j
,
mi

acqp = −

C j xˆ i j · xˆ jk
.
mj

(9)

(10)

If acpq = acqp holds, matrix A is symmetric. Actually, it is not
hard to prove that for any 3 × 1 vectors u and w, Ci u · w =
Ci w · u holds. Therefore, matrix A is symmetric.
Next, we will prove that Ac is positive definite. Before
doing that, we give a useful equation
Ci u · Ci w = Ci u · w, for any 3 × 1 vectors u and w. (11)
This equation can be proved as Ci u · Ci w = uT CTi Ci w =
uT Ci w = (Ci u)T w = Ci u · w.
The positive definiteness of Ac can be validated by proving sT Ac s = ∑xi ∈N mi |δvci |2 , for any nonzero vector s,
where N is the set of all nodes. Due to mi |δvci |2 = mi (δvci ·
δvci ), expanding it according to Equ. 7 and Equ. 8 and applying Equ. 11 yields
mi |δvci |2 =

1 2
[s (Ci xˆ i j · xˆ i j ) + s2il (Ci xˆ il · xˆ il )
mi i j
+s2f i(Ci xˆ f i · xˆ f i ) + s2hi (Cixˆ hi · xˆ hi)
+2si j sil (Ci xˆ i j · xˆ il ) − 2si j s f i (Ci xˆ i j · xˆ f i )
−2si j shi(Ci xˆ i j · xˆ hi ) − 2sil s f i (Ci xˆ il · xˆ f i )
−2sil shi (Cixˆ il · xˆ hi) + 2s f i shi(Ci xˆ f i · xˆ hi)]
(12)

ll Re-organizing ∑xi ∈N mi |δvci |2 by numbering all edges as
oppose to nodes, we get
=

c 2
∑xi ∈N mi |δvi |
(Ci xˆ i j ·ˆx f i )
∑xi j ∈E [−si j s f i mi
(C j xˆ i j ·ˆxg j )
(C xˆ ·ˆx )
+si j sg j
− si j shi i mi ji hi
mj

Ci xˆ i j ·ˆxi j
C xˆ ·ˆx
(C xˆ ·ˆx )
+ j mi jj i j ) − si j s jk j mi jj jk
mi
(C xˆ ·ˆx )
(C xˆ ·ˆx )
+si j sil i mi ji il − si j s jn j mi jj jn ]
T c

+s2i j (

and
δvcj =

Ci xˆ i j · xˆ i j C j xˆ i j · xˆ i j
+
),
mi
mj

=

s A s≥0

where E is the set of all stretching springs. Unless all δvci
are zero, Ac is strictly positive. In the case of all δvci being
zero, no velocity adjustment is needed, so the process of assembling and solving such a system is not activated at all.
We can therefore consider all linear systems constructed to
be symmetric positive definite, which enable us to choose a
special algorithm for solving it.
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

Juntao Ye / PG Inextensible Cloth

1905

rows and columns of A, and the same permutation applied
to b. Permutation of the rows is done by left-multiplying A
with a permutation matrix P, and permutation of the columns
is done by right-multiplying A with PT . Once the reordering
is done, factorizing PAPT , instead of A, into LDLT requires
less calculation and leads to much less fill-in in L. Thus instead of solving Ax = b, we solve (PAPT )(Px) = Pb.
For the direct factorization, finding an optimal permutation that results in the minimum amount of fill-in is NPhard [HEKP01]. Heuristics are usually used to find a decent permutation. Research on how to find a good permutation matrix P has made much progress in the past few
years. Particularly, Davis’s group provides some exciting
results [ADD04] [CDHR06] [DH99] [DH01] [DH05]. The
Approximated Minimum Degree (AMD) method, given by
this group, is the most efficient in the family of Minimum
Degree Reordering. To solve As = b, we can first use AMD
to find a close-to-optimal permutation for matrix A. We then
permute A and b followed by LDLT factorization and backward and forward substitution. Doing an inverse permutation
to the solution vector gives the solution to the original system.

Figure 4: Cloth with 1,681 nodes suspended from two corners, and
swinging down after one corner released.

Please note if both nodes of an edge are completely constrained, the corresponding row and column are null vectors, making the matrix rank deficient. In this case, that row
and column need to be deleted, resulting in a matrix of size
|E| − 1, which is still symmetric positive definite.
7. Solving the Linear System
Although sparse linear systems is typically solved by iterative methods, particularly the Conjugate Gradient method
for symmetric positive definite systems, direct methods
should not be neglected. A direct method is either the
Gaussian elimination or its variant tailored to exploit the special structure of the matrix. Cholesky factorization is such a
variant for symmetric positive definite matrices: A = LDLT ,
where L is the lower triangular matrix with all diagonal elements being one, and D is a diagonal matrix. Thus solving the system Ax = b turns into solving three sub-systems
Ly = b, Dz = y and LT x = z.
One issue with direct methods is that when a sparse matrix A is factored, it typically suffers some fill-in and becomes less sparse. The fill-in means the triangular factor L
has non-zeros in positions which are zero in A. It is possible
to reduce the amount of fill-in by reordering the matrix prior
to the factorization, thus saving computer execution time and
storage. A reordering means a symmetric permutation of the
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

Which is better, the iterative method or the direct factorization, is really application-dependent. If a matrix is numerically diagonal-dominant, the CG method converges quickly
when using its diagonal as the preconditioner. A proper initial guess for the solution is also very helpful to the convergency. However, The matrix in our system is far from
diagonal-dominant, and a better-than-the-diagonal preconditioner can not be easily found. Moreover, it is not easy to find
a decent initial guess but to use a zero vector. On the other
hand, for the direct method, the performance of AMD usually increases nonlinearly as A gets sparser. For our system,
the number of nonzeros of each row is seven, with which
the AMD performs fairly well. Our test results verified that
AMD plus the factorization is at least 30% more efficient
than CG algorithm in terms of the execution time.
There is another reason that makes us favor the direct factorization with AMD reordering over the CG method for
our linear system. Table 1 shows the five stages of the direct method and their CPU time percentage for each stage
while simulating a square cloth of 1,681 nodes for 1,000
steps (Figure 4). The first three stages depend only on the
nonzero pattern of a matrix, not its numerical values. It is often the case that for a number of consecutive steps the matrix
does not change its pattern, therefore these three steps only
need to be done once. The matrix pattern changes only when
a spring is removed from or added to the impulse system due
to both end-nodes being completely constrained or released.
This situation does not happen frequently, thus skipping the
three stages will cut the CPU time for the impulse solver by
36%.

1906

Juntao Ye / PG Inextensible Cloth

Table 1: Task of the direct method breakdown
subroutines
AMD to find P
permutation PAPT
symbolic factorization
numeric factorization
Ly = b,Dz = y,LT s = z
total

time (sec)
2.40
1.86
0.39
6.37
1.87
12.89

percentage
18.6
14.5
3.0
49.4
14.5
100.0

8. Experiment and Conclusion
We have described an impulse based method which intends
to be used as an add-on to any existing simulation system
that suffers the over-stretching problem. We set up several
simulation scenarios to test the performance of our method.
All experiments were tested on a Intel Core 2 Duo 2.13G
system, but no multi-threading programming is involved.
The first example is the simulation of a sheet hanging by
two/one corners and subject to gravity (Figure 4). The length
of springs at the fixed corner(s) is within a desired limit. We
also used the impulse method on a larger cloth mesh of 6,561
nodes, hit by a flying ball (Figure 5). The proper behavior is
for the cloth to get out of the way of the ball rather than
letting the ball stretch the cloth. Our approach also works
well on more complicated meshes, such as T-shirt (Figure 7).
For a mesh containing limited number of nodes, we are able
to achieve real-time performance (Figure 6). The impulse
method not only greatly alleviates the problem of extensibility, but also creates enough folds to greatly enhance the
realism of the animation.
In order to integrate collision handling into the impulse
based method, we adopted a special approximation to the
nonlinear constrained system. Compared to the fast projection in [GHF∗ 07], our approximation scheme does not perform equally well in terms of convergence. If the predicted
spring lengths are going to exceed the limit by too much, either because of a too-large time step or because of the spring
coefficient being too low, the impulse application will result in a "rugged" cloth, creating unneeded out-of-plane displacement. However, it does not blow out the computation.
If this happens, decreasing the time step or increasing the
spring stiffness improves the result. For a mesh of modest
size, e.g. the one having 1,681 nodes, the impulse method
can be combined with the explicit Euler integration to take
advantage of the small time step, and still achieve efficient
overall execution time. In the future, we will certainly refine
our linearization scheme to allow larger time step.
Acknowledgements
The author is grateful to Robert E. Webber and Irene Gargantini for their discussions. This work was partially funded by

the National High Technology Research and Development
Program of China (863 Program) #2007AA01Z341.

References
[ADD04] A MESTOY P. R., DAVIS T. A., D UFF I. S.: Algorithm 837: AMD, an approximate minimum degree ordering algorithm. ACM Transactions on Mathematical
Software 30, 3 (2004), 381–388.
[BFA02] B RIDSON R., F EDKIW R., A NDERSON J.: Robust treatment of collisions, contact and friction for cloth
animation. ACM Transactions on Graphics (SIGGRAPH
’02) 21, 3 (2002), 594–603.
[BHW94] B REEN D. E., H OUSE D. H., W OZNY M. J.:
Predicting the drape of woven cloth using interacting particles. In Proceedings of SIGGRAPH ’94 (1994), pp. 365–
372.
[BW98] BARAFF D., W ITKIN A.: Large steps in cloth
simulation. In Proceedings of SIGGRAPH ’98 (1998),
pp. 43–54.
[CDHR06] C HEN Y., DAVIS T. A., H AGER W. W.,
R AJAMANICKAM S.:
Algorithm 8xx: CHOLMOD,
supernodal sparse Cholesky factorization and
update/downdate.
Unpublished Technical Report TR-2006-005, University of Florida, 2006.
http://www.cise.ufl.edu/research/sparse/, see also accompanying software.
[CK02] C HOI K.-J., KO H.-S.: Stable but responsive
cloth. ACM Transactions on Graphics (SIGGRAPH ’02)
21, 3 (2002), 604–611.
[DH99] DAVIS T. A., H AGER W. W.: Modifying a sparse
Cholesky factorization. SIAM Journal on Matrix Analysis
and Applications 20, 3 (1999), 606–627.
[DH01] DAVIS T. A., H AGER W. W.: Multiple-rank modifications of a sparse Cholesky factorization. SIAM Journal on Matrix Analysis and Applications 22, 4 (2001),
997–1013.
[DH05] DAVIS T. A., H AGER W. W.: Row modifications
of a sparse Cholesky factorization. SIAM Journal on Matrix Analysis and Applications 26, 3 (2005), 621–639.
[DSB99] D ESBRUN M., S CHRÖDER P., BARR A.: Interactive animation of structured deformable objects. In
Proceedings of Graphics Interface ’99 (1999), pp. 1–8.
[DV03] D OCHEV V., VASSILEV T.: Efficient superelasticity handling in mass-spring systems. In Proceedings of the 4th International Conference on Computer
Systems and Technologies (2003), pp. 483–490.
[GHF∗ 07] G OLDENTHAL R., H ARMON D., FATTAL R.,
B ERCOVIER M., G RINSPUN E.: Efficient simulation of
inextensible cloth. ACM Transactions on Graphics (SIGGRAPH ’07) 26, 3 (2007).
c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

1907

Juntao Ye / PG Inextensible Cloth

Figure 5: Ball hitting a piece of cloth modeled by 6,561 nodes, Δt = 2.22ms and the average simulation time was 5.5 seconds/frame taking
no consideration of self-collision handling.

Figure 6: Real-time simulation of a skirt modeled by 108 nodes at 140 frames per second. Figure 7: A T-shirt modeled by 2,792 nodes
dropped onto a dummy model.

[HCJ∗ 05] H ONG M., C HOI M. H., J UNG S., W ELCH S.,
T RAPP J.: Effective constrained dynamic simulation using implicit constraint enforcement. In International Conference on Robotics and Automation (2005), pp. 4520–
4525.
[HD96] H OUSE D., D E VAUL R.: Towards simulating
cloth dynamics using interacting particles. International
Journal of Clothing Science and Technology 8, 3 (1996),
75–94.
[HEKP01] H EGGERNES P., E ISENSTATZ S. C., K UM FERT G., P OTHEN A.: The computational complexity of the minimum degree algorithm. In Proceedings
of 14th Norwegian Computer Science Conference, NIK
2001, University of Troms, Norway (2001), pp. 98 – 109.
[KCC00] K ANG Y.-M., C HOI J.-H., C HO H.-G.: Fast
and stable animation of cloth with an approximated
implicit method. In Computer Graphics International
(2000), pp. 247–255.
[MDDB01] M EYER M., D EBUNNE G., D ESBRUN M.,
BARR A.: Interactive animation of cloth-like objects in
virtual reality. Journal of Visualization and Computer Animation 12, 1 (2001), 1–12.
[Pro95]

P ROVOT X.: Deformation constraints in a mass-

c 2008 The Author(s)
Journal compilation c 2008 The Eurographics Association and Blackwell Publishing Ltd.

spring model to describe rigid cloth behavior. In Graphics
Interface ’95 (1995), pp. 147–154.
[TB06] T SIKNIS D., B RIDSON R.: Cloth animation
through unbiased strain limiting and physics-aware subdivision. In Proceedings of SIGGRAPH/Eurographics Symposium on Computer Animation (SCA 2006), poster session (2006).
[VCM95] VOLINO P., C OURCHESNE M., M AGNENAT
T HALMANN N.: Versatile and efficient techniques for
simulating cloth and other deformable objects. In Proceedings of SIGGRAPH ’95 (1995), pp. 137–144.
[VSC01] VASSILEV T., S PANLANG B., C HRYSANTHOU
Y.: Fast cloth animation on walking avatars. In EUROGRAPHICS ’01 (2001), vol. 20, pp. C/260–C/267.
[Wit01] W ITKIN A.: Constrained dynamics. In SIGGRAPH ’01 Course Notes (2001).


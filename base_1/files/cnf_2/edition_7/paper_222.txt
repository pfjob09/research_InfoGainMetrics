DOI: 10.1111/j.1467-8659.2009.01438.x

COMPUTER GRAPHICS

forum

Volume 28 (2009), number 8 pp. 2255–2263

Semi-Uniform Adaptive Patch Tessellation
C. Dyken1,2 , M. Reimers1 and J. Seland1,2
1 Centre

of Mathematics for Applications, University of Oslo, Norway
2 SINTEF ICT, Applied Mathematics, Norway

Abstract
We present an adaptive tessellation scheme for surfaces consisting of parametric patches. The resulting tessellations
are topologically uniform, yet consistent and watertight across boundaries of patches with different tessellation
levels. Our scheme is simple to implement, requires little memory and is well suited for instancing, a feature
available on current Graphical Processing Units that allows a substantial performance increase. We describe
how the scheme can be implemented efficiently and give performance benchmarks comparing it to some other
approaches.
Keywords: triangle mesh, GPU, tessellation, instancing
ACM CCS: I.3.1 Parallel processing; I.3.3 Viewing algorithms; I.3.5 Curve, surface, solid, and object representations; I.3.5 Geometric algorithms, languages, and systems

1. Introduction
Higher-order primitives like B´ezier patches can model complex and smooth shapes parameterized by relatively few
control points, and are easier to manipulate than triangular meshes with corresponding fidelity. Because current
Graphical Processing Units (GPUs) can not handle higherorder primitives directly, these must be tessellated into triangle meshes before rendering. A standard approach is
to tessellate the parameter domain of the patch, map the
vertices of this triangulation to the patch surface, and
render the resulting triangulation. A uniform tessellation
results if each patch is tessellated in the same way.
Otherwise, one can use an adaptive approach with varying tessellation levels. A complication with adaptive methods is that the tessellations of adjoining patches must
match edge-by-edge to guarantee watertight rasterization
[SAF∗ 06].
The performance of GPUs rely heavily on massive parallelism, and thus to achieve good GPU utilization, geometry
must be grouped into large batches. Instancing is a feature of
DirectX 10-class GPUs that drastically increases batch sizes
by letting multiple instances of an object be rendered using a
single draw-call. A patch tessellation approach, as described
earlier, is well suited for instancing if the number of different
c 2009 The Authors
Journal compilation c 2009 The Eurographics Association and
Blackwell Publishing Ltd. Published by Blackwell Publishing,
9600 Garsington Road, Oxford OX4 2DQ, UK and 350 Main
Street, Malden, MA 02148, USA.

tessellations is low and patches with identical tessellations
are easily grouped.
We present an adaptive patch tessellation scheme based on
dyadic tessellations of the triangular parameter domain. To
make adjacent patches meet edge-by-edge, we use a snap
function that in one step moves patch boundary vertices
and collapses triangles in a consistent manner. The effect
of the snap function can be interpreted as edge-collapsing
[HDD∗ 93]. In this way we can efficiently produce adaptive and topologically consistent tessellations from a limited set of source tessellation patterns, see Figure 1. As an
example, a maximum refinement level of M = 5 requires
(M +1)3 = 216 tessellation patterns to cover all combinations in our setting. We produce all of these on the fly using
just six uniform tessellation patterns and a simple vertex
shader snap routine. We also show how the patches can be
grouped into render queues according to tessellation level
on the GPU. Combined, this provides a pure GPU rendering pipeline for adaptive tessellation with efficient use of
instancing.
After a brief account of previous work in the next section,
we discuss uniform tessellations and our new semi-uniform
adaptive approach in Section 3. In the subsequent section,
we elaborate on implementation and describe a pure GPU

2255

2256

C. Dyken et al. / Semi-Uniform Adaptive Patch Tessellation

contains a hardware tessellation unit, and it is likely that
standard graphics hardware will incorporate such units in
the future. The geometry shader of DirectX 10-class hardware can in principle be used for tessellation. For reference,
we have benchmarked a geometry shader-based implementation of our scheme.

3. Semi-Uniform Adaptive Patch Tessellation

Figure 1: Semi-uniform adaptive tessellation of the Stanford
bunny, with refinement level increasing from left to right.
pipeline suitable for current graphics hardware. Section 5 is
devoted to performance benchmarks, comparing a number
of alternative implementations with and without instancing.
We conclude the paper with a few final remarks.
2. Related Work
Boubekeur and Schlick [BS05] propose to store a parameter space tessellation in a vertex buffer object (VBO) on the
GPU, letting the vertex shader evaluate the patch at the vertices. Their approach was extended by adaptive refinement
patterns [BS08] that stores an atlas of tessellations covering all the different combinations of edge refinement levels
in GPU memory, which allows patches with different refinement levels to meet edge-by-edge. However, the number
of tessellations grows cubically with maximum tessellation
level.
GPU based adaptive tessellation has been demonstrated
for subdivision surfaces [SJP05, Bun05] and for grid based
terrain models using Geometry Clipmaps [LH04]. These
methods either yield tessellations with hanging nodes, or
watertight tessellations by inserting triangles.
We have earlier proposed an adaptive tessellation scheme
based on dyadic uniform tessellations with geometric continuity [DRS08]. The present scheme is to some extent similar
but guarantees that tessellations are topologically consistent.
Moreton [Mor01] discusses adaptive tessellations and
crack removal strategies, and proposes a forward differencing scheme for B´ezier patches, aimed at hardware implementation. The GPU of the Xbox 360 [AB06] game console

A parametric triangular patch F : P 0 → R3 can be rendered
by evaluating F at the vertices of a tessellation P of its
triangular parameter domain P 0 ⊂ R2 . If the resulting tessellation T in R3 is fine enough it can be rendered as a good
approximation of the patch itself. A dyadic tessellation of
P 0 is a natural choice due to its uniformity and that it is
trivial to produce on the fly, as demonstrated by our geometry shader-implementation. A dyadic refinement P 1 of P 0
can be obtained by inserting a vertex at the midpoint of each
edge of P 0 and replacing the triangle with four new triangles.
Continuing the refinement procedure, we get at the mth step
a triangulation P m of the m-dyadic barycentric points
Im =

1
(i, j , k) :
2m

i, j , k ∈ N,

i + j + k = 2m .

Note that dyadic tessellations of P 0 are nested in the sense
that Im ⊂ Im+1 , i.e. a vertex of a coarse tessellation is also
a vertex of its refinements. A dyadic tessellation P m of
the patch parameter domain yields a corresponding tessellation T m of the patch itself, consisting of the triangles
[F(ui ), F(uj ), F(uk )] for triangles [ui , uj , uk ] of P m . This
approach lends itself naturally to the use of VBOs and vertex
shader programs for patch evaluations.
We are interested in the case where we have a number of
triangular patches that meet with geometric continuity, i.e.
with common boundaries. We wish to construct one tessellation for each patch such that the individual tessellations are
sufficiently fine. Allowing this form of adaptivity faces us
with the problem of making the tessellations of neighbouring patches compatible. One approach is to add triangles on
the patch boundaries in order to fill holes in the tessellations,
resulting in a slightly more complex mesh than in the case
of uniform tessellations. Another approach is to let two tessellations meet with geometric continuity [DRS08, LH04].
However, this results in hanging nodes as illustrated in
Figure 2 (left), which can result in artefacts such as dropout pixels. To guarantee a watertight tessellation one must
ensure that the patch tessellations are topologically consistent, i.e. that adjacent triangles share the end-points of their
common edge.
Consider dyadic tessellations as the ones in Figure 2 (left),
with neighbouring patches of different tessellation levels and
thus a number of hanging nodes. Our approach is to move
each hanging node to the nearest dyadic barycentric point
shared by the neighbouring tessellations, as illustrated in

c 2009 The Authors
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

C. Dyken et al. / Semi-Uniform Adaptive Patch Tessellation

2257

Figure 2: The left figure shows the case where patches with different tessellation levels meet, resulting in numerous hanging
nodes (red) along the boundaries. The centre triangulation is the result of our method, which amounts to moving hanging nodes
to the nearest vertex common to both tessellations. The close-up to the right illustrates how the red vertices are moved by the
snap function φ as indicated by the arrows. The dashed edges are either collapsed or moved as a result.
Figure 2 (centre). This results in a new tessellation that is
uniform in the interior and topologically consistent with
neighbouring tessellations, although with degenerate triangles. Because the resulting mesh is in fact still topologically
uniform it can be rendered using a VBO corresponding to a
dyadic tessellation P m . Degenerate triangles pose no problems as they are quickly discarded in the rendering process.
We next discuss the details of our approach.
We consider a single patch to be tessellated at level
m and denote by p0 , p1 , p2 the tessellation levels of its
neighbouring patches. In order to remove hanging nodes
we define a dyadic snap function φ : Im → Im which maps
u = (u0 , u1 , u2 ) ∈ Im to the nearest dyadic barycentric point
consistent with neighbouring tessellations, illustrated in
Figure 2 (right). More precisely,
φ(u) =

if u0 , u1 , u2 = 0;

(u0 , u1 , u2 ),
σpi (u0 ), σpi (u1 ), σpi (u2 ) ,

if ui = 0,

edge, φ(u) ∈ Ipi . In conclusion, φ preserves interior vertices
and snaps a hanging boundary vertex to the closest dyadic
barycentric coordinate at the required tessellation level.
Applying φ to all the vertices of P m we obtain a corresponding planar tessellation of P 0 ,
Ppm0 p1 p2 = {[φ(ui ), φ(uj ), φ(uk )] : [ui , uj , uk ] ∈ P m },
m
m
with vertices Im
p0 p1 p2 = {φ(u) : u ∈ I } ⊆ I . A triangle in
m
Pp0 p1 p2 is degenerate if two of its vertices are identical. The
remaining triangles cannot fold over and because φ preserves
the order of the boundary vertices, Ppm0 p1 p2 is a valid tessellation of P 0 if we ignore the degenerate triangles.

Our choice of snap function minimizes the problem of
long thin triangles for a given set of vertices because φ always maps a boundary point to the closest boundary point in
Im
p0 p1 p2 . It can be shown that if P is an equilateral triangle,
then Ppm0 p1 p2 is a Delaunay triangulation of Im
p0 p1 p2 .

where σp maps a real value to the nearest p-dyadic number,
1
σp (t) = p
2

2p t − 1/2

if t < 1/2;

2p t + 1/2

otherwise,

4. Implementation
(1)

breaking ties towards 0 if t < 1/2 and towards 1 otherwise. Thus, for a tie with u being equally distant from two
pi -dyadic points, φ snaps towards the closest corner vertex
of P 0 , yielding some degree of symmetry.
Let us verify that φ is well defined and works as required.
If u0 , u1 , u2 = 0, then φ(u) = u, i.e. interior vertices of P m
are preserved. Because σp (i) = i for any integers i and p, the
corners of P 0 are left unchanged by φ. This also implies that
φ is well defined even if two of the coordinates (u0 , u1 , u2 ) are
zero. Suppose now that u ∈ Im is a boundary vertex, i.e. with
some ui = 0. Because σp (t) + σp (1 − t) = 1 for any integer
p and real value t, then σpi (u0 ) + σpi (u1 ) + σpi (u2 ) = 1 and
hence φ(u) ∈ Ipi . Note that this holds for all integers pi .
Therefore φ(u) ∈ Im and in the case u is on the ith boundary

In this section, we describe a pure GPU implementation of
the tessellation scheme on DirectX 10-class hardware. The
performance benchmark in the next section compares this
approach to CPU-assisted alternatives on older hardware.
Conceptually, an implementation of the scheme is straightforward, and the snap function can be realized in a few lines
of shader code, see Listing 1. For simplicity we assume the
input patches are static, but this is not a requirement. Given
an input mesh of patches and a maximum refinement level
M, we use some predicate to associate a refinement level
0 ≤ le ≤ M with every edge, e.g. silhouetteness [DRS08],
patch curvature, or the distance from the camera. The patch
tessellation level m is the maximum of the integer edge tessellation levels le . We then issue the rendering of P m ,
applying the snap function φ and the patch evaluator F to
calculate the final vertex positions. Any parametric patch

c 2009 The Authors
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

2258

C. Dyken et al. / Semi-Uniform Adaptive Patch Tessellation

Figure 3: A schematic view of our implementation. The thick arrows designate control flow, while the data flow is drawn in
green using dashed arrows. Static data is drawn in red. Instancing is indicated by the ⊗-symbol.
evaluator can be used, such as subdivision patches [Sta98]
or PN-triangles [VPBM01]. Similar to adaptive refinement
patterns [BS08], the tessellations only handle integer refinement levels. However, continuous refinement levels can be
accommodated by using a blending scheme like adaptively
blended B´ezier patches [DRS08].
Listing 1: GLSL-implementation of φ.
vec4 p = gl Vertex;
vec4 mask = equal(floor(p.wwww), vec4(0,1,2,3));
float lod = dot(levels, mask);
if(mask.w == 0) {
float s = exp2(ceil(lod));
float t = (1/s)∗floor(
s∗dot(p.xyz, mask.xyz) + fract(p.w));
p.xyz = mix(mask.zxy, mask.xyz, t);
}

The calculations are organized as in Figure 3. We first
calculate the patch tessellation level for each input patch.
Thereafter we group the patches according to tessellation
level, using the HistoPyramid [ZTTS06] data compaction
algorithm. For each level m = 1, . . . , M we first extract a
render queue consisting of all patches with tessellation level
m. Then we render the P m -patches in the queue using a single
draw call using instancing, applying F ◦ φ to the vertices
using a vertex shader.
4.1. Building the render queues
For each frame, the first step is to determine the tessellation level of each patch. This is done in a GPGPU-pass,
resulting in a patch tessellation level texture. Then, for each
m = 1, . . . , M we build a HistoPyramid, setting the base
level of the pyramid to 1 if the patch is of level m and 0
otherwise. The upper levels in the HistoPyramid are built by

Figure 4: The render queues (left) are extracted in a single
pass by traversing an array of HistoPyramids (right).
a sequence of GPGPU-passes. Finally, we trigger an asynchronous readback of the top-elements of the HistoPyramids
to the CPU, a total of M integers, which give the number
of patches in each render queue. These numbers are needed
by the CPU to control subsequent passes, e.g. the number of
instances to produce of a given tessellation.
The render queues are laid out in a texture and extracted
using a single GPGPU-pass, see Figure 4. The elements of
the render queue texture are indexed by linear enumeration.
The HistoPyramids are laid out in an array of mipmapped textures, and the accumulative sums of the top elements form
ranges of indices occupied by each queue. Thus, by inspecting the top elements of the HistoPyramids, one can determine
which render queue a render queue element belongs to, and
then descend into the appropriate HistoPyramid and determine the corresponding patch. The patch index is stored in
the render queue, along with the tessellation levels of the
neighbours.
Our OpenGL bucket sort approach based on combining several HistoPyramids can be used to group geometry
for other uses, e.g. sorting geometry into layers to control

c 2009 The Authors
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

C. Dyken et al. / Semi-Uniform Adaptive Patch Tessellation

sequence of pixel overwrites in scenes with transparent
geometries.
The HistoPyramid algorithms are quite efficient on sparse
data [DZTSar], which is the case when we extract patches
along the silhouette. In other settings, it may be beneficial to use a data parallel programming environment, like
Nvidia’s CUDA, instead of the graphics API to build the
render queues. The use of CUDA would allow for a less
restrictive choice of algorithms. Our instancing approach requires the number of patches with a given refinement level to
be known, and thus a regular sorting algorithm alone does not
suffice without some subsequent reduction passes. However,
Prefix Sum Scan [Har07] can be used in the same manner
as we use the HistoPyramid, using one stream reduction per
bucket. Finally, the render queues must be passed to a graphics API in order to exploit instancing for the final rendering
pass.
4.2. Rendering
The geometry is rendered in two stages, one for unrefined
patches and one for the refined patches. The input patches
are stored in a static VBO, with the patch index encoded. We
render this VBO using a vertex shader that degenerates all
patches tagged for refinement in the patch tessellation level
texture.
We then render the patches in the render queues. For each
tessellation level m we have a parameter space tessellation
P m stored in a static VBO [BS05]. The xyz-coordinates of
gl Vertex contain the barycentric coordinates, and the integer part of w specifies if the vertex is in the interior or
on an edge. Because the first case of (1) can be exchanged
for a sufficiently small > 0, we let
with 2p t + 12 −
the fraction part of w contain 12 or 12 − and thus avoiding run-time conditionals in σp . Listing 1 shows our GLSLimplementation of φ. We bind the render queue as a texture
and trigger the given number of instances of P m . The vertex
shader fetches the neighbouring tessellation levels and patch
index from the render queue using the instance ID, and then
use the patch index to fetch the per-patch data. We get the
final vertex position by applying φ and F, producing the
evaluated patch at the primitive assembly stage. Thus, any
regular fragment shader can be used without modification.
4.3. Optimizations
The description above gives a simplified view of the implementation. We reduce the number of GPGPU-passes by
storing the set of HistoPyramids in a single mipmapped 2D
texture array. In this way, all HistoPyramids can be bound to
a single texture sampler and built in parallel using multiple
render targets.
Per-patch data, such as shading normals and coefficients,
can be uploaded through bindable uniforms instead of buffer
textures. The rationale behind this is that it is faster to have

2259

data that is constant for numerous vertices stored in constant
memory instead of (cached) textures. We store the extra data
in addition to the edge refinement levels in the render queue,
increasing the storage requirement to 40 floats per patch.
The render queues are built using transform feedback. A
restriction of bindable uniforms is that the amount of constant
memory is limited. This limits the batch size to roughly 400
patches, resulting in more draw calls. The performance effect
of this approach is described in the following section.
5. Performance Analysis
We have performed a series of benchmarks on the implementation described in the last section, as well as a few variations
of it, on two GPUs: Nvidia GeForce 7800 GT and 8800 GT.
The benchmarks consists of measuring the average framerate
and throughput (number of triangles per second) for a series of differently shaped and sized meshes with a randomly
varied viewpoint. The results are presented in Table 1 and
some of the meshes are depicted in Figure 5. For the benchmarks, we have used the silhouetteness criterion [DRS08]
to determine the patch tessellation level and PN-Triangles
[VPBM01] as the patch evaluator.
Method A is a brute force approach that, as a preprocess,
tessellates all patches to level M, and stores this in a static
VBO that is rendered for every frame. Method B is the uniform refinement method [BS05], using a single parameter
space tessellation of level M that is invoked for every patch.
Method C is our earlier method that results in hanging nodes
[DRS08]. In method D this method is augmented with the
proposed snap function φ, and Method E also uses instancing
to draw the geometry instead of per patch triggering. We build
the render queues on the host CPU using memory-mapped
buffer objects. Then, each queue is bound to a buffer texture,
and rendered in one batch using instancing. Method F is identical to Method D except that the render queues are exposed
to the vertex shader through bindable uniforms as outlined in
Section 4.3. Methods G and H are the pure GPU implementation described in Section 4. Method G builds a single texture
with all render queues in a GPGPU-pass. Method H exposes
the per-patch data through bindable uniforms. Method I is
semi-uniform tessellation implemented as a single geometry
shader program. The triangle adjacency primitive is used to
stream the base triangles along with direct neighbours into
the geometry shader, which initially calculate the silhouetteness of the edges. If none of the edges dictate a refinement,
the triangle is passed directly through. Otherwise, an uniform dyadic tessellation is produced on the fly and F ◦ φ is
applied to every emitted vertex.
We now discuss the results of our performance benchmarks. As method A renders the refined mesh directly, it is
the fastest uniform approach, as long as the VBO fits in GPU
memory. Because methods A and B yield the same set of
triangles, their relative performance gives some information
on the cost associated with triggering one VBO per patch and

c 2009 The Authors
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

GeForce
8800 GT

GeForce
7800 GT

0.2 k
0.8 k
1.0 k
1.5 k
4.0 k
6.1 k
23 k
97 k

0.2 k
0.8 k
1.0 k
1.5 k
4.0 k
6.1 k
23 k
97 k

Max level 5

0.2 k
0.8 k
1.0 k
1.5 k
4.0 k
6.1 k
23 k
97 k

Max level 5

Max level 3

0.2 k
0.8 k
1.0 k
1.5 k
4.0 k
6.1 k
23 k
97 k

Max level 3

Base

205 k
819 k
1024 k
1573 k
4096 k
6291 k
23,773 k
99,293 k

13 k
51 k
64 k
98 k
256 k
393 k
1486 k
6206 k

205 k
819 k
1024 k
1573 k
4096 k
6291 k
23,773 k
99,293 k

13 k
51 k
64 k
98 k
256 k
393 k
1486 k
6206 k

Uniform

155 k
347 k
595 k
412 k
1055 k
876 k
4151 k
11,945 k

11 k
25 k
42 k
31 k
80 k
71 k
325 k
914 k

155 k
347 k
595 k
412 k
1055 k
876 k
4151 k
11,945 k

11 k
25 k
42 k
31 k
80 k
71 k
325 k
914 k

Adaptive

Number of triangles

1417 (290)
532 (436)
425 (435)
296 (466)
115 (471)
76 (478)
20 (475)
—

3593 (46)
2513 (129)
3098 (198)
2341 (230)
1082 (277)
746 (293)
216 (321)
52 (323)

609 (125)
199 (163)
158 (162)
113 (178)
8.8 (36)
5.7 (36)
—
—

1988 (25)
1396 (71)
1187 (76)
981 (96)
500 (128)
351 (138)
120 (178)
3.6 (22)

A

1349 (276)
475 (389)
381 (390)
258 (406)
101 (414)
66 (415)
18 (428)
4.2 (417)

1667 (21)
614 (31)
511 (33)
293 (29)
117 (30)
93 (37)
24 (36)
5.9 (37)

214 (44)
57 (47)
46 (47)
30 (47)
12 (49)
7.6 (48)
2.0 (48)
0.5 (50)

1146 (15)
440 (23)
363 (23)
252 (25)
103 (26)
68 (27)
18 (27)
4.4 (27)

B

732 (114)
484 (168)
382 (227)
424 (175)
222 (234)
239 (209)
64 (266)
24 (287)

745 (7.9)
482 (12)
369 (15)
428 (13)
218 (17)
239 (17)
66 (21)
23 (21)

232 (36)
113 (39)
71 (42)
97 (40)
41 (43)
49 (43)
11 (46)
4.0 (48)

672 (7.1)
387 (9.8)
291 (12)
329 (10)
182 (15)
197 (14)
59 (19)
22 (20)

C

731 (113)
485 (168)
377 (225)
427 (176)
220 (232)
240 (210)
64 (266)
23 (275)

736 (7.8)
482 (12)
384 (16)
419 (13)
219 (18)
234 (17)
65 (21)
23 (21)

203 (32)
98 (34)
62 (37)
86 (35)
36 (38)
42 (37)
9.3 (39)
3.4 (41)

648 (6.8)
368 (9.4)
276 (12)
323 (10)
172 (14)
184 (13)
54 (18)
20 (18)

D

680 (106)
420 (146)
294 (175)
383 (158)
171 (180)
191 (167)
45 (187)
16 (191)

1014 (11)
850 (22)
813 (34)
821 (25)
590 (47)
559 (40)
193 (63)
67 (61)

E

E
F
G
H
I

A
B
C
D

846 (131)
497 (173)
362 (216)
530 (218)
262 (276)
277 (243)
78 (324)
30 (358)

1000 (11)
832 (21)
693 (29)
762 (24)
500 (40)
488 (35)
195 (63)
68 (62)

F

693 (108)
435 (151)
336 (200)
403 (166)
210 (222)
240 (210)
59 (245)
22 (263)

931 (9.8)
862 (22)
824 (35)
813 (25)
685 (55)
686 (49)
278 (90)
111 (101)

G

693 (108)
509 (177)
397 (236)
461 (190)
235 (248)
290 (254)
74 (307)
29 (346)

798 (8.4)
841 (21)
822 (35)
814 (25)
684 (55)
685 (49)
273 (89)
108 (99)

H

I

—
—
—
—
—
—
—
—

250 (2.6)
81 (2.1)
60 (2.5)
65 (2.0)
25 (2.0)
26 (1.8)
6.0 (2.0)
1.2 (1.1)

Adaptive, SU tess, CPU RQ, texture coeffs
Adaptive, SU tess, CPU RQ, bindable uniforms
Adaptive, SU tess, GPU RQ, texture coeffs
Adaptive, SU tess, GPU RQ, bindable uniforms
Adaptive, SU tess, geometry shader

Uniform, dyadic tess, static VBO
Uniform, dyadic tess, per patch VBO [BS05]
Adaptive, dyadic tess, per patch VBO [DRS08]
Adaptive, SU tess, per patch VBO

Table 1: Performance in frames per second for a variety of algorithms, including both dyadic and semi-uniform (SU) tessellation. We indicate how many millions of triangles that are processed
per second in parentheses. The first column gives the number of triangles unrefined, with uniform refinement, and with adaptive refinement. Algorithms E–H use instancing, and algorithm I rely
on the geometry shader, features only available on DirectX 10-class GPUs.

2260
C. Dyken et al. / Semi-Uniform Adaptive Patch Tessellation

c 2009 The Authors
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

C. Dyken et al. / Semi-Uniform Adaptive Patch Tessellation

2261

Figure 5: Some of the models used in the performance analysis. The top row shows the base meshes of four models with 200,
1,000, 1,546, and 96,966 triangles, respectively. The middle and bottom rows show these base meshes adaptively refined using
semi-uniform tessellations guided by the silhouetteness-predicate, with a maximum refinement level of three.
c 2009 The Authors
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

2262

C. Dyken et al. / Semi-Uniform Adaptive Patch Tessellation

evaluating f in the vertex shader. It is clear that a large preevaluated VBO is much faster than evaluating the vertices
for every frame, but it can be prohibitively expensive with
respect to memory usage. We note, however, that for deeper
refinement levels, the methods are roughly equal in performance on the 8800 card but not on the 7800. We believe that
this is due to the unified shader architecture of the 8800 that
allows for better load balancing when the vertex processing
dominates.
For the semi-uniform schemes we observe that there is a
marginal difference between C and D on the same hardware,
indicating that applying φ has a negligible overhead. The
adaptive methods (C–H) outperform the uniform method B
as the number of patches grow above 1000–1500, probably
due to the reduced number of vertices processed.
The algorithms based on instancing (E–H) give a considerable performance increase, and for larger meshes even outperforms using a static VBO (A). We observe that patches at
intermediate refinement levels yield a relatively low throughput when rendered per patch, while using instancing with a
small number of tessellation types reduce the triggering cost
significantly. For deeper refinement levels we observe that
our approach performs nicely, with the relative cost of the
snapping function diminishing.
We believe that adaptive refinement patterns [BS08] would
have performance comparable to Method C. Instancing could
be used, however, we believe that the benefit would be somewhat limited because the number of tessellation patterns
grows like O(M 3 ), which in turn results in smaller batches
and more elaborate sorting.
For meshes with more than about 1000 patches, render
queue generation appears to be faster on the GPU (G and
H) than on the CPU (E and F). When it comes to the different methods for passing the patch coefficients, the results are less clear. For M = 3 it appears that texture buffers
is the fastest approach while for M = 5 it is faster to use
bindable uniforms. We believe this is because the patch data
is more heavily accessed, so the fast constant memory outweighs the smaller batch sizes.
The geometry shader implementation (I) is the simplest
adaptive method to implement, however, it has consistently
the worst performance. We believe the reason is that the
hardware does not know in advance the number of output
primitives per patch, and this makes load balancing difficult.
Also, the geometry upscale capabilities are insufficient for
refinement levels greater than three, which limits the applicability of this approach.

easily be modified to e.g. quadrilateral patches and subdivision surfaces and other refinement predicates.
The individual patch tessellations are dyadic refinements,
which are topologically uniform and trivial to generate. A
simple snapping operation with marginal overhead ensures
that tessellations are consistent across patch boundaries. The
snap function is well suited for implementation in a vertex shader, requiring only a few lines of code, and can
be incorporated in a rendering framework using one single VBO for each tessellation level. Because the number
of VBOs is low, the memory requirements are minimized
and allows for deep refinement levels. Moreover, it makes
our approach well suited for instancing, which improves the
performance significantly as shown by our performance analysis. Our experiments also confirm that performing tessellation using the geometry shader is not competitive on current
GPUs.
The advent of fast GPUs built on wide parallelism has
favoured large regular meshes over small irregular meshes,
and uniform refinement methods over more general refinement. From our experiments, one might draw the conclusion that adaptivity can be competitive as long as enough
uniformity is present in the vertex stream to use instancing. This allows for all GPU pipelines to be used efficiently, while the unified shader architecture adaptively balances the workload. Our semi-uniform approach appears to
find a good balance between adaptivity and uniformity, and
seems particularly well suited for massively parallel modern
GPUs.
Acknowledgements
We thank Denis Kovacs and Ignacio Castano for helpful
comments in this work. Furthermore, we would like to thank
Nvidia for hardware donations.
References
[AB06] ANDREWS J., BAKER N.: Xbox 360 system architecture. IEEE Micro 26, 2 (2006), 25–37.
[BS05] BOUBEKEUR T., SCHLICK C.: Generic mesh refinement on GPU. In Graphics Hardware 2005 (July 2005),
pp. 99–104.
[BS08] BOUBEKEUR T., SCHLICK C.: A flexible kernel for
adaptive mesh refinement on GPU. Computer Graphics
Forum 27, 1 (2008), 102–114.
[Bun05] BUNNELL M.: Adaptive tessellation of subdivision surfaces with displacement mapping. In GPU Gems
2. Addison-Wesley, 2005, pp. 109–122.

6. Conclusion
We have presented a framework for semi-uniform adaptive
tessellation of triangular patches. Our approach is independent of the patch type and tessellation level criterion, and can

[DRS08] DYKEN C., REIMERS M., SELAND J.: Real-time
GPU silhouette refinement using adaptively blended

c 2009 The Authors
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.

C. Dyken et al. / Semi-Uniform Adaptive Patch Tessellation

B´ezier patches. Computer Graphics Forum 27, 1 (2008),
1–12.
[DZTSar] DYKEN C., ZIEGLER G., THEOBALT C., SEIDEL
H.-P.: High-speed marching cubes using histogram pyramids. Computer Graphics Forum 27, 8 (2008), 2028–
2039.
[Har07] HARRIS M.: Parallel prefix sum (scan) with
CUDA. NVIDIA CUDA SDK 1.0, 2007.
[HDD*93]
HOPPE H., DEROSE T., DUCHAMP T., MCDONALD
J., STUETZLE W.: Mesh optimization. In Proceedings of
SIGGRAPH ’93 (August 1993), Computer Graphics Proceedings, Annual Conference Series, pp. 19–26.
[LH04] LOSASSO F., HOPPE H.: Geometry clipmaps: terrain
rendering using nested regular grids. ACM Transactions
on Graphics 23, 3 (August 2004), 769–776.
[Mor01] MORETON H.: Watertight tessellation using forward differencing. In Graphics Hardware ’01 (2001),
pp. 25–32.

2263

[SAF*06] SEGAL M., AKELEY K., FRAZIER C., LEECH J.,
BROWN P.: The OpenGL Graphics system: A Specification,
version 2.1. Silicon Graphics, Inc., 2006.
[SJP05] SHIUE L.-J., JONES I., PETERS J.: A realtime GPU
subdivision kernel. ACM Transactions on Graphics 24, 3
(August 2005), 1010–1015.
[Sta98] STAM J.: Exact evaluation of Catmull-Clark
subdivision surfaces at arbitrary parameter values. In
Proceedings of SIGGRAPH ’98 (July 1998), Computer Graphics Proceedings, Annual Conference Series,
pp. 395–404.
[VPBM01] VLACHOS A., PETERS J., BOYD C., MITCHELL
J. L.: Curved PN triangles. In Proceedings of the ACM
Symposium on Interactive 3D Graphics ’01 (March 2001),
pp. 159–166.
[ZTTS06] ZIEGLER G., TEVS A., THEOBALT C., SEIDEL
H.-P.: GPU Point List Generation through Histogram
Pyramids. Tech. Rep. MPI-I-2006-4-002, Max-PlanckInstitut f¨ur Informatik, 2006.

c 2009 The Authors
Journal compilation c 2009 The Eurographics Association and Blackwell Publishing Ltd.


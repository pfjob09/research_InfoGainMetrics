DOI: 10.1111/j.1467-8659.2009.01602.x
EUROGRAPHICS 2010 / T. Akenine-Möller and M. Zwicker
(Guest Editors)

Volume 29 (2010), Number 2

Fast and Efficient Skinning of Animated Meshes
L. Kavan1,2 , P.-P. Sloan1 and C. O’Sullivan2
1 Disney
2 Trinity

Interactive Studios, USA
College Dublin, Ireland

Abstract
Skinning is a simple yet popular deformation technique combining compact storage with efficient hardware accelerated rendering. While skinned meshes (such as virtual characters) are traditionally created by artists, previous
work proposes algorithms to construct skinning automatically from a given vertex animation. However, these methods typically perform well only for a certain class of input sequences and often require long pre-processing times.
We present an algorithm based on iterative coordinate descent optimization which handles arbitrary animations
and produces more accurate approximations than previous techniques, while using only standard linear skinning
without any modifications or extensions. To overcome the computational complexity associated with the iterative
optimization, we work in a suitable linear subspace (obtained by quick approximate dimensionality reduction)
and take advantage of the typically very sparse vertex weights. As a result, our method requires about one or two
orders of magnitude less pre-processing time than previous methods.
Categories and Subject Descriptors (according to ACM CCS): Computer Graphics [I.3.7]: Three-Dimensional
Graphics and Realism—Animation

standard in most interactive applications. The sparsity constraint is crucial for efficient evaluation of Formula (1), especially when implemented on graphics hardware.

1. Introduction
Linear blend skinning (also known as matrix palette skinning) is a mesh deformation technique implemented in almost all modern 3D engines, most frequently used for virtual characters driven by skeletal animation. However, recent research suggests new possible applications, including
animation of highly deformable objects, such as cloth.

An animated mesh with fixed connectivitycan be represented by a 3F × N matrix A, where F is the number of
frames and N the number of vertices:
⎛ (1)
⎞
(1)
v1
· · · vN
⎜ .
.. ⎟
..
⎟
A=⎜
.
⎝ ..
. ⎠
(F)
(F)
· · · vN
v1

Standard linear blend skinning works as follows: let us
denote the i-th rest pose vertex as v˜ i ∈ R4×1 (with the last
coordinate equal to 1 as usual), the palette of P affine trans(f)
(f)
formations for frame f as M1 , . . ., MP ∈ R3×4 and vertex
weights as wi,1 , . . ., wi,P ∈ R. A skinned vertex position in
frame f is then computed as:
(f)

vi

=

P

(f)

∑ wi, j M j

v˜ i ,

(f)

vi

∈ R3×1

The problem addressed in this paper is to approximate the
animation matrix A by skinning with a small number of
proxy-bones P. We can obtain useful insights about this
problem by rewriting Formula (1) in matrix form. If we
stack the skinning parameters in matrices T ∈ R3F×4P and
X ∈ R4P×N as follows:
⎛ (1)
⎞
⎛
⎞
(1)
M1 · · · MP
w1,1 v˜ 1 · · · wN,1 v˜ N
⎜ .
⎟
⎟
.. ⎟ , X = ⎜ ..
..
..
..
T=⎜
⎝ .
⎠
.
.
⎝ ..
. ⎠
.
(F)
(F)
w1,P v˜ 1 · · · wN,P v˜ N
··· M
M

(1)

j=1

Motivated by skeletal animation terminology, the transfor(f)
mations M j are also sometimes referred to as bones (or
proxy-bones). The vertex weights wi,1 , . . ., wi,P are usually
required to be convex (i.e. non-negative and summing to 1)
and sparse—a maximum of 4 non-zero weights is a de facto

1

c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.
Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and
350 Main Street, Malden, MA 02148, USA.

327

P

328

L. Kavan, P.-P. Sloan & C. O’Sullivan / Fast and Efficient Skinning of Animated Meshes

SMA, 22 bones (414s)

SAD, 22 bones (1512s)

Our method, 10 and 22 bones (22.1 and 22.8s)

Original, 5095 vertices

Figure 1: Skinning approximation of a skirt animation computed using SMA (Skinning Mesh Animations) [JT05], SAD (Skinning Arbitrary Deformations) [KMD∗ 07] and our proposed method (execution times in brackets). Our method produces more
accurate skinning approximations in a fraction of the time required by previous methods (skirt dataset, see Table 2).
2. Related Work

then Formula (1) can be written in matrix form as:
TX = A

(2)

For small P, this equation typically cannot be satisfied exactly. Therefore, the task is to minimize the Frobenius norm
TX − A F for a given number of proxy-bones P.
Formula (2) suggests that linear blend skinning can be
also considered as a special kind of matrix decomposition
(in the following, we will use the term skinning decomposition). The main difference to standard matrix decompositions, such as the popular Singular Value Decomposition (SVD), is the limit on the number of non-zero elements in each column of X (typically 16—four non-zero
weights times four elements of v˜ i ). Compared to truncated
SVD [AM00], skinning typically requires more per-frame
data, but the amount of per-vertex data is small and fixed.
The constant number of vertex attributes is probably one of
the reasons for the popularity of skinning, as it simplifies
many implementation issues and enables very efficient hardware processing.
Building on the results of previous work, we introduce a
technique that produces quite accurate skinning decompositions with low bone counts (see Figure 1). Our method employs only standard linear blend skinning without any modifications or extensions and is thus suitable for many existing
applications. However, we do not attempt to organize our
proxy-bones into a hierarchy (see Figure 2), and we do not
address the problem of motion post-processing.

Figure 2: Example of vertex weights and bone transformations produced by our method.

The problem of approximating mesh animation with skinning was first addressed by James and Twigg [JT05].
Their method, called Skinning Mesh Animations (SMA),
works by applying mean-shift clustering to identify core
bone triangles (and thereby bone transformations). Subsequently, vertex weights are determined by truncated SVD or
non-negative least squares. The reconstruction quality can
be optionally improved by a corrective technique similar
to EigenSkin [KJP02], which works by compressing pervertex residuals using truncated SVD. SMAs work best with
models consisting of approximately rigid components (i.e.,
quasi-articulated), such as human or animal figures.
The follow-up work of Kavan and colleagues [KMD∗ 07]
aims to address the issues associated with highly deformable
animations. Their method, called Skinning Arbitrary Deformations (SAD), uniformly distributes proxy-bones over
the rest pose mesh and optimizes their transformations using least squares. While this provides more accurate skinning of highly deformable animations, it is slower than SMA
and requires a lot of proxy-bones (typically 100) and EigenSkin corrections (typically 10) to achieve visually pleasing reconstructions. SAD also produces suboptimal results
for quasi-articulated animations, because it does not attempt
to identify coherent mesh components. Focusing on quasiarticulated animations, Schaefer and Yuksel [SY07] and
deAguiar and colleagues [dATTS08] develop methods to extract not only the skinning parameters but also full hierarchical skeletons, thus enabling convenient editing. Both also
propose faster clustering methods than mean-shift and alternative vertex weights optimization methods, but highly deformable animations (lacking any natural skeletal hierarchy)
are not considered. Baran and Popovi´c [BP07] show how to
rig characters using only the rest pose and skeleton, without
any training animation.
While standard linear blend skinning according to Formula (1) is the most popular method, several modifications
are studied in the literature (we review only the most closely
related work, please see [GB08] for a survey). AnimationSpace [MMG06a] is a linear skinning technique which rec 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

L. Kavan, P.-P. Sloan & C. O’Sullivan / Fast and Efficient Skinning of Animated Meshes

laxes the constraints on matrix X from Formula (2) (similarly to its predecessor Multi-weight Enveloping [WP02]).
The elements of XAnimationSpace can be arbitrary and do
not have to have the form wi, j v˜ i as in standard skinning.
However, the sparsity pattern of XAnimationSpace remains unchanged, i.e., there is a maximum of 16 non-zero elements in
each column. The fitting process described in [MMG06a] assumes the bone transformations matrix T to be known (e.g.,
specified by an animated skeleton).
Clustered PCA [SSK05] can also be considered as matrix decomposition according to Formula (2), but with a different sparsity pattern—in particular, XCPCA is required to
be a rectangular block diagonal matrix (while T can be an
arbitrary dense matrix). On one hand, this allows for more
flexibility within every single cluster, but on the other hand,
every vertex belongs to one cluster only (i.e., the clusters are
not allowed to overlap). Because of the latter property, the
resulting reconstruction may be non-smooth, see Figure 7.
This can be alleviated by reducing the number of clusters
and increasing their dimension instead, which in the limit
leads to truncated SVD (i.e., only one cluster) [AM00].
Nonlinear skinning techniques, such as dual-quaternion
skinning [KCŽO08], have also been studied in the context of skinning decomposition [KMD∗ 07, FKY08]. Dualquaternion representation of bone transformations is more
compact (8 scalars instead of 12) and avoids the sometimes
undesirable non-rigid transformations. Unfortunately, even
though the resulting optimization problem is still linear, it
has different system matrix for every frame and therefore, its
solution is rather time consuming. In this paper, we trade off
the advantages of dual quaternions for faster pre-processing.
This is not a major limitation, because nonlinear skinning
can always be converted to linear skinning with extra proxybones [MG03, KCO09].
Formula (2) reveals that skinning decomposition is a special case of sparse matrix factorization—a more general
problem with applications also in rendering [RK09] and
statistics [WTH09]. While sharing certain common principles, each application considers different kinds of data and
specific factorization constraints. Linear blend skinning is
differentiated by the special structure of matrix X (see Section 1) and the requirement for convex vertex weights.
Another closely related field is general animation compression (see [Váš08]). While techniques such as those
based on predictive coding [KG04] or progressive meshes
[GK04, KG05] achieve high compression ratios, they typically require sequential decompression, which poses challenges for implementation on parallel graphics hardware.
Linear blend skinning finds its use not only in
performance-critical interactive applications, but also in related research. Wang and colleagues [WPP07] employ skinning decomposition to obtain a very fast system for synthesizing non-linear deformations of quasi-articulated models.
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

329

Feng and colleagues [FKY08] skin highly deformable animations (using an improved SAD procedure) to obtain an
efficient posing system based on canonical correlation analysis. In general, we believe skinning decomposition itself deserves further investigation, as attempted in this paper.
2.1. Overview of Our Method
Our main tool for obtaining accurate skinning decompositions is alternating least squares, i.e., a variant of coordinate
descent (proposed in a similar context already in [MG03]).
In contrast to previous work, we optimize all of the skinning parameters respectively: bone transformations, vertex
weights and rest pose positions. Since several iterations are
required (we use 15, see Section 5), this results in a lot of
least squares problems to be solved, suggesting high computational costs.
Therefore, we propose to formulate our optimization process in reduced coordinates, by decomposing the input animation matrix A ∈ R3F×N to B ∈ R3F×d and C ∈ Rd×N such
that BC ≈ A, where B has orthonormal columns and d <<
3F (Section 3). Intuitively, this corresponds to eliminating
vertex trajectories that can be expressed as linear combinations of representative vertex trajectories (columns of B).
This allows us to pose the problem as finding Tr ∈ Rd×4P
and X ∈ R4P×N minimizing BTr X − BC F = Tr X − C F
and not reconstruct the actual bone transformations matrix
T = BTr until the whole optimization is finished. When
combined with the sparse nature of X and our improved formulation of fitting vertex weights, we obtain a fast and efficient solver for each of the skinning parameters (Section 4).
3. Approximate Dense Dimensionality Reduction
Given the animation matrix A ∈ R3F×N , the task is to find
the dimension d and matrices B ∈ R3F×d , C ∈ Rd×N , where
BT B = I, such that:
BC − A

F

≤ε

We choose the error threshold ε conservatively to ensure that
the error incurred by using BC instead of A is close to imperceptible (see Section 5).
The optimal d and the corresponding matrices B and C
could be found using truncated SVD [GL96]. However, even
the very efficient LAPACK [ABB∗ 99] routines take an impractically long time to compute the SVD of our animation
matrices. Therefore, we propose an alternative dimensionality reduction technique which requires slightly higher d,
but runs much faster than SVD. One possibility would be
to apply Gram-Schmidt orthonormalization [JF03], but this
approach typically results in a too high d and not exactly
orthogonal basis vectors (the modified Gram-Schmidt procedure [GL96] is more numerically stable, but still not perfect). We propose Algorithm 1 which addresses both of these
issues.

330

L. Kavan, P.-P. Sloan & C. O’Sullivan / Fast and Efficient Skinning of Animated Meshes

Algorithm 1
Input: Matrix A ∈ R3F×N , error threshold ε ∈ R
Output: Matrices B ∈ R3F×d , C ∈ Rd×N such that BT B = I
and BC − A F ≤ ε
1: A1 = A, B0 =empty matrix, C0 =empty matrix, i = 0
2: repeat
3:
i = i+1
4:
mi =maximum norm column of Ai {mi ∈ R3F×1 }
5:
mi = mi − Bi−1 BTi−1 mi {stabilization}
6:
mi = mi / mi {normalization}
7:
Ai+1 = Ai − mi mTi Ai {deflation}
8:
Bi = (Bi−1 |mi ) {append column}
Ci−1
{append row}
9:
Ci =
mTi Ai
10: until Bi Ci − A F ≤ ε
11: d = i, B = Bi , C = Ci

The vector mi defined on line 4 of Algorithm 1 is our approximation of the leading singular vector (principal component). Several alternatives are possible. For example, setting
mi to columns of Ai one by one corresponds to the GramSchmidt strategy. Another possibility we tried is to per(k+1)
=
form several iterations of the power method (i.e., mi
(k)

(k)

Ai ATi mi / Ai ATi mi ), which gives results close to exact
SVD. The proposed strategy, i.e., selecting the maximum
norm column of Ai , presents a good compromise between
fast computations and a small dimension d (see Table 1).
Related techniques are also discussed in the literature, such
as variations of the power method [PC98] or discrete principal components [Mar06], but we prefer the maximum norm
strategy because of its simplicity and good performance.
Line 5 is the stabilization step and we can ignore it for
a moment (in exact arithmetics it has no effect on mi since
BTi−1 mi is a zero vector). Line 7 performs deflation, i.e., for
every column of Ai it subtracts its component in the direction mi , see Figure 3. This also guarantees that columns of
Ai+1 will be orthogonal to mi (and also to m j for j < i).
Since mi is always selected from the column space of Ai ,
this means that the columns of matrix Bi will be orthogonal. Line 9 incrementally updates Ci so that Ci = BTi A. The
termination condition on line 10 can be simplified as follows: Bi Ci − A 2F = A 2F − Bi Ci 2F and because Bi has
orthonormal columns, Bi Ci 2F = Ci 2F (see supplemental
materials for a detailed justification). Therefore, it is not necessary to explicitly compute the product Bi Ci to determine
the current approximation error.
Since B represents an orthonormal basis, it can be shown
that even when working with reduced transformations Tr
(and reconstructing T = BTr at the end as discussed in Section 2.1), we can get an upper bound of the total error of the
non-reduced skinning decomposition:
TX − A

F

=

TX − BC + BC − A

F

mi

mi

Ai

Ai+1

Figure 3: Algorithm 1 selects mi as the point farthest from
the origin (line 4, left) and then subtracts projections in the
mi direction, obtaining Ai+1 (line 7, right).
≤

TX − BC

=

BTr X − BC

=

Tr X − C

F

+ BC − A
F

F

+ BC − A

F + BC − A

F

F

Algorithm 1 provides BC such that BC − A F ≤ ε, which
is chosen to be very small, and therefore the error of the reduced skinning decomposition Tr X − C F is the dominating factor (its minimization is the topic of Section 4). However, if B does not have exactly orthogonal columns, it is not
the case that BTr X − BC F = Tr X − C F and the error
Tr X − C F may get amplified through the skewed basis.
Fortunately, there is a simple and efficient way (line 5 in
Algorithm 1) to prevent the accumulation of rounding errors that cause the loss of orthogonality. This is essentially
a classical Gram-Schmidt step subtracting projected numerical inaccuracies Bi−1 BTi−1 mi , see [GLRvdE05] for a detailed theoretical analysis. Figure 4 compares the precision
of the non-stabilized (without line 5) and stabilized (with
line 5) version, computed with double precision. We can see
that the non-stabilized version (left) exhibits an obvious loss
of orthogonality (up to the 12th decimal place), whereas the
stabilized version (right) is much more accurate.

-12
-14
-16
-18
-20
Figure 4: Decadic logarithm of absolute values of (BT B−I)
for the non-stabilized (left) and stabilized (right) versions of
Algorithm 1 (flag dataset, d = 101).
We also compared the performance of various strategies
for selecting the vector mi (line 4). While the asymptotical
complexity of Algorithm 1 is always O(FNd), the actual
performance varies significantly. For illustration, Table 1
summarizes the resulting dimension d and the total runtime
of Algorithm 1 on the flag dataset (N = 6906, 3F = 600, see
Section 5) with the same ε in all cases.
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

L. Kavan, P.-P. Sloan & C. O’Sullivan / Fast and Efficient Skinning of Animated Meshes

d
time

MAX
101
2.78s

GS
278
5.8s

PM1
80
6.3s

PM2
72
9.9s

SVD
69
27.9s

Table 1: Results of Algorithm 1 for various mi selection
strategies: our method (MAX), Gram-Schmidt (GS), and 1
and 2 iterations of the power method (PM1, PM2). The last
column (SVD) is the result of dgesdd [ABB∗ 99].
Note that while the Gram-Schmidt (GS) technique features the fastest update, its uninformed mi selection strategy
results in a high number of iterations d and thus the total runtime is longer than with our method (MAX). SVD is the theoretical minimum, i.e., it is not possible to obtain a smaller d
for the given error threshold. We prefer our maximum norm
strategy (MAX), because it is very fast and produces bases
with dimensions not too far from the optimum.
4. Skinning Decomposition
In this section we present our method to find matrices Tr ∈
Rd×4P and X ∈ R4P×N , where X is sparse and contains rest
pose vertex positions multiplied by weights (as discussed in
Section 1). For a given P, the task is to minimize Tr X −
C F , where C ∈ Rd×N was computed by Algorithm 1 from
Section 3.
We start by establishing initial rigid skinning weights X0
(Section 4.1), followed by computing the corresponding Tr,0
(Section 4.2). The reconstruction Tr,0 X0 is typically crude
and non-smooth, but this is quickly improved after transformation (Section 4.2), rest pose (Section 4.3) and vertex weights optimization (Section 4.4), thereby producing
a more accurate Tr,k Xk in the k-th step. We experimentally
found the order of optimization operations has little influence on the result.

331

be contiguous and is initialized to the seed triangle vertices.
We extract deformation gradients D1 , . . ., DP of the seed triangles and for every cluster c we maintain a priority queue of
immediately adjacent vertices, sorted by their Dc prediction
error. Checking the fronts of all the priority queues, we find
the vertex v with the minimal prediction error and append it
to its cluster, updating the data structures accordingly. This
process is repeated until all vertices are assigned a cluster.
Even though this approach is undoubtedly inferior to advanced clustering techniques, the subsequent vertex weights
optimization (Section 4.4) attracts proxy-bone influences to
their optimal locations (and also allows them to overlap).
For example, the initial sketchy segmentation of the character’s head (Figure 5 left) is considerably improved after 15
iterations of our optimization process (Figure 5 right)—in
particular, note that the whole head becomes influenced by
one bone only. While more careful initialization may lead
to slightly lower approximation error, we prefer our region
growing technique because it is simple to implement and
very fast (e.g., the segmentation in Figure 5 was computed in
0.13s, which is several thousand times faster than mean-shift
clustering, requiring 618s—see Section 5).

Figure 5: Our clustering technique produces crude initial
segmentation (left), but this is fixed in subsequent optimization (right) (samba dataset, see Table 2).

4.1. Initialization

4.2. Transformations Optimization

Since initialization of the rest pose is straightforward (for
example, we can use the first frame of the animation), the
main task is to cluster the vertices of the input animated
mesh (note that rigid skinning corresponds to segmentation). This problem has been studied extensively in the literature [Sha08] and we tested several previously proposed
approaches, such as mean-shift clustering [JT05], clustered
PCA [SSK05] and hierarchical clustering [WPP07, SY07].

For any given X ∈ R4P×N and C ∈ Rd×N , the task is to compute the matrix Tr ∈ Rd×4P so that Tr X − C F is minimized. This is a linear least squares problem and it can be
solved efficiently by inverting the normal equations:

While each method has certain unique features, we found
that the subsequent iterative optimization blends away the
differences between different initializations of X0 and typically results in quite similar errors Tr,k Xk − C F for higher
k. Therefore, in our algorithm, we have decided to apply only
a very simple segmentation based on multiple source region
growing. We start by selecting P seed triangles distributed
approximately uniformly over the rest pose mesh by solving
the p-center problem as in [KMD∗ 07] (only executed on triangles instead of vertices). Each cluster will be required to
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

Tr XXT = CXT
while exploiting the sparsity of X (i.e., the maximum of 16
non-zero elements in each column). With indexed storage,
the product XXT can be computed in time O(PN + P2 ) instead of O(P2 N). Similarly, the asymptotic cost of computing CXT can be reduced to O(dP + dN).
We compute the inverse of XXT using Cholesky decomposition [GL96]. If the Cholesky algorithm detects singular XXT , we fallback to a (slower) pseudoinverse computed
using eigen-decomposition. However, this happens only in
pathological cases (usually, the system is sufficiently overdetermined). We also experimented with sparse Cholesky factorization, but we found that XXT is typically not too sparse

332

L. Kavan, P.-P. Sloan & C. O’Sullivan / Fast and Efficient Skinning of Animated Meshes

(and the Cholesky factor even less so) and therefore we
opt for the dense LAPACK routines dpotrf and dpotri
[ABB∗ 99].

non-zero by selecting the four columns of Θ that are closest
to the right hand side y (this corresponds to selecting the
bones that individually best predict the deformed vertices,
as in [JT05]).

4.3. Rest Pose Optimization

If we denote the chosen columns as φ1 , . . ., φ4 ∈ Rd×1 and
the set of their convex combinations as:

Recall that X ∈ R4P×N combines both rest pose vertices and
weights, i.e., Xi, j = w j,i v˜ j ∈ R4×1 . For a given Tr ∈ Rd×4P ,
C ∈ Rd×N and vertex weights wi, j ∈ R, the task is to compute
the rest pose vertices v˜ 1 , . . ., v˜ N ∈ R4×1 in X so that Tr X −
C F is minimized. Because of the special structure of X, it is
convenient to denote also the elements of Tr in vector form
ti, j where ti, j ∈ R1×4 for i = 1, . . ., d, j = 1, . . .P. Using
this notation we can rewrite equations Tr X ≈ C as:
P

∑ ti,k w j,k v˜ j ≈ Ci, j

i = 1, . . ., d, j = 1, . . ., N

k=1

The optimization thus reduces to N linear least squares problems of the form:
⎛
⎞
⎞
⎛ P
C1, j
∑k=1 t1,k w j,k
⎜ . ⎟
⎟
⎜
..
⎠ v˜ j ≈ ⎝ .. ⎠ , j = 1, . . ., N
⎝
.
P

∑k=1 td,k w j,k

Cd, j

Since the fourth coordinate of v˜ j is usually supposed to
be 1 (homogeneous coordinates), we subtract the last column of the system matrix from the right hand side, obtaining equations Λ j v˜ j ≈ Γ j , where v˜ j ∈ R3×1 , Λ j ∈ Rd×3 and
Γ j ∈ Rd×1 . The corresponding normal equations have especially compact form:
ΛTj Λ j v˜ j = ΛTj Γ j

L=

4

4

k=1

k=1

∑ αk φk : ∑ αk = 1, αk ≥ 0

we can formulate the problem as finding m ∈ L which minimizes y − m . While previous work typically solves this
problem using general purpose Non-Negative Least Squares
solver [LH74], we propose to take advantage of the small
and fixed number of influencing bones per vertex. In this
case, our approach is simpler, faster and more accurate (note
that with NNLS, the affinity condition ∑4k=1 αk = 1 is not
enforced exactly, but is treated as a soft constraint [JT05]).
Geometrically, the set L is a tetrahedron in d-dimensional
space and the task is to find its closest point to y ∈ Rd×1 .
We will show that this problem can be reduced to three dimensions, which simplifies its solution considerably. To accomplish this, we shift both the tetrahedron L and the point
y, obtaining L = L − φ4 and y = y − φ4 . The new tetrahedron L thus has one of its vertices coincident with the origin
and therefore, there is a 3D linear subspace S ⊆ Rd×1 such
that L ⊆ S. It can be shown that finding m ∈ L minimizing y − m is equivalent to finding m ∈ L minimizing
yS − m , where yS is the orthogonal projection of y on
the subspace S (see Figure 6 for an intuitive justification and
the Appendix for a formal proof).

where ΛTj Λ j is just a 3 × 3 matrix and thus can be inverted
efficiently, e.g., using cofactors (with a fallback to pseudoinverse if det(ΛTj Λ j ) is close to zero. However, this is rarely
the case.)

y'

4.4. Vertex Weights Optimization
For a given Tr ∈ Rd×4P , C ∈ Rd×N and rest pose vertices
v˜ 1 , . . ., v˜ N ∈ R4×1 , the task is to determine vertex weights
wi, j ∈ R in X so that Tr X − C F is minimized subject to
the constraints that wi,1 , . . ., wi,P are convex and only 4 of
them are non-zero for every i = 1, . . ., N.
As above, the weights can be optimized separately for every vertex v˜ i . Using the notation of Tr elements introduced
in Section 4.3, the problem for the i-th vertex can be stated
in matrix form as follows:
⎞⎛
⎞ ⎛
⎞
⎛
C1,i
wi,1
t1,1 v˜ i · · · t1,P v˜ i
⎟⎜ . ⎟ ⎜ . ⎟
⎜
..
..
..
⎠ ⎝ .. ⎠ ≈ ⎝ .. ⎠
⎝
.
.
.
wi,P
Cd,i
td,1 v˜ i · · · td,P v˜ i
Θ ∈ Rd×P

y ∈ Rd×1

We start by choosing the weights which will be allowed to be

⊆ Rd×1

L'2

S

m'
y'S

Figure 6: Illustration of our problem for d = 3 and triangle
L2 (instead of tetrahedron). We can see that if m ∈ L2 is as
close as possible to yS , it is also as close as possible to y .
Therefore, if we pick an orthonormal basis b1 , b2 , b3 ∈
Rd×1 of S, we can express both the tetrahedron vertices
φ1 − φ4 , φ2 − φ4 , φ3 − φ4 , 0 and the point yS using three coordinates only, thereby reducing it to the 3D problem of finding the closest point on a tetrahedron to a point, which can be
solved efficiently [Eri04] (since calculations in three dimensions are obviously much faster than in d dimensions). If the
optimal m (which always exists and is unique) is expressed
in barycentric coordinates, then these coordinates represent
exactly the desired vertex weights α1 , . . ., α4 .
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

L. Kavan, P.-P. Sloan & C. O’Sullivan / Fast and Efficient Skinning of Animated Meshes

The orthonormal basis b1 , b2 , b3 ∈ Rd×1 can be computed by executing Gram-Schmidt orthonormalization on
vectors φ1 −φ4 , φ2 −φ4 , φ3 −φ4 ∈ Rd×1 . Since there are only
three vectors, this is very simple and numerically stable even
with the most straightforward implementation. If the GramSchmidt process detects the vectors φ1 − φ4 , φ2 − φ4 , φ3 − φ4
to be close to linearly dependent, it means that one of the
chosen proxy-bones is redundant and we replace it with another column of matrix Θ.
Note that while the above described procedure could be
generalized to h > 4 influencing bones, the number of faces
of a h-dimensional simplex grows exponentially with h and
therefore, for higher h, a generic solver such as NNLS would
be preferable. However, a high number of vertex weights is
not desirable anyway and, if present, weight reduction techniques can be applied [LS09].
5. Runtime Implementation and Results
While the evaluation of Formula (1) is trivial, for a high performance implementation it is often necessary to consider
particulars of the target graphics hardware [Lee07]. Most 3D
engines contain skinning routines and/or shaders optimized
for the supported platforms.
There are several strategies to handle vertex normals, the
( f ) −T

simplest being to transform them by ∑Pj=1 wi, j M j
[MG03]. This is only an approximation, but an accurate
solution is possible at the cost of extra vertex attributes
[MMG06b]. In our implementation we adopt the approach
of Wang and colleagues [WPP07], who compute vertex normals by averaging normals of the incident triangles. This results in smooth normal fields and allows for efficient implementation on modern graphics hardware.
In previous work [JT05, KMD∗ 07], approximation error
is typically reported in terms of the following error metric,
adopted from [KG04]:
100.0% · A − Aapprox

F/

A − AtimeAverage

F

where AtimeAverage ∈ R3F×N is a matrix representing a static
mesh (average of all keyframes). Unfortunately, this metric is sensitive to global motion applied to the entire mesh.
For example, adding linear motion increases the denominator A − AtimeAverage F but leaves the numerator A −
Aapprox F unchanged because skinning can trivially reproduce translation (by simply adding the translation to all bone
transformations). For example, an on-spot walking sequence
will have higher error than exactly the same animation where
the character moves forward.
√
Therefore, we propose to simply use 3NF as the normalizing factor, obtaining:
ERMS = 1000

A − Aapprox
√
3NF

F

Since 3NF is the total number of elements of matrix A, ERMS
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

333

is simply the average error per element (scaled by 1000 for
convenience). To be able to compare ERMS between objects
with different proportions, we uniformly scale every animation so that its first frame is tightly enclosed by a unit ball.
Therefore, roughly speaking, ERMS can also be interpreted
as the number of pixels on a 1000 × 1000 parallel-projection
viewport displaying our mesh full screen. With our method,
the error threshold
ε in Algorithm 1 (Section 3) is always set
√
to 0.0005 3NF to obtain approximately half-pixel accuracy
of the initial dense dimensionality reduction. The results for
various testing animations are summarized in Table 2. Please
note the ERMS reported for our method accounts for the final
skinning error TX − A F (and not the error in the reduced
coordinates Tr X − C F , which would be slightly lower).
With SMA, we used the (best possible) results from
[JT05], where available. In the case of the skirt and cloak
animations, we were unable to configure mean-shift clustering to produce enough clusters. This is probably an issue
with the applied mean-shift software [GSM03], mentioned
also in [KMD∗ 07]. Our implementations of SMA and SAD
use flexible (affine) bones and non-negative vertex weights,
just like our method.
For comparison, we also report the results of two related methods: clustered PCA [SSK05] and truncated SVD
[AM00]. The number of clusters for CPCA is set to the number of bones P and the number of dimensions per cluster is
set to 4, to obtain the same amount of per-frame data as with
skinning. While the approximation error of CPCA reported
in Table 2 is attractive, the actual visual quality suffers from
the fact that clusters are not allowed to overlap (see Figure 7). With truncated SVD, the number of dimensions is set
to 4P (in order to obtain the same amount of per-frame data,
as above). Even though the approximation error of SVD is
very low, note that SVD requires much more per-vertex data
(i.e., 4P) than skinning (which is constant). In other words,
each SVD “bone” is global and can affect the whole mesh
(unlike bones in skinning which have localized influences).
In practice, this implies not only higher memory consumption, but especially more complex vertex reconstruction, requiring O(P) arithmetic operations and data fetches (while
skinning requires only O(1)).
From Table 2 we can see that our method is never worse
and is typically several times better than SMA, SAD and
CPCA in terms of approximation error. In many cases, our
method outperforms SMA and/or SAD even after rank-10
EigenSkin corrections (no corrective techniques were applied with our method). Note that while SMA performs better for quasi-articulated animations (Table 2 bottom) and
SAD for highly deformable ones (Table 2 top), our method
handles both cases equally well, as well as animations with
both quasi-articulated and highly-deformable components
(Table 2 middle).
We measured the execution time of all algorithms on an
Intel Core 2 Duo (3.0GHz) processor with 2GB RAM. The

334
Model

L. Kavan, P.-P. Sloan & C. O’Sullivan / Fast and Efficient Skinning of Animated Meshes
Input Data
Vertices
Frames

Bones

SMA

Approximation Error ERMS
SAD
Our
CPCA

SVD

SMA

Execution Time
SAD
Our total (init, 1 step)

elasticCow
clothHorse
flag32
flag100
skirt22
skirt50
cloak10
cloak35

2904
8431
6906
6906
5095
5095
3069
3069

204
53
200
200
360
360
360
360

18
6
32
100
22
50
10
35

17 (9.2)
48 (1.3)
27 (7.6)
1.9 (1.6)
34 (22)
13 (12)
-

16 (9.1)
26 (0.8)
7 (2.6)
1.6 (1)
6.6 (6.4)
3.4 (3)
6.6 (5.8)
2.8 (2.5)

3.6
8.3
1.6
0.7
2.5
1
3
0.8

7.3
12.4
3.2
1.4
4.6
2.6
5.6
2.2

1.3
1
0.3
0.01
1.2
0.2
1.9
0.2

2.3m
2.7m
6.7m
10.5m
6.9m
4.3m
-

2.8m
3.5m
22m
68m
25.2m
32.1m
9.8m
15m

5.0s (1.8s, 0.21s)
3.5s (0.5s, 0.20s)
13.3s (4.0s, 0.62s)
23.9s (4.0s, 1.32s)
22.8s (9.9s, 0.86s)
24.4s (9.9s, 0.97s)
6.3s (3.2s, 0.21s)
7.0s (3.2s, 0.25s)

samba
crane
swing

9971
10002
9971

175
175
175

30
40
30

8.6 (3.6)
6 (2.8)
8.8 (3.5)

11.4 (6)
5.9 (4.5)
26 (16)

1.5
1.4
1.6

4
3.6
4.2

0.2
0.2
0.3

10.3m
12.6m
10.6m

20.2m
20.6m
18.7m

15.8s (4.2s, 0.77s)
21.7s (5.6s, 1.08s)
18.6s (5.0s, 0.91s)

horse
camel
elephant

8431
21887
42321

48
48
48

30
23
25

2.3 (0.3)
3.1 (0.5)
2.6 (0.5)

4.9 (2.9)
4.7 (2.2)
15 (6.5)

1.3
1.4
1.4

2.4
2.8
2.3

2E-5
2E-4
6E-5

2.7m
16.4m
26.3m

6m
7.5m
20.1m

4.3s (0.4s, 0.26s)
11.3s (1.0s, 0.69s)
21.9s (1.9s, 1.34s)

Table 2: Results for Skinning Mesh Animations (SMA), Skinning Arbitrary Deformations (SAD), Our method, Clustered PCA
and truncated SVD. With SMA and SAD we report also approximation error after rank-10 EigenSkin corrections (in brackets).
Note that the time for SMA and SAD (without EigenSkin) is measured in minutes and the time for our method in seconds (with
a breakdown to initialization and iteration time in brackets).
second (see Table 2), which enables almost interactive previewing of the optimization process. Note that the initialization needs to be done only once regardless of P, and therefore, manual selection of the number of bones is quite comfortable. If a fully automatic pipeline is required, we can
find the optimal P for a given global error threshold (e.g.,
ERMS = 1.5) using binary or interpolation search at the cost
of running the optimization multiple times.

swing
horse
skirt50

2.5

Clustered PCA

Our method

Original

Figure 7: In contrast to skinning computed with our method,
clustered PCA may result in non-smooth reconstruction
(cloak10 dataset).
time reported for SMA is only the time of mean-shift clustering computed using the publicly available implementation [GSM03]. In the case of SAD, the execution time is
dominated by the LSQR solver [PS82]. The total running
time of our method is the sum of the initialization time (Section 3) plus the time for 15 iterations of coordinate descent
(Section 4). From Table 2 we can see that our algorithm runs
about one to two orders of magnitude faster than SMA and
SAD.
To examine the convergence of our iterative optimization
process (Section 4), we measured ERMS after each iteration,
see Figure 8. We can see that the error quickly approaches
its optimal value regardless of the animation type—in our
implementation we therefore terminate the optimization after 15 iterations. Each iteration takes typically less than 1

2

1.5

1
1

5

10

15

20

25

30

Figure 8: Approximation error ERMS (vertical axis) vs. number of iterations of our optimization process (horizontal
axis).
5.1. Applications
The main advantages of skinning are compact animation
representation combined with efficient hardware accelerated
rendering. For example, in applications featuring large numbers of characters with limited motion styles (such as pedestrian crowds), we can precompute physically based cloth anc 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

335

L. Kavan, P.-P. Sloan & C. O’Sullivan / Fast and Efficient Skinning of Animated Meshes

imations for the given set of skeletal motions (perhaps organized in a motion graph) and use our method to create their
skinned approximations, which can be trivially exported to
any 3D engine that supports linear blend skinning. This enables us to enhance fidelity of virtual characters with minimal computational and implementation costs, see Figure 9.
Many other applications of skinning decomposition were
discussed in the literature, ranging from rest pose editing
and efficient collision detection [JT05, KMD∗ 07] (including the recently proposed technique for self-collision detection [SGO09]) to advanced non-linear deformation systems [WPP07] and animation interfaces [FKY08].

7. Acknowledgements
We would like to thank the anonymous reviewers and our
colleagues, Martin Pražák, Daniel Sýkora, Rachel McDonnell and Simon Dobbyn, for their insightful comments and
suggestions. We are also indebted to Peter Lozsek for creating the characters and cloth animation (see Figure 9). We
thank Doug James for the flag animation [JT05], Robert
Sumner and Jovan Popovi´c for the clothHorse, horse, camel
and elephant datasets [SP04] and Daniel Vlasic and his colleagues for the samba, swing and crane mesh sequences
[VBMP08]. The elasticCow animation was obtained from
the geometry videos project [BSM∗ 03]. This work was supported by Science Foundation Ireland (project Metropolis).
Appendix
Lemma: Let L be a compact convex set and S a three dimensional linear subspace such that L ⊆ S ⊆ Rd . Let y be
an arbitrary point from Rd and let yS ∈ Rd be its orthogonal
projection on the subspace S. Then point m ∈ L minimizes
y − m if and only if m minimizes yS − m .
Proof: Let b1 , b2 , b3 ∈ Rd be an orthonormal basis of S and
let b4 , . . ., bd ∈ Rd be its orthonormal complement to the basis of Rd . Therefore, y = ∑di=1 βi bi for βi ∈ R and its orthogonal projection on S is simply yS = β1 b1 + β2 b2 + β3 b3 .
Similarly, any m ∈ L can be written as m = µ1 b1 + µ2 b2 +
µ3 b3 for some µi ∈ R. Therefore,
y −m

Figure 9: Application of our method in practice: both the
bodies and the cloth are rendered with linear blend skinning
(skirt50 and cloak35 datasets).

6. Conclusions and Future Work
We present an algorithm to quickly construct high quality skinned approximations of arbitrary mesh animations,
demonstrating that even complex highly deformable animations can be skinned efficiently without any corrective techniques or excessive pre-processing. We believe that these
features will make our method appealing for applications,
such as in games development.
There are several possible avenues for future work. If
higher pre-computation speeds were required, we could implement our algorithms on parallel computing architectures
such as CUDA, taking advantage of easily parallelizable matrix computations. One limitation of skinning is that it only
addresses spatial coherence. For longer (or finely sampled)
animation sequences, it may be desirable to tackle temporal coherence also using methods such as in [Ari06]. From a
broader perspective, skinning can be considered as a special
kind of sparse matrix decomposition and does not have to be
limited to mesh animation—one could, for example, “skin”
ambient occlusion or precomputed radiance transfer.
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

2

3

d

=

∑i=1 (βi − µi )bi + ∑i=4 βi bi

=

∑i=1 (βi − µi )bi

=

yS − m

3

2

2

2

+ ∑di=4 βi bi

2

+ ∑di=4 β2i

where we used the fact that b1 , . . ., bd ∈ Rd are orthonormal.
Since the term ∑di=4 β2i is fixed (it is determined solely by y
2
and S), it follows that y − m
is minimized if and only if
2

yS − m
is minimized (and the same applies after taking
their square roots).
✷
References
[ABB∗ 99] A NDERSON E., BAI Z., B ISCHOF C., B LACKFORD
S., D EMMEL J., D ONGARRA J., D U C ROZ J., G REENBAUM
A., H AMMARLING S., M C K ENNEY A., S ORENSEN D.: LAPACK Users’ Guide, third ed. Society for Industrial and Applied
Mathematics, Philadelphia, PA, 1999.
[AM00] A LEXA M., M ÜLLER W.: Representing animations by
principal components. Comput. Graph. Forum 19, 3 (2000), 411–
418.
[Ari06] A RIKAN O.: Compression of motion capture databases.
ACM Trans. Graph. 25, 3 (2006), 890–897.
[BP07] BARAN I., P OPOVI C´ J.: Automatic rigging and animation
of 3D characters. ACM Trans. Graph. 26, 3 (2007), 72.
[BSM∗ 03] B RICE NO H. M., S ANDER P. V., M C M ILLAN L.,
G ORTLER S., H OPPE H.: Geometry videos: a new representation for 3D animations. SCA ’03: Proceedings of the 2003

336

L. Kavan, P.-P. Sloan & C. O’Sullivan / Fast and Efficient Skinning of Animated Meshes

ACM SIGGRAPH/Eurographics symposium on Computer animation (2003), 136–146.

[LH74] L AWSON C. L., H ANSON R. J.: Solving Least Squares
Problems. Prentice Hall, Englewood Cliffs, NJ, 1974.

[dATTS08] DE A GUIAR E., T HEOBALT C., T HRUN S., S EIDEL
H.-P.: Automatic Conversion of Mesh Animations into Skeletonbased Animations. Computer Graphics Forum (Proc. Eurographics EG’08) 27, 2 (4 2008), 389–397.

[LS09] L ANDRENEAU E., S CHAEFER S.: Poisson-based weight
reduction of animated meshes. Computer Graphics Forum 28
(2009), to appear.

[Eri04] E RICSON C.: Real-Time Collision Detection. Morgan
Kaufmann Publishers Inc., 2004.
[FKY08] F ENG W.-W., K IM B.-U., Y U Y.: Real-time data
driven deformation using kernel canonical correlation analysis.
In SIGGRAPH ’08: ACM SIGGRAPH 2008 papers (New York,
NY, USA, 2008), ACM, pp. 91:1–91:9.
[GB08] G AIN J., B ECHMANN D.: A survey of spatial deformation from a user-centered perspective. ACM Trans. Graph. 27, 4
(2008), 107:1–107:21.
[GK04] G USKOV I., K HODAKOVSKY A.: Wavelet compression
of parametrically coherent mesh sequences. In SCA ’04: Proceedings of the 2004 ACM SIGGRAPH/Eurographics symposium
on Computer animation (New York, NY, USA, 2004), ACM
Press, pp. 183–192.
[GL96] G OLUB G., L OAN C. F. V.: Matrix Computations,
third ed. John Hopkins University Press, Baltimore, 1996.
[GLRvdE05]

G IRAUD L., L ANGOU J., ROZLOŽNÍK M.,
VAN DEN E SHOF J.: Rounding error analysis of the classical
Gram-Schmidt orthogonalization process. Numerische Mathematik 101 (2005), 87–100.

[GSM03] G EORGESCU B., S HIMSHONI I., M EER P.: Mean shift
based clustering in high dimensions: a texture classification example. In Computer Vision, 2003. Proceedings. Ninth IEEE International Conference on (2003), pp. 456–463 vol.1.
[JF03] JAMES D., FATAHALIAN K.: Precomputing interactive
dynamic deformable scenes. Technical report CMU-RI-TR-0333, Carnegie Mellon University, 2003.
[JT05] JAMES D. L., T WIGG C. D.: Skinning mesh animations.
ACM Trans. Graph. 24, 3 (2005), 399–407.
[KCO09] K AVAN L., C OLLINS S., O’S ULLIVAN C.: Automatic linearization of nonlinear skinning. In Proceedings of the
2009 symposium on Interactive 3D graphics and games (February/March 2009), ACM Press, pp. 49–56.
[KCŽO08] K AVAN L., C OLLINS S., Ž ÁRA J., O’S ULLIVAN C.:
Geometric skinning with approximate dual quaternion blending.
ACM Trans. Graph. 27, 4 (2008), 105:1–105:23.
[KG04] K ARNI Z., G OTSMAN C.: Compression of soft-body animation sequences. Computers & Graphics 28, 1 (2004), 25–34.
[KG05] K IRCHER S., G ARLAND M.: Progressive multiresolution meshes for deforming surfaces. In SCA ’05: Proceedings of the 2005 ACM SIGGRAPH/Eurographics symposium on
Computer animation (New York, NY, USA, 2005), ACM Press,
pp. 191–200.
[KJP02] K RY P. G., JAMES D. L., PAI D. K.: EigenSkin: real
time large deformation character skinning in hardware. In Proceedings of the 2002 ACM SIGGRAPH/Eurographics symposium
on Computer animation (2002), ACM Press, pp. 153–159.
[KMD∗ 07] K AVAN L., M C D ONNELL R., D OBBYN S., Ž ÁRA
J., O’S ULLIVAN C.: Skinning arbitrary deformations. In Proceedings of the 2007 symposium on Interactive 3D graphics and
games (April/May 2007), ACM Press, pp. 53–60.
[Lee07] L EE M.: Seven ways to skin a mesh: Character skinning
revisited for modern GPUs. In Gamefest Unplugged (Europe)
(2007).

[Mar06] M ARTIN S.: An approximate version of kernel PCA.
In ICMLA ’06: Proceedings of the 5th International Conference
on Machine Learning and Applications (Washington, DC, USA,
2006), IEEE Computer Society, pp. 239–244.
[MG03] M OHR A., G LEICHER M.: Building efficient, accurate
character skins from examples. ACM Trans. Graph. 22, 3 (2003),
562–568.
[MMG06a] M ERRY B., M ARAIS P., G AIN J.: Animation space:
A truly linear framework for character animation. ACM Trans.
Graph. 25, 4 (2006), 1400–1423.
[MMG06b] M ERRY B., M ARAIS P., G AIN J.: Normal transformations for articulated models. In SIGGRAPH ’06: ACM
SIGGRAPH 2006 sketches (New York, NY, USA, 2006), ACM,
p. 134.
[PC98] PARTRIDGE M., C ALVO R.: Fast dimensionality reduction and simple PCA. Intelligent Data Analysis 2, 1 (1998), 203–
214.
[PS82] PAIGE C. C., S AUNDERS M. A.: Algorithm 583: LSQR:
Sparse linear equations and least squares problems. ACM Trans.
Math. Softw. 8, 2 (1982), 195–209.
[RK09] RUITERS R., K LEIN R.: BTF compression via sparse
tensor decomposition. Computer Graphics Forum 28, 4 (July
2009), 1181–1188.
[SGO09] S CHVARTZMAN S. C., G ASCÓN J., O TADUY M. A.:
Bounded normal trees for reduced deformations of triangulated surfaces. In SCA ’09: Proceedings of the 2009 ACM
SIGGRAPH/Eurographics Symposium on Computer Animation
(New York, NY, USA, 2009), ACM, pp. 75–82.
[Sha08] S HAMIR A.: A survey on mesh segmentation techniques.
Computer Graphics Forum 27, 6 (2008), 1539–1556.
[SP04] S UMNER R. W., P OPOVI C´ J.: Deformation transfer for
triangle meshes. ACM Trans. Graph. 23, 3 (2004), 399–405.
[SSK05] S ATTLER M., S ARLETTE R., K LEIN R.: Simple and
efficient compression of animation sequences. In SCA ’05: Proceedings of the 2005 ACM SIGGRAPH/Eurographics symposium
on Computer animation (New York, NY, USA, 2005), ACM
Press, pp. 209–217.
[SY07] S CHAEFER S., Y UKSEL C.: Example-based skeleton
extraction. In SGP ’07: Proceedings of the fifth Eurographics
symposium on Geometry processing (Aire-la-Ville, Switzerland,
Switzerland, 2007), Eurographics Association, pp. 153–162.
[Váš08] V ÁŠA L.: Methods for size reduction of dynamic meshes.
PhD thesis, University of West Bohemia, 2008.
[VBMP08] V LASIC D., BARAN I., M ATUSIK W., P OPOVI C´ J.:
Articulated mesh animation from multi-view silhouettes. ACM
Transactions on Graphics 27, 3 (2008), 97:1–97:9.
[WP02] WANG X. C., P HILLIPS C.: Multi-weight enveloping:
least-squares approximation techniques for skin animation. In
Proceedings of the 2002 ACM SIGGRAPH/Eurographics symposium on Computer animation (2002), ACM Press, pp. 129–138.
[WPP07] WANG R. Y., P ULLI K., P OPOVI C´ J.: Real-time enveloping with rotational regression. ACM Trans. Graph. 26, 3
(2007), 73:1–73:9.
[WTH09] W ITTEN D. M., T IBSHIRANI R., H ASTIE T.: A penalized matrix decomposition, with applications to sparse principal components and canonical correlation analysis. Biostat 10, 3
(July 2009), 515–534.

c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.


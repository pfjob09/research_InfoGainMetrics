DOI: 10.1111/j.1467-8659.2010.01663.x

COMPUTER GRAPHICS

forum

Volume 29 (2010), number 6 pp. 1969–1980

Resampling Strategies for Deforming MLS Surfaces
Jo˜ao Paulo Gois1 and Gustavo C. Buscaglia2

2 Instituto

1 Universidade Federal do ABC, Santo Andr´
e, Brazil
de Ciˆencias Matem´aticas e de Computac¸a˜ o, Universidade de S˜ao Paulo, S˜ao Carlos, Brazil

Abstract
Moving-least-squares (MLS) surfaces undergoing large deformations need periodic regeneration of the point set
(point-set resampling) so as to keep the point-set density quasi-uniform. Previous work by the authors dealt with
algebraic MLS surfaces, and proposed a resampling strategy based on defining the new points at the intersections
of the MLS surface with a suitable set of rays. That strategy has very low memory requirements and is easy to
parallelize. In this article new resampling strategies with reduced CPU-time cost are explored. The basic idea
is to choose as set of rays the lines of a regular, Cartesian grid, and to fully exploit this grid: as data structure
for search queries, as spatial structure for traversing the surface in a continuation-like algorithm, and also as
approximation grid for an interpolated version of the MLS surface. It is shown that in this way a very simple
and compact resampling technique is obtained, which cuts the resampling cost by half with affordable memory
requirements.
Keywords: MLS surfaces, point-set resampling, front tracking, MLS surfaces deformations
ACM CCS: I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling—Curve, surface, solid,
and object representations; I.6.8 [Computer Graphics]: Types of Simulation—Animation

1. Introduction
Computer graphics specialists often need to deal with surfaces undergoing large deformations. An example is the surface of a running animal or of a fluid evolving in time, or
the shape of an object being interactively changed by the
designer.
If the surface representation is mesh-based, the mesh vertices are moved according to the specified deformation and
the deformed surface is interpolated using the connectivity
structure. Along the evolution the mesh may become too
distorted (Figure 1) to ensure good representation of the surface, requiring the generation of a new mesh. This involves,
in particular, the generation of a new set of vertices, which
are obtained by suitably sampling the surface. Hereafter this
operation will be referred to as resampling, since the initial and final point densities are not very different and the
goal is to obtain a better distribution of the points. More
classical in the computer graphics literature is the case of
static surfaces, on which most common operations are upsampling, mainly used for rendering purposes [ABCO∗ 03],
c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and
Blackwell Publishing Ltd. Published by Blackwell Publishing,
9600 Garsington Road, Oxford OX4 2DQ, UK and 350 Main
Street, Malden, MA 02148, USA.

and downsampling, mainly used in model simplification
[PGK02].
Recently, point-based representations of surfaces have
been the focus of increased attention [GGG08, GNNB08,
GPJE∗ 08]. Again, the natural way to deform a point-based
surface is to move the point set according to the specified
deformation, and thus resampling is necessary to ensure that
the density of points remains quasi-uniform and guarantee a
good representation [WSS08, AK04].
In this article we address a specific family of point-based
surfaces, namely moving-least-squares (MLS) surfaces. The
redistribution of the point set has been addressed previously
using particle simulation procedures [PGK02] and smoothing techniques (coupled with iterative refinement [GBP05]),
but these procedures are regarded as too costly [GGG08].
More efficient alternatives that have been developed for
rendering purposes [ABCO∗ 03, GBMP04, GGG08] are not
well-suited for surfaces undergoing deformation, since they
are focused on upsampling and do not target a quasi-uniform
distribution over the surface.

1969

1970

J. P. Gois & G. C. Buscaglia / Resampling MLS Surfaces

Our purpose here is to explore variants of the LDC resampling strategy that are both simpler and more computationally effective, and as a by-product to study the behaviour of
resampled MLS surfaces in non-fluid-inspired cases. Specifically, robustness is assessed by severely deforming geometrical shapes with the method proposed by Schaefer et al.
[SMW06].

Figure 1: Evolution of vertices in the upper hemisphere:
Along the evolution, a mesh-based surface may become to
distorted (top), whereas considering the point-based MLS
definition (Sec. 2), the surface remains satisfactorily reconstructed (bottom).

Another possibility that has only recently been exploited
for MLS surfaces is to resample the surface by intersecting
it with a suitably chosen set of rays. A simple and usually
effective choice is to take the set of rays as the lines of a
regular, Cartesian grid, which leads to a layered depth cube
or LDC [PZvBG00]. An interesting variant is an octree-based
voxelization of the model, followed by the detection of one
intersection per voxel [NS04]. None of these techniques has
been studied in the context of MLS surfaces.
Surfaces that evolve (in time, for example) undergoing
large deformations pose some specific challenges. Each time
the surface is resampled, subtle changes in the surface geometry take place. These changes depend on the specific
representation chosen and in principle accumulate along the
deformation process. It is thus not obvious how any given resampling algorithm with behave when applied to a deforming
MLS surface. Recently, Gois et al. [GNNB08] studied timeevolving MLS surfaces as applied to tracking of fluid–fluid
interfaces, and tested them in well-accepted benchmarks.
They introduced a variant of the algebraic MLS surfaces of
Guennebaud and Gross [GG07], which is less prone to visual
artefacts and is free of user-specified parameters (these improvements have been also, and independently, proposed by
Guennebaud et al. [GGG08]). In what concerns resampling,
Gois et al. adopted an LDC strategy, but no use whatsoever
was made of the background Cartesian grid to accelerate
the algorithm. This had the advantages of minimizing the
memory requirements and making parallelization easy, at
the expense of not optimizing the CPU time cost.

After briefly recalling the specific version of MLS surfaces adopted in the article in Section 2, the proposed resampling algorithm is detailed in Section 3. The basic idea is to
fully exploit the background Cartesian grid that is implicit
in the LDC strategy: We use it as data structure for search
queries and as spatial structure for traversing the surface in a
continuation-like algorithm [Blo94]. We eliminate the need
of kd-trees, ray-spheres intersections and other geometrical
calculations needed in the ray-tracing version of the algorithm. Further, exploiting the grid structure and the proposed
traversing method, we are able to inhibit the creation of point
clusters, thus avoiding to detect and remove them. This results in a simple and compact resampling technique, which
cuts the cost by half with respect to the ray-tracing algorithm,
keeping the memory requirements affordable.
No novelty is introduced in the handling of the deformation, which is briefly described in Section 4 for completeness.
Section 5 reports several qualitative and quantitative tests.
Another version is also introduced in that section, based on
the interpolation of the implicit MLS function, which further
reduces the CPU time cost though with significant loss in
accuracy. Conclusions are drawn in Section 6.

2. MLS Surface Definitions
Let P = {p1 , . . . , pm } be a set of quasi-uniformlyspaced points, and let {qk }(k = 1, . . . , 5) be the so-called
algebraic–sphere polynomial basis (i.e.; q1 (x) = 1, q2 (x) =
x1 , q3 (x) = x2 , q4 (x) = x3 , q5 (x) = x12 + x22 + x32 ). We introduce the function
5

f (α, x) =

αk qk (x),

(1)

k=1

where α = (α1 , . . . , α5 ) ∈ R5 . The Algebraic-MovingLeast-Squares (AMLS) Surface S is defined as the zero-set
of the (implicit) function
F (x) = f (γ (x), x),

(2)

where γ (x) = (γ1 (x), . . . , γ5 (x)) is obtained as follows:
Let us consider a continuous non-negative localization
function:
ψ(s) =

(1 − s 2 )4

if s < 1

0

otherwise

,

(3)

c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

1971

J. P. Gois & G. C. Buscaglia / Resampling MLS Surfaces

and an influence radius . A set of weight functions is defined
as wi (x) = ψ( x−pi ). The following two-steps complete the
definition:
Step 1: For each pi ∈ P, compute the pseudo-normal vectors Ni as the normal to the best-fit sphere at pi .
Let
Q = α ∈ R5 : ∇x f (α, x) = 1 ∀xs.t.f (α, x) = 0
= α ∈ R5 : α22 + α32 + α42 − 4α1 α5 = 1

For each point pi ∈ P, compute α (i) ∈ Q by solving
the constrained minimization problem
m

α (i) = arg min
β∈Q

wj (pi )|f (β, pj )|2 ,

(5)

j =1

which reduces to a generalized eigenvalue problem
in R5 [GNNB08, GG07]. The pseudo-normal Ni at
pi is given by
Ni = ∇x f (α (i) , pi )/ ∇x f α (i) , pi

.

(6)

Step 2: Computing the AMLS surface S(P). It only remains
to compute γ (x) for all x, which is done by solving
the unconstrained minimization problem:
m

γ (x) = lim arg min

β ∈ R5

K→∞

wi (x)|f (β, (pi ))|2
i=1

m

+ K

wi (x) ∇x f (β, pi ) − Ni

(a)

(b)

(4)

2

. (7)

i=1

Notice the elimination of the tunable parameter K by taking the limit K → ∞. All necessary details can be found in
[GNNB08].

3. Point-set Resampling
As previously stated, the resampling technique consists of
defining the new points at the intersections of S(P) with
a Cartesian grid of spacing h. Typically h is taken as the
average spacing of the point set P. The details of the proposed
implementation are as explained later.

3.1 Storing and querying points
The underlying grid automatically defines a simple hashing
operator H : pm ∈ P → H(pm ) = (i, j , k), as depicted in
Figure 2. Since more than one point can be mapped to the
same grid vertex, chaining by linked lists is applied. The
name of the corresponding method is Hash().
A neighbor-query of a point pm , mapped to H(pm ) =
(i, j , k) consists of finding all points p ∈ P such that
w (pm ) = 0. These points are efficiently computed as the

Figure 2: Two-dimensional case of hashing operator H. (a)
Resample(): new points are created on pair of black edges.
These ‘L’-shapes are traversed from bottom to top and from
left to right. (b) Update Function(): red vertices are those
where MLS function is stored, to save processing time.

image, by the inverse mapping H−1 , of the neighbouring vertices [i − d, i + d) × [j − d, j + d) × [k − d, k +
d), where d is an integer such that d h > . In general, we
choose d = 3.
There are three methods which require neighbour-queries:
The method Update Normals(), which computes pseudonormals for each point in P (as described in Section 2); the
method Update Function(), which computes the values of
F at grid vertices in a neighbourhood of P (this neighbourhood is described in Figure 2(b), it consists of 12 vertices in
2D and of 44 in 3D); finally, the method Resample(), which
creates new points on grid edges. This last method is detailed
in the next section.
3.2 Continuation-like point creation
The intersections of the grid lines with the surface are computed by traversing the edges of the underlying grid in a
continuation-like way but, instead of creating polygons, as
done by Bloomenthal [Blo94], just the points are created,
making the case table unnecessary. The algorithm for the
two-dimensional case reads:

Algorithm 1 Method Resample()
1:
2:
3:
4:
5:
6:
7:
8:

for each point p ∈ P do
(I , J ) = H(p)
for each grid vertex (i, j )∈ [I − 1, I + 3) × [J − 1, J +
3) do
if (i, j ) is not VISITED then
Set (i, j ) as VISITED
if MLS surface S(P) crosses edge
((i, j )(i + 1, j )) then
Compute q as intersection between S(P) and
((i, j )(i + 1, j ))
s = H(q)

c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

1972

J. P. Gois & G. C. Buscaglia / Resampling MLS Surfaces

Algorithm 1 Method Resample() (Continued )
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:

if s − (i, j ) < s − (i + 1, j ) then
ri = i
else
ri = i + 1
end if
if (ri, j ) does not HAVECLOSEPOINT then
Insert q in the new list of points
Set (ri, j ) as HAVECLOSEPOINT
end if
end if
if S(P) crosses edge ((i, j )(i, j + 1)) then
Proceed as previously, but considering the
edge (i, j )(i, j + 1)
end if
end if
end for
end for

Above, we denote by ((i, j )(i + 1, j )) the edge with vertices (i, j ) and (i + 1, j ). Figure 2(a) depicts those edges
that are traversed from a point p. These edges are organized as a set of pairs sharing a common vertex; that is the
‘L’-shapes shown in black in the figure. These L-shapes are
traversed from bottom to top and from left to right, but since
several points can share the same grid vertex (i, j ) as neighbor, the flag VISITED is assigned to (i, j ) to preclude the
same L-shape to be analyzed more than once. Also, the flag
HAVECLOSEPOINT is used to avoid creating points very close
from one another, thus eliminating the need of removing
point clusters. The 3D algorithm is analogous.
Pfister et al. [PZvBG00] had proposed a quite different
acceleration of the LDC strategy. They noticed that a subset
of rays (those aligned with just one of the coordinate directions) is sufficient in most parts of the surface. This 3-to-1
reduction (2-to-1 in 2D) significantly reduces the computational burden. A similar acceleration is accomplished by our
algorithm. In fact, notice that of the six (four in 2D) half
edges that converge to a grid vertex, only one intersection is
stored (since once one is stored the vertex is tagged as having
a close point). Our procedure is more general than the 3-to-1
reduction in that it does not need to be applied locally in
regions in which the surface does not exhibit folds.
4. MLS Surfaces under Deformations
Let P0 be the initial point set and let S be the operator that,
for any point set, assigns the AMLS surface defined by it.
We thus have an initial surface S0 = S(P0 ).
Our aim is to deform the surface S0 according to some
known deformation history ϕs→t : Rn → Rn , continuous
with respect to the parameters s and t, which can be thought
of as initial and final instants of time. To be precise, a point

x ∈ Rn , as it deforms from time s to time t, goes from x
to ϕs→t (x). The deformed surface St is, in terms of ϕs→t ,
defined as
St = ϕ0→t (S0 ).

(8)

Though St is well-defined by (8), it is not feasible to compute it from its definition (one should map each and every
x ∈ S0 !). Instead, the initial point set is mapped to its deformed position, Pt = ϕ0→t (P0 ), and used to define an approximation of St by
S˜t = S(Pt ) = S (ϕ0→t (P0 )) .

(9)

The surface S˜t is only approximate because the operators S
and ϕ0→t do not commute. The approximation worsens as the
point set Pt deforms and becomes unevenly distributed. The
basic idea to tackle this difficulty is to periodically replace
the point set Pt with a new point set obtained by resampling
the surface S(Pt ).
To clarify ideas, let R be the resampling operator defined
in Section 3. Notice that the deformation history from 0 to t
can be split, for some 0 < τ < t, as
ϕ0→t (x) = ϕτ →t (ϕ0→τ (x)) .

(10)

We can thus define a new approximation of St , in which
the point set is deformed from 0 to τ , then the surface is
resampled, and the new point set is deformed from τ to t. In
terms of the operators defined above this reads
S˜ t = S (ϕτ →t (R (S(ϕ0→τ (P0 ))))) .

(11)

This can be performed periodically with step τ , leading to
the following algorithm:
for each deformation ϕmτ →(m+1)τ (m = 1, 2, . . .) do
Update Normals()
Update Function()
Resample()
Deform Points()
Hash()
end for
5. Results
We first examine the improvements brought by the proposed
resampling strategy to the modelling of curves and surfaces
under large deformations. The first example consists of deforming a circle of unit radius into a four-leaf clover. The
deformation consists of several steps, as shown in Figure 3,
and is defined by repositioning the control points (as shown
in the figure) using the method proposed by Schaefer et al.
[SMW06]. Figure 4 shows the evolution of the MLS curve
defined by applying the deformation to a point set consisting
of 250 evenly spaced points on the initial circle (shown in
black). Notice that, because of our choice of polynomial basis, the initial MLS curve exactly coincides with the circle.

c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

J. P. Gois & G. C. Buscaglia / Resampling MLS Surfaces

1973

Figure 3: Reference deformations transforming a circle into a four-leaf clover. The deformation is defined by the control points
(in blue if not moved, in green if moved). To compute this reference deformation 5000 markers were put in the initial circle and
their positions were tracked.

Figure 4: Deforming a circle into a four-leaf clover, with a deformation defined by the control points (in blue and green as in
Figure 3). MLS curve (without resampling) corresponding to the deformed point set.
c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

1974

J. P. Gois & G. C. Buscaglia / Resampling MLS Surfaces

(a)

(b)

(c)

(d)

(e)

(f)

Figure 5: Deforming a circle into a four-leaf clover, with a deformation defined by the control points (in blue and green as in
Figure 3). Same as Figure 4, but with resampling turned on (120 resampling operations between initial and final shapes).
If no resampling is applied and = 0.0075 is kept fixed,
the MLS curve associated to the deformed point set is only
well defined until the stage shown in the third graph of Figure 4. After that stage, the points on the stem are too far
apart (fourth graph) and the MLS curve breaks down. One
can nevertheless go on deforming the point set so as to take it
to the final deformed position. In the sixth graph of Figure 4
we show the final point set and the pseudo-normals obtained
with the Update Normals() method. Their illogical magni-

tudes and orientations are clear evidences of the breakdown
of the MLS curve.
In Figure 5, on the other hand, we show the results obtained with the resampling algorithm, using a grid that keeps
the distance between points close to the initial one. In this
case, the MLS curve remains well defined throughout the deformation, and the final curve is a good approximation of the
exact final shape (compare to the rightmost graph in part (a)

c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

J. P. Gois & G. C. Buscaglia / Resampling MLS Surfaces

1975

Figure 6: Three-dimensional example. The sequence corresponds to the same deformation of Figure 5, here applied to a
sphere.
of the figure). The pseudo-normals are also plotted, showing
that they are consistent with the deformed curve.
We also examined the ability of the proposed algorithm to
model three-dimensional deformations. In Figure 6 and 7 we
show two representative examples, both of them using a 2503
grid. Figure 6 corresponds to exactly the same deformation
as above, but now applied to a sphere. The point set contains
10,000 points initially, and ends up with 18,000 points, which
is a quite small quantity for modelling complex 3D shapes.
Figure 7 corresponds to a model of Homer Simpson, which
is deformed so as to render it ‘elf-like’. The initial point
set has 48,000 points, which reduces to 20,000 points in the
last stage. Both examples show that the resampling algorithm
allows us to accomplish severe deformations without any user
intervention, and without the appearance of visual artefacts.
Having shown the beneficial effects of resampling on the
modelling of deformations of point-set surfaces, let us now
turn to a quantitative assessment of the newly-developed,
continuation-like algorithm. For this purpose, we consider
the single vortex flow test already considered in the previous
article [GNNB08]. The initial geometry is a circle centered at
(0.5,0.75) with radius r = 0.15 inside a square unit domain.
The deformation is defined by its associated velocity field
(v(x, t) = ∂s ϕt→t+s (x)|s=0 )
v(x1 , x2 , t) = T (t) sin2 (π x1 ) sin(π x2 ) cos(π x2 ),
sin(π x1 ) cos(π x1 ) sin2 (π x2 )

(12)

where T (t) = 2 cos(π 8t ). At t = 8 the exact surface St coincides with the initial circle S0 , as illustrated in Figure 8.
We resample the surface every 0.01 time units, leading to

a total of 800 resampling operations. The continuation-like
algorithm is compared to the ray-tracing algorithm, which
as discussed earlier is the standard LDC strategy without
any acceleration. The results are reported in Table 1. The
total time (in seconds) for a single processor of a QuadCore
3.0 GHz is 96.57 (5122 grid) and 48.73 (2562 grid) for the
original ray-tracing algorithm. These CPU times are reduced
by 60% with the continuation-like algorithm, to 39.95 and
20.69, respectively. Most of the time of the ray-tracing algorithm (85%) is spent in calculating the intersections to
get the new point set. In the new algorithm, this is accomplished by calculating the values of the implicit function at
the vertices (Update Function in the table) so as to detect
edges in which change of sign occurs, together with the resampling step that computes the actual intersections. These
two steps of the new algorithm take 57% of the CPU time,
and in them concentrates most of the gain with respect to the
ray-tracing algorithm, with a reduction from 70.5 seconds to
22.6 seconds on the 5122 grid. Some gain is also obtained
in the step of calculating the pseudo-normals, coming from
the convenience of the hashing technique based on the background grid with respect to the general kd-tree used in the
ray-tracing version. Finally, the convenience of inhibiting the
creation of points that are too close, as proposed in method
Resample(), leads to additional CPU-time savings, since
less points are deformed and no need of removing excess
points is needed. This saves about 4 seconds on the 5122
grid. Notice that in this case, being 2D, the reduction proposed by Pfister et al. [PZvBG00] would lead to at most 50%
reduction. Our acceleration method, which can be applied
globally without partitioning the surface into blocks, is thus
competitive.

c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

1976

J. P. Gois & G. C. Buscaglia / Resampling MLS Surfaces

Figure 7: Three-dimensional example. The sequence corresponds to the deformation of Homer Simpson into an elf-like creature.

Figure 8: Scheme of single vortex flow deformation at t = 0 (initial), 2, 4 (maximum torsion), 6 and 8 (final curve) time units.
Results of the proposed method corresponding to 5122 -grid.

c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

1977

J. P. Gois & G. C. Buscaglia / Resampling MLS Surfaces
Table 1: CPU time of ray-tracing (original) and continuation-like
(proposed) algorithms for the single vortex flow test.

Original

512

Method
Deform
Remove
Rebuild Tree
Intersections
Comp. Normals
Total

Sec
4.59
1.04
0.19
70.51
20.24
96.57

Proposed

512

Method
Deform
Update Function
Resample
Hash
Comp. Normals
Total

Sec
1.80
6.55
16.11
0.48
15.01
39.95

Table 2: Single vortex flow test: Errors obtained with the proposed
technique and with its interpolated version, as compared to those of
the original ray-tracing technique.

256
%
2.55
0.58
0.11
85.52
11.25
100.00

Sec
2.35
0.53
0.07
35.9
9.88
48.73

%
2.55
0.58
0.08
86.05
10.74
100.00

Grid

Original

Proposed

Interpolated

128
256
512
1024

0.00730
0.00107
0.00015
NC

0.00643
0.00102
0.00015
0.00003

F
0.02326
0.00573
0.00138

Note: NC denotes that the error was not computed and F denotes that
the MLS surface failed.

256
%
4.51
16.40
40.33
1.20
37.57
100.00

Sec
1.12
3.20
8.86
0.17
7.34
20.69

%
5.41
15.47
42.82
0.82
35.48
100.00

We believe the performances of Table 1 to be quite satisfactory, since they tell us essentially that a relatively complex
2D shape of about 1,000 points can be resampled in just
24 milliseconds. Similar tests in 3D yield an estimate of
about 15 seconds for a complex 3D shape defined by 50,000
points with memory footprint of 4.5 GB on 5123 grid.
It is possible to further reduce the CPU-time by not computing the intersection exactly. Instead, the new points can be
created at those edges where the implicit function changes
sign by linearly interpolating the values at the grid points.
This leads to a redefinition of the AMLS surface, reducing
its accuracy (as will be shown later), but reduces the total
time to just 24 seconds in the 5122 grid. This means just
15 milliseconds to resample a 2D curve of 1,000 points.
It is however essential to numerically assess the accuracy
both of the new algorithm and of its interpolated variant.
As discussed above, the continuation-like algorithm does
not generate exactly the same points as the ray-tracing one,
implying that the approximate deformed surfaces they generate are not coincident. Further, the interpolated version of
the proposed algorithm explicitly modifies the MLS surface
by redefining it as the zero level-set of the interpolant of
the implicit function. To quantify the difference between the
different approximations, we measure the error of the final
shape S˜ t=8 with respect to the exact one S0 (i.e. the unit circle). This error is defined as the area between S˜ t=8 and S0
(this is denoted by L1 -error by Gois et al. [GNNB08] and
other authors).
Table 2 reports the errors obtained with the new algorithm, both in its non-interpolated and interpolated versions,

together with those obtained with the original ray-tracing algorithm. The comparison is made for meshes ranging from
1282 to 10242 . It is observed that the new algorithm does
not exhibit any significant loss of accuracy with respect to
the original ray-tracing one. In fact, the error of both algorithms converge to zero at a rate of about h2.7 , h being the
grid spacing. The accuracy of the interpolated version, on the
other hand, is significantly poorer. In fact, its error is of order
h2 , requiring a 10242 -grid to attain the same accuracy as the
non-interpolated algorithm on a 2562 -grid.
The periodic point-set resampling keeps the point-set density quasi-uniform. However, it can lead to loss of volume
and/or geometry details. To show this fact, let us consider
the Stanford Bunny with center of mass at (0.5,0.75,0.75)
and a (circularly constant) velocity field v(x1 , x2 , x3 , ) =
π
(0.5 − x2 , x1 − 0.5, 0). The bunny takes one complete
314
turn at 628 steps. Figure 9 presents results at 0, 157, 314, 471
and 628 steps, for grid resolutions of 1003 , 2003 , 3003 , 4003
and 5003 , respectively. One infers that, despite the capability
of the proposed resampling strategy for producing quasiuniformly spaced samples (as noticed in (a)), a milestone
for MLS surface quality, volume and/or geometry details are
lost along the resampling steps, mainly on coarser grids. A
straightforward future work is to minimize the number of
resampling steps.
Table 3 presents numerical assessments of previous 3D
rigid rotation test. We compute both L1 -error and averageerror. The L1 -error is obtained between RAMLS surface at
step 628 and original Stanford Bunny mesh (that one with
35k vertices), and the average error is the arithmetic average
of the distance from each sample of 628-step point-set to
the Stanford Bunny mesh. It can be seen that the L1 -error
is around 10 times bigger than the average error, which is
reasonable as large details disappear (e.g. the ears). Also,
on Table 3, we plot the initial and final number of points.
One can observe that for coarser grids, the number of points
is bigger in the initial stage, whereas for thinner one, the
number of points becomes larger in the final stage. However,
despite the number of points being bigger, one can observe
that details are still lost.

c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

1978

J. P. Gois & G. C. Buscaglia / Resampling MLS Surfaces

Figure 9: Periodic point-set resampling keeps the point-set density quasi-uniform. However, such a periodicity can lead to loss
of volume and/or geometry details even in a rigid rotation velocity field.

c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

J. P. Gois & G. C. Buscaglia / Resampling MLS Surfaces
Table 3: Numerical assessments for Stanford Bunny Rigid Rotation.

Grid

L1 -error

Average-error

# points (initial/final)

100
200
300
400
500

0.058769
0.046150
0.023020
0.014833
0.010437

0.007906
0.003707
0.002320
0.001700
0.001398

438/367
1730/1529
3756/3747
6577/6927
8663/11103

1979

the number of neighbours suffices) are updated (resampling
is not applied). In that case, it can be noticed that the surface
becomes drastically fragmented when deformation is at step
35. However, when it comes back to the initial stage, surface
is close to the original (only some small spurious surfaces
are detected). We believe this advantage is due to the normals
orientations do not change drastically, allowing the surface
for being reasonably recovered in the final stage.

6. Conclusion
We have explored the benefits of exploiting a background
Cartesian grid to reduce CPU-time cost of resampling MLS
surfaces under deformation. A new algorithm was proposed
which traverses the MLS surface in a continuation-like way
and cuts the cost by half. It was also shown that further
savings can be obtained by replacing the implicit function by
its interpolant. An accuracy assessment was then conducted,
which suggests that the non-interpolated version should be
preferred in general, unless CPU-time restrictions are critical.
Suggested improvement of the proposed method includes
the development of point-set quality to automatically trigger
resampling, and the use of the hierarchical run-length encoding of the grid data [HNB∗ 06] to enable the use of very large
3D grids.

Figure 10: Three-dimensional deformation of Stanford
Bunny: when resampling is employed (a), the surface is
well recovered at 35-step stage (center), but at 70-step stage
(right) a large spurious surface arises, due to the connectivityless nature of MLS surface. On the other hand, when
resampling is not employed (b), the surface becomes drastically fragmented at 35-step stage, but, basically all points
come back to their original positions (right) and only some of
them have their normals poorly defined (which causes some
small spurious surfaces).
Finally, in opposite to the loss of volume and/or geometry
details, there is also a case of gain of volume. In Figure 10,
we perform a 3D torsion for Stanford Bunny along 70 steps
(35 steps in each direction) in a grid resolution of 5003 . It
can be notice that at step 35 (the maximum of torsion) the
proposed method is able to recover satisfactorily the surface
(Figure 10(a)-center). However, when torsion comes back
to the original stage (Figure 10(a)-right), a large spurious
surface arises. It is probably due to the connectivityless definition of the MLS surface. As the surface stretches, opposite
sides of it become very close and they interfere with one
another. Such interferences cause small protuberances which
are propagated along the deformation.
In order to compare, we perform the same deformation
(Figure 10(b)), but, for each time step, only normals (when

Acknowledgments
This work was supported by Fundac¸a˜ o de Amparo a` Pesquisa
do Estado de S˜ao Paulo (FAPESP) and Conselho Nacional
de Desenvolvimento Cient´ıfico e Tecnol´ogico (CNPq).

References
[ABCO∗03] ALEXA M., BEHR J., COHEN-OR D., FLEISHMAN
S., LEVIN D., SILVA C. T.: Computing and rendering point
set surfaces. IEEE Transactions on Visualization and
Computer Graphics 9, 1 (2003), 3–15.
[AK04] AMENTA N., KIL Y. J.: The domain of a point set surfaces. In Eurographics Symposium on Point-based Graphics, 2004, pp. 139–147.
[Blo94] BLOOMENTHAL J.: An implicit surface polygonizer.
In Graphics Gems IV, Heckbert P. (Ed.), Academic Press,
Boston (1994), pp. 324–349.
[GBMP04] GUENNEBAUD G., BARTHE L., MATHIAS, Paulin:
Dynamic surfel set refinement for high quality rendering.
Computer & Graphics 28, 6 (2004), 827–838.
[GBP05] GUENNEBAUD G., BARTHE L., PAULIN M.: Interpolatory refinement for real-time processing of point-based
geometry. Comp. Graphics Forum 24, 3 (2005), 657–667.

c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

1980

J. P. Gois & G. C. Buscaglia / Resampling MLS Surfaces

[GG07] GUENNEBAUD G., GROSS M.: Algebraic point set surfaces. In SIGGRAPH?07 (New York, NY, USA, 2007),
ACM Press, p. 23.
[GGG08] GUENNEBAUD G., GERMANN M., GROSS M.: Dynamic sampling and rendering of algebraic point set surfaces. Computer Graphics Forum 27, 2 (2008), 653–
662.

[NS04] NEHAB D., SHILANE P.: Stratified point sampling of
3D models. In Eurographics Symposium on Point-Based
Graphics, June 2004, pp. 49–56.
[PGK02] PAULY M., GROSS M., KOBBELT L. P.: Efficient simplification of point-sampled surfaces. In VIS’02: Proceedings of the conference on Visualization (Boston, Massachusetts, 2002).

[GNNB08] GOIS J. P., NAKANO A., NONATO L. G., BUSCAGLIA
G. C.: Front tracking with moving-least-squares surfaces. Journal of Computational Physics 227, 22 (2008),
9643–9669.

[PZvBG00] PFISTER H., ZWICKER M., VAN BAAR J., GROSS M.:
Surfels: surface elements as rendering primitives. In SIGGRAPH ’00: Proceedings of the 27th annual conference
on Computer Graphics and Interactive Techniques (New
York, NY, USA, 2000), ACM Press/Addison-Wesley Publishing Co., pp. 335–342.

[GPJE∗ 08] GOIS J. P., POLIZELLI-JUNIOR V., ETIENE T., TEJADA
E., CASTELO A., NONATO L. G., ERTL T.: Twofold adaptive partition of unity implicits. The Visual Computer
24, 12 (2008), 1013–1023.

[SMW06] SCHAEFER S., MCPHAIL T., WARREN J.: Image deformation using moving least squares. ACM Trans. Graph.
25, 3 (2006), 533–540.

[HNB∗ 06] HOUSTON B., NIELSEN M. B., BATTY C., NILSSON
O., MUSETH K.: Hierarchical RLE level set: A compact and
versatile deformable surface representation. ACM Trans.
Graph. 25, 1 (2006), 151–175.

[WSS08] WANG H., SCHEIDEGGER C., SILVA C.: Optimal bandwidth selection for MLS surfaces. In Shape Modeling and
Applications. M. Spagnuolo, D. Cohen-Or and X. D. Gu
(Eds.). IEEE Computer Society, Los Alamitos, CA, USA
(2008), pp. 111–120.

c 2010 The Authors
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.


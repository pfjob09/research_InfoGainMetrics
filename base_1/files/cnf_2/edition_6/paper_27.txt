DOI: 10.1111/j.1467-8659.2009.01600.x
EUROGRAPHICS 2010 / T. Akenine-Möller and M. Zwicker
(Guest Editors)

Volume 29 (2010), Number 2

Multi-Scale Geometry Interpolation
T. Winkler1
1 University

J. Drieseberg2

of Lugano, Switzerland

2 TU

M. Alexa3

K. Hormann1

Clausthal, Germany

3 TU

Berlin, Germany

Abstract
Interpolating vertex positions among triangle meshes with identical vertex-edge graphs is a fundamental part of
many geometric modelling systems. Linear vertex interpolation is robust but fails to preserve local shape. Most
recent approaches identify local affine transformations for parts of the mesh, model desired interpolations of the
affine transformations, and then optimize vertex positions to conform with the desired transformations. However,
the local interpolation of the rotational part is non-trivial for more than two input configurations and ambiguous
if the meshes are deformed significantly. We propose a solution to the vertex interpolation problem that starts from
interpolating the local metric (edge lengths) and mean curvature (dihedral angles) and makes consistent choices
of local affine transformations using shape matching applied to successively larger parts of the mesh. The local
interpolation can be applied to any number of input vertex configurations and due to the hierarchical scheme for
generating consolidated vertex positions, the approach is fast and can be applied to very large meshes.
Categories and Subject Descriptors (according to ACM CCS): I.3.5 [Computer Graphics]: Computational Geometry
and Object Modeling—Hierarchy and geometric transformations

1. Introduction

more pronounced in the three-dimensional instance of the
problem: interpolating edge lengths and angles is robust and
fast, but it is difficult to formulate the subsequent optimization problem in such a way that it can be solved both efficiently and uniquely. The fundamental problem is that the
orientation of each element of the shape is unknown, meaning that the optimization involves rotations and is non-linear.

Creating vertex positions or trajectories for a triangle graph
from two or more sets of vertex positions is a fundamental
building block of many techniques in geometry processing
and animation. In the context of morphing it has been considered a challenge in its own right and is usually referred to
as the vertex path problem. It is generally accepted that linear
interpolation of vertex positions yields undesirable results,
because the local shape distorts in the presence of rotations.

On the other hand, prescribing local transformations for
each element in the mesh defines this orientation and consolidating the different vertex positions can be done, for example, by linear least squares. But, interpolating the rotational part of each affine transformation is ambiguous. This
is mainly due to the non-Euclidean nature of rotations, which
makes it impossible to distinguish the effect of a rotation by
x degrees and another by x + 360n degrees (for any integer
n), as they both result in the same orientation of the rotated
object [Lee08]. Note that picking a preferred rotation (i.e.
the one with smallest angle) fails if some parts in the target differ from their corresponding parts in the source by a
rotation of more than 180 degrees.

Better solutions to the vertex-path problem, therefore,
try to preserve the local shape throughout the interpolation. There are two fundamental approaches that can be
traced back to two techniques for morphing planar figures.
Sederberg et al. [SGWM93] interpolate intrinsic parameters of a polygon, namely edge lengths and angles. Alexa et
al. [ACOL00] identify local affine transformations for each
part of the shape and then compute preferred interpolations
of these transformations. Both approaches have in common
that no global vertex configuration satisfies the local constraints, so that vertex positions are found by an optimization
process.

In the following section we discuss several approaches
that apply the idea of factoring and interpolating local affine
transformations to geometric modelling approaches in 3D.
We have found, however, that the fundamental ambiguity

The two approaches have complementary advantages and
disadvantages and, as we will see, the disadvantages become
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.
Published by Blackwell Publishing, 9600 Garsington Road, Oxford OX4 2DQ, UK and
350 Main Street, Malden, MA 02148, USA.

309

310

Winkler, Drieseberg, Alexa, Hormann / Multi-Scale Geometry Interpolation

Figure 1: Example of a source mesh (left) and a target mesh
(right) that illustrates the problem of interpolating large
global rotations.

cannot be reliably resolved. Consequently, our proposed approach follows Sederberg et al. [SGWM93] and we suggest
to interpolate edge lengths and dihedral angles. Note that interpolating these quantities bears a nice connection to the
local metric and directional curvatures of the surface. The
main contribution of our approach is applying a global multiregistration and to efficiently compute it using a hierarchical
structure of the mesh.
2. Shape interpolation based on local transformations
Sumner et al. [SP04] were the first to lift the idea of deriving local affine transformations to 3D and then used it
in [SZGP05] for interpolation among several meshes. For
interpolation, they split the matrix into a rotational and a
scale/shear part. While the scale/shear part can then be interpolated linearly without any further treatment, the rotational part should be treated in log-space, which requires to
compute matrix logarithms and exponentials [Ale02].
The main drawback of this approach is that the triangles
are interpolated individually, and so a situation as shown
in Figure 1 cannot be handled correctly. From a global
perspective, it is clear that the cylinder is deformed, but
for all approaches that are based on deformation gradients [SZGP05, DSP06], it is not possible to distinguish between the top of the cylinder in the source mesh and the rotated top of the bent cylinder in the destination mesh. More
precisely, the affine transformation between both parts is a
translation. During the interpolation, this part of the mesh
will therefore move in a very undesirable way, as it will not
rotate at all. The same holds for Poisson shape interpolation [XZWB05], as it was shown by Botsch et al. [BSPG06]
that it is equivalent to the deformation gradient approach in
this setting.
The fact that deformation gradients rely upon a reference
mesh can be exploited to improve the interpolation by using
a global alignment in relation to the reference mesh. For example, Baran et al. [BVGP09] achieve this by factoring out
the average rotation. But even then it is still not a sufficient
representation method for interpolation.
What other options do we have for interpolating the rotation then? One idea is to track the rotations during a breadth-

first traversal from some seed triangle. In 2D, this actually
works pretty well, because all triangles are rotated about the
same axis and neighbouring triangles have similar rotation
angles. For example, Alexa has applied this technique to
generate the results in [ACOL00]. But in 3D, this approach
also requires to propagate the rotation axes, and our experiments show that it is impossible to find a globally consistent
distribution of rotation axes unless the object has a very simple shape, and even then the result depends on the traversal
order. Moreover, it is often the case that the natural deformation path is not a geodesic in the space of rotations and
can therefore not be described correctly by a rotation about
a fixed axis [Gra98].
Another option is to take the connectivity information of
the triangle mesh into account, and instead of treating all
triangles individually, considering transformations that connect local frames in the mesh. Lipman et al. [LSLCO05] pioneered an approach in this direction. They construct a local coordinate frame for each vertex of the mesh and then
consider connection maps to encode the transformation between neighbouring frames. A key property of this method is
that it represents the local geometry of a mesh in a rotationinvariant way, which appears to overcome the problem that
all linear mesh representation (such as deformation gradients
and Laplace coordinates) suffer from. Although this may
cause counterintuitive results for extreme rotations (by more
than 180 degrees) when used as an editing tool, it solves the
orientation problem discussed above when used for interpolation. The reason is that the reconstruction process is performed in two steps: the connection maps are used to compute local frames, and based on the local frames, the vertex
coordinates are reconstructed.
Kircher and Garland [KG08] improve upon this approach
by considering affine connection maps between neighbouring triangles and storing them explicitly. This also results
in a two-step linear reconstruction process, but the matrices
that are involved are rather big (three times the number of
triangles) and need to be factorized for each interpolation
step, which in turn limits the method to rather small meshes.
Baran et al. [BVGP09] reduce the rotation problem by splitting the meshes into patches such that the triangles within a
single patch are not rotated by more than 180 degrees relative to the patch frame. This is a significant improvement,
however, it is not clear if such a segmentation necessarily
exists.
All of the approaches discussed so far try to model the
non-linear nature of the problem in a linear way and require only the solution of one or two large but sparse linear systems. Clearly, the problem can also be modelled nonlinearly if we accept more involved optimization. Pyramid
coordinates [SK04] are a natural non-linear local representation of vertex positions. Kilian et al. [KMP07] define a
Riemannian metric that penalizes non-isometric deformations and search for geodesic paths in the resulting shape
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

Winkler, Drieseberg, Alexa, Hormann / Multi-Scale Geometry Interpolation
c0
t=¡1/3

A0
a0

b0

t=0
®0
A0

ct

At
at

bt

t=1/3
B0

®t

c1
t=2/3

the wedge (At , Bt ) in space, but at least it determines the relative position of one triangle to the other.

b1

t=1

t=4/3

®1 B
1

Bt

At

A1
a1

311

A1

Figure 2: Linear interpolation of a single triangle (top) and
a wedge (bottom).

space. In both cases the reconstruction process is computationally intense. Lastly, another recent method [CL09] with
very promising results tries to solve the problem of large rotations by applying a hierarchical version of the mean shift
cluster algorithm.
In contrast, our approach follows the idea of Sederberg et
al. [SGWM93] and interpolates the local intrinsic properties
of the mesh (edges and dihedral angles). In order to derive
a globally coherent solution, we utilize a hierarchical shape
matching approach. The latter works for much larger meshes
than any of the above mentioned techniques, and local intrinsic shape interpolation naturally applies to more than two
input configurations. Moreover, our mesh representation actually provides a new kind of shape space and thus has the
potential to be used for other applications beyond shape interpolation.
3. Multi-Scale Interpolation
Our method is based on a hierarchical approach and is similar in spirit to the shape matching in [MHTG05, BPGK06,
SA07]. At the bottom of the hierarchy, we consider single triangles and linearly interpolate the local metric of the given
meshes. Let A0 and A1 be two corresponding triangles in the
source and the target mesh with edge lengths a0 , b0 , c0 and
a1 , b1 , c1 . Given some interpolation parameter t ∈ [0, 1], we
construct the destination triangle At by linearly interpolating the edge lengths (see Figure 2). That is, At is a triangle
with edge lengths at = (1 − t)a0 + ta1 , bt = (1 − t)b0 + tb1 ,
ct = (1 − t)c0 + tc1 , and it is clear by construction that such
a triangle always exists. However, although this determines
shape and size of At , we do not yet know where to place it,
and that is where the hierarchy comes into play.
On the next coarser hierarchy level, we consider pairs of
adjacent triangles (wedges) and linearly interpolate the local mean curvature of the given meshes. Let (A0 , B0 ) and
(A1 , B1 ) be such corresponding wedges in the source and the
target mesh with dihedral angles α0 and α1 at the common
edge (see Figure 2). We then glue the interpolated triangles
At and Bt together such that they form a wedge with dihedral angle αt = (1 − t)α0 + tα1 . Note that At and Bt fit together seamlessly as the common edge has the same length
in both triangles. Again, this does not tell us where to place
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

In some sense, this method interpolates between corresponding wedges as rigidly as possible, because both the local metric (edge lengths) and the local mean curvature (dihedral angle) are interpolated in the straightest way (linearly).
It now remains to paste all interpolated wedges together in
order to yield the interpolated mesh. If we consider all possible wedges, that is, one for each edge in the mesh, then
it is clear that for each triangle there are three wedges that
overlap, like the scales of a fish. And it is this small overlap
that can be exploited in order to arrange all wedges globally. All we have to do is to find a set of rigid transformations, one for each wedge, such that the overall sum of distances (or rather squared distances) between all corresponding vertices for two overlapping wedges is minimized. Such
a global alignment procedure for all wedges can in principle be solved by a multi-registration method, but for meshes
with more than a few hundred triangles this can become very
slow and unstable.
Thus, we take further advantage of our hierarchical approach. On the next coarser level above the wedges in our
hierarchy, we cluster all the wedges around a common vertex and align them with the multi-registration method of
Williams and Bennamoun [WB00] (see Section 3.1). Once
aligned, we average the coordinates of corresponding vertices (see Section 3.2) and combine the wedges to form a
one-ring. If we do so for all vertices of the mesh, we get a
set of larger patches, which again overlap by an even bigger amount (neighbouring one-rings share two triangles),
like the scales of an armadillo. Proceeding this way recursively, we create larger and larger patches by always clustering, aligning, and blending a small number (4 to 10) of
overlapping and neighbouring patches. And at the top of the
hierarchy we get the interpolated mesh, similar to the way
the scales of a crocodile form its exoskeleton.
Note that this method clearly reproduces T0 and T1 for
t = 0 and t = 1, respectively, because in both cases the
patches can be aligned with zero distance on all levels of
the hierarchy.
3.1. Aligning patches
Let us now take a closer look at how to align multiple
patches, so that they form a globally consistent mesh. This
problem is somewhat similar to the registration of point
clouds in 3D. But our setting is even simpler, in that we
already know all corresponding vertices and do not have
to bother searching for closest points. Consider, for example, the alignment of two neighbouring wedges. Since they
have an overlap of one triangle, there are exactly three corresponding vertex pairs (the corners of said triangle), and that
suffices to optimally align them. And on all upper levels of
the hierarchy, neighbouring patches overlap by even more
triangles.

312

Winkler, Drieseberg, Alexa, Hormann / Multi-Scale Geometry Interpolation

In order to register two neighbouring patches, we could
apply the method of Bessel and McKay [BM92] or one of
its improved siblings and directly compute the optimal rotation and translation for transforming one patch such that it
aligns best to the other. But unfortunately, pairwise registration leads to error accumulation in the hierarchy. We therefore need a method that allows to distribute the registration
error between the patches as equally as possible.
We tested several such multi-registration methods [SH96,
CS99, PLH02] and found the one of Williams and Bennamoun [WB00] to be very well adapted to our particular
problem. Their goal is to simultaneously determine all rigid
transformations (translation and rotation), i.e., one for each
of the patches that need to be registered. This is done by
minimizing a cost function which sums up all the squared
distances between corresponding vertices for neighbouring
patches. The key idea of their approach is to pre-compute
in an elegant way a constant matrix that encodes the whole
registration problem. This matrix then allows to iteratively
solve for the best rigid transformations, and only few iterations suffice to get close to the optimal solution. In our setting, we can actually stop the iterations rather early (after 4
passes), for we post-process the alignment anyway in order
to smoothen the result (see Section 3.2).
Due to the iterative nature of the method, one would
assume that a good starting solution is essential. Yet, we
learned from our experiments that the approach is robust
enough to allow for an initialization of all rotations with the
identity matrix. Moreover, the result is (in principle) unique
only up to a global rotation, but this can easily be adjusted
by constraining one of the rotation matrices to be the identity matrix, thereby fixing the global orientation of the corresponding patch. Finally, it is possible (in case of coplanar or
collinear data), that some of the resulting rotation matrices
have a negative determinant and thus contain an unwanted
reflection. We fix this as described in [AHB87], that is, we
simply negate the last column of these matrices and continue
iterating.
3.2. Blending patches
Once we have computed the best rigid transformations for
a set of m small patches P[1] , . . . , P[m] at some level of our
hierarchy, it remains to blend them into a consistent larger
patch P at the next coarser hierarchy level. In general, even
an optimal alignment still leaves a small gap between corresponding vertices so that the patches do not fit together
seamlessly in their overlap region. At first, we tried to simply average the coordinates of corresponding vertices, but
this turned out to be insufficient as the alignment errors still
tend to accumulate, yielding an unsatisfactory overall result
for the whole mesh. Instead, we decided to distribute the remaining alignment errors in a more global way as follows.
Inspired by the handling of the consistency requirements

v[31]

v[35]
v4

v[21]

[1]

v4

[5]

v5

[5]

v[75]
v[42]
v[52]

v[33]

v[23]

v[73]

v[71]

v[74]

v[56]

v[14]

v[16]

v4

v2

v7
v5

v[64]

v[66]

v[62]

v2

v1

v[76]

v[72]

v3
[4]

[3]

v1
v6

Figure 3: Notation for blending m = 6 wedges P[1] , . . . , P[6]
(left) into a one-ring P (right) with n = 7 vertices.

in the deformation gradient setting [SP04], we determine the
coordinates of the vertices in the large patch P such that its
edges deviate as little as possible from all the corresponding
edges in the small patches P[k] . Suppose that v = (v1 , . . . , vn )
are the vertices of P and that [vi , v j ] is one of the edges in P.
Then this edge also occurs in some of the small patches P[k] ,
but there it is spanned by the vertices with local coordinates
[k]
[k]
vi and v j (see Figure 3). Ideally, the vertices v of P should
be such that
[k]

[k]

v i − v j = vi − v j

(1)

for all edges [vi , v j ] in P and all its occurrences in the small
patches P[k] . Gathering all these conditions yields a linear
system
Mv = e,

(2)

where v are the unknown vertex positions of P, M is a large
sparse matrix with exactly two entries 1 and −1 per row,
reflecting the left hand side of (1), and e is the vector of
corresponding edges from the small patches, reflecting the
right hand side of (1). In general, this is an overdetermined
linear system and we compute its least squares solution by
solving the linear problem
min Mv − e
v

2
2

M T Mv = M T e.

⇐⇒

Similar to the linear systems that appear in the work of Sumner et al. [SZGP05] and Kircher and Garland [KG08], the
solution is unique only up to translation. In our setting, we
resolve this by simply adding the constraint v1 = 0 to the
linear system.
Note that the system matrix M T M does not depend on the
blending parameter t. Hence we can factorize it in a preprocessing step when building the hierarchy, so as to allow
for a more efficient construction of the interpolated meshes
when the user explores the shape space.
We can improve the quality of the result by replacing condition (1) with
vi − v j =

[k]

[k]

[k]

[k]

vi − v j
vi − v j

si j (t),

(3)

where si j (t) is the linear interpolation of the lengths of edge
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

Winkler, Drieseberg, Alexa, Hormann / Multi-Scale Geometry Interpolation

313

Figure 4: Building the hierarchy: the whole mesh (root node at level 0) is split into m patches at level 1, which in turn get split
into m patches each at level 2 and so on, until the patches consist of less than m triangles (lowest level). From top left to bottom
right: one branch of the hierarchy tree, where it is always the red patch whose split is shown in the next picture.

[vi , v j ] in the source and the target mesh. In this way, we only
keep the orientation of the edge from the small patch, but enforce its desired length on each hierarchy level. Overall, this
drastically reduces the deviation of the edge lengths in the interpolated mesh from the ideal, linearly interpolated lengths
that we use at the bottom of the hierarchy to assemble the interpolated single triangles. It is remarkable to note that solving the linear system (2) with the conditions from (3) seems
to yield a locally optimal solution. That is, solving the system iteratively, with the edges vi − v j from the current solu[k]

[k]

tion instead of vi − v j , does not improve the edge lengths.
Moreover, this approach allows to apply additional local
deformations to parts of the mesh by modifying the destination lengths. For example, we can scale parts of the mesh
by tagging a set of edges and multiplying the corresponding
lengths si j (t) with some common scaling factor, as shown in
Figure 12.
3.3. Building the hierarchy
One question that we have not yet answered is how to get
the adjacency information about the patches and how to set
up the hierarchy. A common practice is to recursively decimate or cluster the mesh to construct a progressive hierarchy. Then a multi-grid method is used to propagate the
solution from the coarsest up to the finest level. For example, Botsch et al. [BPGK06] solve their hierarchical shape
matching problem this way. Our approach is different in
that we recursively split the mesh into smaller and smaller
patches, resulting in a hierarchy tree.
We start by taking the complete mesh as root node of
the tree (level 0) and then descend one level by taking as
many random seed triangles as we want the hierarchy to have
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

patches on each level, say m. Using these seed triangles, we
concurrently apply a region growing step until the patches
meet and overlap by a triangle strip of width one. Our experiments show that it does not matter how the seed triangles are
located, but theoretically it is better to place them such that
the resulting patches have an irregular boundary and hence a
larger overlap region. This creates the first m patches of the
hierarchy tree at level 1.
By recursively applying this scheme, we build the whole
tree until we arrive at the lowest level (see Figure 4). Theoretically, this should be the level of triangles, but it turned out
to be sufficient to stop as soon as the patches consist of less
than m triangles. At this lowest level, we interpolate each of
the triangles and the dihedral angles between neighbouring
ones as described above and glue them together in a greedy
way. That is, we start with any of them and keep attaching
the others one by one, respecting the desired dihedral angles. If such a lowest level patch is a triangle strip, then this
is actually the best one can do. But if it is a triangle fan (or
contains one), then this simple strategy may create gaps because the fan does not necessarily close up perfectly. However, we found that the blending procedure (see Section 3.2)
takes care of this and smoothes these imperfections. Overall,
this speeds up the interpolation process, because it reduces
the number of hierarchy levels.
Although the multi-registration step (see Section 3.1) allows any number of patches to be aligned, we found that using m = 6 patches per node gives the best trade-off in terms
of computation time. A smaller m creates too many hierarchy levels, and a larger m slows down the multi-registration
steps, because each of them requires to compute the singular value decomposition of a matrix whose size is 3m × 3m
(see [WB00] for more details).

314

Winkler, Drieseberg, Alexa, Hormann / Multi-Scale Geometry Interpolation

Figure 5: Interpolation between multiple input meshes. The n reference meshes correspond to the vertices of a control polygon
in 2D, and any point within this polygon corresponds to an interpolated pose. The user can change the interpolated mesh by
either moving the reference point inside the polygon, or by changing the shape of the control polygon.

3.4. Multiple input meshes
Since our approach is based on linear interpolation, it trivially allows for the interpolation between more than two input meshes. Let a1 , . . . , an be the lengths of a corresponding
edge in n input meshes, and let t = (t1 , . . . ,tn ) ∈ [0, 1]n be
an n-dimensional interpolation parameter. Then the interpolated edge length is at = t1 a1 + . . . + tn an , and likewise for
the interpolated dihedral angles αt = t1 α1 + . . . +tn αn . Once
these values have been used to construct the two lowest levels of the hierarchy (single triangles and wedges), the remaining levels are constructed in the same way as described
above. In the example shown in Figure 5, we use mean value
coordinates [Flo03] with respect to the corners of the control
polygon as interpolation parameter t.
3.5. Extrapolation
In principle, our method can also be used for extrapolating
between two or more input meshes, that is, the interpolation
parameter can be chosen outside the range [0, 1]. But it is
then no longer guaranteed that the interpolated edge lengths
match up to form a triangle (an interpolated edge can end up
being negative or bigger than the sum of the other two), and
the interpolated dihedral angle may leave the valid range between −180 and +180 degrees. However, we found that this
happens only for rather extreme extrapolations and works
well in most cases (see Figure 10 and 11).
4. Results
In general our results are comparable in quality to all
state-of-the-art approaches [KMP07, KG08, CL09], but our
method is significantly simpler and faster. The only method
that can compete in terms of speed, is the one by Kircher

and Garland [KG08], but as mentioned above we can handle much larger meshes, because our mesh hierarchy decomposes them into digestible chunks.
4.1. Interpolation
Figure 6 confirms that our approach generates basically
the same interpolation results as the ones by Kilian et
al. [KMP07] and Chu et al. [CL09], but we are at least an order of magnitude faster (see Table 1). The armadillo example
emphasizes that very large meshes do not pose a challenge
for our method, because of our hierarchical structure.
The cylinder deforming into a helix probably illustrates
best what we are striving for in this paper. The interpolation
follows the multiple rotations (far greater than 180 degrees)
in a visually plausible way, due to the fact that the multiregistration step takes care of the global rotation. Note that
the result shows a remarkable resemblance to the outcome of
the physical simulations of discrete elastic rods [BWR∗ 08]
and does not suffer from the fact that the triangle density
varies strongly over the mesh.
Figures 13 and 14 further show that the method is robust
enough to tolerate a reasonable amount of vertex noise and
able to handle long and skinny triangles.
Figure 7 illustrates how little the edge lengths in the interpolated mesh deviate from the desired lengths that we impose at the bottom of our hierarchy. The plots show the maximum and the minimum relative difference from the linearly
interpolated lengths. While the global worst case is about
−12% the major fraction of the edges (99%) do not differ by more than 2.5% from the ideal value. This confirms
that our alignment and blending steps affect the local metric only very slightly. Figure 8 shows the equivalent plots
for the angles, but this time on an absolute scale. Although
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

Winkler, Drieseberg, Alexa, Hormann / Multi-Scale Geometry Interpolation

315

Figure 6: Interpolation between two input meshes (leftmost and rightmost column). The interpolated poses (in green) are shown
for parameter values of t = 0.25, t = 0.5, t = 0.75.
meshes
vertices faces
cylinder
312
620
helix
1212
2420
lion
5000
9996
horse
8431
16843
elephant 39969 79946
armadillo 165954 331904

pre-processing
splitting factorizing
2.94
59.71
12.75
243.76
127.55
1248.22
300.41
2140.96
5975.31 11954.33
90106.71 54339.12

mesh interpolation
interpolation registration blending
1.17
18.78
5.21
3.98
84.11
24.66
16.05
365.99
122.45
72.45
544.01
205.93
126.15
2632.40
1327.28
570.07
11273.22 7105.04

Table 1: Timings for all meshes shown throughout the paper, measured in milliseconds

c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

316

Winkler, Drieseberg, Alexa, Hormann / Multi-Scale Geometry Interpolation

Figure 7: Relative error between the effective edge lengths
in the interpolated mesh and the ideal linearly interpolated
lengths, for the elephant example in Figure 11. Plotting this
error for all edges yields the envelope represented by the
blue curves. Neglecting the 0.1% edges with the worst deviation results in the green envelope, and the red one visualizes
the envelope of 99% of all edges.

Figure 9: Relative error between the volume of the interpolated mesh and the volume of the input meshes for the examples in Figures 6 and 11.

Figure 12 finally shows an example of a constrained interpolation as explained at the end of Section 3.2. We applied
an additional scaling factor of t + 1 to the lions head, tail
and paws (i.e., the scaling factor varies linearly from 1 at the
source mesh to 2 at the target mesh).
4.3. Timings

Figure 8: Relative error between the effective dihedral angles and the linearly interpolated ones for the elephant example. Compare to Figure 7.

the overall worst case differs by more than 100 degrees from
the ideal value, such extreme deviations are very rare to happen. For 99.9% of all edges, the interpolated dihedral angle
lies within ±5 degrees from the linearly interpolated angle,
and the maximum error of 99% of the angles is less than
1 degree. Again this shows how well our global alignment
procedure keeps the dihedral angles that we impose on the
wedge-level. Interestingly, our method also does a good job
in preserving the volume of the meshes during interpolation
as shown in Figure 9, although we do not directly consider
this as a constraint during our reconstruction.
4.2. Extrapolation and constrained interpolation
As mentioned in Section 3.5 our approach can also be used
for extrapolation, according to the limits mentioned. For the
elephant example in Figure 11 we cannot go much beyond
the interval [−0.25, 1.25], but if the edge lengths and dihedral angles in the input meshes are quite similar, then we can
actually extrapolate quite far as shown in Figure 10.

The timings in Table 1 report that the preprocessing step is
the computationally most intense part of the approach, but
still reasonable even for large meshes. Once this work is
done, constructing an interpolated pose is not too expensive.
The cost for interpolating the edge lengths and dihedral angles at the bottom of the hierarchy is negligible and the registration time grows linearly with the number of triangles.
From a certain mesh size on, the blending step becomes the
most expensive part of the pipeline, since the matrices from
Equation (1) are then relatively large on the top of the hierarchy. All timings were measured on a Core2Duo Laptop with
4 GB RAM and a 2.5 Ghz CPU.
5. Conclusion
We presented a novel method for interpolating between two
or more compatible meshes that is not based on local affine
transformations. Instead we linearly interpolate the intrinsic
local properties of the input meshes, which is the most natural and simplest thing to do on the level of wedges. The simplicity of this idea is counterweighed by the fact that putting
the wedges together such that they yield a globally consistent
mesh is a rather complex optimization problem. However,
we found that this problem can be solved in principle by
multi-registration methods and since this can be combined
with a hierarchical decomposition of the mesh in larger and
larger patches, it can actually be solved efficiently as well.
As the examples confirm, our approach yields very intuitive interpolations and can hence be used for exploring the
natural space shape spanned by a set of key poses. This allows for a number of interesting applications. For example,
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

Winkler, Drieseberg, Alexa, Hormann / Multi-Scale Geometry Interpolation

317

Figure 10: Extrapolation of a cylinder. The two input meshes and extrapolated poses for parameter values of t = 2, t = 3, t = 4
(from left to right).

Figure 11: Extrapolating the elephant. The parameter values of the meshes are t = −0.25, t = 0, t = 0.5, t = 1, t = 1.25 (from
left to right).

Figure 12: Example of a constrained interpolation for the lion using a scaling factor of 2t for the edges in the selected regions
(blue). The parameter values of the interpolated meshes are t = 0.25, t = 0.5, t = 0.75, t = 1 (from left to right).

approaches like [SPK∗ 07, WDH∗ 08, HSS∗ 09] can be used
on top of our method, and it can also be used for shape editing based on user-defined constraints, similar to how it is described in [KMP07]. Moreover, our framework can be used
to express animation sequences as simple 2D paths in a reference polygon (compare Figure 5), which in turn may provide an intuitive tool for character animation or even crowd
generation.
6. Acknowledgements
We would like to thank Martin Kilian for providing the
meshes used in [KMP07] and especially John A. Wiliams for
helpful hints on his implementation of the multi-registration
method.
References
[ACOL00] A LEXA M., C OHEN -O R D., L EVIN D.: As-rigid-aspossible shape interpolation. In Proceedings of SIGGRAPH 2000
(July 2000), pp. 157–164.
[AHB87] A RUN K. S., H UANG T. S., B LOSTEIN S. D.: Leastsquares fitting of two 3-D point sets. IEEE Trans. Pattern Anal.
Mach. Intell. 9, 5 (Sept. 1987), 698–700.
c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.

[Ale02] A LEXA M.: Linear combination of transformations.
ACM Trans. Graph. 21, 3 (July 2002), 380–387. Proceedings
of SIGGRAPH.
[BM92] B ESL P. J., M C K AY N. D.: A method for registration of
3-D shapes. IEEE Trans. Pattern Anal. Mach. Intell. 14, 2 (Feb.
1992), 239–256.
[BPGK06] B OTSCH M., PAULY M., G ROSS M., KOBBELT L.:
Primo: coupled prisms for intuitive surface modeling. In Proceedings of Symposium on Geometry Processing 2006 (Cagliari,
Italy, June 2006), pp. 11–20.
[BSPG06] B OTSCH M., S UMNER R., PAULY M., G ROSS
M.: Deformation transfer for detail-preserving surface editing. In Proceedings of Vision, Modeling, and Visualization 2006
(Aachen, Germany, Nov. 2006), pp. 357–364.
[BVGP09] BARAN I., V LASIC D., G RINSPUN E., P OPOVI C´ J.:
Semantic deformation transfer. ACM Trans. Graph. 28, 3 (Aug.
2009), 36:1–36:6. Proceedings of SIGGRAPH.
[BWR∗ 08] B ERGOU M., WARDETZKY M., ROBINSON S., AU DOLY B., G RINSPUN E.: Discrete elastic rods. ACM Trans.
Graph. 27, 3 (Aug. 2008), 63:1–63:12. Proceedings of SIGGRAPH.
[CL09] C HU H.-K., L EE T.-Y.: Multiresolution mean shift clustering algorithm for shape interpolation. IEEE Trans. Vis. Comput. Graph. 15, 5 (Sept. 2009), 853–866.
[CS99] C UNNINGTON S. J., S TODDART A. J.: N-view point
set registration: A comparison. In Proceedings of the 10th

318

Winkler, Drieseberg, Alexa, Hormann / Multi-Scale Geometry Interpolation

Figure 13: Interpolating the elephant with additional noise (compare with Figure 11). The parameter values of the interpolated
poses are t = 0.25, t = 0.5, and t = 0.75 (from left to right).

Figure 14: Interpolating long and skinny triangles. The parameter values of the interpolated poses are t = 0.25, t = 0.5, and
t = 0.75 (from left to right).

British Machine Vision Conference (Nottingham, UK, Sept.
1999), pp. 234–244.
[DSP06] D ER K. G., S UMNER R. W., P OPOVI C´ J.: Inverse kinematics for reduced deformable models. ACM Trans. Graph. 25,
3 (July 2006), 1174–1179. Proceedings of SIGGRAPH.
[Flo03] F LOATER M. S.: Mean value coordinates. Comput. Aided
Geom. Des. 20, 1 (Mar. 2003), 19–27.
[Gra98] G RASSIA S.: Practical parameterization of rotations using the exponential map. Journal of Graphics Tools 3, 3 (Mar.
1998), 29–48.
[HSS∗ 09]

H ASLER N., S TOLL C., S UNKEL M., ROSENHAHN
B., S EIDEL H. P.: A statistical model of human pose and body
shape. Comput. Graph. Forum 2, 28 (Mar. 2009). Proceedings of
Eurographics 2009.

[KG08] K IRCHER S., G ARLAND M.: Free-form motion processing. ACM Trans. Graph. 27, 2 (Apr. 2008), 12:1–12:13.
[KMP07] K ILIAN M., M ITRA N. J., P OTTMANN H.: Geometric
modeling in shape space. ACM Trans. Graph. 26, 3 (July 2007),
64:1–64:8. Proceedings of SIGGRAPH.
[Lee08] L EE J.: Representing rotations and orientations in geometric computing. Computer Graphics and Applications 28, 2
(Mar./Apr. 2008), 75–83.

[SA07] S ORKINE O., A LEXA M.: As-rigid-as-possible surface
modeling. In Proceedings of Symposium on Geometry Processing 2007 (Barcelona, Spain, July 2007), pp. 109–116.
[SGWM93] S EDERBERG T. W., G AO P., WANG G., M U H.: 2-D
shape blending: an intrinsic solution to the vertex path problem.
In Proceedings of SIGGRAPH 1993 (Aug. 1993), pp. 15–18.
[SH96] S TODDART A. J., H ILTON A.: Registration of multiple
point sets. In Proceedings of the 13th International Conference
on Pattern Recognition (Vienna, Austria, Aug. 1996), pp. 40–44.
[SK04] S HEFFER A., K RAEVOY V.: Pyramid coordinates for
morphing and deformation. In Proceedings of the 2nd International Symposium on 3D Data Processing, Visualization, and
Transmission (Thessaloniki, Greece, Sept. 2004), pp. 68–75.
[SP04] S UMNER R. W., P OPOVI C´ J.: Deformation transfer for
triangle meshes. ACM Trans. Graph. 23, 3 (Aug. 2004), 399–
405. Proceedings of SIGGRAPH.
[SPK∗ 07] S MITH R. C., PAWLICKI R., KÓKAI I., F INGER J.,
V ETTER T.: Navigating in a shape space of registered models.
IEEE Trans. Vis. Comput. Graph. 13, 6 (Nov. 2007), 1552–1559.
[SZGP05] S UMNER R. W., Z WICKER M., G OTSMAN C.,
P OPOVI C´ J.: Mesh-based inverse kinematics. ACM Trans.
Graph. 24, 3 (July 2005), 488–495. Proceedings of SIGGRAPH.

[LSLCO05] L IPMAN Y., S ORKINE O., L EVIN D., C OHEN -O R
D.: Linear rotation-invariant coordinates for meshes. ACM
Trans. Graph. 24, 3 (July 2005), 479–487. Proceedings of SIGGRAPH.

[WB00] W ILLIAMS J. A., B ENNAMOUN M.: Simultaneous
registration of multiple point sets using orthonormal matrices.
In Proceedings of the International Conference on Acoustics,
Speech and Signal Processing 2000 (Istanbul, Turkey, June
2000), vol. 4, pp. 2199–2202.

[MHTG05] M ÜLLER M., H EIDELBERGER B., T ESCHNER M.,
G ROSS M.: Meshless deformations based on shape matching.
ACM Trans. Graph. 24, 3 (July 2005), 471–478. Proceedings of
SIGGRAPH.

[WDH∗ 08] W INKLER T., D RIESEBERG J., H ASENFUSS A.,
H AMMER B., H ORMANN K.: Thinning mesh animations. In
Proceedings of Vision, Modeling, and Visualization 2008 (Konstanz, Germany, Oct. 2008), pp. 149–158.

[PLH02] P OTTMANN H., L EOPOLDSEDER S., H OFER M.: Simultaneous registration of multiple views of a 3D object. In Photogrammetric Computer Vision, Kalliany R., Leberl F., (Eds.),
vol. 34, Part 3A of Archives of the Photogrammetry, Remote
Sensing and Spatial Information Sciences. 2002, pp. 265–270.

[XZWB05] X U D., Z HANG H., WANG Q., BAO H.: Poisson
shape interpolation. In Proceedings of the 2005 ACM Symposium
on Solid and Physical Modeling (Cambridge, MA, June 2005),
pp. 267–274.

c 2010 The Author(s)
Journal compilation c 2010 The Eurographics Association and Blackwell Publishing Ltd.


Visual Representation of Database Queries
using Structural Similarity
Dennis P. Groth
School of Informatics
Indiana University
Bloomington, IN 47405, USA
dgroth@indiana.edu

Abstract
It is often useful to get high-level views of datasets in
order to identify areas of interest worthy of further exploration. In relational databases, the high-level view
can be described using Entity-Relationship diagrams,
which identify relationships between entities in the data
model. Such high-level views are useful for database
design activities, and can be used to generate user interfaces for constructing queries. This research introduces techniques for visualizing structural similarity of database queries. We demonstrate that individual
queries can be visualized using graph visualization techniques. A distance measure based on query structure is
proposed that provides database designers and administrators with a high-level perspective of relationships in
the underlying data.

1 Introduction
Developing an understanding of the underlying structure of information is a key element of information visualization research. Typically, the mapping of data to the
visualization space is based on the user’s model of the
structure of the data. For example, mappings that plot
datapoints close to each other based on their similarity
provide can be used to provide an overall view of the
structure.[10, 11]
In this research we focus on the questions about data,
in the form of database queries, as the information visualization problem. We defer the formal deﬁnition of
query structure to a later section. However, to motivate
the problem consider Figure 1. Although these two simple queries are clearly not equivalent, they are similar.
In particular, they share the same input table.
This simple example illustrates the intuition behind

Figure 1. Two database queries with similar, but not identical structure.

our approach, in which the structure of queries (i.e. attributes, tables, join conditions) can be graphically depicted. This work represents a new approach to database
query comparison that can be used for database design
activities, query optimization, and improved user search
interfaces. We utilize graph-based techniques for visualizing queries based on straightforward structural equivalences. In addition, we deﬁne a straightforward distance
measure that allows collections of database queries to be
visualized according to their structural similarity.
This work differs from traditional query optimization
strategies that transform queries using algebraic identities. Instead, our intention is to provide a user with tools
that will allow them to develop queries faster and easier.
The remainder of this paper is structured as follows.
We outline previous work in Section 2 Section 3 describes the structural components of queries that we consider, as well as graph-based techniques for visualizing
queries. In Section 4 we deﬁne a distance measure for
query similarity and demonstrate its application to collections of queries. Lastly, Section 5 concludes with a
description of future work.

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

= ft:X jt 2 r ^ X Rg.

2 Related Work
Visual representations of database structure are most
frequently used for communicating the design of the
database. Entity-relationship diagrams [5] and Bachman
diagrams [3] are the most frequent styles used. Large
databases cannot be concisely presented on a single diagram. Instead, decomposition of a data model based
on functional area of the application yields more understandable information.
Our earlier work in this area includes an information theoretic approach for visualizing relationships
in data.[9] We also introduced the initial concept of
query structure visualization using graph visualization
techniques.[8]
Clearly, work on visual query speciﬁcation is relevant to our approach. The goal of visual query development, in contrast to ours, is to assist the user in
specifying queries - not uncovering information about
the underlying information structure. Graphical representations of queries based on data model diagrams
has been shown to improve user’s abilities to formulate queries.[1, 2, 4] Some of these approaches include
graph-based presentations.[12, 7]

The underlying basis of our approach is the relational
model.[6] For sake of clarity we identify the key constructs of the relational model that are are employed.
= fR S T g be a database schema with a
First, let
ﬁnite set of relations. For each relation R 2 , we deﬁne a ﬁnite set of attributes, R = fA1 ::: An g. For
each attribute Ai we associate a set of possible values
dom(Ai ), called the domain of Ai . When considering
an instance r we deﬁne adom(Ai ), the active domain
of Ai , to be the set of values existing in r. Note that,
while adom(Ai ) is ﬁnite, dom(Ai ) may be inﬁnite. A
tuple t of is a function dom(Ai ) ! adom(Ai ). Deﬁne
dom(R) = dom(A1 ) : : : dom(An ).
A query q is a function mapping from instances of
relations to instances. We focus on the structural components of such queries for this research. In particular,
we consider relational algebra (RA) queries involving
relation symbols, attributes, and the following relational
operators:
Selection: This operator, written (R), selects tuples
from its input that satisﬁes the boolean condition . The
expression is typically of the form
, where
2
R dom(R) and is a binary relation. For instance ,
( ) = ftjt 2 ^ g.
Projection:
This operator, written
X (R),
projects attributes of R.
For instance , X ( )

R

r

r

r

sr s

select attribute_list
from
table_list
where boolean condition
With respect to the relational algebra, the list of attributes is equivalent to the project operator, the list of
tables is equivalent to the cartesian product operator, and
the boolean condition is equivalent to the select operator.
We assume some familiarity with the relational model
and relational query languages.[6]
In order to visualize query structure we must ﬁrst
identify the structural elements that are contained within
a query. In this section we deﬁne the elements that are
contained within Project-Select-Join (PSJ) queries. In
particular, we focus on relations, attributes, and join conditions.
be a database schema, and q be a PSJ query,
Let
we deﬁne:

R

3 Query Structure

R

Cartesian Product: This operator, written R S , combines relations. For example, if R = fA B C g and
R = fD E g, R S = fA B C D E g. For instances
and ,
= ftjht:A t:B t:C i 2 r ^ht:D t:E i 2 sg.
In practice, the Structured Query Language (SQL) is
used to specify queries against relational database systems. As the name implies, each query is structured with
the following basic syntax:

r

r

r

r

Deﬁnition 3.1 Relation Schema:
f(R c)jR 2 ^ R occurs c times in qg

R

Rel(q)

=

It is sometimes useful to consider the set of relations
without their occurrence count:
Deﬁnition 3.2 Relation:

fRj(R c) 2 Rel(q) ^ R = R g
0

0

Let q be a query and
we deﬁne:
Deﬁnition 3.3 Project

Schema:

q

be a query,

Sch(q )

= f= 6= <

>

A A be a select expression in q , we deﬁne:
0

=

be a project expression in q ,

f(R A)jR 2 R ^ A 2 g
Let

Relation(q)

=
g,

and

00

Deﬁnition 3.4 Select

Schema:

Sch(q )

=

f(R A)jR 2 R ^ R 2 q ^ A 2 R ^ A = A _ A = A ]g
0

00

Building upon the select schema, we deﬁne the join
conditions in a query:
Condition:
Join(q)
=
S B ij(R A) 2 Sch(q )^(S B ) 2

Deﬁnition 3.5 Join

fhR A

Sch(q )g

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

In summary, we consider these elements to be the
base structure of a query. Consider the following example:

of the properties. For example, if q1 and q2 are Join
and Select Schema equivalent we denote the equivalence by
q1 Sch( ) Join q2 .

Example 3.1

3.2 Visualizing Query Structure as Graphs

Consider the following relations:

Emp = fEmpID EmpName Salary DeptIDg
Dept = fDeptId DeptName ManagerIDg

We’ll use the following query: List employee names and
the names of departments that each employee works for. The
relational algebra expression for this query is:

EmpName DeptName (
Emp:DeptID=Dept:DeptID (Emp

Dept)))

The SQL query is:

select E.EmpName,D.DeptName
from
Emp E, Dept D
where E.DeptID = D.DeptID
The structural elements for this query are:

Relation(q) = fEmp Deptg
Sch(q ) = f(Emp EmpName) (Dept DeptName)g
Sch(q ) = f(Emp DeptID) (Dept DeptID)g
Join(q) = fhEmp DeptID = Dept DeptIDig
3.1 Structural Domination and Equivalence
Using the base structural elements deﬁned in the previous section we deﬁne in this section the concept of structural equivalence. Structural equivalence provides the basis for
comparing queries, which we use for visualization purposes.
Given two queries q1 and q2 we say that q1 alphadominates q2 , written q1
q2 , if q1 dominates q2 relative
to some property . The properties that we consider for are
the structural elements of the query, dilineated below:
Relation Domination:

Rel(q1 ) Rel(q2 ) ! q1

Sch(q1 ) Sch(q2 ) ! q1

Sch( ) q2

Sch(q1 ) Sch(q2 ) ! q1

Sch( ) q2

Select Schema Domination:

Join(q1 ) Join(q2 ) ! q1

f

g

= ( )
=
= f( )j
2 g

Example 3.2
Let q1
=
S ), q2 =
R:A=S:A(R
S
T ), and q3 =
R:A=S:A^R:B=T:B (R
R:A=S:A^R:B=U:B(R U ). Figure 2 shows the graph for

these queries. Note that the graph demonstrates the dominance
relation q1 Join q2 .

Rel q2

Project Schema Domination:

Join Domination:

We utilize a graph-based model for depicting query structure. A graph is represented by G
VE. V
vi vj vi vj V
v1 : : : vn is the set of vertices. E
is the set of edges in the graph. We consider two types of vertices in the graphs we draw - relations and queries. Edges are
drawn between each query and the relations contained in the
query. In addition, edges are drawn between the relations if a
join condition exists for some query involving those relations.
Queries are drawn radially according to their time of occurrence, with the 12 o’clock position being the starting point.
When more than one query is visualized the similarity between the queries is graphically derived from the graph structure in two ways. First, queries that are join equivalent are
drawn as the same graph, with color being used to show an
increased frequency for those queries. Second, relations are
drawn only once , which allows for non-equivalent queries
that share some (but not all) of the join conditions to become
connected. Example 3.2 shows the graph generated for three
queries. The relations are drawn to the midpoint between all
queries that refer them.

Join q2

Given these structural domination properties we can deﬁne
the concept of structural equivalence. Again, given two queries
q1 and q2 we say that q1 is alpha-equivalent to q2 , written
q1
q2 , if q1 alpha q2 and q1
q2 , again relative to
some property . Accordingly, we deﬁne the following alphaequivalent properties:
Relation Equivalent:
q1 Rel q2
Project Schema Equivalent: q1 Sch( ) q2
Select Schema Equivalent:
q1 Sch( ) q2
Join Equivalent:
q1 Join q2
In cases where queries may be alpha-equivalent in more
than one way we extend alpha to be a logical expression

Figure 2. A graph showing three queries.
The technique can scale up to support a modest number
of queries. For example, Figure 3 shows the graph for 100
randomly generated queries. We use random queries in order
to evaluate the basic properties of our approach and to not be
biased by any one set of real-life data. As expected, the relations used in the queries are clustered towards the center of the

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

Note that the similarity measure is not a distance metric,
since Sim(A A) = 1. However, the dissimilarity measure,
Dis(A B ) = 1 Sim(A B ), does satisfy the following
properties, and is a distance metric:

Dis(A A) = 0 Dis(A B ) 0
Dis(A B ) = Dis(B A)
Dis(A C ) Dis(A B ) + Dis(B C )
Using this measurement we can deﬁne the similarity between queries based on their structure. The distance between
two queries is deﬁned by two vectors. The ﬁrst is a vector of
dissimilarities and the second is a vector of weights.
Deﬁnition 4.3

Dis = hDis1 : : : Dis i
k

Each Dis refers to a speciﬁc dissimilarity measure parameterized by two particular sets. For example, given two queries
q and q0 , Dis = hDis(Relation(q) Relation(q0 )i illustrates the approach.

Figure 3. A graph showing 100 randomly
generated queries.

P

Deﬁnition 4.4 W =
and ki=1 wi = 1.

hw1 : : : wk i, such that wi 2

0

: : : 1]

The distance between two queries is deﬁned:
graph. We would expect that, in the limit, all relations would
converge to a single, central point for random data.
The graph-based visualizations we presented in this section
are useful due to their one-to-one correspondence to the underlying model of the data. However, comparisons across all of
the structural equivalences while maintaining the correspondence to the model is not likely to yield a meaningful global
view due to the locality of the query to query connectivity. In
essence, the graphs appear more useful for local, small scale
comparisons of the query structure. We expand upon this technique in the next section by developing a distance measure that
combines the structural equivalences.

4 Query Similarity
In this section we develop a framework for combining the
structural equivalence mechanism into a distance measure that
provides an overall description of similarity between queries.
The framework is ﬂexible, and allows the user to manipulate
the inﬂuence of the structures according to a set of deﬁned
weights.
We utilize a straightforward distance measure based on the
similarity of the sets deﬁned by the structures deﬁned in Section 3. Given any two sets A and B we deﬁne the similarity
between the sets:
Deﬁnition 4.1

Sim(A B ) = jA \ B j=jA B j

We also deﬁne a corresponding dissimilarity measure:
Deﬁnition 4.2

Dis(A B ) = 1 Sim(A B )

D(q q ) = P =1 Dis w

Deﬁnition 4.5 Given two queries q and q 0 ,
k
i

0

i

i

The weights are used to control the inﬂuence of the structure comparisons. For example, a user may be more interested
in ﬁnding queries that are more similar in their use of relations
than in the attributes being projected. Example 4.1 demonstrates the use of this framework.
Example 4.1
Consider the same relations from Example 3.1:

Emp = fEmpID EmpName Salary DeptIDg
Dept = fDeptId DeptName ManagerIDg
We’ll use the following queries:

q1 = List employee names and the name of their depart-

ment

q2

=

List employee names and the name of their man-

ager

q3 = List employee names
The SQL syntax for these queries is:
select E.EmpName, D.DeptName
from
Emp E, Dept D
where E.DeptID = D.DeptID
select E1.EmpName, E2.EmpName
from
Emp E1, Dept D, Emp E2
where E1.DeptID = D.DeptID AND
E2.EmpId = D.ManagerID

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

select E.EmpName
from
Emp E
For each pair of queries we will use the following dissimilarity measures:

=
2 =
3 =

(
(
(

()
) (
) (

Dis1

Dis Relation q

Dis

Dis Sch q

Dis

(
(

Sch q

Dis Sch q

( ))

Relation q

Sch q

0
0

))
))

0

We summarize the dissimilarities in the following table:
Dis1
q1

q2

Dis2
q3

q1

q2

Dis3
q3

q1

q2

0
0
0.5
0
0.5 0.5
0
0.5
q2
0
0
0.5 0.5
0
0
0.5
0
q3
0.5 0.5
0
0.5
0
0
1
1
1 1 1
Using equal weights W
h 3 3 3 i we compute the
tance between each query:
q1

=

q3

1
1
0
dis-

( ) = 0 33
( 1 3 ) = 0 66
( 2 3 ) = 0 50

D q1 q2

:

D q

q

:

D q

q

:

Figure 4. The matrix representation for
pairwise comparisons of structural similarity for 100 randomly generated queries.

According to these weights q1 and q2 are most similar. If
1
1
h2
we consider a different set of weights W
2 i we get a
different distance comparison:

=

0

( ) = 0 25
( 1 3 ) = 0 75
( 2 3 ) = 0 75

D q1 q2

:

D q

q

:

D q

q

:

q2

Under this weighting scheme the similarity between q1 and
becomes even more obvious.

4.1 Visualizing Query Similarity
In this section we utilize the distance measurement framework described in the previous section to generate visualizations of a collection of database queries in order to get an
overall feel for the similarity between queries. For data we
have created a utility to create random queries. For purposes
of maintaining continuity with the previous section we will use
the same dissimilarity measures and both weighting schemes.
We utilize a matrix layout for representing the similarity
showing the pairwise comparisons for all queries. The matrix
allows us to simultaneously use two weighting schemes. A
simple color scale is used to communicate similarity:

Figure 5. Visualization for 1000 random
queries.

Red - 75-100% similar
Yellow - 50-75% similar
Green - 25-50% similar
Blue - 1-25% similar
Black - No similarity

Figure 4 shows the resulting visualization for the same 100
queries using the graph technique. The lower left portion of the
matrix uses equal weights, while the upper right portion uses
the weighting scheme that ignores the attributes projected.
Certain patterns are worthy of further explanation. First,
the equal weighting scheme does not discriminate well be-

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

tween the queries, as evidenced by the lower left portion of
the display. The other weighting scheme shows a number of
queries that have high similarity to other queries. The random
nature of the data yields many queries that have average similarity when the number of relations is modest - in this case 50.
When the number of queries is increased to 1000 (e.g. more
diverse searches) the sparsity yields better discrimination between the queries, even for the simple weighting scheme, as
shown in Figure 5.
We show a magniﬁcation of the data in Figure 6. As can
be seen in this ﬁgure, there are numerous examples of similar
queries.

users. Secondly, database administrators can use the technique for identifying frequently-used queries and then construct views to support more effective queries. Thirdly, for
database designers a view of similar queries might suggest
constraints or index methods to improve performance.

Acknowledgements
I would like to thank the Database Research Group at Indiana University for their feedback on early stages of this work.

References

Figure 6. Upper left section of the previous
visualization.
The results shown in this section indicate that a coarser similarity measure, if chosen correctly, does better at separating
the datapoints than a measure that considers more comparisons. This is positive, in the sense that simple comarisons
may yield an easier understanding of the phenomenon for end
users.

5 Conclusion and Future Work
This paper describes an approach to similarity-based visualizations of database queries. A formalism for identifying the
structural components of queries was presented. A combined
distance measure framework was described that supported all
pairwise comparisons of queries. Through this approach we
gain insight into our data that is otherwise unavailable.
We envision several applications in which thiese techniques
might be useful. First, as a user interface for information retrieval or data browsing activities, in which a user could get visual feedback and guidance on similar queries posed by other

[1] M. Angelaccio, T. Catarci, and G. Santucci. QBD*: A
fully visual query system. Journal on Visual Languages
and Computing, 1(2):255–273, 1990.
[2] M. Angelaccio, T. Catarci, and G. Santucci. QBD*: A
graphical query language with recursion. IEEE Transactions on Software Engineering, 16(10):1150–1163, 1990.
[3] C. Bachman. Data structure diagrams. Data Base, 1(2),
March 1969.
[4] T. Catarci, M. F. Costabile, S. Levialdi, and C. Batini.
Visual query systems for databases: A survey. Journal of
Visual Languages and Computing, 8(2):215–260, 1997.
[5] P. P. S. Chen. The entity-relationship model — toward a
uniﬁed view of data. Proceedings of the 1th Conference
on Very Large Databases, Morgan Kaufman pubs. (Los
Altos CA), Kerr(ed), pp.173, 1975.
[6] E. F. Codd. A Relational Model for Large Shared Data
Banks. Communications of the ACM, 13(6):377–387,
1970.
[7] I. F. Cruz. DOODLE: a visual language for objectoriented databases. In SIGMOD 1992, Proceedings ACM
SIGMOD International Conference on Management of
Data, pages 71–80, 1992.
[8] D. P. Groth. Visualizing query structure. In Proceedings
of the 18th ISCA International Conference on Computers
and Their Applications CATA, March 2003.
[9] D. P. Groth and E. L. Robertson. An entropy-based approach for visualizing database structure. In Proceedings
of the Sixth IFIP Conference on Visual Database Systems
(VDB6), pages 157–170, May 2002.
[10] T. Kohonen. Self-Organizing Maps. Springer-Verlag,
1997.
[11] J. D. Leeuw and G. Michailidis. Graph layout techniques
and multidimensional data analysis, 2000.
[12] J. Paredaens, J. V. den Bussche, M. Andries, M. Gemis,
M. Gyssens, I. Thyssens, D. V. Gucht, V. Sarathy, and
L. V. Saxton. An overview of GOOD. SIGMOD Record,
21(1):25–31, 1992.

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE


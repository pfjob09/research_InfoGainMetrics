Balloon Views of Source Code and Their Multiscalable Font Modes
Chun-Cheng Lin, Hsu-Chun Yen∗
Department of Electrical Engineering, National Taiwan University, Taipei, Taiwan 106, ROC
sanlin@cobra.ee.ntu.edu.tw, yen@cc.ee.ntu.edu.tw

Abstract
The majority of program editors available on the market support the view of a directory-explorer style to display
only those code lines of interest. Among them, the fisheye
and the fractal views of source code (in which each line has
a value reflecting the degree of interest and importance)
have received a lot of attention in the literature. In information visualization, drawing trees based on fractal theory
also plays an interesting role as the so-called balloon drawing of hierarchical data includes two models: the fractal
and the SNS (subtrees with nonuniform sizes) models. It is
therefore natural to consider a new source code visualization style based on the SNS model of balloon drawing. A
main feature of the SNS view is that the value of each line
reflects the number of its descendants when the source code
is viewed as a tree structure. Unlike the view of a directoryexplorer style, the multiscalable font mode (which was originally utilized in the fractal view of source code) displays all
the lines in such a way that each line has the font size proportional to its value. In this paper, we investigate various
issues concerning the multiscalable font modes of the fisheye, the fractal, and the SNS views of source code, in hope
of providing guidelines for the programmer to better comprehend the program code in practice.

1. Introduction
In developing a huge and complicated program, the programmer often not only applies the text editor to writing the
program, but also observes a variety of views of the program
source code to comprehend the program. Suppose we consider the program source code as a hierarchical structure.
The source code view in some common program editors,
like a directory explorer, allows the programmer to hide
or show the source code lines of lower levels by clicking
the line of the upper level. With this feature, programmers
can show on the screen only the lines that they concern,
∗ Corresponding author. Research supported in part by Grants 95-EC17-A-02-S1-049 and NSC 95-2221-E-002-074.

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

which preserve the outline of the source code. In addition,
in object-oriented programming, the class view, which gives
the visual directory explorer of the hierarchical relation of
classes and variables, makes it easy for programmers to navigate, understand, and manipulate the classes and variables.
Designing a source code view which fits the needs of
programmers (i.e., allowing them to easily understand and
navigate through the codes) is of increasing importance,
especially for those writing new codes based upon existing codes possibly created by other programmers. Previous work along this line of research includes the following. Furnas [6] proposed the fisheye view of source code,
in which a focus line is selected and each source code line
is assigned a value, called degree of interest (DOI), calculated by its a priori importance and its distance from the
focus line; the lines with DOI less than a certain threshold
are hidden, i.e., only the interesting lines are shown. Recently, the work of [7] presented an empirical evaluation
of the fisheye view that emphasizes both the measures of
usability and the analysis of interaction patterns (as compared to the linear view of source code). As programs of
a huge size are not uncommon in practice, navigating the
source code line by line in the fisheye view may cause the
amount of the displayed information to grow beyond any
reasonable scale that can be handled by a programmer. To
overcome this shortcoming, Koike [9] proposed the fractal
view of source code, in which every source code line is assigned a value calculated according to fractal theory, and
he showed that the amount of the displayed information is
always kept nearly constant no matter where the focus line
is located. In order to demonstrate the effect of the fractal view, a multiscalable font mode of the fractal view was
given, showing all the source code lines each of which has
the font size proportional to its associated value. It was suggested in [9] that this mode helps the user to understand the
relation between the views before and after a change of the
focus line.
The fisheye view is successful in the visualization of not
only the source code but also the graphical data [5, 13],
which gets a lot of attention in the society of graph drawing (or information visualization in a broader sense). Graph

drawing addresses the issue of constructing geometric representations of graphs in a way to gain better understanding
and insights into the graph structures. For a program source
code, if each line is viewed as a node and every hierarchical
relation between two lines is viewed as an edge, the program source code corresponds to a tree structure. In the
literature of graph drawing, there exist a lot of algorithms
for drawing tree structures, e.g., layered tree drawing [12],
radial drawing [3] and balloon drawing [1, 8, 10, 11] with
respect to cone trees , and so on. Since the majority of algorithms for drawing trees take linear time, tree structures
are suited to be used in an environment in which real-time
interactions with users are frequent. Very recently, the work
of [4] suggested to apply the drawing of the tree structure
representing the program source code to visualizing the hierarchical relationship.
In this paper, our work is associated with the balloon
drawing of a tree structure, which is a style of tree drawing having the following properties (see also Figure 1): all
the children under the same parent are placed on the circumference of the circle centered at their parent; there exist no edge crossings in the drawing; for the two edges on
any path from the root node, the farther from the root an
edge is, the shorter its drawing length becomes. Note that
there exist two models in the literature for generating balloon drawings of trees, as shown in Figures 1 (a) and (b),
respectively. Given a node v, let r(v) be the radius of the
drawing circle centered at v. If we require that r(v) = r(w)
for arbitrary two nodes v and w that are of the same depth
from the root of the tree, as shown in Figure 1 (a), then
such a drawing is called a balloon drawing under the fractal model [10]. Unlike the fractal model, the subtrees with
nonuniform sizes (abbreviated as SNS) model [1, 8] allows
subtrees associated with the same parent to reside in circles
of different sizes, as shown in Figure 1 (b), and hence, the
drawing based on this model often results in a clearer display on large subtrees than that under the fractal model.

view of source code, and noticing that the balloon drawing
of a tree structure involves the fractal model and the SNS
model, in this paper we devise the multiscalable font mode
of the SNS view of source code, where the font size of each
source code line is proportional to a value that is derived
from the balloon drawing under the SNS model for the tree
structure representing the program code. Similarly, the multiscalable font mode of the fisheye view of source code also
can be defined. In addition to helping users to understand
the relation between the views before and after they change
their focus lines [9], the multiscalable mode also has the advantage that the size of the value of each source code line
is visible to users by observing its font size, as compared to
the original view of the directory-explorer style.
Generally speaking, we refer the fractal and the SNS
views of source code as the balloon view of source code. In
this research, we implement the multiscalable font modes
of the fisheye, the fractal, and the SNS views, and compare
their characteristics qualitatively. The experimental results
reveal that the multiscalable font mode of each of the above
three views has its pros and cons, and hence, we suggest that
in practice the programmers should consider the multiscalable font modes of all the three views for comprehending
the program deeply. Other work concerning the visualization of source code includes the XML approaches (e.g., see
[2]), which attach some information to the source code for
storing and representing the source code. The results of this
paper are not compared with those work because we are
concerned only with the source code without attaching additional information. The main contributions of this paper
are summarized as follows:
• The SNS view of source code is devised.
• Similar to the multiscalable font mode of the fractal
view of source code, the multiscalable font modes of
the fisheye and the SNS views of source code are defined and investigated.
• The discussion and comparison of the pros and cons of
the multiscalable font modes of the fisheye, the fractal,
and the SNS views are given.

2. Preliminaries
2.1. Tree structure of source code
(a)

(b)

Figure 1. Balloon drawings under (a) the fractal model and (b) the SNS model.

Inspired by the multiscalable font mode of the fractal

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

In this paper, we view the program source code as a tree
structure (e.g., see also Figure 2), in which each source code
line is viewed as a node labeled by its line number; each hierarchical relation of two source code lines is viewed as an
edge; a virtual node labeled by 0, as the initial root, is connected to all the nodes at the upmost level. As navigating
a view of source code, we selected a source code line as

the focus line (focus node) at every moment, and every approach to generating a view of source code considers the
tree structure taking the focus node as a new root.
root (initial focus)
0

1 #include <iostream.h>
2 void main() {
3
int i, sum = 0;
4
for ( i = 1 ; i <= 10 ; i++ ) {
5
sum += i;
6
}
7
cout << sum << endl;
8 }

1

2
3 4

8
6

7

5

Figure 2. The relationship between a program
source code and a tree structure.

In the fisheye view of source code [6], each line is assigned a degree of interest (DOI), which is computed by
its a priori importance and its distance from the focus line.
That is, given the focus line y, the generalized fisheye DOI
at line x is expressed as
DOIf isheye (x|. = y) = AP I(x) − D(x, y)
where AP I(x) is the global a priori importance of x and
D(x, y) is the distance between x and the focus line y. Here
we are concerned with the DOI for tree structures. Given the
focus line y in a tree structure representing certain source
code, the DOI at line x can be computed as
DOIf isheye(tree) (x|. = y) = −dtree (x, root)−dtree (x, y)
(1)
where dtree (x, y) is denoted as the path length distance
between x and y in the tree structure, i.e., D(x, y) =
dtree (x, y). Intuitively, it is fair to assume that the nodes at
the levels closer to the root are more important, and hence,
we let AP I(x) equal −dtree (x, root), i.e., the distance of
x from the root.

2.3. Fractal view of source code
The theory behind the fractal view of source code is basically from Koike’s work [9]. Consider a tree structure of
source code. By viewing the focus line as a new root, we
assign each node of the tree a so-called fractal value in a
top-down fashion. Initially, the fractal value of the focus is
assigned to 1. The fractal values of the other nodes are propagated by multiplying a ratio correlated with their branch
numbers. That is, the formulas for computing the fractal
values can be expressed as follows:

x

= 1
= γx × F vx

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

where F vx is the fractal value of node x; C is a constant
for 0 < C ≤ 1; Nx is the number of branches of node
x; D is the fractal dimension. For convenience, throughout
this paper we assume that C = D = 1, i.e., the ratio γx
of each node x is correlated only with its branch number.
(In fact, the modification of C and D does not affect our
conclusion.) Koike also gave the multiscalable font mode
of the fractal view of source code [9], in which the font size
of each source code line is proportional to its fractal value
(see the right subfigures of Figures 4 (c) and (d)).

2.4. Balloon drawings of rooted trees

2.2. Fisheye view of source code

F vf ocus
F vchild of

γx = CNx−1/D = Nx−1

(2)

There exist two models in the literature for generating
balloon drawings of trees: the fractal model and the SNS
model. The balloon drawing of a tree structure under the
fractal model means that if rm and rm−1 are the lengths of
edges at depths m and m − 1, respectively, then
rm = γ × rm−1
where γ is the predefined ratio (0 < γ < 1) associated with
the drawing under the fractal model. Clearly, edges at the
same depth have the same length in a fractal drawing.

j

Rj+1

free_arc

Rj-1

Rj

r

O

r
O = c0

R1
1

RO

w1(i)
w0(i) ci

wedge i

Rmin
free_arc
vparent

(b)

(a)

Figure 3. The SNS model. (a) Node O is not
the root, and the edge between O and its parent goes through a circle with radius Rmin ;
(b) is a star graph centered at c0 .
Given a rooted ordered tree T with n nodes, a balloon
drawing under the SNS model [1, 8] can be obtained in
O(n) time in a bottom-up fashion with the edge length and
the angle between two adjacent edges respectively by:
RO
θj

∼
= max(

2

j

Rj

, Rmin ) + max{Rj }
j
2π
R
+
f
ree
arc
+
R
j−1
j
∼
=
r

(3)

where Rj is the radius of the outer circle enclosing all subtrees of the j-th child of O, and RO is the radius of the outer

circle enclosing all subtrees of O (see Figure 3). Since there
exists a gap between C and the sum of all diameters, such a
gap can be distributed evenly to every θj (see f ree arc in
Figure 3).

3. Our results
3.1. SNS view of source code
In view of the relationship between the fractal view of
source code [9] and the balloon drawing under the fractal
model [10], we establish the SNS view of source code according to the theory behind the balloon drawing under the
SNS model [1, 8] as follows.
Consider a tree structure of source code taking the focus
as a new root. In the bottom-up fashion of the tree, we assign each node a so-called SNS value. In the beginning, all
the leaves are assigned to 1. According to Eq. (3), the SNS
value of each of the other nodes is computed by the sum of
the SNS values of all its children as well as the maximum
among its children. The formulas for computing the SNS
values are expressed in the following:

 Svleaf = 1
= max( j Svchildj of x /π, 1)
Svx
(4)

+ maxj {Svchildj of x }
where Svx is the SNS value of node x.
After each node is assigned a value by Eq. (4), the SNS
value of the focus (Svf ocus ) must be the largest among all
the values. In order to facilitate the comparison of the SNS
value and the fractal value, we use the following formula to
adjust the scale of the SNS values such that the largest value
becomes 1:
Svx ←

Svx
Svf ocus

, for each node x

In general, we say that the fractal view and the SNS view
of source code belong to the balloon view of source code.

3.2. Implementation of diﬀerent views of
source code
Based on the theory explained in the previous subsections, we have that each source code line is associated with
a value. In the fisheye view (resp. the fractal view and the
SNS view), the value is called DOI (resp. the fractal value
and the SNS value). It should be noted that in implementing the three views, the deviation among the font sizes of
lines may not be obvious, or the deviation is too large that
it is not easy to observe the lines with small values. Consequently, we apply the power function (resp. the logarithmic

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

function) to raising (resp. lessening) the strength of the deviation among the font sizes of lines.
For comparison purpose, our target program source code
is the same as [9], which is in fact derived from [6].
In our investigation, the multiscalable font mode involves both the text mode and the box mode. The text
mode is just another representation of the multiscalable font
mode, which shows all the source code lines (with font sizes
proportional to their values) in the text form; the box mode
shows all the lines in the rectangular box form for abstracting out irrelevant details. The left (resp. right) subfigures
of Figures 4 (a), (c), and (e) are the text mode (resp. box
mode) of the fisheye, the fractal, and the SNS views of the
target source code focusing on line 0. The left (resp. right)
subfigures of Figures 4 (b), (d), and (f) are the text mode
(resp. box mode) of the fisheye, the fractal, and the SNS
views of the target source code when the focus is on line
24. In the text mode, the detail of each code line is illustrated, giving the user meaningful information; in the box
mode, each box differentiates its importance from the others through the box height, which lets the user easily be able
to compare the difference from either its own modification
or the other views.

3.3. A experimental comparison among
three diﬀerent views of a source code
In this subsection, we compare in a qualitative way the
display of the target source code under the fisheye view, the
fractal view as well as the SNS view. The pros and cons
of each of the three visualization styles are discussed with
respect to the following desirable properties in source code
visualization:
(P1 ) For ease of navigating the code, it is desirable to be
able to easily trace the path from the focus to the root
of the tree structure associated with the underlying program.
(P2 ) To understand the complexity of a program code, it is
useful to find out qualitatively the amount of descendants of a line, which in turn symbolizes the degree of
its importance in the program.
(P3 ) In order to fit a program code into a limited display
area, it is desirable to keep the amount of the lines with
font size larger than a threshold fixed.
(P4 ) As far as understanding the structure of a program is
concerned, it is helpful to be able to tell the importance
of a line by observing its font size in the initial view
(i.e., focusing on line 0 of the program code).
• Fisheye view:
(Pros) Under the fisheye view [6], it is easy to trace the

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54

# d e f i n e DI G 4 0
# i n c l u d e <s t d i o . h >
ma i n ( )
{
i n t c , i , x [ DI G/ 4 ] , t [ DI G/ 4 ] , k = DI G/ 4 , n o p r i n t = 0 ;
wh i l e ( ( c = g e t c h a r ( ) ) ! = EOF ) {
i f ( c > = ’ 0 ’ && c < = ’ 9 ’ ) {
x[ 0] = 10 * x[ 0] + ( c - ’ 0’ ) ;
f o r ( i =1 ; i <k ; i ++) {
x[ i ] = 10 * x[ i ] + x[ i - 1] / 10000;
x [ i - 1 ] %= 1 0 0 0 0 ;
}
} el se {
s wi t c h ( c ) {
c a s e ’ +’ :
t [ 0] = t [ 0] + x[ 0] ;
f o r ( i =1 ; i <k ; i ++) {
t [ i ] = t [ i ] + x[ i ] + t [ i - 1] / 10000;
t [ i - 1 ] %= 1 0 0 0 0 ;
}
t [ k - 1 ] %= 1 0 0 0 0 ;
br e a k;
case ’ - ’ :
t [ 0] = ( t [ 0] + 10000) - x[ 0] ;
f o r ( i =1 ; i <k ; i ++) {
t [ i ] = ( t [ i ] + 10000) - x[ i ] - ( 1 - t [ i - 1] / 10000) ;
t [ i - 1 ] %= 1 0 0 0 0 ;
}
t [ k - 1 ] %= 1 0 0 0 0 ;
br e a k;
case ’ e’ :
f o r ( i =0 ; i <k ; i ++) t [ i ] = x [ i ] ;
br e a k;
c a s e ’ q’ :
e xi t ( 0) ;
de f a ul t :
nopr i nt = 1;
br e a k;
}
i f ( ! nopr i nt ) {
f o r ( i = k - 1 ; t [ i ] < = 0 && i > 0 ; i - - ) ;
p r i n t f ( " %d " , t [ i ] ) ;
i f ( i > 0) {
f o r ( i - - ; i >= 0 ; i - - ) {
p r i n t f ( " %0 4 d " , t [ i ] ) ;
}
}
put c ha r ( ’ ’ ) ;
f o r ( i =0 ; i > k ; i ++) x [ i ] = 0 ;
}
}
nopr i nt = 0;
}
}

(a) Fisheye view (focus node on line 0).

(b) Fisheye view (focus node on line 24).

(c) Fractal view (focus node on line 0).

(d) Fractal view (focus node on line 24).
1

# d e f i n e DI G 4 0

2

# i n c l u d e <s t d i o . h >

3

ma i n ( )

{

1

# d e f i n e DI G 4 0

4

2

# i n c l u d e <s t d i o . h >

5

i nt

6

wh i l e ( ( c = g e t c h a r ( ) )

3

ma i n ( )

4

{

5

6

7

c,

i,

x [ DI G/ 4 ] ,

t [ DI G/ 4 ] ,

k = DI G/ 4 ,

nopr i nt

i f ( c >= ’ 0 ’

8

= 0;

c,

i,

x [ DI G/ 4 ] ,

t [ DI G/ 4 ] ,

k = DI G/ 4 ,

nopr i nt

= 0;

x[ i ] = 10 * x[ i ]

i f ( c >= ’ 0 ’

9

f o r ( i = 1 ; i < k ; i + +) {

10

x[ i ] = 10 * x[ i ]

11

x[ i - 1]

12

+ x[ i - 1] / 10000;

s wi t c h ( c ) {

15

%= 1 0 0 0 0 ;

}

+ x[ i - 1] / 10000;

} el se {

14

+ ( c - ’ 0’ ) ;

%= 1 0 0 0 0 ;

}

13

!=

&& c < = ’ 9 ’ ) {
x[ 0] = 10 * x[ 0]

x[ i - 1]

12

wh i l e ( ( c = g e t c h a r ( ) )

7
8

+ ( c - ’ 0’ ) ;

f o r ( i = 1 ; i < k ; i + +) {

10
11

i nt

! = EOF ) {

&& c < = ’ 9 ’ ) {
x[ 0] = 10 * x[ 0]

9

c a s e ’ +’ :

16

t [ 0] = t [ 0] + x[ 0] ;

17

f o r ( i = 1 ; i < k ; i + +) {

18

13

} el se {

14
15

t [ i ] = t [ i ] + x[ i ] + t [ i - 1] / 10000;

19

s wi t c h ( c ) {

t [ i - 1]

20

}

21

t [ k- 1]

22

br e a k;

%= 1 0 0 0 0 ;

%= 1 0 0 0 0 ;

c a s e ’ +’ :

16

t [ 0] = t [ 0]

17

f o r ( i = 1 ; i < k ; i + +) {

18

t[i] = t[i]

19

t [ i - 1]

20

23

+ x[ 0] ;

+ x[ i ]

+ t [ i - 1] / 10000;

%= 1 0 0 0 0 ;

}

21

t [ k- 1]

22

case ’ - ’ :

%= 1 0 0 0 0 ;

br e a k;

23

24

case ’ - ’ :

24

t [ 0] = ( t [ 0]

25

f o r ( i = 1 ; i < k ; i + +) {

+ 10000)

- x[ 0] ;

26

t[i] = (t[i]

27

t [ i - 1]

28

}

29

t [ k- 1]

30

+ 10000)

- x[ i ]

-

(1 -

t [ i - 1] / 10000) ;

%= 1 0 0 0 0 ;

t [ i ] = ( t [ i ] + 10000) - x[ i ] - ( 1 -

27

t [ i - 1]

28

f o r ( i = 0 ; i < k ; i + +)

33

t[i]

= x[ i ] ;

t [ k- 1]

30

35

case ’ e’ :

32

e xi t ( 0) ;

f o r ( i = 0 ; i < k ; i + +)

33

de f a ul t :
nopr i nt

38

c as e ’ q’ :

35

e xi t ( 0) ;

36

}

40

i f ( ! nopr i nt ) {

de f a ul t :

37

41

f o r ( i =k -

1; t [ i ]

p r i n t f ( " %d " , t [ i ] ) ;

if(i

> 0; i - - ) ;

> 0) {

44

f or ( i - -

;

i

>= 0 ;

i--){

}

40

i f ( ! nopr i nt ) {
f o r ( i =k -

42

p r i n t f ( " %0 4 d " , t [ i ] ) ;

= 1;

br e a k;

39

41

45
46

nopr i nt

38

< = 0 && i

42

43

t [ i ] = x[ i ] ;

br e a k;

34

= 1;

br e a k;

39

%= 1 0 0 0 0 ;

br e a k;

31

37

=

t [ i - 1] / 10000) ;

%= 1 0 0 0 0 ;

}

29

br e a k;
c a s e ’ q’ :

36

f o r ( i = 1 ; i < k ; i + +) {

26

case ’ e’ :

34

t [ 0]

25

%= 1 0 0 0 0 ;

br e a k;

31
32

1; t [ i ]

<= 0 && i

> 0; i - - ) ;

p r i n t f ( " %d " , t [ i ] ) ;

43

if(i

> 0)

{

}
44

47

f or ( i - - ;

i

>= 0 ;

i--){

}
45

48

put c ha r ( ’

p r i n t f ( " %0 4 d " , t [ i ] ) ;

’);
46

49

f o r ( i =0 ;

i

> k ; i ++)

}

x[ i ] = 0;
47

50

}

51

nopr i nt

put c ha r ( ’

49

= 0;

f o r ( i =0 ;

50

}

54

}

48

}

52
53
}

> k ; i + +)

x[ i ] = 0;

}

52

nopr i nt

53
54

’);
i

}

51

= 0;

}
}

(e) SNS view (focus node on line 0).

(f) SNS view (focus node on line 24).

10

line No.

50
40
30
20
10
0

line No.

0

line No.

SNS value

SNS value

10

50
40
30
20
10
0

line No.

Figure 5. The value of each line vs. the number
of its descendants (focus node on line 0).

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

50

50

40

40

30

30

20

20

10

10
0

line No.

60
50
40
30
20
10
0

fractal value

20

20

60

60

line No.

# of descendents

30

30

fisheye DOI

40

40

0

fractal value

50

50

# of descendents

fisheye DOI

Figure 4. Experimental results.

0

line No.

60
50
40
30
20
10
0

line No.

Figure 6. The value of each line vs. the number
of its descendants (focus node on line 24).

path from the focus line to the root of the tree structure associated with a program. To see this, consider Figure 4(b).
Assuming line 24 to be the focus, the concerned path can
be found by following lines 24, 23, 14, 13, 6, and 4. It is
worth pointing out that all the lines on such a path from
the focus line to the root are of the same font size and also
the largest among all the lines in the code. With the help of
such an advantage of tracing the program structure upwards,
a programmer can easily realize the structure in which the
current focus lies. Again take the left subfigure of Figure
4(b) for example. The focus (i.e., line 24) is located within
a ‘case’ of ‘switch’, the ‘switch’ is in the ‘else’ block, and
the ‘else’ block is in a ‘while’ loop in ‘main’. A change in
view is easily calculated because only the DOIs on the path
from the focus to the root need be adjusted.
(Cons) The initial view (i.e., focusing on line 0 of the program code) does not reveal any meaningful information, as
all the lines are of the same size (see Figure 4(a)). In comparison with the fractal view, the amount of the lines with
font size larger than the threshold cannot be controlled, and
the lines at the same level of a tree cannot be observed in
the initial view. Compared to the SNS view, the number of
descendants of any line cannot be observed.
• Fractal view:
(Pros) Displaying a source code based on the fractal view
enjoys the following merits. By fractal theory, it is easy to
observe that the amount of lines with font size larger than
a certain fixed threshold is fixed, and is independent of the
focus [9]. In the initial fractal view, the lines at the same
level of the changed tree are of the same font size, as shown
in Figure 4(c). A fractal-view display of a program corresponds to a balloon drawing of a rooted tree.
(Cons) Although the lines at the same level of a tree are of
the same font size, this does not necessarily give meaningful
information. For example, in Figure 4(d), lines 14 and 25
are of the same font size in spite of the fact that they are not
really related to each other. In comparison with the fisheye
view, the path from the focus to the root cannot be traced
straightforwardly; such a path can only be traced indirectly.
Unlike the SNS view, the font size of a line does not reflect
the number of descendants of that line.
• Balloon view under the SNS model:
(Pros) This visualization style enjoys the merit that the font
size of a line reflects the number of its descendants. For example, consider Figures 4 (a) – (f). The number of descendants of line 40 is remarkable, as clearly illustrated under
the SNS view. With this advantage, the programmer can
easily observe how many descendants a line has even under
the circumstance that the source code involves a huge number of lines. Intuitively the amount of descendants of a line

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

symbolizes the degree of its importance in the program. In
the initial SNS view, it is easy to observe the importance of
each line simply by judging from its font size (see Figure
4(e)) – a desirable property that the other two views lack
(see Figures 4 (a) and (c)). Note that every SNS view corresponds to a balloon drawing of a rooted tree. To better
understand the feature of the SNS view against the other
two views, we plot the value of each line versus the number
of its descendants in Figures 5 and 6, focusing on lines 0
and 24, respectively, in which we can observe that the SNS
value of each line respects the number of its descendants.
(Cons) In comparison with the fisheye view, the path from
the focus to the root cannot be traced obviously. (It can
be traced indirectly, nevertheless.) Unlike the fractal view,
the amount of lines with font size larger than the threshold
cannot be controlled, and the lines at the same level of a
tree cannot be observed in the initial view as Figure 4(c)
indicate.

References
[1] J. Carri`
ere and R. Kazman. Research report: Interacting
with huge hierarchies: Beyond cone trees. In IV 95, pages
74–81. IEEE CS Press, 1995.
[2] A. Cox and M. L. Collard. Working session: Textual views
of source code to support comprehension. In IWPC ’05,
pages 109–112. IEEE Press, 2005.
[3] P. Eades. Drawing free trees. Bulletin of the Institute for
Combinatorics and its Applications, pages 10–36, 1992.
[4] R. Falke, R. Klein, R. Koschke, and J. Quante. The dominance tree in visualizing software dependencies. In VISSOFT 2005, pages 83–88. IEEE Press, 2005.
[5] A. Formella and J. Keller. Generalized fisheye views of
graphs. In GD 1995, volume 1027 of LNCS, pages 242–253,
1996.
[6] G. W. Furnas. Generalized fisheye views. In CHI ’86, pages
16–23. ACM Press, 1986.
[7] M. R. Jakobsen and K. Hornbæk. Evaluating a fisheye view
of source code. In CHI 2006, pages 377–386. ACM Press,
2006.
[8] C.-S. Jeong and A. Pang. Reconfigurable disc trees for visualizing large hierarchical information space. In InfoVis ’98,
pages 19–25. IEEE CS Press, 1998.
[9] H. Koike. Fractal view: A fractal-based method for controlling information display. ACM Trans. Inf. Syst., 13(3):305–
323, 1995.
[10] H. Koike and H. Yoshihara. Fractal approaches for visualizing huge hierarchies. In VL ’93, pages 55–60. IEEE CS
Press, 1993.
[11] C.-C. Lin and H.-C. Yen. On balloon drawings of rooted
trees. In GD 2005, volume 3843 of LNCS, pages 285–296,
2005.
[12] E. Reingold and J. Tilford. Tidier drawing of trees. IEEE
Trans. Software Eng., SE-7(2):223–228, 1981.
[13] M. Sarkar and M. H. Brown. Graphical fisheye views. Commun. ACM, 37(12):73–83, 1994.


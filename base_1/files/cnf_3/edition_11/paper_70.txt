Drawing conics on a hexagonal grid
M. L. V. Pitteway
Brunel University, Uxbridge UB83PH, England
Mike.Pitteway @ brunel .ac .uk

A bst riact

first sectant, "movel" and "move2" are to alternative adjacent hexagons as shown, and the sign bit of the control
variable d is supposed to answer the question: Does the
line pass below the indicated mid-point (d < 0), above the
midpoint (d > 0), or through it (d = 0, treated as positive
here for simplicity though at the risk of an "equal error
anomoly" discussed by Bresenham himself at some length
t41.)
The introduction of the curvature constants k l , k2 and
k3 imply that b and a are no longer supposed to be constant, but vary, causing the gradient to change and thus the
intended line becomes curved. With the signs as shown
and if all three k are small and positive b slowly decreases
and a increases, and so the gradient of the line decreases
until eventually the algorithm would lock onto an
extended sequence of move2, and we need to move clockwise into the next sectant in order to continue the curve.
Similarly if, as a consequence of one or more of the k
being set negative, it is b which reduces towards zero we
curve upwards and until eventually a change to the next
sectant in an anti-clockwise direction is required.
It is easy to show (though the detailed mathematical
development is not presented here) that the curve in fact
follows a quadratic form in which the succesive values of
d are defined as a residue, showing as before whether the
mid-point between the alternative moves lies above or
below the intended curve, and this defines a "best fit"
incremental version of an intended conic section. Note,
however, that the constant k2 is used in both branches of
algorithm 1. (This is essential if d is to be defined as a
single valued function of position, for otherwise we would
have a situation in which a change in sign of an initial
very small value of d would result in a significant change
two moves later.)

An algorithm is presented which can be used to outline
ellipses, circles, or any of the other conic sections on a
hexagonal lattice. The basic algorithm requires just one
test and three add operations in the inner loop, though an
additional test is required to detect a change in the overall
direction between two adjacent sectants.

1. Introduction
Most graphic displays are based on a traditional raster,
in which each point addressed is supposed to represent a
square (or sometimes rectangular) picture element, "pixel"
or "pel". Many algorithms have been developed to run at
the lowest level of the software to assist in the construction of line drawings and otheir images, e.g. [21, [31, 151,
for both four way and eight way connections between the
adjacent pixels.
Sometimes, however, it may be useful to construct an
image using an alternative choice of picture element. A
hexagonal mesh, like a bee's honeycomb, is one such.
Each pixel has six neighbours, and drawing a straight line
involves choosing one of two possible neighbours in succession according to the gradient of the intended line.
Bresenham's algorithm [2] can be applied directly to this
case also, though the initial conditions are different.
Some advantages of the hexagonal lattice have been listed
by Tytkowski at IVZOOO [9], and indeed he goes on to
propose the contruction of hexagonal mesh hardware for a
graphics display unit.

1.1 Algorithmic developmeint
The basic algorithm 1 was introduced [ 5 ] as an extension of Bresenham's algorithm 1-21for the control of a digital plotter. If the constants k l , k2 and k3 are all set equal
to zero a straight line results, with a gradient determined
by the relative magnitude of the constants (in this case) b
and a, which are both supposed to be positive. The control variable d operates in the range from -a up to (but
excluding) +b to mix the output sequence of moves as
evenly as possible to best approximate a straight line.
This applies equally to the hexagonal mesh as shown in
figure 1, where the line is supposed to be directed in the

1.2 The anti-clockwise sectant change
If a becomes negative, we have the situation sketched
in figure 2. We need to move into the next sectant where
we still have move2 available, but we need to change
movel so that we look at the pixel vertically above the
present situation, i.e. move1 is replaced (in a vector sense)
by move2 minus movel. At the same time we need to
evaluate d at the midpoint between move2 and the new
move]. We can study the arithmetic required for this

489
0-7695-1195-3/01 $10.00 0 2001 1E:EE

operation algorithmically, [8], [6]. We need to backtrack
the algorithm through a move1 , then forwards through
one half of a move2 to evaluate d at the required new
position. A "half move2" is defined as an algorithmic
operation which, if performed twice, would give the same
change of variables inside a computer as "move2", and so
"b - k212 + b; a + k3l2 + a; d - a12 - k3l8 + d". (The
- k318 is required for the half change to d in order to
achieve "d - a + d" after two goes.) Thus we can establish the arithmetic for the change to the new value of d as
being d - b - a12 + k2 12 - 3 k3 18. Finally, we require a
sign change, for now we wish to output a new move1 if
the curve passes to the left of the new mid-point. Similarly for the variables b and a, and the three k constants;
thus the whole sectant change arithmetic required can be
written:
-d

2. Initial conditions
For a Cartesian axial system, with y directed vertically
upwards and x towards the right, and with movel or
move2 defining the unit of length, the initial conditions
for the conic
d E 2 v x - 2 U Y - a x 2 - P y 2 - 2 y ~ fyc = 0
are:

+d
u - 6 v - p m 3 a ~ 4+ a
U + 6 v + PI4 - 3 a t 4 + b
PI2 + 3 a12 -'6 y+ k l
-Dl2 + 3 a12 + k2
PI2 + 3 a12 + '6 y+ k3
6 v -3al4+ c

+ b + a12 - k212 + 3 k3 I8 + d

An example is shown in figure 4 for an ellipse with v =
28, U = 384, a = -29, P = -36, y = 12 and c = -4, thus an
ellipse centered at x=4, y=12, with major axis = 30 and
minor axis = 20.

b+a+k3/2-k212+b

+ k2 - k3 12 + a
2 k2 - k l - k3 + k l
k2 - k3 + k2
-k3 + k3
move2 - move 1 + move 1
-a

(1)

3. Alternative algorithms
As suggested in [6], the algorithm can be improved to
follow the intended curve more closely near the sectant
changes if the test "is a < O?" is replaced by asking if it
would become increased following an anti-clockwise
change, i.e. "is a < k2 12 - k3 14?", and similarly if the test
"is b < O?" is replaced by "is b < k l 14 - k212?". Then
we return from the sectant changes back to the branch test
on the sign of d. There is, however, a danger of endless
looping through the sectant changes if this version is used
in an attempt to draw a very small or thin ellipse, or a
very sharply turning hyperbola, a problem for which
Vaughan Pratt offers a fix [7] albeit at the cost of extra
work in the inner loop. Further improvements have been
suggested by Ebadollah Banisse [ l ] , but that work is
beyond the scope of this paper.
An alternative "minimum residue" criterion has also
been suggested [3] as an alternative to the mid-point criterion used here. We ask instead to choose the move to the
next hexagonal pixel which has the smallest value of Id1
evaluated at its centre. Bearing in mind that we expect d
to be negative at the centre of the pixel following a move2
and positive after a movel, or at least in any case where
the choice might be marginal, it turns out that our basic
algorithm is unchanged except that d becomes
- d + b + a12 - k2 14 + k3 14 after an anticlockwise sectant
change and - d - a - b12 - k2 14 + k l 14 after a clockwise
change. Similarly, the intial condition for d with the axial
system of section 2 becomes 6 v - 3 a14 - PI4 + c.

Note that the ordering is important in this sequence in
order to avoid overwriting quantities that are required for
subseqent operations. Also that the sequence is identical
to that required for the diagonal octant change in the original 1967 paper [ 5 ] , which is not surprising as there, too,
an identical algorithmic sequence is required to construct
the new value for d.

1.3 The clockwise sectant change
The algorithmic development for the clockwise sectant
change sketched in figure 3 follows similarly, and requires
move2 backwards followed by half a move I . It can be
written:
- d - a - b l 2 - k2l2 + 3 k l I8

4d

a + b + k212 - k l 12 + a
- b - k2 + k l 12 + b

2 k2 - k l - k3 + k3

(3)

(2)

k2-kl +k2

+kl
move1 - move2 + move2
-kl

Here again, the order is important.

490

4. References

Figure 1. Choice of adjacent moves on a hexagonal lattice for a line with initial gradient in the
first sectant.

[ I ] Banisse, E. (1990), A conic drawing algorithm with
grey scale, Ph. D. thesis, Brunel University.
[2] Bresenham, J.E. ( 1 9 6 9 , Algorithm for computer control of a digital plotter, IBM Systems J., 4, 25-30.
[3] Bresenham, J.E. (1977), A. linear algorithm for incremental digital display of circular arcs, Com. ACM 20,
100- 106.
[4] Bresenham, J.E. (1985), jRun length slice algorithm
for incremental lines, Proc. of the NATO AS1 series Fundamental Algorithms for computer graphics, F17, 59- 104.
[5] Pitteway, M.L.V. (1967:1, Algorithm for drawing
ellipses or hyperbolae with a digital plotter, Computer J.
10,282-289.
[6] Pitteway, M.L.V. (1985), The algebra of algorithms,
Proc. of the NATO AS1 series Fundamental Algorithms
for computer graphics, F17, 837-853.
[7] Pratt, V. (1985), Techniques for conic splines, Computer Graphics (Proc. ACM SIGGRAPH), 5, 151-159.
[8] Sproull, R.F (1982), Using program transformations to
derive line-drawing algorithms, ACM Transactions on
Graphics, 1, 259-273.
[9] Tytkowski, K.T. (2000), I-Iexagonal raster for computer graphic, Proc. IEEE Conference on Information
Visualization, 69-73.

Figure 2. Change of sectant in an anti-clockwise
direction.

Figure 3. Change of sectant in a clockwise direction.

Figure 4. An example ellipse centered at x=4,
y=12, with major axis = 30 and minor axis = 20.
The starting point is highlighted.

Algorithm 1.

Set up the initial conditions
Branch on the sign of d

Branch ford < 0:
Clockwise change if b < 0
b-kl + b
a+k2+a
d+bbd
move 1
go back to branch on d unless done

M. L. V. Pitteway, Department of Computer Science,
Brunel University, Uxbridge U:B8 3PH, England.
Copyright IV 2001 (IEEE).
Paper number g609

Branch ford 2 0:
Anti-clockwise change if a < 0
b-k2+b
a+k3+a
d-a+d
move2
go back to branch on d unless done

49 1


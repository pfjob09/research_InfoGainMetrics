Towards a Web Based CAD System
Frkdkric Danesi', Laurent Denis', Yvon Gardan', Yann Lanue12 and Estelle Perrin2
CMCAO Team / LERI
1
IFT2, Charleville-Mkzikres, France
Metz University, France
{ fred.danesi, 1aurent.denis} @netcourrier.com, gardan @ infonie. fr
{ lanuel, perrin} @sciences.univ-metz.fr

Abstract

data volume. Therefore, it is necessary to provide our
system with adequate data representation and architecture
in order to get the Same performances as a local system.
A study has been realised in our team [l] that
concerns the transmission of the three main models used in
CAD (CSG, octree and BRep). It has shown that such
classical models are too less-level information for our
specifications and that a functional model is needed.
This paper deals with our first results concerning the
architecture which will be the basis of different
implementations and with a first operational prototype.
The first section introduces the tests we processed in order
to understand advantages and drawbacks of different
alternatives and describes the final choices for the
architecture. The second section describes a prototype.
proving the feasibility of our approach. It is based on new
intuitive interaction techniques even if we only outline this
point in this paper.

Actual CAD systems are still monolithic and are
based on complex geometrical models. Our aim is to
implement a new approach taking advantcige of web
possibilities and providing a novice end-user with an easyto-use system. In order to get the same performances as a
local system, it is necessary to provide our system with
adequate data representation aid architecture.
A study realised in our team has shown that classical
models are too less-level information for our
specocations and that a functional model is needed.
This paper deals with our.first results concerning the
architecture which will be the basis of different
implementations and with a first operational prototype.
The first section introduces the tests we processed in order
to understand udvantages and drawbacks of digerent
alternatives and describes the final choices for the
architecture. The second section describes a prototype,
proving the feasibility of our upproach. It is based on new
intuitive interaction techniques even if we only outline this
point in thispaper.

2. Architecture of a distributed CAD system
We recall that in order to have a CAD system
available on Internet, the architecture has to allow the
client to use CAD data (or representation model) stored on
the server. This can be done by two ways:
- the client has to invoke remote methods on the
server. The section 2.1. studies different
available tools for integrating distributed objects
into programming languages: COMA, DCOM
and Java RMI and shows that all these solutions
are not adequate;
- the server provides the client with a replica of the
data. Then, the client is able to work by its own
and this is explained in section 2.2.
The replica solution is suitable for our system and we
describe in the section 2.3. the mechanisms implemented
in our prototype architecture.

1. Introduction
Actual CAD systems are still monolithic and are
based on complex geometrical models. Our aim is to
implement a new approach laking advantage of web
possibilities and providing a novice end-user with an easyto-use system. This implies that such a system has no
knowledge about the remote computer (operating system,
memory, processor and storage capabilities, etc.) and its
user. Consequently, the whole CAD system cannot be
uploaded on the client and the model has to be stored on
the server. During a work-session, numerous specific CAD
transmissions between the server and the client will be
added to classical ones. Moreover, CAD systems use
specific representation models and by the way carry huge

269
0-7695-1195-3/01 $10.00 0 2001 IEEE

2.1. Remote methods invocation

invoking methods on higher granularity objects. New tests
have been realised on an outline of 3D points. The outline
used representation is either N distinct 3D points, or an
array of N 3D points. In the first case, we invoke N times
the remote method that returns one of the coordinates of a
3D point. In the second case, we invoke the remote
method that returns an array of the coordinates of the
outline 3D points. Results of this test with N equals to 500
are shown in Table 2.

In order to let the programmer call remote methods as
he does with local methods, we could use tools like
CORBA (Common Object Broker Architecture) [2],
DCOM (Distributed Component Object Model) [3], or
JAVA RMI (Java Remote method invocation) [4]. All
these tools provide a solution to manipulate objects from a
distant machine. They use the notion of client stub and
a method on a remote object, a request is sent to the client
stub which dialogs with the server stub, by transferring the

500 3D points
Array of 500 3D points

way.

590 ms

10.9 ms

method on an array.

C O D A and DCOM have drawbacks which lead us
to give them up: CORBA requires installing a specific
software on the client, by an experienced user, and DCOM
is only available on MICROSOmm operating systems.
That is the reason why we have only studied Java
RMI in order to measure the time consumed by calling
remote methods. These tests have been made on INTELm
Celeron and INTELTMPentium processors and consist in
invoking methods that return one of the coordinates of a
3D point by three ways:
- the method is locally called,
- the method is remote, but the server is the same
computer as the client,
the method is remote and the client and the
server are relied by a 10 Mbits network.
Methods invocations time are summarised in Table 1.

As expected, a higher granularity provides better time
results, but in our case, such a solution often transfers too
many useless data. For example, if the client program
needs only 20 points of the outline, it is obvious that it is
better to get the entire array, but it will have to store 500
points instead of 20 and to extract these 20 points among
the 500 ones.
In conclusion, with a low-level granularity, Java RMI
is too slow to satisfy our specifications, and with a highlevel one, we loose control over transferred data and tasks
sharing out between the server and the client. Finally, the
different studied available tools are inadequate for our
system. We study in the next section data replication to
provide client with local treatments.

pFT-iW-1

2.2. Replication

Celeron
Pentium
533MHz
166MHi
Local method
0.0001 ms 0.0005 ms
RMI on one machine
1 SO86 ms
0.9096 ms
RMI on a 1OMbitsnetwork 1.1800ms 1.9357ms
Table 1. Comparison between spent time on a call to
a local method, a call to a remote method on a
unique computer, a call to a remote method on two
computers on a local network.

Replication process consists in copying on the client
the data that the remote program needs among those stored
on the server, and in ensuring the consistency at each
modification realised on a data or on one of its replicas.
Only few works have been published on this subject, and
only one is under our context [5]. This work is a generalpurpose object-oriented library for developing distributed
3D graphics applications called Repo-3D. Repo-3D uses
three kinds of distributed object semantics:
Simple objects with no special distributed
semantics.
0
Remote objects with a client-server distribution
semantics. All method invocations are forwarded
to the original object.
Replicated objects with a replicated distribution
semantics. If any replica is changed, the change is
reflected in all replicas.
As the time delay of synchronous remote method
invocations is unsuitable for rapidly changing graphical

Results show that a call to a remote method on a
unique computer spends almost the same time as the one
on two computers on a local network, but the spending
time on the call of a local method is very lower than the
two previous ones. This is explained by the fact that the
use of RMI involves numerous extra treatments which
imply very important overhead time.
As the system spends time on numerous extra
treatments for each invoked method, we can decrease it by

270

in two points. First, the user does not have to spend all
time connected to Internet. Twice, he is protected from
problems with network. Even if his connection is broken,
or his computer has problem, he does not have lost his
work.
Our system architecture is represented in Figure 1.

applications, in Repo-3D the data needed are updated
asynchronously with replicated objects. In order to update
the replicas, all the operations are performed in the same
order on all copies.
Repo-3D shows that it is possible to use replicas in
order to obtain an application with satisfying access-time.
For our system, it will allow us to realise more or less
complex computations on the client. Nevertheless, the
server will still have to take into account specific tasks like
the high-functional level ones. If the tasks natures between
the server and the client are different, it seems that the
client and the server may have different data
representations. As replicas are realised in Repo-3D, they
do not allow us to use different representations.
We present in the next section our own architecture,
based on replica.

2.3. System architecture
As we mention it before, replication process consists
in duplicating on the client the data that the remote
program needs. The duplicated elements concern the part
really used by the client. The rest of the model could be
loaded as and when required. The second replication
process task consists in ensuring the consistency of the
two representations in several cases. When the model on
the client is modified, the systern has to react on the server
model and, when the client asks the server to do some
treatments, the system has to react on the client model. To
do that, we have to implement a communication system
between the client and the server. A common language is
used to describe the modifications to do. The client and the
server use this language to exchange orders through a
socket. When the client modifies its model, it gives the
server the order to do the same. When the server modifies
its model, it gives the client the order to do the same only
on replicated objects. Then, the server has to maintain a
correspondence list, with which it is able to know all the
objects present on the client.
As methods are not directly invoked, the models can
be different: for a same modification, the order is the
same, but the interpretation is different. The language
bridges the gap between the two different representations.
For obvious reasons, a goal is that the user needs not
to be connected during all the session, so at the beginning
of the session the needed data. are loaded. He does not
have to reconnect until he needs a new part of his model or
at the request of the server. Consequently, no real time is
possible. That is the reason why all the modifications are
stored in a file. The contents of the file are sent in order to
update regularly the model on the server if the client is
connected or on user request. This technique is interesting

Figure 1. System architecture.

2.4. Conclusion
We have presented an architecture for web-based
CAD system. This architecture responds to problems of
reactivity by duplicating a part of the model of the server
on the client computer. When a modification occurs on
one of the two models, a description of the modifications
is sent. As a language describes the modifications, two
different models can be used for client and server. In this
way, we can improve the reactivity of the system by
downloading data in an appropriate format according to
the use made by the client.

3. Prototype implementation
A prototype has been implemented, proving the
feasibility of our approach. In this section, we describe its
features.

3.1. Specifications
As our goal is to provide a web-based CAD system,
the later has to be adapted to each possible user: from
CAD system expert to neophyte. For somebody that has
never used a CAD system, creating geometry is a very
difficult task. We are so interested in providing a more
intuitive interface than a classical one.

271

By intuitive interface, we mean interface that does
not require the user to think about it. For example, if the
user will create a cube, he has not to ask himself where the
adequate menu, button or command is. If we want the
interface to be intuitive, he has to know naturally what to
do. Sketching is a natural method for everyone to show
roughly shape specifications. Since sketch modelling has
been largely studied (see related work in the section 3.2.),
we present in the section 3.3. new sketch modelling tools
based on deformation of primitive shapes.

Figure 2. Sketch and recognised
pattern in the Quicksketch system.

3.2. 3D Sketch Modelling

3.3. Interface software tool

Knowing that 3D design is very important but often
not very obvious to be realised by an operator, we are
interested in 3D sketch modelling. In this section, we
present a brief state-of-the-art in the context of CAD, on
the 3D sketch modelling. We show then how to extend this
concept of sketching in order to improve CAD systems.
We present here a study based on the complete work
in [6]. This study is based on numerous operational
systems. All proposed 3D modelling systems are based on
sketch in various forms (from interaction techniques like
navigation or selection, to input methods or shape
approximation). Most of the studied systems are CAD
systems which can be designated by lax; namely, CAD
systems which let more freedom to the operator during the
design stage than in traditional ones. It is the case for
example, of 3-Draw [7] which makes possible to draw
directly in 3D free forms by capturing specific points and
drawing curves. In the same way, 181 defines Holosketch
like a 3D drawing (and animation) system, providing an
easy to use environment. It is also the case of’ the
following systems: 3D Palette [9], COVIRDS [lo],
JDCAD [ 111 and SKETCH [ 121 which aim to approximate
modelling, within the meaning of the size, of an object or a
3D scene by aggregation of primitive shapes. However,
this modelling method limits the possibilities of the
systems. To compensate this lack, COVIRDS ensures the
creation of surfaces, just as the systems DO-IT [13] and
Virtual Clay [14], which are based on NURBS
deformation using specific input devices.
In a CAD system, the user must usually precisely
know his goal as well as the step to catch it (primitive
shapes, CSG operator and so on). Some systems propose
an opposite approach: the user roughly draws (sketch) his
goal and the system proposes a solution. Let us cite the
example of 3DSketch [ 151, Quicksketch [ 161, Digital Clay
[17], TEDDY [18] and SKETCHI121. These systems use a
gesture-based engine of pattern recognition, which
proposes a corresponding model (Figure 2).

In our prototype, we use a shape recognition method.
The user draws in two dimensions a sketch of the shape he
wants to model. Then he validates (always by sketching,
but without noise) his drawing (Figure 3). The stroke is
then sampled as a sequence of points from which the
program interprets the type of the shape (Figure 4a).

Figure 3. Left : the user free sketch, with noise.
Right : the user validation sketch.
With this method, we are limited to a set of primitive
shapes (box, sphere, cylinder,. ..I. But the user, especially
novice CAD system user, wishes to create free form 3D
shapes (an expert too, but he can do it by using Boolean
operators on primitive shapes), so we cannot limit his
creativity with a countable set of forms. We provide him
with intuitive deformation modelling tools based on sketch
input. Once he has created a shape, the user can deform it,
by stretching one of the shape surfaces (surface
deformation), or by deforming the shape globally (shape
deformation):

The surface deformation tool lets the user deform
a selected surface by redefining the global aspect. For
example, the user can introduce notion like “to arch”
(Figure 4d: deformation applied on the box defined in
Figure 4a) or ‘;to dig” (Figure 4b), or precise himself the
future global aspect of the selected surface (Figure 4c).

272

I
Figure 5. Global aspect for
shape deformation.
...........................................................

a)

I ............................................................

b)

Figure 6. Shape deformation with Figure 5 global
aspect.

Figure 4. a) the recognised box, b) the
recognised box after the "lo dig" action, c) the
recognised box after a global aspect deformation,
d) the recognised box after the ''to arch' action.

developers with a powerful 3D-rendering tool named
Java3D. Therefore we choose Java as programming tool,
for realising the two-dimensional interface and the clientserver communication process, and Java3D for realising
the 3D rendering.
According to these choices, we develop a first
prototype, implementing and validating the proposed
architecture (see section 2.). This prototype provides the
feasibility of our approach. It is based on new dialog
techniques outline in the section 3.

The shape deformation tool lets the user deform
the entire shape by redefining the global aspect (in several
times, from different point of view, if necessary). For
example, deforming the box defined in Figure 4a using the
global aspect defined in Figure 5 will give the shape
viewed in Figure 6a. If we apply he same deformation on a
second point of view, we will obtain a new shape, viewed
in Figure 6b.

4. Conclusion and future work

Many surface deformation methods exist. Some are
intuitive, but often require specific or dedicated 3D input
devices. 3DSketch uses a repulsive / attractive virtual
source, attached to a 3D arm input, to deform shape
surfaces. COVIRDS uses data gloves to locate and
interpret user's hand position and movement. DO-IT uses
as input tool a dedicated deformable object that has the
same shape as the virtual object. Our system will be used
over the World Wide Web. By the way, the interface
software tool has to be adapted to each kind of input and
output devices which user could have. Our surface
deformation method is adequate to every kind of input
device. These two methods bring new and intuitive way of
3D shape modelling.

We have presented in this paper an architecture to
implement Web-based CAD software, and some ideas on
new approaches for man-machine dialog. The
implementation of a prototype based on the proposed
architecture and using our interface software tools has
shown the feasibility of our approach. Our future work
will consist in using the proposed architecture to develop a
complete CAD system, including some previous results
about function-to-shape translation [191. Moreover, the
ideas about man-machine dialog will be extended in this
complete CAD system.

5. References

3.4. Implementation

[l] F. Danesi, C. Dartigues, Y. Gardan and E.Pemn, "World
Wide Web Adapted Geometric Model in the Context of
Functional Design", 4th International Conference on Design of
Information Infrustructure System for Munufucturing 2000, 1517 November 2000, Melbourne (Australia), pp.432-440.

The acceptance of Java applets is very high among
Internet users. A Java applet can be interpreted by any
modem web browser. Furthermore, Java provides

273

[2] Object Management Group, “The Common Object Request
Broker: Architecture and Specification”, February 2001,
http://www.omg.org.

[l I] J. Liang and M. Green, “JDCAD : A Highly Interactive 3D
Modeling System”, Computer and Graphics, vol. 18(4), 1994,
pp. 499-506.

[3] Microsoft, “DCOM Technical Overview”, January 2000,

[12] R. C. Zeleznik, K.P. Hemdon and J.F. Hughes, “Sketch: An
interface for Sketching 3D Scenes”, Computer Graphics, vol.
30(4), 1996,pp. 163-170.

http://www.microsoft.com.

[4] Sun Microsystems Inc., “Java Remote Method Invocation Distributed Computing For Java”, November 1999,
http://j ava.sun.com.

[13] T. Murakami and N. Nakajima, “DO-F: deformable object
as input tool for 3-D geometric operation”, Computer-Aided
Design, vol. 32(1), 2000, pp. 5-16.

[5] B. MacIntyre and S. Feiner, “Distributed 3D graphics
library”, ACM SIGGRAPH’98, 18-24 July 1998, Orlando, pp.
361-370.

[14] K. Kameyama, “Virtual Clay Modeling System”, ACM
Virtual Reality Sofhyare and Technology VRST97, Lausanne,
Switzerland, 1997,pp. 197-200.

[6] F. Danesi, Y. Gardan, B. Martin and I. Pecci., “La conception
3D par esquisses”, Revue intentationale de CFAO et
d‘informatiquegraphique, vol. 15(1),june 2000, pp. 71-86.

[15] S . Han and G. Medioni, “3DSketch: Modeling by Digitizing
with a Smart 3D Pen”, ACMMulrimedia’97, 1997,pp. 41-49.

[7] E. Sachs, A. Roberts and D. Stoops, “3-Draw: A tool for
designing 3D shapes”, IEEE Computer Graphics & Applications,
vol. 11(11), 1991,pp. 18-26.

[16] L. Eggli, C. Hsu, B. Bruderlin and G. Elber, “Inferring 3D
models from freehand sketches and constraints”, ComputerAided Design, vol. 29(2), 1997, pp. 101-112.

[8] M. F. Deering, “Holosketch : A Virtual Reality Sketching /
Animation Tool”, ACM Transaction on Computer-Human
Interaction, vol. 2(3), 1995,pp. 220-238.

[17] M. D. Gross and E. Y.-L. Do, “Drawing on the Back of an
Envelope: a framework for interacting with application programs
by freehand drawing”, Computer & Graphics, vol. 24, 2000, pp.
835-849.

[9] M. Billinghurst, S . Baldis, L. Matheson and M. Philips, “D
Palette : A Virtual Reality Content Creation Tool”, ACM Virtual
Reality Software Technology VRST97, Lausanne, Switzerland,
1997,pp. 155-156

[18] T. Igarashi, S. Matsuoka and H. Tanaka, “Teddy: A
Sketching Interface for 3D Freeform Design”, ACM
SIGGRAPH’99, 8-13 August 1999, Los Angeles, pp. 409-416.
[19] Y. Gardan, C. Minich and D. Pallez, “On shape to
specifications adequacy”, Proceedings of the IEEE International
Conference on Information Visualisation IV’99, 14-16 July 1999,
London, England, pp. 315-320,.

[lo] C. Chu, T.H. Dani and R. Gadh, “Multi-sensory user
interface for a virtual-reality-based computer-aided design
system”, Computer-Aided Design, vol. 29( lo), 1997,pp 709-725.

274


A Study on the Ray-tracing Acceleration Technique
Based on the ZF-buffer Algorithm
Sehyun Kim, Sungye Kim, Kyung-hyun Yoon
Department of Image Engineering, Graduate School of
Advanced Image Science, Multimedia, and Film,
Chung-Ang University, 156-756, Seoul, Korea

depth control [3]; and generalized rays technique like
beam tracing method [4][8].
When we divide the process of ray-tracing speeding-up
into preprocessing and main processing, the geometric
information like bounding volume or space subdivision
of the object to be viewed is stored in the data structure
during the preprocessing. And intersection-test and
determination of pixel intensities are carried out during
the latter.
Vista-buffer, light buffer and first hit speed up methods
are among the faster intersection techniques in the
speeding up methods of ray tracing. Also, they are
examples of applying acceleration algorithm in
preprocessing. Vista-buffer method [ 5 ]chooses the object
that can meet the first ray by projecting bounding volume
of the object to a view plane. It produces as many
intersection candidates as the screen resolution, and
references the intersection candidate list to carry out an
intersection test between the rays. When the objects to be
rendered are not occluded and distributed evenly on the
screen, the speed of finding intersection of this method is
good. But, the efficiency goes down if the bounding
volume is occluded or the object within bounding volume
consists of lots of polygons, because this method uses the
relationship between the bounding volume and the ray.
The light buffer method [6] is designed to reduce the
number of intersection tests between rays by placing the
light buffer at the camera or light source. When a
direction cube is positioned at the camera, we store
candidate lists to all directions of the direction cube
around the camera. Each face of the cube is subdivided
into small cells, and each cell has its own candidate list.
Each of the six subdivided direction cube are examined
in order to find an object that will intersect with a ray
created from the camera. This method has a same
searching problem when using vista buffer algorithm.
First hit speed up method [7] tried to apply a hybrid

Abstract
In this work, we propose ZF-buffer algorithm in order to
accelerate the intersection test of ray tracing. ZF-buffer
is used in the preprocessing of ray tracing and records
the pointer that points to a parent face of a depth value
(z value) of an object determined in Z-buffer. As a result,
the face that intersects with the first ray can be
determined easily by using the pointer stored in F-buffer.
Though ZF-buffer and vista-buffer resemble each other,
the difference between the two methods is that what ZFbuffer records is not bounding volume but the pointer of
a displayable face. We applied the ZF-buffer algorithm
for the first ray to Utah teapot that consists of 9216
polygons. By comparing the elapse time of our method
with vista-buffer algorithm, we can acquire improvement
in speed that it is 3 times faster than vista-buffer
algorithm. We also try to apply our method to reflective
objects.

1. Introduction
One of the purposes of computer graphics is to create
realistic images in real-time. However, when trying to
satisfy the conditions of reality and real-time, there is
always a trade-off. As a technique in realistic image
generation, ray tracing has emerged as a clear winner in
terms of its ability to render such effects as shadow,
transparency; reflection and refraction. On the other
hand it’s computationally exorbitant calculating the
intersections. A variety of research has been conducted
into different acceleration techniques. Those researches
can be roughly categorized into faster intersection
technique using bounding volume [l], or spatial
subdivision [2];fewer rays technique using adaptive tree-

393
0-7695-0743-3/00
$10.00 0 2000 IEEE

Table I Preprocessing of ZF-buffer

and that of Z-buffer are the same. But we record the
pointer of the face of the visible pixel instead of the pixel
value on the F-buffer (Figure 2(c)). Table 1 shows the
algorithm that makes a F-buffer in the preprocessing.

For(
pixels 9(' y)) {
Initialize Z-buffer[x][y] with very large value
Initialize F-buffer[x][y] with NULL
/I NULL means that No intersection is found.

1
for (all vertices) transform vertex to CCS
for(al1 faces) (
for(al1 pixels on the current face) {
if(z value of current pixel < z value of Z-buffer) (
set Z-buffer[x][y] with current z
set F-buffer[x][y] with memory pointer of current
face

I
I
I

Figure 1 target image

After the process shown in Table I is finished, Z-buffer
has the distance value from the camera to the pixel and
F-buffer has the pointer of the face which is a parent of

394

the pixel. As a result, the face that intersects with the
first ray can be determined easily by using the pointer
stored in F-buffer. In ow method, Z-buffer is used only
in determining the F-buffer. F-buffer is used in the main
process in order to apply shading and texture mapping.
Table I1 shows the pseudo code of the main process.
This process and the algorithm of conventional ray
tracing are the same.
Though ZF-buffer and vista-buffer resemble each other,
the difference between the two methods is that ZF-buffer
records not bounding volume but the pointer of a
displayable face. As a result, it is possible that the
additional intersection test problem of bounding volume
is mitigated, and that the intensity of a pixel is
determined by using only the face information in Fbuffer.

position of the camera C I , we have to compute the
correspondent position of one point from an arbitrary
face.

Table I1 main processing of ZF-buffer
for (all pixels (x, y)) (
if (F-buffer[x][y] is not NULL) {
get the face pointer f with which current pixel meet
create view vector for current pixel
calculate distance parameter t by the relationship
between view vector v and face f
calculate pixel value c by Intersection point I and
face f
set pixel c

Figure 3 Recursive ray tracing for reflection using
ZF-buffer

In figure 4, t is the nearest point from X to the plane P
If the distance from X to t is a , then

X = t + a *normal(P),

I

(1)

where t is a point on the plane P. Thus, P(t)= 0 and

I

t =X

2.2. Applying ZF-buffer algorithm to the
second ray

- a * normal(P), So,
P( X -a *normal( P ) ) = O . ( 2 )

With this formula,

Q

can be computed.

- Suppose X 't = X t , then

Because ZF-buffer is a useful method when the direction
of the rays are known in advance or easily computed, it
can be applied only to the first ray. However, it can be
applied if we can create an environment that is similar to
that of the first ray for the reflective and refractive rays.
In conventional ray tracing, reflection is implemented
recursively. On the other hand, ZF-buffer algorithm uses
a reflective face as a new screen and executes the process
like that of the first ray by positioning the camera behind
the reflective face. Figure 3 shows the reflection occurred
when a camera is pointing at the reflective facef. When
the first ray started from the original camera CO,it meets
the reflective facefand the second ray r is created. By
using r, we can create a new camera position Cl to the
other side of the reflective face. The new camera lies at
the same distance from the facef. Though the ray from
the secondary camera CI is the first ray for the camera CI
it is the secondary ray for the camera CO.To compute the

X ' = X - 2 * a * n o r m a l ( P ) . (3)
Substitute plane eq.

ax+ by + cz + d for P and use

formula (l), and (2), then position vector

X'=

x -2"

x ' becomes

(a,b,c)X + d
2 . (4)
a2 +b2+ c

When we try to calculate direction vectors like U, V , N in
the camera matrix, d of plane equation has no more
meaning. So we can rewrite formula (4) for direction
vector X ! ! .

395

Table I11 Recursive ray tracing using ZF-buffer
For (all pixels (x, y)) {
if(F-buffer[x][y] is not NULL) {
calculate t;
if (current face is reflective or refractive) {
if (there is no ZF-buffer for this face) {
create new camera;
create new screen for new camera
create F-buffer corresponding to new screen
recursive call this function
save result to texture map

1
calculate pixel value by texture map and light

Figure 4 The opposite side of X is X’

1

~~~~~~

3. Implementation
In this paper, we implemented our algorithm with
Borland C++ Builder 4.0 on IBM-PC Pentium I1
266MHz. We applied the ZF-buffer algorithm for the
first ray to Utah teapot that consist of 1248, 2304, 4096,
and 9216 polygons.
The result images are Figure 5 and Figure 6. Table IV
shows the time comparison of our method with vistabuffer algorithm for the first ray. By comparing the
elapse time, we can acquire improvement in speed that i t
is 3 times faster than vista-buffer algorithm. Our
algorithm, like general Z-buffer algorithm, does not
increase the elapsed time by increasing the number of
polygons of an object. Even if Z-buffer is supported by
hardware, it is limited and can apply only to the first ray.
Vista-buffer method also can be applied only to the first
ray in order to improve the speed of intersection test.
In our work, we extend our algorithm to the secondary
ray. Figure 7 and figure 8 show the resultant images of
ZF-buffer method for the environment with a mirror.
Figure 7 has small size of mirror (200x00 in world
coordinate.) and Figure 8 has a larger one (400x400 in
world coordinate). Table V shows the elapse time of our
method and table VI shows that of vista-buffer algorithm.
By comparing the elapse time, we can acquire same
speed improvement that ZF-buffer is 3 times faster than
vista-buffer algorithm.
For the scene with a simple mirror, our method is faster
than other algorithms. However, for the complex object
with many reflective faces, the camera setup for each
reflective face is needed. For the recursive execution of
the setup, we have to make a stack for the F-buffer. In

To calculate U, V, N values, let eq(4) forf(x) and eq(5)
for g(x).
Then,

View up vector
View direction vector
X-axis
Translation vector

V’= g ( V )
N’= g ( N )
U’=VkN’
T’= j - ( ~ )

As a result, new camera position

v:

c, becomes

v7y v:

N Y x N’,
1 0
0

N’,
0

11

From C, , as derived above, it is possible to implement
reflection effect in ZF-buffer algorithm. Table I11 shows
pseudo code of ZF-buffer recursive ray-tracing algorithm.

396

that case, our algorithm may not guarantee the fast
execution time. However, ZF-buffer method can
guarantee a high speed for those scenes in which the
majority consists of opaque objects.

Figure 7 Utah teapot reflected by the mirror I

Figure 5 Utah teapot (1248 faces)

Figure 8 Utah teapot reflected by the mirror I1

Figure 6 Utah teapot (9216 faces)

397

Number of
polygon

ZF-buffer
(sec)

Vista-buffer
(sec>

Improvement
(times)

1248
2304
4096
9216

0.225
0.230
0.231
0.240

0.695
0.720
0.754
0.820

3.08
3.13
3.26
3.41

Table V Elapse time of recursive ray tracing
Number of
Polygon
1248
2304
4096
9216

Size of reflective face

0.741
0.745
0.750
0.760 4 g 7 >

2.280
2.332
2.446
2.599

This research was partially supported by the Brain Korea
21(BK21) research grant of the Ministry of Education.

References

2.010
2.01 1
2.015
2.021 <fig8>

Table VI Elapse time of recursive ray tracing
execution-using Vista-buffer
I
Size of reflective face
Number of
(world coordinate)
Polygon
200x200
400x400
1248
2304
4096
9216

Acknowledgments

I

6.191
6.294
6.569
6.871

4. Conclusions and Future Work
In this work, we proposed ZF-buffer algorithm in order
to accelerate the intersection test of ray tracing
algorithm. All the processes that are needed in the
intersection test of ZF-buffer algorithm are executed in
preprocessing, and these can be understood and
implemented easily. When the proposed algorithm is
applied to the first ray, we can reduce the computation
time by almost one third of vista-buffer algorithm. We
also apply our algorithm to the second ray in the limited
environment that consists of a simple mirror. Because
ZF-buffer is simply an extension of Z-buffer, it is
possible to apply ZF-buffer to the environment that
consists of only polygon meshes. And it can make good
efficiency when the number of reflective faces is small.
But if the object consists of many reflective faces, it may
take much computation time than existing methods. The
reason is that the geometrical computation to the position
of camera increases in proportion to the number of
reflective faces. To overcome these limits, we hope that a
hardware accelerator with a geometry setup engine can
be used.
In conclusion, our method, as a great
alternative algorithm, can be applied to those scenes that
consist of objects whose faces are almost all opaque.

398

[l] Whitted, T., An improved illumination model for shaded
display. Commun. ACM 243(6), 343-349, June 1980.
[2] Kaplan, M.R., The use of spatial coherence in ray tracing.
In Techniques for Computer Graphics (eds David F. Rogers
and Rae A. Earnshaw), Spnnger-VerlagNew York, 1987.
[3] Hall, R.A. and Greenberg, D.P.,
A tested for realistic image
synthesis. IEEE Comput. Graph. Appl. 3(10, 10-20, November
1983.
141 Dadoun, N. and Kirkpatick, D.G., The geometry of beam
tracing. Proc.of the symposium on ComputationalGeometry,
pp.55-61, June 1985.
[SI Dieter Bayer, Faster Than POV-RAY 2.1
[6] Haines, E.A. and Greenberg, D.P., The light buffer: a
shadow testing accelerator. IEEE Comput. Graph. Appl. 6(9),616, September 1986
[7] Weghorst, H., Hooper, G.and Greenburg, D.P. Improved
ComputationalMethods for Ray tracing, ACM Trans.
Graphics.3(1),52-69, January 1984
[8] Andrew S. Glassner, An Introduction to Ray tracing, 6,
1989
[9] E. Reinhard, A.J.F. Kok, F.W. Jansen: Cost Prediction in
Ray Tracing, EGWRP6, pp. 41-50, 1996


A Three-dimensional Object Similarity Test Using Graph Matching
Techniques

Carsten Maple
Yu Wang
Departement of Computing and Information Systems
University of Luton
U.K.
yu.z.wang@luton.ac.uk
carsten.maple@luton.ac.uk;
Abstract
In this paper we present method for finding
similarities in a pair of three-dimensional objects. The
method
involves
obtaining
Boundary
Cubes
approximations to the two objects, see [14]. The
Boundary Cubes algorithm is a modification to the wellknown Marching Cubes algorithm of Lorensen and Cline
[11]. Having obtained the approximations we can apply
exact and inexact graph-matching algorithms to quantify
the similarity between two objects. This paper considers
methods for exact and inexact graph matching and
provides novel and efficient algorithms for graph
matching applied to Boundary Cubes representations.

1. Introduction
The problem of finding similarities between a pair of
three-dimensional objects arises in many different
application areas. Novotni and Klein explain that
applications arise in areas such as "Biology, Chemistry,
Anthropology and Archaeology to name a few", [19].
Indeed, an interesting application is given by Novotni and
Klein in their paper Geometric 3D Comparison – an
Application, [18], which concerns finding the best fitting
shoe given a 3D foot scan. Techniques employing
geometric matching in two-dimensions have been applied
to room planning, [13], and the extension to three
dimensions is obvious.
It is apparent that as computational and storage
power increases so too will the uses for three-dimensional
matching algorithms. Osada et al [20] state that "3D
model databases will become ubiquitous, and the

applications of 3D shape analysis and matching will
expand into a wide variety of other fields."
A particular area of interest is that of protein
modelling and ligand binding, see [6] for example.
Protein modelling is usually based upon data provided by
a PDB file. This is a standardised file created by the
Brookhaven Protein Database [1], that contains 3D
atomic co-ordinates (x, y, z) of the atoms that comprise
the protein, connection data between the atoms and
source information. Pocket, [10], is an example of
software used to find candidate binding sites in proteins.
It is based upon an adaptation of the Marching Cubes
algorithm [11] and involves identifying possible binding
sites by searching for cavities in protein structure files.
Although much research has been undertaken in the
area of marching cubes, boundary cubes and their
applications none have yet considered the issue of how to
compare two representations. It is this area that this
paper considers.
The paper is organised in the following way.
Section 2 describes the Boundary Cubes algorithm and
how to obtain a graph representation of the
approximation to the object. Section 3 goes on to
describe methods for exact and inexact graph matching
before section 4 describes how these would apply to
Boundary Cubes representation. We conclude the paper
with the summary comments and suggestions for further
work in section 5.

2. Representing Three-Dimensional Objects
as Graphs
The marching cubes algorithm of Lorensen and Cline
[11], is a surface rendering technique used to produce 3D

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

images given point data from 3-space. The algorithm has
been seen to have a wide variety of applications and has
again been modified to combat domain specific problems,
see for example [7], [10], [21], as well as been used as
the basis for generating piecewise-planar representations
of 3D objects, see [6] and [14].
The traditional data structure for this type of
information is a standard three-dimensional array, where
the value of the pixel, 0 or 1, at position (i, j, k) is stored
in position [i, j, k] of the array. There is a simple
mapping from a pixel-wise representation to a marching
cube representation. Two consecutive slices, k and k-1
say, are used to define a layer of marching cubes. Four
neighbouring pixels that form a square from each of the
two slices comprise a cube. The marching cubes
algorithm forms a piecewise-planar approximation to an
object. The boundary of the object is assumed to pass
exactly half way between a pixel that is exterior to the
boundary of an object and a neighbouring pixel that is
not. This determines the way in which the surface
intersects a cube, if indeed it does. There are 8 vertices to
each cube, each of which can be outside the surface of the
object or not. There are, therefore, 256 different ways in
which a cube can intersect (or not) the surface. In order
to uniquely identify each of the 256 ways we assign a
weighting value to each vertex of a cube as shown in Fig.
1. We can label the vertices (locally) as v0, v1, … , v7,
such that vertex vi is weighted wi = 2i.

also not of consequence. Since every unique shape of an
object has a single Marching Cubes approximation (for a
given pixelisation) and there exists a simple mapping
between a shape and its approximation, storing a
Marching Cubes approximation is equivalent to storing
the pixelisation of the actual shape.
We can now characterise the path of the boundary over a
three-dimensional object. We do this in such a way as to
determine the faces through which the boundary passes
through a particular cube. We index the six faces through
which the boundary can pass as in Fig. 2. Using this
direction index, we can describe every direction that the
surface passes out of the cube through.
We can construct a table that contains information about
the faces through which the surface passes for each of the
254 possible cube values (excluding the two trivial
cases). It should be noted that cubes with index 1 and
254 have surfaces that pass through exactly the same
faces; also cubes with index 2 and 253 have surfaces
which pass through the same faces. In general, surfaces
from cubes with values x and 255 - x pass through the
same face due to the dual nature of the two cubes and so
it is only required to store information for cube values up
to and including 127. In essence, the cubes with values x
and 255 - x can be viewed as conjugates. An equivalence
relation can be defined (see [14]) such that ci { cj if and
only if they have the same exit faces, which results in 28
equivalence classes.

Fig. 1. The weightings given to the
vertices of each cube.
If the pixel at the front bottom-left of the cube
(locally vertex v0) is outside the cube it is assigned a
value of 0, and a 1 otherwise. Similarly, if the pixel at
the back top-right of the cube (locally vertex v6) is
outside the cube it is assigned a value of 0, and 64
otherwise, and so forth. Each cube, c, is given a value i
( {0, 1, … , 255}) that is the sum of the value of its
vertices. The marching cubes algorithm then uses
rendering techniques produce 3D images. In this paper
we are not concerned with the rendering of the surface,
but simply with the way of representing the data using
voxels. Equally, the fact that the marching cubes
algorithm only gives an approximation to an object is

Fig. 2. The index of the faces of a cube
through which a surface can pass.

2.1 An Algorithm to Obtain a Boundary
Representation
We now require a data structure that will allow a threedimensional pixelwise representation to be transformed
into a boundary method representation.
The
representation is stored in a graph-like structure. A
selection of an example of a graphical representation

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

arising using the boundary method on a threedimensional object is given in Fig. 3. There is a one-toone correspondence between cubes constructed from
pixels on the boundary of the object and nodes in the
graph. It is typical that, for a computer representation of
a standard graph, information about each node is stored in
an element of a one-dimensional array. For a graph such
as that in Fig. 3, it is required that the cube value and the
connection list for each node is stored.

Boundary_List(I)=(complete,coords,
connection_list)
(1)
Here connection_list is a list of elements
(exit_face, next_cube), where exit_face is an
integer in 1, … , 6 and next_cube is an integer that
determines which element of Boundary_List contains
information about the next cube. Using this data
structure we can devise an algorithm to translate
pixelwise data into a boundary method representation, see
[14]. Using the algorithm given in [14] will result in an
array with a structure such as (1). This storage is
inefficient since there is, as was argued earlier, no need to
store the co-ordinates of every cube. Only relative coordinates are important and can be determined without
the storage of absolute coordinates.
Giving the
coordinates of a single cube will allow the absolute
coordinates of any other cube to be determined, if
desired. There is also no need to store the complete
variable since this was only used for construction
purposes. The storage can also further be reduced by
noting that if we pass through face 1 of cube A into cube
B, then this is equivalent to stating that we pass through
face 6 of cube B into cube A. Hence every connection is
stored twice, causing redundancy. A simple trimming
operation can halve the storage required for the edges.

3

Exact and Inexact Graph Matching

Before we discuss exact and inexact graph matching
principles and techniques it is necessary to give some
basic definitions.

Fig. 3. A section of a graph depicting the
boundary of a three-dimensional object.
For purposes of constructing the boundary representation,
the co-ordinates of each cube must be stored. Storing the
co-ordinates of cubes allows a check to be made as to
whether any information about the cube has already been
stored. The graph is complete once every connection
between cubes has been considered.
For each node, we introduce a variable, complete,
which is set to 1 if all the connections of that cube have
been stored and 0 otherwise. Once every element in the
boundary list has complete = 1 the boundary
representation is complete. We can write the data
structure to be used in the algorithm as:

Definition: Graph
A graph G = <V, E> is defined by a non-empty
finite set of vertices, V(G), and a (possibly empty)
collection of edges, E(G)  V x V.
Each edge is identified with two, not necessarily distinct,
vertices in V. If the edges are associated with an ordered
pair of vertices, then G is called a directed graph. In
general, more than one edge may be associated with the
same pair of vertices, in such cases G is said to have
multiple or parallel edges. If the two vertices associated
with an edge are coincident, that edge is said to be a selfloop. In cases where each element eE is distinct and
none are self-loops, the graph is known as a simple graph.
We define the order of G, ord(G) to be the number of
vertices in the graph, that is ord(G) = |V|.
Definition: Labelled Graph
A (directed) labelled graph G = <V, E, Pv, Pe, Lv,
Le> is a graph with Pv : V o Lv, a function assigning

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

labels to the vertices, and Pe : E o Le, a function
assigning labels to the edges. Lv and Le are finite sets of
symbolic labels.
Boundary Cubes give rise to simple labelled graphs.
A major area of research activity concerns subgraphs, and
so we define the notion of a labelled subgraph.
Definition: Labelled Subgraph
A labelled subgraph S = <Vs, Es, Pvs, Pes, Lvs,
Les>, of a labelled graph G=<V, E, Pv, Pe, Lv, Le> is a
labelled graph such that Vs  V; E = E  (Vs x Vs); Pvs
(vs) = Pv (vs) for all vs  Vs; Pes (es) = Pe (es) for all es 
Es.

3.1 Exact Graph Matching
Exact graph matching is any technique used to determine
a graph isomorphism between two graphs, G1 and G2 say.
A graph isomorphism is any bijection, or permutation,
from the vertices of graph G1 to the vertices of G2, such
that the edge connections are respected. If graph G1 is
isomorphic to G2 we write G1 # G2. There exist a number
of techniques available for graph isomorphism, see for
example [12], [16].

3.2 Inexact Graph Matching
There are various definitions for inexact graph matching.
Many researchers determine the problem of inexact to be
that of finding exact subgraph isomorphisms. This
problem has a number of applications including
integrated circuit testing [2], robot motion planning [8]
and semantic network retrieval [9]. Most applications are
concerned with determining the maximum common
subgraph of graphs G1 and G2. A common subgraph of
graphs G1 and G2 consists of a subgraph S1 of G1 and a
subgraph S2 of G2, such that S2 # S2. A maximum
common subgraph of two graphs is a common subgraph
that is not a proper subgraph of another common
subgraph. There has been a great deal of work
undertaken in the area of subgraph isomorphism and
maximal common subgraphs. In particular, in 1999
Eppstein published an excellent piece regarding subgraph
isomorphism [4].
In a real-world situation, however, there are often
distortions or errors in a graph that is being subject to
isomorphism techniques. This justified the need for an
area usually termed error-correcting graph isomorphism.

The principle involves using graph edit operations, such
as insertion or deletion of vertex or edge, and relabelling
of edges or vertices, to transform one graph into another.
Obviously an arbitrary graph can be transformed into any
graph using these operations, and as such there is an
inexact match between any pair of graphs. The principle
employed in the area, however, is to restrict similarities
to those transformations that can be achieved within some
total cost, Tc. Each operation, such as inserting a vertex,
is assigned a cost, and so the problem is to determine
whether one graph can be transformed into another at a
cost c < Tc. For details of such techniques the reader is
referred to [15] and [22]. While this is, in many
applications, the most appropriate form of inexact
matching, problems arise due to the combinatorial
explosion of the problem. The Messmer and Bunke
paper [15] in fact highlights how the implementation
managed graphs of 16 vertices. This is obviously too few
for many real-world applications.
The other notion of inexact graph matching is errorcorrecting subgraph isomorphism, see [3] for example. It
is transparent however that this is merely a special case of
error-correcting graph isomorphism since any subgraph
of a graph can be obtained by deletion of a set of vertices
and edges. The only difference that occurs is in
calculating the total cost of the transformation, since
extracting the two subgraphs in the latter method is
achieved at zero cost.

4 Object Comparisons Using Boundary
Cubes
Since the boundary cubes representation of an object can
be considered as a graph, we begin this section by
explaining how exact and inexact graph matching can be
applied to boundary cubes representations. We then
provide an algorithm for exact graph matching that
generally involves considerably fewer steps than existing
techniques. However, it should be noted that the reason
that this algorithm is more efficient is due to the fact that
consideration is given to the special type of graph
generated by a boundary cubes representation. Other
algorithms exist that have similar efficiencies if using
very specific properties of graphs. We end this section
by outlining a method for subgraph isomorphism for
graphs arising from boundary cubes representations. This
method may be modified and applied to a wider range of
graphs.

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

4.1 Exact Graph Matching and Boundary Cubes
Exact graph matching techniques may be applied to
graphs arising from boundary cubes representations.
When we wish there to be an isomorphism between two
objects we are requiring that the two three-dimensional
An Algorithm
Isomorphism

for

Boundary

Cubes

Graph

Input: Two boundary cubes representations, G1 = <V1,
E1> and G2 = <V2, E2>. Denote a vertex with cube value
i by vi. Denote the jth vertex in graph Gk with value i by
vi(Gk, j)
Output: A Boolean variable (true if G1 is isomorphic to
G2, otherwise false.)
Step 1:
If (ord(G1) <> ord (G2)) then return FALSE
Step 2:
Partition V1 and V2 by cube values. That is, V1 :=
n1,1{v1}  n1,2{v2}  …  n1,254{v254}; V2 := n2,1{v1} 
n2,2{v2}  …  n2,254{v254}.
Step 3:
Define number_least := 1000 //a big number
For i := 1 to 254) do
If n1,i <> n2,i then return FALSE
If (1 <= n1,i< number_least) then
Least_cubes = i
end
Step 4:
For j = 1 to n1,Least_cubes do
M = Match (vLeast_cubes (G1, 1), vLeast_cubes (G2, j))
If M = TRUE then return TRUE
end
return FALSE
The algorithm begins by ensuring that there is the same
number of vertices in each graph since this is an obvious
invariant in isomorphisms. In our implementation, the
graph holds the pointers (array) to all of its nodes. Thus,
the number of vertices will be the size of array and would
be performed using a length function.
The next check for invariance is that there is the same
number of cubes with a particular value in each graph.
We also determine which value of cube is common to
both graphs, but occurs least frequently. We do this
since one of these cubes in G1 must be isomorphic to one

of the cubes with the same value in G2. We perform the
check using a function named Match. This returns TRUE
if there is an isomorphism between the two cubes in each
graph. This check is performed by consider a depth-first
search through the graph and returns true if the is an
isomorphism between all elements in the graphs. If this
fails at any point, it returns FALSE immediately. The
main program then tries to match this cube with another
in graph G2. If vLeast_cubes (G1, 1) does not match with any
cube in G2 then the two graphs are not isomorphic.
An Algorithm
Isomorphism

for

Boundary

Cubes

Subgraph

Input: Two boundary cubes representations, G1 = <V1,
E1> and G2 = <V2, E2>. Denote a vertex with cube value
i by vi. Denote the jth vertex in graph Gk with value i by
vi(Gk, j)
Output: A Boolean variable (true if G1 is isomorphic to
G2, otherwise false.)
Step 1:
Partition V1 and V2 by cube values. That is, V1 =
n1,1{v1}  n1,2{v2}  …  n1,254{v254}; V2 = n2,1{v1} 
n2,2{v2}  …  n2,254{v254}.
Step 2:
Define s_least := 1000
//a big number
For i := 1 to 254 do
si := min (n1,i, n2,i)
If (1 <= s,i< s_least) then
Least_cubes = i
end
Step 3:
Define Vs = s1{v1}  s2{v2}  …  s254{v254}
S := LCS (Vs, G)
Step 4:
For j = 1 to sLeast_cubes do
For k = 1 to n2,Least_cubes do
M = SMatch (vLeast_cubes (S, 1),
vLeast_cubes (G2, k))
If M = TRUE then return S
end
n1,i := 0
Goto Step 2
end

We begin by finding an upper limit on the order of the
maximum common subgraph. At Step 3 we know that
the maximum common subgraph, S, is of order less than

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

or equal to the sum of the number of vertices of a
particular cube value common to each graph. That is
ord(S) <= 6 si, i = 1 to 254.
In Step 3 we find the largest connected subgraph of G
using a limited vertex set, Vs. This can be performed
using existing well-known techniques. In Step 4, we
determine whether S is isomorphic to a subgraph of G2.
This is based on a procedure similar to Match described
earlier, and is optimised by using the characteristic that
the vertices are all weighted. If an isomorphism cannot
be made, this element is removed from S. This process is
continued until there does exist an isomorphism between
S and G2.

Conclusions and Further Work
In this work we have presented ideas object comparison
based upon a boundary cubes representation. We have
explained what the effects are in relation to reality and
presented algorithms for exact object matching and exact
matching of connected parts of two objects. The
algorithms utilise special characteristics of the graphs
arising from boundary cubes representations.
Ongoing work involves the testing of the algorithms
presented herein and adaptation of error-corrected graph
matching algorithms for use with boundary cubes
representations.

References
[1] Berman, H., et al, 2000, Protein Data Bank, Nucleic
Acids Research, 28 235-242. http://www.rcsb.org/pdb
[2] Brown, A. D., Thomas. P. R., 1998, Goal-oriented
Subgraph Isomorphism Technique for IC Device
Recognition. IEE Proceedings I (Solid-State and Electron
Devices) 135,141-150.
[3] Bunke, H., Shearer, K., , 1998, A Graph distance
metric based on the Maximal Common Subgraph, Pattern
Recognition Letters, Vol. 19.
[4] Eppstein, D., 1999, Subgraph Isomorphism in Planar
Graphs and Related Problems, J. Graph Algorithms and
Applications 3(3):1-27.
[5] Gati, G., 1979, Further annotated bibliography on the
isomorphism disease. Journal of Graph Theory 3, 95–
109.
[6] Hannaford, G., Maple, C., Mullins, J., 2001, Finding
and Characterising Candidate Binding Sites, Proceedings
of the 5th IEEE International Conference on Information
Visualisation, InfVis2001, 157-161.
[7] Heiden, W., Goetze, T., Brickmann, J., 1993, Fast
generation of Molecular-Surfaces from 3D Data Fields

with an Enhanced Marching Cube Algorithm, Journal of
Computational Chemistry, 14, 2, 246-250.
[8] Lang, S. Y. T., Wong, A. K. C., 1991, A Sensor
Model Registration Technique for Mobile Robot
Localization. Proc. Int. Symp. Intelligent Control, 298305, 1991.
[9] Levinson, R., 1992, Pattern Associativity and the
Retrieval of Semantic Networks. Computers and
Mathematics with Applications 23,573-600.
[10] Levitt, D.G., Banaszak, L.J., 1992, Pocket - A
Computer-Graphics method for Identifying And
Displaying Protein Cavities and their Surrounding
Amino-acids, Journal of Molecular Graphics, 10, 4, 229234.
[11] Lorensen,W.E., Cline, H.E., 1987, Marching Cubes:
A High Resolution 3D surface Construction Algorithm,
Computer Graphics, 21, 4, 163-169.
[12] McKay, B. D., 1981, Practical Graph Isomorphism,
Congressus Numerantium, 30, 45-87.
[13] Maple, C., 2003, Geometric Design and Space
Planning Using the Marching Squares and Marching
Cube Algorithms, Proceedings of the IEEE International
Conference on Geometric Modelling and Graphics,
GMAG2003.
[14] Maple, C., Donafee, A., 2002, A Boundary
Representation Technique for Three-Dimensional
Objects, Proceedings of the 5th IEEE International
Conference on Information Visualisation, InfVis2001,
397-403.
[15] Messmer, B. T., Bunke, H., 1996, Fast ErrorCorrecting Graph Isomorphism Based on Model
Precompilation, Institut fur Informatik, University of
Bern No IAM-96-012.
[16] Messmer, B. T., Bunke, H., 1999, A decision tree
approach to graph and subgraph isomorphism detection,
Pattern Recognition, vol. 32, 1979-1998.
[17] Novotni, M., Klein, R., 2001, Geometric 3D
Comparison - an Application, in proceedings of ECDL
WS Generalized Documents, 2001.
[18] Novotni, M., Klein, R., 2001, A Geometric
Approach to 3D Object Comparison, in proceedings of
International Conference on Shape Modeling and
Applications, 167-175, 2001.
[19] Novotni, M., Klein, R., 2003, 3D Zernike
Descriptors for Content Based Shape Retrieval, in
proceedings of 8th ACM Symposium on Solid Modeling
and Applications 2003.
[20] Osada, R., et al, 2001, Matching 3D Models with
Shape Distributions, Workshop on Shape-Based Retrieval
and Analysis of 3D Models 2001.
[21] Nagae, T., Agui, T., Nagahshi, H., 1993, Orientable
closed Surface Construction from Volume Data, IEICE
Transactions on Information Systems, 76, 2, 269-273.

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

[22] Tsai, W.-H., Fu, K.-S., 1979, Error-correcting
Isomorphisms of Attributed Relational Graphs for Pattern
Analysis, IEEE Trans. Syst. Man, Cyber., vol. 9, pp. 757768.

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE


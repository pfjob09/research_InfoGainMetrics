The User’s View Level of the GOQL Graphical Query Language
Euclid Keramopoulos1, Philippos Pouyioutas2, Tasos Ptohos1
Abstract
The paper addresses issues related to the design of a
graphical query mechanism that can act as an interface
to any Object-Oriented Data Base System (OODBS), in
general, and the Object Model of ODMG 2.0, in
particular. In the paper, a brief literature survey of
related work is given, and an analysis methodology that
allows the evaluation of such languages is proposed.
Moreover, the User’s View level of a new graphical
query language, namely GOQL (Graphical Object Query
Language), for ODMG 2.0 is presented. The User’s View
level provides a graphical schema that does not contain
any of the perplexing details of an object-oriented
database schema, and it also provides a foundation for a
graphical interface that can supports ad-hoc queries for
object-oriented database applications. Herein we
illustrate, using an example, the User’s View level of
GOQL.

1. Introduction
The evolution of database query languages during
the last thirty years is strongly related to the evolution of
database models and database systems. In the early days,
i.e. the file processing systems era, the manipulation of
data stored in such systems depended on programs
written in some third generation programming language.
Similar imperative languages were also used for querying
the hierarchical and network database systems that
followed the file processing systems. The introduction of
relational database systems proved a major leap forward
in the design/use of query languages as it led to the
development and use of declarative query languages.
The development of declarative query languages,
such as QUEL and SQL, meant that users were able to
query a system by describing what they wanted rather
than how to get what they wanted. The declarative nature
1 School of Informatics & MT, University of North London, 166-220
Holloway Rd, London N7 8DB, UK.
2 School of Computing, Intercollege, 46 Makedonitissas Ave., P.O. Box
24005, Nicosia 1700, CYPRUS.

of these languages made them easier, for the end-user, to
use and understand; moreover, it allowed them to be
established as “user friendly” query languages suitable
for both expert and naive users. Tabular query languages,
that were based on the QBE paradigm [24], were also
proposed for relational database systems. In a tabular
language, such as DBase-IV and Paradox, a skeleton
(structure) of the required tables is displayed on the user's
screen; users can usually express their queries by
checkmarking projected attributes, inserting selection
criteria in the appropriate attributes, and performing any
join operations by inserting common example variables
in the join attributes.
Recent developments in database systems have
resulted in the appearance of object-oriented databases,
which also support the use of declarative query
languages. The SQL-like object-oriented query language
of the ODMG 2.0 [5], namely OQL, has been widely
accepted as the standard in the field. However, OQL is
much richer than the current SQL/92 standard [11] both
in terms of the data structures and the operators it
supports, as it caters for the support of complex object
structures and the object-oriented features of objectoriented databases; furthermore, the language “avoids”
the SQL problem of joining tables because traversing
data over simple navigational paths replaces the need for
joins.
Recent advances in the use of graphical interfaces
and the successful introduction of the Graphical User
Interfaces (GUIs) by a number of vendors, such as Apple
and Microsoft, have also led to the development of a
number of graphical programming languages, such
Visual C++ and Visual Basic. The popularity of
graphical programming languages might be attributed to
users’ perception that these languages are easier to use
and learn compared to textual languages, mainly because
users are freed by the perplexing details of the constructs
of textual languages.
The phenomenal success of graphical programming
languages combined with researchers’ drive to provide
casual database users with an interface that will allow
these users to pose ad-hoc queries, led to the development
of a number of graphical interfaces for various database
systems. Typically, such interfaces allow queries to be

visualised and be represented diagrammatically or
graphically rather than in some obscure code.
In this paper, in Section 2 we critically review most
of the recently proposed graphical query languages,
whereas in Section 3 we propose an analysis
methodology that allows the evaluation and comparative
study of such languages. In Section 4, firstly we outline
some of the features that GOQL offers, and secondly we
introduce a database that we will be using in the
remainder of this paper. In Section 5 we present (and
illustrate, with the use of the example database) the
graphical database schema that GOQL utilizes in order to
represent an object-oriented database schema. The
proposed graphical schema, which is called the User’s
View, allows the representation of all the perplexing
details of any object-oriented database schema and yet it
makes these details simpler for the naive user to
understand and use. We conclude, in Section 6, by
discussing our current and future work and the
implementation of the proposed language.

2. Critical Review of Related Work
The importance of graphical interfaces to the
database field has been reflected by the number of
graphical query languages that have appeared in the
literature during the last decade. Each of these interfaces
caters more or less for the needs of database users by
providing them with a variety of features that allow them
to interface with an underlying database in a graphical
way. Here we review most of these graphical query
languages.
PICASSO [14] is one of the first graphical query
languages proposed and provides an interface for the
universal relation database system System/U; KIVIEW
[17] is a browser interface for object-oriented databases.
PASTA-3 [15] provides a graphical user interface,
similar to the interface of GQL [22], for the KB2
knowledge database system.
QBD* [1,2] is a graphical user interface which
supports most of the relational algebra primitives. One of
the innovative characteristics of QBD* is that it
introduces abstraction to simplify the representation of
the database schema. QBD* is claimed to be a userfriendly graphical query language, however, users have
to go through a series of rather complex steps to
formulate even the simplest of queries; finally, QBD*
does not support the use of universal/existential
quantifiers and the Boolean operator not.
GOOD [21] was built based on the idea of perceiving
a database instance as a graph; the language allowed
users to express queries visually by graphs that were built
from components of a scheme graph. G-Log [20] also

builds on the representation power of graphs but a
prolog-like interface is utilised to express queries on an
object-oriented schema. Although innovative, we feel that
G-Log’s prolog-like interface can alienate most users, as
to express even the simplest of queries prolog rules have
to be used.
OOQBE [23] is based on the QBE paradigm and it
provides a form-based graphical interface for the KIWIS
knowledge base management system. DOODLE [7] is a
visual browser that provides an interface that allows endusers to display database contents using arbitrary
pictures. SMARTIE [25] is another graphical browser
that uses a set of visual display methods to display data
stored using the ITASCA Distributed Object Database
Management System.
AMAZE [3] provides a 3D interface to represent
data and to express queries on an object-oriented
database. The fact that the language supports only
arithmetic/logical expressions, i.e. no support is provided
for
set
operators,
aggregate
functions,
existential/universal quantifiers and recursion, casts
doubts on the expressiveness of the language. Moreover,
we are sceptical about the possible benefits of a 3D
interface because we feel that the process of navigating
through the schema/data maze might be overwhelming
for the user.
Both GQL [22] and Visualizer Query for Windows
[10] utilise the Entity-Relationship (E-R) Model and
allow users (a) to perceive data and the relationships
between these data in terms of an E-R Diagram and (b) to
perform graphical queries on that E-R Diagram. Business
Objects [4] provide users with an interface that allows a
database to be perceived as a set of meaningful objects,
which are constructed from various tables and which
incorporate and encapsulate “join” relationships; based
on this set, queries can be expressed in a diagrammatic
and graphical way.
SUPER [9] is a generic interface, which can provide
support for queries in both relational and object-oriented
databases. It is based on the ERC+ data model, which is
an enhancement of the E-R Model designed to support
complex objects and object identity. OdeView [8] is based
on the Ode object-oriented database system and is
influenced by the QBE paradigm [24].
Gql [19] is a powerful query language based on the
functional data model. It allows graphical queries to be
expressed on a functional database schema, it is at least
as expressive as relational algebra and relational calculus
and it supports queries that contain aggregate functions,
simple arithmetic expressions and nesting of results.
GOMI [12] is based on the object-oriented database
model, and provides users with a powerful graphical
interface for data manipulation and data definition. We

believe that GOMI is not intuitive for naive users as (a) it
utilises mathematical symbols to provide a visual
representation of operators, and (b) its graphical queries
reflect the underlying object-oriented database, which a
naive user might not understand; finally a major
drawback of GOMI is that it does not support method
invocation, and thus, it deprives expert users from using
the full expressive potential of the underlying model.
Kaleidoquery [18] is based on a filter flow-oriented
visual model that provides a 3D interface for data stored
in an object-oriented database. The language is ODMG
2.0 compliant and consistent with OQL; however, we feel
that the 3D interface might suffer from the same
problems as that of AMAZE, and the filter flow-oriented
visual model uses a limited number of metaphors, the
semantics of which might be restrictive.
Quiver [6] seems to be a rather promising graphical
query language for the object-oriented model, and it
provides an interesting interface to formulate graphical
queries; however, from the published work, it looks as if
its design is in its early stages. Thus, for example, it is
not clear, how the database schema looks like or whether
the language supports/will support the set of operators,
that are usually provided by the other query languages.
Based on the published work the language does not
support negation, set operators, existential/universal
quantifiers, etc.

3. An Analysis/Evaluation Methodology
It is apparent that each of the above-discussed
languages addresses a variety of topics and issues, and if
we were to embark on a comparative study of these
languages it would be necessary to adopt an analysis
methodology. The methodology we are proposing builds
on an analysis methodology used in [16] to evaluate
conventional query languages. Our methodology modifies
and enhances this methodology with features and
characteristics that apply to the graphical query
languages case. The features/criteria that we have used
are as follows:
• the underlying data model that is supported by the
graphical query language - the underlying model is
rather important as graphical languages are
interfaces to the data structures and the querying
mechanism that the underlying model provides; for
example, OODBMSs provide a much richer data
definition and querying mechanism;
• the functionality available to user, i.e. whether a
language allows retrieval, update, and/or other
organisational /data definition functions;
• the language interface, - the type of interface affects
the structural appearance of a language; furthermore,

a graphical language with a textual interface is not
so user-friendly, whereas a 3D interface might be too
overwhelming for some types of users;
• the levels of user expertise supported; users have
been categorised as:
♦ casual or naive users, i.e. untrained users,
♦ skilled frequent users, i.e. users who although
have access to a database they do not have much
knowledge of computer systems in general, and
♦ expert users, i.e. professional database
programmers;
• the expressiveness, i.e. whether a language supports
any/all of the following features:
♦ predicates,
♦ complex Boolean expressions and set operations
(union, intersection, difference),
♦ arithmetic expressions,
♦ existential and universal quantification,
♦ aggregate functions (count, max, min, sum,
avg),
♦ the Group-by operator,
♦ recursion;
• the support of methods; although this characteristic
is applicable only to object-oriented databases, it has
been included because it represents an important
feature of a model that is used as the underlying
database in a high proportion of the reviewed
languages;
• the colour support; despite a number of problems
related to the use of colour (colour aesthetics are
subjective, some people are colour blind), it can be
used to effectively emphasise, differentiate, or order
important elements, or to code quantitatively values.
The table, in Figure 1, contains a comparative study
of most of the above surveyed graphical query languages
using the criteria laid out above and is based on
information that can be found in the literature.

4. An Overview of GOQL
The language GOQL has been designed to address
the needs of naive users; thus, the provided interface
hides and encapsulates some features of the underlying
database and represents some others using metaphors.
The language is based on the object model of the ODMG
2.0 and it provides a graphical querying mechanism.
Because there is a direct correspondence between the
features of GOQL and OQL (GOQL supports all the
features of OQL), the language can be used as an
alternative graphical interface to OQL. Thus, GOQL
allows users to express graphically queries ranging from
simplistic ones to rather complicated ones. Among the
features provided/supported by the language are: the

support of a 2D colour interface, the use/support of
methods, predicates, boolean & set operators, arithmetic
expressions existential/universal quantifiers, aggregate
functions, group by and sort operators, functions, and
subqueries.
In the remainder of the paper we present the User’s
View level of GOQL, through which users pose ad-hoc
queries using our graphical query language. The User’s

Data Model
Functionality
Language
Form
User Type

Expressivity

Methods
Colour

Relational
Object-Oriented
Functional
Retrieval
Update
Organisational
2D
3D
Textual
Naive
Skilled
Expert
Predicates
Boolean & Set Operators
Arithmetic Expressions
Existential/Universal Quantifiers
Aggregate Functions
Group-by Operator
Recursion
Yes
No
Not applicable
Black & White
Colourful

'
'
'
'
'
'
'
'
'
'
'

'
'
'
' ' '
'
'
'
'
' '
'
'
'
'
' ' '
' ' '
' ' '
' '
' ' '
' ?
'
'
'
' ' '

Quiver

Kaleidoquery

GOMI

Gql

'
' ' '
' ' ' ' ' '
'
'
'
'
' ' ' '
'
'
'
' '
' '
'
' ' ' ' ' '
' ' ' ' ' '
' ' ' ' ' '
'
' '
?
' ' ' '
'
' ' '
?
'
'
' ' '
' '
'
' '
'
'
'
'

Ode View

SUPER

OOQBE

AMAZE

QBD*

' ' '

G-Log

Pasta-3

PICASSO

)HDWXUHV

View level of GOQL is presented through a database
schema example. The database schema used is called
HOSPITAL. The database is assumed to contain
information about patients, surgeons and operating
theatres. Figure 2, contains the schema definition of the
HOSPITAL database expressed in ODL, the data
definition language of ODMG 2.0.

' '
' '
'

'

'
'
'
'
' '
'
' '
'
'
?

' '

Figure 1
Class Person {
attribute string Name;
attribute string Address;
attribute string Tel_no;
attribute date DoB;
attribute string Sex;
unsigned short Age ();
};
Class Surgeon extends Person {
attribute string Staff_no;
attribute float Salary;
relationship set <Operation> Performs_op
inverse Operation::Performed_by;
relationship set <Private_Patient> Treats
inverse Private_Patient::Treated_by;
float Tax ();
};
Class Private_Patient extends Patient{
relationship Surgeon Treated_by
inverse Surgeon ::Treats;
};

Class Patient extends Person {
attribute char Blood_gp;
relationship set<Operation> Undergoes
inverse Operation::Performed_on;
};
Class Operation {
attribute date Op_date;
attribute string Type;
relationship Theatre Located_in
inverse Theatre::Holds;
relationship Surgeon Performed_by
inverse Surgeon::Performs_op;
relationship Patient Performed_on
inverse Patient::Undergoes;
};
Class Theatre {
attribute short Theatre_no;
relationship set <Operation> Holds
inverse Operation::Located_in;
attribute set <string> Room;
};

Figure 2

number of named class tables; each of these class tables
is named by the name of the class it represents, and it
contains a list of all the attributes, relationships and
methods of that particular class and all its superclasses;
the types of the properties of a class are hidden. The
desktop metaphors that we use in a UV are the following:
• Folders are used to represent relationships, and they
are linked to the row of a class table that is named by
the relationship they represent, e.g. the “Operation”
folder is linked to the “Undergoes_op” row of the
class table “Patient”.
• Briefcases are used to represent a relationship
between a class and its superclasses; i.e. briefcases
are linked to the row of a class table that is named by
the particular relationship. A briefcase can be either
“shut”, in which case it is named with the name of
the most general superclass, or “open”. An “opened”
briefcase reveals a number of folders/shut briefcases
that are immediate subclasses of the class that gives
the name to the briefcase, e.g. the “Performed_on”
property of the “Operation” class table.
• Paper-clips are used to represent collections; they
appear on the right hand side of a class table row
that is named by a collection type, e.g. in the
“Theatre” class table the “Room” row is a collection
of strings, whereas the “Holds” row represents a
collection of “Operation”. The UV does not
distinguish between the different types of collections.
• Disks are used to represent parameters of a method
or a function.
• Envelopes are used to represent properties that have
a complex internal structure, i.e. properties defined
as struct constructs in the underlying object model,
and they are placed on the right hand side of a class
table row.

5. The User’s View Level of GOQL
The graphical representation of the schema of the
underlying database has been utilised by most of the
graphical interfaces that appeared in the literature. The
presence of a graphical database schema is rather
important as it provides a basis upon which graphical
queries can be expressed. Thus, this graphical
representation of the schema must provide for the various
features supported by the underlying data model.
Other graphical interfaces have chosen to represent
explicitly every feature of the underlying database
schema; e.g. in [12] class hierarchies, subtyping, object
relationships, and methods are explicitly represented.
However, such representations can be rather confusing to
naive users, because they contain details which should
not be of their concern.
The graphical representation of the underlying
database schema, that GOQL provides, is called User’s
View (UV). A UV allows the representation of all the
features of the underlying ODMG 2.0 object model;
however, it hides from users most of the perplexing
details, such as methods, hierarchies, relationships. In
particular, a UV (a) does not distinguish between
methods and attributes; (b) does not explicitly support the
representation of is-a hierarchies, but instead it allows
properties inherited by a subclass to be explicitly
represented in that subclass as properties of the
corresponding class table; (c) utilises a number of
desktop metaphors that allow the representation of the
other features of the object model. In Figure 3, the UV of
the HOSPITAL database is given.
The UV is generated from the stored metadata of the
underlying database schema, and it is comprised by a

Person

Theatre
T heatre_no
Holds
Room

Operation

Operation
Op_date
T ype
Located_in
Performed_by
Performed_on

Patient
Name
Address
T el_no
DoB
Sex
Age
Blood_gp
Undergoes_op

Theatre
Surgeon
Patient
Private_Patient

Operation

Name
Address
T el_no
DoB
Sex
Age

Surgeon
Name
Address
T el_no
DoB
Sex
Age
Staff_no
Salary
Performs_op
T reats
T ax

Figure 3

Private_Patient
Name
Address
T el_no
DoB
Sex
Age
Blood_gp
Undergoes_op
T reated_by

Operation
Surgeon

Operation
Private_Patient

6. Conclusions
In this paper we have reviewed and evaluated most
of the graphical interfaces that have appeared in the
literature during the last decade. We have also presented,
using an example, the User’s View level of GOQL which
can be used as a graphical interface to OQL. We believe
that the proposed interface supported by GOQL is the
“simplest” interface amongst those supported by the
various other proposed query languages. We are
currently engaged in a detailed evaluation exercise. The
database schema example presented in this paper will be
mapped to the corresponding graphical representation
schema of each of the discussed query languages. All
these graphical schemas will be given to a group of users
to compare and evaluate. The results of this comparison
study will be presented in a forthcoming paper.
We are also currently implementing, using Tcl/Tk,
on an O2 OODBMS the design of the GOQL User’s
View level and the query constructs of the language. We
are at the same time working on the formal specification
of the language’s semantics.

7. References
1.

2.
3.

4.
5.
6.

7.
8.

9.

Angelaccio M., Catarci T. & Santucci G., 1990a: QBD*: A
Graphical Query Language with Recursion. In IEEE
Transaction on Software Engineering, Vol. 16, No 10, pp.
1150-1163.
Angelaccio M., Catarci T. & Santucci G, 1990b: Query by
Diagram*: A Fully Visual Query System. In Journal of
Visual Languages and Computing, Vol. 1, pp. 255-273.
Boyle J., Fothergrill J.E. & Gray P.M.D., 1994: Design of
a 3D User Interface to a Database. Proceedings of 2nd
International Workshop on Interfaces to Databases, Vol.
2, pp. 127-142.
Business Objects Ltd, 1995: Business Objects.
Cattell R.G.G. & Barry D.K. (Eds.), 1997: The Object
Database Standard: ODMG 2.0. Morgan Kaufmann
Publishers.
Chavda M. & Wood P. T., 1998: Towards an ODMGCompliantrdVisual Object Query Language. In Proceedings
of the 23 VLDB Conference, Athens (Greece), August,
pp. 456-465
Cruz I., 1992: DOODLE: A Visual Language for ObjectOriented Databases. In ACM SIGMOD, No. 5, pp. 71-80.
Dar S., Gehani N.H., Jagadish H.V. & Srinivasan J., 1995:
Queries in an Object-Oriented Graphical Interface. In
Journal of Visual Languages and Computing, Vol. 6, pp.
27-52.
Dennebouy Y., Andersson M., Auddino A., Dupont Y.,
Fontana E., Gentile M. & Spaccapietra S., 1995: SUPER:
Visual Interfaces for Object + Relationship Data Models.

10.
11.
12.

13.

14.
15.

16.
17.
18.

19.

20.

21.
22.
23.

24.
25.

In Journal of Visual Languages and Computing, Vol. 5,
pp. 73-99.
IBM-ASTRAC Ltd, 1995: Visualizer Query for Windows
(VQ/W).
International Standards Organisation, 1992: ISO/IEC
9075:1992(E) Information technology - Database
language - SQL.
Jun Y.S. & Yoo S.I., 1995. GOMI: A Graphical User
Interface for Object-Oriented Databases. In Proceedings of
International Conference on Object-Oriented Interface
Systems (OOIS), pp. 238-251.
Keramopoulos, E., Pouyioutas, P. & Sadler, C. 1997.
GOQL, a Graphical Query Language for Object-Oriented
Database Systems. In Proceedings of the Third Basque
International Workshop on Information Technology
(BIWIT’97): Data Management Systems, Biarritz
(France), July 2-4, pp. 35-45.
Kim, H., Korth, H.F. & Silverschatz, A., 1988: PICASSO:
A Graphical Query Language. In Software-Practice and
Experience, Vol. 18, No 3, 169-203.
Kuntz, M. & Melchert, R. 1989: Pasta-3’s Graphical
Query Language: Direct Manipulation, Co-operative
Queries, Full Expressive Power. Proceedings of the 15th
International Conference on Very Large Databases, pp.
97-105.
McDonald N.H. & McNally J., 1982: Query Language
Feature Analysis by Usability. In Computer Languages,
Vol. 7, pp. 103-124.
Motro A., D'atri A. & Tarantino L., 1988: The Design of
KEVIEW: An Object-Oriented Browser. In Journal of
Expert Database Systems, pp. 107-131.
Murray N., Paton N. & Goble C., 1998: Kaleidoquery: A
Visual Query
Language for Object Databases. Proceedings
th
of the 4 IFIP Working Conference on Visual Database
Systems - VDB 4.
Papantonakis A., & King, P.J.H., 1995: Gql, a Declarative
Graphical Query Language Based on the Functional Data
Model. In Journal of Visual Languages and Computing,
Vol. 6, No 1, pp. 3-25.
Paredaens J., Peelman P. & Tanca L., 1991: G-Log, A
Declarative Graphical Query Language. In Proceedings of
the 2nd International Conference on Deductive and
Object-Oriented Databases, pp. 108-128.
Paredaens J., Van den Bussche J., Andries M., Gemis M.,
Gyssens M. & Thyssens I., 1992: An Overview of GOOD.
In ACM SIGMOD Record, Vol. 21, No. 1, pp. 25-31.
SOFT TOOLRACK LTD, 1995: GQL (Graphical Query
Language).
Staes F., Tarantino L. & Tiems A., 1991: A Graphical
Query Languages for Object Oriented Databases. In
Proceedings of the IEEE workshop on Visual Languages,
pp. 205-210.
Zloof M. M., 1975. Query By Example. In Proceedings of
the AFIPS Conference, Vol 44, pp. 431-438.
Zoeller R. & Barry D, 1992: Dynamic Self-Configuring
Methods for Graphical Presentation of ODBMS Objects.
IEEE, pp. 136-143.


A General Approach to Constraint Solving
for Declarative Modeling Domain

Kwaiter Ghassan
Department of Computer Science
University of Paul Sabatier
118, route de Narbonne, 31062 Toulouse Cedex, France
E-mail: kwaiter@irit.com

Abstract
Research in declarative modeling started some
years ago, and an important progress has been
accomplished and different orientations have been
studied. However, some fundamental problems are not
exhaustively explored: the role of the constraint solvers
in maintaining the scene, detecting the incoherence and
the contradictions between constraints, reducing the
number of generated solutions by dynamically adding
new constraints, are not sufficiently distinct.
In this paper, our main contribution concerns the
declarative modeling with constraints. We have
developed a constraint solver called ORANOS that
offers an extended model of constraint satisfaction
problems. The solver supports two independent domains
of artificial intelligence research: hierarchical
constraints and dynamical constraints. The former
offers efficient solving techniques for over-constrained
problems; the latter allows development of interactive
applications. These essential features allow the solver to
extend the range of declarative modeling applications.

Keywords:
Declarative
Modeling,
Constraint
Satisfaction
Problem,
Dynamical
Constraints,
Hierarchical Constraints, and Intervals Propagation.

1.

Introduction.

Today, the declarative modeling presents an
interesting methodology and offers helpful means to
support the designer in his modeling tasks. With this

paradigm, the designer raisons about the objective to
reach and not about the construction. In other words, the
designer can describe a scene not in providing a
numeric data, but by expressing the features defining
the model characteristic in a high level of abstraction
and imprecision. The modeler then looks for a set of
solutions verifying the given description. Consequently,
the underlying geometrical model of the scene is hidden
from the designer and lets him concentrate on the
essential aspects.
Research in declarative modeling started some ten
years ago. The achieved works in this domain let us to
distinguish a three main phases:
•
The description phase: This phase allows the
designer to describe scenes in a high level of
abstraction. Currently, the existing modelers offer
different tools of interaction. The scene can be
described either by an interpreted language [19], or by
dynamic and scrolling menus [15], or by an almost
natural language [2].
•
The generation phase: In this phase, the
modeler solves the features and provides one or several
solutions, if they exist. The model can be solved by a
procedural approach [22], or by transforming the
description either to a set of rules, which can be solved
using a rule-based technique [24], or to a collection of
constraints which can be solved by a constraint solver
technique [7].
•
The understanding phase: As the designer’s
description is generally vague, several or an infinity of
solutions can be found. In order to overcome this
drawback, the declarative modelers now offer specific
tools allowing the designer to navigate in the solution
space. One can distinguish refinement tools [3,4] and
browsing tools [22]. The modelers suggest also a set of
tools that help the designer to understand the solutions.
One can classify four tools: presentation tools [9],

exploration tools [23], highlighting tools [5,24] and
comparison tools [21].
In this domain, an important progress has been
accomplished and different orientations have been
studied. The current works have been addressed either
to the phase of description, or to some particular
problems, regarding the reduction of number of tests
during the generation and the management of the
multiple solutions. However, several fundamental
problems have been very little studied:
•
The current declarative modelers use a
procedural method to describe features. This approach
obliges the designer to write detailed code fragments
when the scene becomes more and more complex.
However, the constraint method as means of
description, and the role of the constraint solver to
maintain the described models are not sufficiently
distinct.
•
The current declarative modelers don’t offer
any solution to deal with over-constrained problem
produced by contradictions and inconstancies description. However, the role of the constraint solver to detect
and solve the incoherence is not explored.
•
The current declarative modelers are not
enough interactive. The designer is not able to describe
the scene dynamically and control the generated
solutions numbers. Moreover, the utilization of the
constraint solver to solve this type of problem by
incrementally adding additional constraints has not been
prospected.
We believe that the constraint solver has significant
benefits when it is fully integrated into declarative
modelers. Thus, the improvement of declarative
modeling process must take into account, jointly with a
rich designer interface, an efficient constraint solver
module that must represent a central component in any
truly declarative modeler. The constraint solver must be
generic in order to extend the application domains
though it must always find a solution to critical situation
such as over-constrained problem. Furthermore, it must
resatisfy dynamically the constraints whether new
constraints are added or existing constraints are
removed.
The goal of this paper is to show a complete view
of our constraint solver ORANOS that answers to these
requirements. Thus, some related concepts are not
deeply explained but are referred to its references 1. The
rest of this paper is organized as follows: Section 2
introduces the constraint solver; section 3 presents its
basic aspects; section 4 explains the ORANOS phases;
section 5 gives a simple example clarifying the solver
process; section 6 describes an implementation of

1

ORANOS data structures, implementation code, and
complexity are not presented in this paper. The author’s dissertation
[17] describes the constraint solver in more detail. The reader may
contact also the author for information about implementation of
ORANOS.

ORANOS in DEM2ONS declarative modeler; and
finally section 7 presents the final conclusion.

2.

ORANOS constraint solver.

The numeric constraint satisfaction problem
NCSPs over continuous domains (NCSPs) [6, 12, 20]
offers a general representation allowing to express and
solve a vast range of combinatorial declarative
problems. The formal definition of NCSPs is given by a
set of numeric variables defined over continuous
domains and a set of constraints that describes different
numerical relations on the variables. The task of
constraint satisfaction is to find the value assignments
for the variables such that all constraints are satisfied.
However, this approach is still too restrictive and
has two main limitations: It assumes that the set of
constraints is static and completely given from the
beginning, and that no constraint can be relaxed. The
first limitation inhibits the designer’s interaction and the
second does not offer any answer to deal with overconstrained problem, while these aspects are indispensable in the declarative and interactive applications.
The ORANOS constraint solver, presented in this
paper, offers an extended model of NCSPs: DHNCSPs
(Numerical, Dynamical and Hierarchical CSP), which is
based on two independent domains of artificial
intelligence research: dynamical constraints and
hierarchical constraints. The former allows development
of interactive applications, whereas the latter offers an
efficient solution for over-constrained problems.
Moreover, although the dynamic and hierarchical
aspects are extended upon numeric continuous
constraint satisfaction problems, these aspects stay
general and can be applied also on the numeric discreet
constraint satisfaction problems.

3.

Basic Aspects.

ORANOS extends the constraint satisfaction
problems providing a new formal representation called
DHNCSPs that defined by [14]:
HP = (V, D, Cp)
•

a set of numeric variables V={V1,....Vn}.

•
a set of domains D={D1,....Dn}, where
Di=[ai,bi] is a closed interval of continuous numeric
values.
•
a set of constraints Cp={C1p,....Cnp}.
Constraints could represent a linear and no linear
equations, equality and inequality equations. Each
constraint is attached by an arbitrary strength, indicating
how strongly the designer wants particular constraints to
be satisfied. A constraint is a conjunction of primitive
constraints where each one has a set of methods that
satisfies it.

For example, the primitive constraint V1 = V2+ V3
has tree methods:
V1 =V2+ V3, V2 = V1- V3, and V3 = V1- V2
Each method tightens the minimum and the
maximum values of the output variable employing the
minimum and the maximum values of the input
variables:
V1 ≥ minD(V2)+minD(V3), V1 ≤ maxD(V2)+maxD(V3),
V2 ≥ minD(V1)-minD(V3), V2 ≤ maxD(V1)-maxD(V3),
V3 ≥ minD(V1)-minD(V2), V3 ≤ maxD(V1)-maxD(V2).
The constraints are seen as really declarative
descriptions of relationships between variables without
making commitment to how these relations are
implemented computationally. This generalized view
has several important practical applications. For
example, in declarative modeling applications the same
constraint description can be used for computing
outputs variables from inputs variables but also in
another direction, needed inputs variables from given
outputs specifications. The method interpretation of the
constraint can be determined dynamically depending on
propagation variable process.
In addition, ORANOS supports constraint
hierarchy theory2 [1] to handle over-constraint problem.
Thus, if conflict situation occurs, ORANOS leaves
weaker constraints unsatisfied in order to satisfy
stronger constraints. As a result, it divides HP into two
independent DHNCSPs: HP´ and HP´´.
HP = (V, D, Cp), HP´ = (V, D, C´p), HP´´=(V, D, C´´p)
´

While the variables are still shared between HP
and HP´´, the constraints now are divided into two
disjointed sets of constraints C´p and C´´p. The first one
represents a set of satisfied constraints whereas the
second represents a set of unsatisfied constraints.
C

C´p ∪ C´´p and C´p ∩ C´´p

∅

Before the designer’s interaction, the solver is in
static state. In this state, the variables are placed in
Gen_Vars list, and a constraint is either satisfied and
placed in SCL constraints list in decreasing order to its
strength, or unsatisfied and situated in UCL constraints
list.
When a designer’s interaction occurs, the solver
changes its state and passes to a transition state. In this
state, some related constraints, according to their
strengths, are retracted from both lists and placed in
retracted constraints list RCL, and the task of the
2

The theory of constraint hierarchies has been implemented in
several constraints solver based on local propagation technique [8,
25].

constraint solver is to try to satisfy each of them. In this
stage, the behavior of the solver is intrinsically
important when retracted constraint is added to
previously satisfied constraints.
Supporting designer’s interaction, in naive way, by
iteratively solve a sequence of retracted constraints is
time consuming, since each time the solver is invoked
with one of the constraint, it solves the problem from
the beginning. Thus, incremental aspect must supported
to rapidly pass the solver from the transition phase to a
new static phase.
In literature, time stamping technique has been
used in several constraint solvers, such as CLP (R) [13],
to support incremental aspect. Unfortunately, this
technique has a major limitation. It explicitly saves all
the constraints when a manipulated constraint is being
satisfied, and it restores the system when it backtracks
to this constraint. Naively saving and restoring the
entire constraints by pushing and popping them to and
from a stack is expensive in both space and time
because it charges the solver by extra information is not
really necessary. Further, it does not take into account
the fact that adding new constraints may change the
domains of the variables of satisfied constraints.
In order to overcome this problem, the solver
supports incremental aspect, to avoid restarting
completely solving the system from initial variable
domains, by employing memorizing and restitution
technique. The solver saves only the variable domains
before trying to satisfy a constraint and restores them
when an inconsistency between this constraint and the
other satisfied constraints is detected. Whenever a
constraint is satisfied, the domains of concerned
variables are tightened and are saved also in current
satisfied constraint itself. These domains are restored
later, if a satisfied constraint is removed, or retracted in
order to satisfy unsatisfied constraints.
Next, the solver tries to satisfy all the constraints in
RCL employing interval propagation algorithm. If
manipulated constraint is satisfied, it is situated in SCL
list. Otherwise, an inconsistency between the manipulated constraint and SCL constraints is detected and the
constraint is placed in UCL list. When the process is
terminated a new static state of SCL and UCL are
recovered. Finally, the solver extends Forward
Checking technique over continuous domain to generate
solutions.
One can infer that the comportment of ORANOS is
independently defined, apart from any specific
declarative application. Moreover, the designer manages
and controls the solutions, without taking into account
the details of the implementation of the constraint
solver. However, this behaviour is not completely
determined, and is controlled by the designer through
the use of constraint strength.

4.

ORANOS Phases.

the other satisfied constraints. In any case, the solver
retracts the constraint from its list and transmits it to
transition phase.

In ORANOS constraint solver, we can distinguish
four main phases (Cf. Figure 1): the phase of the
interaction, the transition phase, the refinement phase
and the solution phase.

4.2 The transition phase:
In this phase, ORANOS retracts from SCL and

SCL

´

Cn
Cn-1

RCL
Interaction
Phase

8

UCL

SCL

Cn

Cn

Cn-1

Cn-1

C1

C1

C0

C0

Forward
Checking

Gen-Var
V1

Ci-1

Ci-1

Ci-2

Ci-2

C1

C1

C0

C0

V2

Vn

Ci+1

Solution
Phase

Ci

Constraints
Propagation

Ci

Refinement
Phase

UCL

´

Cn

Transition
Phase

Cn-1

C1
C0

Figure 1: Architecture overview of the ORANOS constraint Solver.

4.1 The interaction phase:
ORANOS supports designer’s interaction that
wants to add, remove, or change the strength of a
constraint.
•
Adding the constraints dynamically offers
many advantages: It frees the designer to provide at
once a complete list of constraints, and lets him add
constraints one by one according to his needs. It guides
the designer toward the wished solution. It helps to
restrict the generated solutions number. ORANOS
accepts the newly constraint, and transmits it to
transition phase.
•
At a given time, an unsatisfied constraint
becomes unnecessary, and the designer removes it to
decrease the number of treated constraints when the
number of constraints grows up. The designer can also
remove a satisfied constraint to enlarge the solution
number. In the first case, the constraint is simply
removed from UCL list without invoking the next
phases, whereas in the second case the solver passes to
transition phase.
•
The solver also offers to designer the
possibility to control the generated solution by
modifying the constraint strength. For example, an
unsatisfied constraint could become satisfied either by
increasing its strength or by weakening the strength of

UCL lists the constraints whose strength is inferior to
the strength of the manipulated constraint in interaction
phase, putting them in the RCL list in decreasing order
according to their strengths. Heuristic strength ordering
guarantees that no satisfied constraint will be retracted
again to satisfy any subsequent constraint. Thus, each
retracted constraint will be treated once. Before treating
these constraints in the next phase, the solver needs to
know the currents domains of the variables. In order to
do so, it restores the variable domains from the weakest
satisfied constraint stayed in SCL and updates the
Gen_Vars list. Finally, the RCL list is passed to the
refinement phase.

4.3 The refinement Phase:
In this phase, the solver attempts to satisfy all
retracted constraints in the RCL with SCL constraints.
ORANOS reaches its objective employing two
algorithms:
• The solver uses interval propagation
algorithm3 to detect if HP´ is still satisfied, when it tries
to satisfy a retracted constraint from RCL, and at the
same time, to transform the HP´ into an equivalent HP´

3

Interval propagation algorithm is derived from original
algorithm presented by [27] and generalized by [6] in order to take
into account the numeric constraints.

but one in which the domains of the variables are
decreased. This algorithm is based on boundconsistency concept [20]. By definition, a variable V1 of
HP´ is bound-consistent iff :

∀ C (V 1 ,..., V k ) a constraint of HP´,
∃ v 2 ,..., v k ∈ D 0 × ... × D k /C(a, v 2 ,..., v k ) is
satisfied,

∃ v 2 ,..., v k ∈ D 0 × ... × D k /C(b, v 2 ,..., v k ) is
satisfied.
where Dv1=[a,b].
Therefore, a HP´ is satisfied if all the domains of
the variables are bound-consistency. This concept
provides efficient solutions for two fundamental
problems:
•
The reduced domains of constrained variables
can be a union of disjointed intervals that are produced
from the disjunctive constraints4. Disjunctive constraint
destroys the convexity of the domains and produces a
combinatorial problem. However, bound-consistency
concept preserves the convexity and guarantees
consistence conditions over the bounds of the domains.
•
Constraint cycles can lead to the convergence
problem that slows the solver considerably. The boundconsistency concept surmounts this problem by
interrupting the propagation when the domains are not
more sufficiently restricted. In this case, the concerned
constraints are not anymore propagated.
Practically, ORANOS removes constraint from
RCL and decomposes it to its primitive constraints.
Then, it executes all the methods associated with each
one. When a method is executed, the intervals for
constrained variables are tightened and propagated
through SCL constraints list, to eliminate values from
the domains of other related variables, using interval
propagation algorithm. If any of the domains of the
variables become empty, then the evaluated HP´ are
unsatisfiable and an inconsistency between this
constraint and SCL constraints list is detected. In this
case, the previous evaluated variable domains are
restored and the manipulated constraint is added to the
UCL. Otherwise, if manipulated constraint is satisfied, it
is added to the SCL list. The solver repeats this process
for all the constraints until RCL is empty.
For example, let HP´ be a set of satisfied
constraints presented by:
•
a set of variables V ={v1,v2},
•
a set of domains D={DV1=[0,100],
DV2=[0,100]},

4

The presence of disjunctive constraints depends on the domain
of variables, where the same constraint can be disjunctive for certain
domains but not disjunctive for others. For example, the constraint
y=x2 is non disjunctive for Dx=[-2,2] and Dy=[0,4], but is disjunctive
for Dx=[-2,2] and Dy=[1,4]. A complete survey of the disjunctive
constraints is found in [12].

a set of constraints HP´= {C1strong :V1+V2=2,
C2medium : v2 ≤ v1+1,C3weak : v2 ≥ v1}.
•

Interval propagation algorithm reduces the domains
to be {Dv1=[0,2], Dv2=[0,2]}.

• The bound-consistency concept determines
only a local consistency and interval propagation
algorithm reaches a fixed point and stops. Generally, the
fixed point doesn’t allow to determine a global solution
of constraints system. So, the solver achieves additional
stronger filtering, based on 3-bound-consistency
concept [20], which also preserves the convexity and
reduces at the utmost the two bounds of the variables.
By definition, a variable V1 of HP´ is 3-boundconsistent iff:
and
where

HP´1 = (HP´ ∪ {V1 =a}),
HP´2 = (HP´∪ {V1 =b}),
Dv1=[a,b].

Therefore, a HP´ is satisfied if all the domains of
the variables are 3-bound-consistency.
This concept has been already implemented by
successively adding additional constraints on each
bound of the variables. However, this implementation
presents a major inconvenient because it adds an
excessive number of constraints and makes the system
slow.
ORANOS supports 3-bound-consistency concept
but it introduces efficient improvement allowing to
overcome this drawback. First, the solver collects the
constrained variables in HP´ and puts them in temporary
list in increasing according to their domain lengths.
After that, ORANOS tries to restrict each variable
domain by increasing its lower bound. It reduces the
domain for manipulated variable, and collects the
related satisfied constraints that share the manipulated
variable, and propagates them using interval propagation filtering. After the propagation, if HP´stays
consistent, the process will be iterated for the same
variable but with a more restricted domain. On the
contrary, if an inconsistency is detected, the examined
domain will be removed and the process will be stopped
in this direction. When the solver treats all the variables
in the list, it repeats the same process, but in opposite
direction considering the higher bounds of the variables.
Applying this filtering now on the previous
example, allows to restrict the domains to {Dv1=[0.5,1],
Dv2=[1,1.5]} which presents a global solution of the
constraints.

4.4 The solution Phase:
Thanks to refinement phase, the designer can
reason on the range of variable domains that satisfy
constraints globally and not on discrete solution. In
practical situations the designer also needs to obtain one
or multiple solutions. For example, instantiating the

variables are necessary to visualize or place objects in
declarative modeling applications.
Forward Checking [11] is really a hybrid of a treesearch algorithm and a filtering algorithm for classic
CSP problem. ORANOS extends this technique for
numeric continuous domains in order to instantiate the
variables [18]. ORANOS sorts the variables in
increasing order according to their domain lengths.
When a variable is instantiated, interval propagation
algorithm filters all the domains of the future variables
in such a way that the remaining domains are still
consistent with the current variable. If during this
filtering process one of the domains of the future
becomes inconsistent, a new value for the current
variable must be tried. When the Forward Checking
algorithm moves forward to instantiate the next variable
it does not need to perform any consistency checks
because all the remaining values in the domain are
guaranteed to be consistent with the past variables.
However,
declarative
applications
involve
inaccurate data or partially defined parameters that
make the problem generally under-constrained, and a
very large number of solutions can be obtained (infinite
solution in the case of continuous domains). Thus,
ORANOS proposes one only solution. In any cases, the
designer can ask the solver for other possible solutions
or control the produced solution, either by changing the
strength of existing constraints or by adding additional
ones.

5.

placed in UCL. The tightened variable domains now are
(DV1=[50,50], DV2=[20,300], DV3=[-300,300], and
DV4=[-300,300]).
•
The designer adds a new required constraint
cn4 composed of two primitive constraints (V1+ V2= V3
and V3 +25= V4) is added. So, the solver retracts cn2
from SCL and places it with cn4 in RCL. Then, it
satisfies first cn4 and cn2 respectively and places them in
SCL. According to its strength, cn3 is still satisfied and
will never be retracted. When cn4 is satisfied, the
variable
domains
become
(DV1=[10,255],
DV2=[20,265], DV3=[30,275] and DV4=[55,300]). When
the solver tries to satisfy cn2, the new reduced domain
of V1 propagates through the satisfied constraints in
SCL. Thus, the tightened variable domains are modified
again and have finally the values: (DV1=[50,50],
DV2=[20,225], DV3=[70,275] and DV4=[95,300]).
Obviously, cn1 stays unsatisfied and placed in UCL.
•
Adding a strong constraint cn5 composed of
one primitive constraint (V4≤100) will retract cn2 from
SCL and places it with cn5 in UCL. ORANOS satisfies
first cn5 propagating the tightened domains through cn3
and cn4; then it satisfies cn2 and the tightened variable
domains will be modified again and have finally the
values: (DV1=[50,50], DV2=[20,25], DV3=[70,75] and
DV4=[95,100]).
•
Finally, the designer asks the solver to find a
solution. ORANOS employs Forward Checking
algorithm to generate the solution: V1=50, V2=20, V3=70
and V4=95.

Example.
6.

The given example has an objective to illustrate the
basic aspects of ORANOS solver: generally, avoid
breaking and dynamically. Considering the following
variables: V1, V2, V3 and V4. Initially, we suppose that
the variables have an initial domain initial [-300,300]
and SCL, RCL, and UCL are empty.
•
First, the designer adds a weak constraint cn1
composed of 4 primitive constraints: (V1=5, V2=5, V3
=10 et V4=200). ORANOS accepts this constraint and
satisfies cn1 and places it in SCL list, tightening the
variable domains to be (DV1=[5,5], DV2=[5,5],
DV3=[10,10] and DV4=[200,200]).
•
Then, it adds a medium constraint cn2
composed of one primitive constraint (V1=50). The
solver satisfies cn2 according to constraint hierarchy
theory. As a result, the constraint cn2 is placed in SCL
list, whereas the constraint cn1 is retracted from SCL
and placed in UCL. Thus, the tightened variable
domains are now (DV1=[50,50], DV2=[-300,300],
DV3=[-300,300], and DV4=[-300,300]).
•
The designer adds a new required constraint
cn3 composed of two primitive constraints (V1≥10 and
V2≥20) is added. So, the solver satisfies cn3 and places it
in SCL with cn2, whereas cn1 is still unsatisfied and

Integration of ORANOS in DEM2ONS
declarative modeler.

DEM2ONS declarative modeler (Declarative
Multimodal MOdeliNg System) [10] represents an
interesting declarative modeler for three-dimensional
scenes. The conceptual design of DEM2ONS must
support a wide class of applications (declarative
placement, declarative animation, and mechanical
assembly modeling,…).
Although the constraints are expressed in high
level of abstraction, they are solved by dynamic links
technique, which doesn’t present a generic method and
inhibits the modeler to maintain a large range of
applications. For complex scene, it becomes much more
difficult to keep track of all the relationships.
Furthermore, it is limited for particular kinds of
constraints and it doesn’t offer any solution to deal with
over-constrained problem and dynamic constraints.
In order to make DEM2ONS declarative modeler
more efficient, an independent module that presents
ORANOS constraint solver is integrated in the modeler.
Therefore, the modeler now is composed of three main
parts: a multimodal interface, the solver, and a 3D-scene
modeler [16] (Cf. Figure 2):

ORANOS
Constraint Solver

Task Model

2D Gestures Geste 3D

Designer

Speech

Application

Multimodal Interface

Words

Objects

Natural Language

Constraints

Gestural Language

Multimodal
Dialogue Manager

Figure 2. The new architecture of the DEM2ONS System.

Multimodal Interface: The DEM2ONS
multimodal interface allows the designer to easily
describe a scene throughout multiple combined
modalities, provided by several input devices.
Designer’s interaction is collected and treated by an
Event Managing module to provide a single command
sent to the constraint solver. DEM2ONS uses a Task
Model module which defines a lot of application
features (function specifications, object attributes, list of
objects...). This model is used to provide information
about the application to the generic modeler, if needed.
•

• The 3D Scene Modeler: The 3D constrained
objects are instantiated from several abstract classes
using object oriented techniques and are modeled and
rendered by using the Inventor ToolKit [26]. Inventor
supports several tasks. It offers a high level for the
designer’s interaction; it handles events and allows the
system to manage pop-up menus and widgets. It also
lets the designer explore the scene from multiple points
of view.
• ORANOS constraint solver: In DEM2ONS,
the constraints have a high significant role in the design
process. The solver supports linear equality as well as
inequality constraints. For example, it supports
geometric constraints expressed by linear and non-linear
equality equations such as distance constraint, parallel
constraint and horizontal constraint; as well as topologic
constraints that are expressed by linear inequality
equations. Encapsulation object-oriented technique
helps the solver to define various types of constraints,
whereas inheritance mechanism aids it to deal with
complex constraints.
The relations between the different modules of the
modeler are strong and coherent. ORANOS handles the
constraints passed from the multimodal interface,
maintains the system, and transmits to DEM2ONS the
new refined interval domains variables, as well as the

instantiated variables values in order to update the
constrained object attributes.
Thanks to the ORANOS module, the utility of
DEM2ONS is considerably enhanced and the ergonomic
of the modeler is greatly improved. ORANOS provides
the modeler a generic method to deal with different
declarative applications. Moreover, the solver increases
the interactivity of the modeler offering different tools
of interaction allowing the designer to dynamically
construct the model, and easily interact to modify the
description or the results through the constraints. The
solver also guarantees the continuous working of the
modeler, even if all the constraints are not satisfied.
Currently, The modeler is employed to solve
declarative placement problem [18]. For this problem,
the modeler differences between three constraint types.
Internal constraints are applied on one object and used
to define its intrinsic properties such as its position,
orientation, or fixed dimensions without any relation to
other objects. These constraints are considered as
required constraints, which are always satisfied.
External constraints are preferential and are applied
between objects. The modeler provides several types of
spatial and geometric constraints such as: in front of,
behind, against, on the left of, and a distance x of, in
order to express relationships between objects. Boolean
constraints react on the pragmatic level also well as on
the geometric level of placement problem. A Boolean
constraint can be imposed on the relevance of the
objects in order to validate a declarative expression. It
can be invoked also to examine the stabilization of the
objects and manages the collisions between them. They
have some common properties: they are implicit,
required, and are not integrated in the solver but are
managed by the modeler.
Each object refers to a particular class that
describes its specific properties. Several properties and
attributes are shared among the objects. On can

distinguish classic geometric attributes such as position,
volume, and bounding box of the object, as well as
functional and pragmatic properties such as orientation
properties, and type property. These properties integrate
knowledge about the usual function of objects in order
to offer the closest solution for the designer dealing with
semantic and the pragmatic constraints.

7.

References

[2]

[3]

[4]

[5]

[6]
[7]

[8]

[9]

[10]

[11]

[13]

[14]

Conclusion.

In this paper, we have first outlined several works
in declarative modeling domain to demonstrate the need
of developing an efficient constraint solver to deal with
the designer’s requirements. Then, we have presented a
complete presentation of ORANOS constraint solver:
both the design principal and different phase’s process.
We have proved that constraint hierarchies and
dynamical and incremental aspects are fundamental for
any truly declarative modeler, by integrating ORANOS
into DEM2ONS declarative modeler.

[1]

[12]

Borning A., Benson B-F, Wilson M. Constraint
Hierarchies. In Lisp and Symbolic Computation
Journal, Vol. 5, 1992.
Caubet R., Djedi N., Gaildrat V., Rubio F.,
Pérennou G., Vigouroux N. NOVAC: A drawing
tool for blind people. In Interface to real and
virtual worlds, France, 1992.
Champciaux L. Declarative Modelling: speeding
up the generation. In Proceedings of the
International Conference on Imaging Science
Systems and Technology, CISST’97, Las Vegas,
June 30-July 3, 1997.
Chauvat D. Le projet VoluFormes: un exemple de
modélisation déclarative avec contrôle spatial.
Thèse de Doctorat, Université de Nantes,
Décembre 1994.
Colin C. Towards a system for Exploring the
Universe of polyhedral Shapes. In Eurographics’88, Nice, 1988.
Davis E. Constraint Propagation with Interval
Labels. In Artificial Intelligence, Vol. 32, 1987.
Donikian S., Hégron G. A Declarative Design
Method for 3D Scene Sketch Modeling. In
Eurographics'93, Vol. 12 (33), 1993.
Freeman-Benson B., Maloney J. and Borning A.
An Incremental Constraint Solver. Communications of the ACM, Vol. 33 (1), January 1990.
Gaildrat V., Caubet R., Rubio F. Conception d’un
modeleur déclaratif de scènes tridimensionnelles
pour la synthèse d’images. MICAD’93, Paris,
1993.
Gaildrat V., Caubet R., Rubio F. Declarative scene
modelling with dynamic links and decision rules
distributed among the objects. In ICCG’93,
Bombay, February 1993.
Haralick R.M., Elliot G.L. Increasing tree search
efficiency for constraint satisfaction problems. In
Artificial Intelligence, Vol. 14, 1980.

[15]

[16]

[17]

[18]

[19]

[20]

[21]

[22]

[23]
[24]

[25]

[26]

[27]

Hyvönen E. Constraint reasoning based on interval
arithmetic: the tolerance propagation approach. In
Artificial Intelligence, Vol. 58, 1992.
Jaffar J., Michaylov, S., Stuckey P., Yap R. The
CLP (R) language and system. ACM Transactions
on Programming Languages and Systems, Vol. 14
(3), July 1992.
Kwaiter G., Gaildrat V. and Caubet R Dynamic
and Hierarchical Constraints Solver with
Continuous Variables. In Proceedings of the 6th
French Conference on Logic Programming and
Constraint Programming, Orléans, 26-28 May
1997.
Kwaiter G., Gaildrat V. and Caubet R.
DEM2ONS: A High Level Declarative Modeler for
3D Graphics Applications. In Proceedings of the
International Conference on Imaging Science
Systems and Technology, CISST’97, Las Vegas,
June 30-July 3, 1997.
Kwaiter G., Gaildrat V. and Caubet R. Integrating
an Incremental Constraint Solver With a High
Declarative
Modeler
for
3D
Graphics
Applications. In Practical Application of Constraint Technology Proceedings, PAPPACT’98,
London UK, 25-27 March 1998.
Kwaiter G. Modelisation declarative de scenes:
Etude et realisation de solveurs de contraintes.
Thèse de Doctorat, Université Paul Sabatier,
Toulouse, Décembre 1998.
Kwaiter G., Gaildrat V. and Caubet R. Controlling
Objects Natural Behaviors with a 3D Declarative
Modeler. In Proceeding of Computer Graphics
International, CGI’98, Hanover, Germany, 24-26
June 1998.
Laakko T. and Mäntyla Martii. Incremental
constraint modelling in a feature modelling
system. Eurographics’96, Vol. 15 (3), 1996.
Lhomme O. Consistency Techniques for Numeric
CSPs. In Proceeding of the 13th International Joint
Conference on IA, 1993.
Lucas M. et Desmontils E. Les modeleurs
déclaratifs. Revue internationale de CFAO et
d’informatique graphique, Vol. 10 (6), 1995.
Martin P. and Martin D. Declarative generation of
a family of polyhedra. In Graphicon’93, Saint
Petersbourg, September 1993.
Mounier J.P. Le projet UrbaForme: premiers pas.
Rapport interne IRIN, N. 117, Nantes 1996.
Plemenos D. Contribution à l’étude et au
développement des techniques de modélisation,
génération et visualisation de scènes: Le projet
MultiFormes. Thèse de Doctorat d’état, Université
de Nantes, Novembre 1991.
Sannella M. SkyBlue : A multi-Way Local
Propagation Constraint Solver for User Interface
Construction. ACM SIGGRAPH Symposium on
User Interface Software and Technology
Proceedings, California, November 1994.
Strauss S., Carey R. An Object-Oriented 3D
Graphics Toolkit. In Computer Graphics, Vol. 26
(2), July 1992.
Waltz D. Understanding line drawings of scenes
with shadows. The Psychology of Computer
Vision, 1975.


Triangle Mesh Compression for Fast Rendering



Dong-Gyu Park, Yang-Soo Kim, Hwan-Gue Cho
Department of Computer Science, Pusan National University
Jang-Jun Dong, Keum-Jung Ku, Pusan, 609-735, Korea
e-mail : fdongupak,yskim,hgchog@pearl.cs.pusan.ac.kr
Abstract
Modern GIS(Geographic Information System) application programs and simulation systems have to handle large
datasets for rendering. Currently three dimensional rendering hardware are facing a memory bus bandwidth bottleneck problem at the graphics pipeline. One general solution
for this problem is to compress the static three dimensional
geometry in a preprocessing phase.
We present a new mesh compression/decompression algorithm for this application. Our compression algorithm
breaks down a triangle mesh into a set of triangle strips
and vertex chains. After decomposition, we encode vertex
connectivity with entropy encoding. Our algorithm provides
a 32% improvement in the compression ratio over existing
“Generalized Triangle Mesh(GTM)” compression and supports parallel decompression. We also proposed a parallelogram prediction method for vertex coordinate compression.

1. Introduction
The volume of geometric models used in GIS and graphics applications is increasing. So many geometric datasets
require a large amount of disk space. One main objective
of geometric compression is to develop a fast and simple
algorithm to handle those large geometric data. As the size
of rendering data increases, a large amount of memory bus
bandwidth is required for graphics display systems. We can
see that rendering a 20 megabyte data model using a 30 Hz
graphics display requires as much as 600 MB/sec of memory bus bandwidth. This transfer rate is beyond the capability of current low-cost graphics systems. So current three
dimensional rendering hardware frequently face a memory
bus bottleneck problem.
Compressing the static three dimensional geometric
datasets through a pre-processing phase has been proposed
 Authors wish to acknowledge the financial support of the Korea Research Foundation made in the Program Year 1999.

as a general solution of this problem. The geometric
datasets are compressed and stored in main memory for
real-time rendering, then they are sent to the rendering hardware for real-time decompression using a fast hardware
decompressor[1]. For this rendering application, the hardware decompressor needs a fast and simple decoding algorithm.
“Generalized Triangle Mesh(GTM)” was first introduced
by Deering, it consists of triangle strips and a mesh buffer
to store the old vertices[2]. In GTM, interior vertices should
be referenced twice to store the original triangle mesh.
GTM has small queues(called mesh buffer) to reference old
vertices in the triangle strip[2][3]. This technique needs
1=8dlog2 ne + 8n bits to represent the connectivity information for a given triangle mesh[6]. Chow improved the
performance of GTM using some heuristics[1].
Taubin have proposed an efficient method for geometric
dataset compression using topological surgery[9]. He encoded total edge connectivity of the mesh about 2 bits per
triangle. But this method needs a large amount of internal
memory during decompression.
Touma proposed a new triangle mesh compression method created by exploiting triangle marching
structure[10]. He uses a vertex connectivity code for compressing triangulation. The connectivity codes consists of
“add”, “split” and “merge”. He encodes mesh connectivity
as a list of vertex degrees in a special order, and this procedure requires a vertex stack to make the final triangles,
where the edge connectivity is encoded by 1.5 bits/vertex.
Floriani has proposed a compression method based on
shelling[8]. This method uses 2 bits for control codes,
which are called “skip”, “vertex”, “left” and “right”. He
also proposed a progressive compression method in which
the edge connectivity is encoded by 4.4 bits/vertex.
Gumhold has presented new compression algorithm
which are fast enough for real time applications[5]. The
connectivity
is encoded about 1.7 bits/vertex and requires
p
10 n memory during compression and decompression.
Recently, Kim has proposed a new triangle mesh compression method based on Delaunay Triangulation[7]. The

main feature of this compression method is that almost 90%
of triangles are the same as in Delaunay triangulation.
Each compression method has trade-offs between
compression ratio and compression/decompression time.
Taubin, Floriani and Kim’s methods need quite a long compression/decompression time. Since hardware decompressor supports only small register to store previous vertices,
Taubin, Floriani, Kim, and Touma’s algorithms will not satisfy real-time rendering constraints. So we will focus on
Deering and Chow’s method for real-time rendering[1].

2. Triangle strip decomposition
We define triangle strip T i as a consecutive sequence
of triangles
ti0 ; ti1 ;    ; tin
and vertex chain C i as
i
a consecutive sequence of vertices
v0i ; v1i ;    ; vn
.
In Figure 1, let t0 = 41; 6; 7, and t1 = 41; 2; 7,
where 4vi ; vj ; vk  denotes a triangle whose vertices are
vi ; vj ; vk . The triangle mesh Mo can be decomposed as a
set of triangle strips fT 0 ; T 1 ;    ; T n g.
1

2

4

3

6

5

11

8
9

7

10

13
14

12

16

15

17

21
18

19

20

24

22
23

Figure 1. Triangle strip T 0 is constructed from
a boundary vertex chain 1; 2; 3; 4; 5 . Also
the second vertex chain is obtained from the
first triangle strip.

Figure 1 shows the triangle strip construction step. The
first triangle strip T 0 can be constructed from the first vertex
chain 1; 2; 3; 4; 5 . All triangles in the first triangle strip
T 0 are adjacent to the first vertex chain C 0 . All triangles
in T 0 are marked as “visited”, and the second vertex chain
6; 7; 8; 9; 10; 11
is obtained from T 0 . We can make
the next triangle strip T 1 from the second vertex chain C 1 .
This procedure continues till whole triangles are marked as
“visited”. Breaking down a triangle mesh into a set of triangle strips is very similar to the GTM algorithm and can be
accomplished in linear time. A triangle strip can be made
from a pair of vertex chains and edge connectivity information between those two vertex chains. Edge connectivity is
represented by the degree of each vertex.
In Figure 1, vertex 6 has only one edge connection to
the first vertex chain, vertex 7 has four edge connections.

We know that all vertices in a vertex chain are ordered by
their adjacency. Therefore, vertex 6 is connected to vertex
1, vertex 7 is connected to vertex 1,2,3 and 4 in the first
vertex chain. We restore vertex chains and degree of each
vertex to reconstruct the triangle strips. One distinguishing
difference with GTM is that our algorithm does not need to
revisit the vertex chain to encode a triangle mesh. Table 1
shows the final encoding results of Figure 1.
vertex chain
C

0

C

1

C

2

C

3

vertex list
1; 2; 3; 4; 5
6; 7; 8; 9; 10; 11
12; 13; 14; 15; 16; 17
18; 19; 20; 21; 22; 23; 24

vertex degree

0; 0; 0; 0; 0
1; 4; 2; 1; 1; 1
1; 2; 1; 3; 2; 2
2; 1; 2; 2; 2; 2; 1

Table 1. Final encoding results of Figure 1.

2.1. Triangle strip encoding
We start with an arbitrary vertex from a given triangle
mesh. Since the starting point has no connectivity to the
previous vertex chain, the degree of starting vertex chain
is 0. The next vertex chain is obtained from the starting
vertex. We obtain the triangle strip from the previous vertex
chain. The vertex degree is the number of connected edges
between the current vertex and the previous vertex chain.
The end of vertex chain has one dummy vertex for marking
the end of vertex chain.
Because we only consider the edge connectivity between
previous vertex chain and current vertex chain, the most
common vertex degree of our algorithm is 2. Large number of vertex degree(e.g. 8,9,10) seldom appear in general
meshes. The number of vertex degree has locality in our experiments, small degree numbers(e.g. 1,2,3) are about 95%
of the total vertices. A sequence of vertex degrees is encoded with Huffman encoding to reduce disk storage[10].
After compression, mesh connectivity information can be
broken down by ordered vertex set fv0 ; v1 ;    ; vn g, and
Huffman code fH dv0 ; H dv1 ;    ; H dvn g.

2.2. Decoding procedure
Here we will explain our decoding algorithm with small
test data. Figure 2 shows an example of the decoding procedure.
Let C k be a k th vertex chain and vik be a ith
vertex in C k .
The test data is encoded as a vertex chain C k = fv1k ; v2k ; v3k ; v4k g and C k,1 =
k,1 k,1 k,1 k,1 k,1
fv1
; v2 ; v3 ; v4 ; v5 g, where dv1k  =1, dv2k 
=3, dv3k  =3, and dv4k  =1. Triangle mesh is constructed
from vertex chain C k and previous vertex chain C k,1 .

The degree of vertex v1k is 1, so we can see that v1k
has connection to v1k,1 . We also know next vertex v2k is
connected to v1k . This connectivity shows that vertex set
k k k,1 g consists of triangle T k,1 . The next verfv1 ; v2 ; v1
1
tex v2k has 3 edge connectivity to C k,1 . This fact tells us
that v2k has connectivity to v1k,1 ; v2k,1 ; v3k,1 and the next
vertex v3k . We can make triangles tk2 ,1 , tk3 ,1 and tk4 ,1
from set of vertices fv2k ; v1k,1 ; v2k,1 g, fv2k ; v2k,1 ; v3k,1 g
and fv2k ; v3k,1 ; v3k g.
At the end of the vertex chain, dv4k  =1, but v4k does
not have a following vertex. After making the final triangle,
vertex chain C k is assigned to the previous vertex chain and
the next vertex chain C k+1 is constructed.
v1k

v2k

Ck
C k,1

(a) Vertex v1k and v2k make 1 and 3 triangles, respectively.
v3k

(b) d(v3k )=3, vertex v3k makes 3 triangles.
v4k

from the previous vertex chain. If one triangle strip has a
pocket or hole, triangles in the next triangle strip are not
adjacent to the current strip. So we have to handle these
special cases. We define two degenerated cases of triangle
strips.
pocket - a set of triangles which are not isolated by
vertex chain and not adjacent to the next vertex chain.
hole - a set of triangles which are isolated by vertex
chain.
If a pocket or hole is encoded in processing a vertex
chain C k , they must be marked to generate next triangle
strip T k , whose information is added to the current vertex.
The basic assumption of our method is that all vertices in
the vertex chain C k and C k+1 are adjacent. But vertices in
pockets and holes are not adjacent to the next vertex chain,
and must be eliminated from current vertex chain.
If a pocket or hole is found, a skip code “S” and the
number of vertices in a pocket or hole are inserted. If a
vertex vi in the current vertex chain C k meets a skip code
“S2”, the set of vertices in C k must be updated to a vertex
chain    ; vi ; vi+3 ;    .

vk
vk+2
1111111
0000000
0000000
1111111
0000000
1111111
0000000
1111111
vk+1
0000000
1111111
0000000
1111111
0000000
(a) 1111111
A triangle in the pocket can be
constructed from skip code S1.

(c) d(v4k )=1, but v4k does not have following vertices.

Figure 2. A snapshot of decoding procedure.

k
k+3
1111111
0000000
0000000
1111111
0000000
1111111
vk+1 v
k+2
0000000
1111111
0000000
1111111
v

v

vk

vk+3

111111
000000
000000
111111
000000
111111
vk+1 vk+2
000000
111111
000000
111111
000000
111111
(b) Triangles in the pocket can be made
from skip code(S2) and OP code C13.

k+2
111111
000000
000000
111111
vk+1
000000
111111
000000
111111
000000
111111
vk

v

(c) Triangles in the pocket can be made (d) In this case, skip code S2 and
from skip code(S2) and OP code C02. OP code C12 cannot make any triangle.

Another advantage of our decompression method is that
it supports parallel decompression. We can make a triangle
strip from only two adjacent vertex chains.
Triangle strip T k,1 and T k are made from vertex chain
k,1 ; C k g and fC k ; C k+1 g, respectively. Although C k
fC
is referenced by T k,1 and T k , vertices in C k,1 , C k and
C k+1 can be referenced independently. Therefore, triangles
in T k,1 and T k can be constructed using parallel algorithm.

3. Special cases: hole, pocket
In this section, we present some degenerated cases of our
triangle strip algorithm and propose heuristics to improve
the compression performance. We make a set of triangles

Figure 3. A snapshot of skip code and OP
code.
The triangles in the holes and pockets comprise about
10% of the total triangles, which are revisited after all of the
triangles are made into a set of triangle strips. All vertices
in these degenerated cases will be referenced twice in the
mesh.
To achieve a high compression ratio, we must reduce
this vertex reference in pockets and holes to improve compression performance. In our experiments, we found that
more than 67% of pockets and holes have only one skip
vertex. This example is shown in Figure 3 (a). Since vertex

4vk ; vk+1 ; vk+2  can be
made using this implicit rule.
Furthermore, we find that more than 20% of pockets
and holes have two skip vertices. If the vertex vk meets
skip code S2, there would be three kinds of degenerated
cases. Figure 3 (b), (c) and (d) show all of the degenerated cases of skip code S2. Figure 3 (b) shows that
two triangles 4vk ; vk+1 ; vk+3  and 4vk+1 ; vk+2 ; vk+3 
can be made from skip code and OP code C13. Also,
Figure 3 (c) shows two triangles 4vk ; vk+1 ; vk+2  and
4vk ; vk+2 ; vk+3  can be made from skip code and OP
code C02. In Figure 3 (d) skip code S2 meets OP code C12
and this kind of OP code cannot make additional triangles.
Additional OP codes are required for this description but
significantly smaller than vertex references. Using those
implicit rules, we can reduce revisited vertices.
Figure 4 shows an example of a run of our encoding algorithm.

vk meets skip code S1, triangle

4. Vertex coordinate compression
The vertices in triangle mesh have three coordinates information, normals and colors. The vertex compression
technique was proposed by Deering[2].
The 8-bit exponent of 32-bit IEEE floating point numbers is used to represent the x, y, z coordinate. Deering
proposed delta encoding to store the x, y, z coordinate. This
compression is lossy but shows a good compression ratio by
using data locality[2].
v0k

Ck

v2k

v1k

y
x

C k,1

The  and the K are prediction parameters, and
vn,1 ; : : : ; vn,K are K ancestors of the vertex along the

unique path to the vertex tree root.
Touma proposed a parallelogram prediction scheme.
The method is based on their encoding scheme, using an
“active list”, whenever a new vertex is encoded, the existing
triangle is used to predict the next vertex. He used a discrete
“curvature” value to make a more accurate prediction value.
Our encoding scheme is similar to Touma’s parallelogram rule. The basic assumption of our algorithm is that the
curvature of a vertex chain C k is very similar to the previous vertex chain C k,1 and next vertex chain C k+1 . Using
this curvature, we can predict the coordinates of the next
vertex.

Ck

C k ,1

v0k

v0k,1

vk

1

v2k
vp

v1k,1

Figure 6. Parallelogram prediction.

Figure 6 shows our parallelogram prediction scheme.
The next prediction position of a vertex v1k in vertex chain
C k is predicted by the parallelogram of a vertex v0k,1 and
the next vertex v1k,1 in the previous vertex chain C k,1 .
Using three vertices 4v1k ; v1k,1 ; v2k,1 , we can predict the
next vertex vp using the parallelogram rule.
We measured the error value with three different methods. The experimental results show that the parallelogram
rule gives 6 %, 15% better prediction results compared with
delta encoding and linear prediction, respectively.

5. Experiments

Figure 5. A snapshot of delta encoding.

Figure 5 shows an example of delta encoding. The vertex v2k in vertex chain C k can be represented by the delta
difference between v1k and v2k . The sum of difference value
 x; y; z  and v1k is v2k . The delta difference between v1k
and v2k is relatively small because they are neighborhood
vertex in the same vertex chain C k .
Taubin encoded the mesh vertex coordinates vi by first
quantizing the three vertex coordinates to a finite number of
bits(8 bit is typical) by bounding the interval in which the
coordinates lie[10]. The algorithm used a linear prediction
scheme:
vn = vn  + P ; vn,1 ; : : : ; vn,K 

The experimental terrain data files were obtained from
USGS(US Geographical Survey). The data were used by
Garland for their experiments with the refinement algorithm
in the SCAPE system[4]. The number of vertices in our test
data is between 30,000 and 50,000.
Table 2 show the experimental results of our compression.
Table 3 shows our experimental results of decoding time.
Execution time was obtained on an SGI O2 workstation,
which has a MIPS R5000 180MHz single processor and
256MB of main memory. The test data are the same as in
table 2. The experimental results show that over 1,466,996
faces are decoded in one second. Our decompression time
outperforms the other compression algorithms. Compared
with the Gumhold’s algorithm, which was run on a similar

model

vertex

face

conn.(bits)

bits/vert.

bits/face

Ashby
Crater
GrandCa’n
Spokane-w
Yakima-e
Yakima-w

50,000
50,000
50,000
30,000
50,000
30,000

99,468
99,472
99,697
59,721
99,637
59,713

302,904
310,912
310,120
224,390
341,720
218,992

6.05
6.21
6.20
7.47
6.83
7.29

3.04
3.13
3.11
3.75
3.42
3.66

Table 2. Experimental results of the mesh
compression.

model

face

Ashby
Crater
GrandCa’n
Spokane-w
Yakima-e
Yakima-w

99,468
99,472
99,697
59,721
99,637
59,713

decompression time(sec)
reading time
decoding time
3,13
3.32
3.22
1.98
3.26
1.98

0.070
0.079
0.059
0.059
0.070
0.059

face/sec
1,420,971
1,259,139
1,689,780
1,688,305
1,261,228
1,688,458

Table 3. Experimental results of decompression time. Our algorithm decodes average
1,466,996 faces per second and read average
30,299 faces per second from disk.

machine(O2 workstation), they decoded average 800,000
faces per second[8].
Figure 7 show the visualized results of Crater Lake. All
test data were encoded and decoded on an SGI O2 workstation and visualized with Open Inventor library and Java3D,
respectively.

6. Conclusions
We proposed a new algorithm for compressing/decompressing large triangle meshes for real-time
rendering.
Among the many existing triangle mesh
compression methods, GTM is widely used for real-time
rendering. Our algorithm gives a 32% improvement in the
compression ratio over existing GTM algorithms for this
application, and does not need any additional buffer during
decompression. Moreover, our method supports linear
time mesh compression and parallel decompression. We
implemented an encoding algorithm on an SGI machine
and visualized the results with Open Inventor and Java3D
environments. Here we give some future works:
1. How to encode the holes and pockets efficiently.
2. To develop an algorithm for minimizing pockets and
holes.

Figure 7. Terrain visualization using Java3D
API(Crater Lake).

3. Implementation of the parallel decompression on parallel
display hardware.

References
[1] M. Chow. Optimized geometry compression for realtime
rendering. In IEEE Visualization ’97 Proc., pages 347–354,
Oct. 1997.
[2] M. Deering. Geometry compression. In SIGGRAPH ’95
Proc., pages 13–20, Aug. 1995.
[3] F. Evans, S. Skiena, and A. Varshney. Optimizing triangle
strips for fast rendering. In IEEE Visualization ’96 Proc.,
pages 319–326, 1996.
[4] M. Garland and P. S. Heckbert. Fast polygonal approximation of terrains and height fields. Technical report, CS Dept.,
Carnegie Mellon U., Sept. 1995.
[5] S. Gumhold and W. Straßer. Real time compression of triangle mesh connectivity. In SIGGRAPH ’98 Proc., pages
133–140, July 1998.
[6] H. Hoppe. Progressive meshes. In SIGGRAPH ’96 Proc.,
pages 99–108, Aug. 1996.
[7] S. Kim, Y. Kim, M. Cho, and H. Cho. A geometric compression algorithm for massive terrain data using delaunay
triangulation. In WSCG ’99, volume 1, pages 124–131, Feb.
1999.
[8] P. M. Leila De Floriani and E. Puppo. Compressing tins. In
ACM-GIS’98, pages 130–145, Nov. 1998.
[9] G. Taubin and J. Rossignac. Geometric compression through
topological surgery. Technical report, Research Report RC20340, IBM Research Division, 1996.
[10] C. Touma and C. Gotsman. Triangle mesh compression. In
Proc. of Graphics Interface ’98, pages 26–34, 1998.

1st vertex chain(C 0 )

Start 1
7
8

2

3

21

26

32

31

30

8

11 12
19

21

28

2

C

2

8
15 16

14

13
10

9

21

32

31

30

26

1

2

5

3

8

C

10

17

1; 1; 2; 1

21

22
29

26

2

3

7
8

34

15 16

14

21

22
29

17
23

30

31

22

.

26
32 33

17

18
26
32

31

2

3

15 16

21

34

22
29

35

(g) Vertex 13 has no edge connectivity to C 6 .
6
C =
28; 34 and its degree list is S 1; 2; 2

.

11

5

C

12

20

27

28

34
35

6

5
4

13
10

9

6

28

.

13;    ; 20 has a pocket, S1 inserted.
5
C =
13; 12; 20; 27; 33; 32; 31 and
its degree list is 1; S 1; 3; 1; 2; 2; 2; 3 .

8

C

35

33

17

18

23

30

24 25

31

26
32

11

12

19

20

27

34

19

24 25

23

7

12

19

28

13
10

30

1

14

18

24 25

11

27

4

9

15 16

(f)

13

9

20

6

5

3

29

35

6
10

2

21

28

4

11 12

33

31

20

4

5

26

32
30

3

.

6

19

24 25

23

8

27

35

13

22

11 12

33

5

18

7

(e) Vertex 4 has no edge connectivity to C ,
4
C =
6; 11; 19; 26; 25; 24; 23; 30; 29 and
its degree degree is S 1; 2; 2; 1; 1; 2; 1; 2; 1; 2
1

17

14

32

31

30

15 16

1

18

24 25

23

.

4

19

34

(d) C has a pocket in 17;    ; 22 , therefore
3
C =
4; 5; 10; 18; 17; 16; 15; 22; 21
and its degree list is 2; 1; 1; 1; 1; S 2; C 13; 2; 2; 1; 1

13

9

15 16

14

9

29

35

4

7

3

10

8

21

34

6

28

4

7

28

(c) Find next vertex chain C 2 from C 1 .
2
C =
3; 9; 8; 14 and its degree list is

20

27

33

20

27

33

C

3

11 12
19

26

31

2

14

18

24 25

23

22
29

17

30

1

4

7

19

24 25

23

11 12

(b) Find next vertex chain C 1 from C 0 .
1
C =
2; 7 and its degree list is 1; 1

6

5

18

32

29

35

3

17

22

34

(a) Make first vertex chain(C 0 ) from a starting vertex.
Vertex chain C 0 is 1 and its degree is 0 .
1

13
10

9

15 16

6

5

4

20

27

33

1

7

14

18

24 25

23

22
29

17

C

3

13
10

2

1

4

9

15 16

14

6

5

33

20

27

28
34

C

7

35

(h) C 7 = 35 and its degree list is 2 .
Vertex 35 has no neightborhood triangle.

Figure 4. An example of a run of our encoding algorithm. The vertex chains are marked by thick lines
and triangles already visited are filled.


2010 14th International
Information
Conference
Visualisation
Information Visualisation

Polytree Numbering for Citation Networks Visualisation
Alex Logvynovskiy, Mohammad Dastbaz
School of Computing, Information Technology and Engineering, 
University of East London, Docklands Campus, University Way 
London E16 2RD, United Kingdom
{a.logvynovskiy, m.dastbaz}@uel.ac.uk
Abstract—Citation networks form directed acyclic graphs.
Visualisation of the reference relationships within the
network requires fast determination of ancestor-descendant
relationships among the nodes within the digraph. Polytrees
(singly connected digraphs) constitute an important class of
acyclic digraphs and can be viewed as generalised directed
trees where multiple parent nodes are permitted. In this paper,
we propose a new ancestral numbering scheme for polytrees
that allows fast determination of ancestor-descendant
relationships among the nodes without traversal. The scheme
is used to index and visualise reference relationships within
citation networks.
Keywords—citation networks, visualisation,
numbering, ancestor-descendant relationships

finding expert
expert profiles

Thiagarajan (2008)

Budanitsky (2006)
expert finding

Fellbaum (1998)

expert finding systems

6
Bogers (2008)
n = No of ref

Maybury (2006)

Turney (2006)

tags

Figure  1.  An example of a bookmark map.

polytree

The scale of the reference network is the main challenge
in visualising the citation network – whilst digraphs
allow a great flexibility in modelling and presentation,
many of the important algorithms and tasks belong to the
nondeterministic polynomial class (NP-complete) [5]. If
the modelling requirements can be restricted to acyclic
digraphs (dags), it is possible to reach a better trade-off
between flexibility in representing data and efficiency of
its processing – due to the fact that the complexity of the
graph algorithms for dags can be significantly reduced. Even
further improvements can be achieved if directed trees can
be used instead of dags [6].
However, it is not always possible to reduce graph models
to trees without losing the essential structural information,
nor there exist efficient solutions for general graphs. In such
cases, polytrees may provide adequate solutions. Choi and
Darwiche examined computing mutual information between
nodes in Bayesian networks [7]. They showed that using
polytrees in approximate inference algorithms can reduce
the overall algorithm complexity
Trees can be considered as a special case of polytrees.
Dietz showed that an ancestor relationship between nodes in
an ordered tree can be determined based on the preorder and
postorder traversal numbers of the nodes. Any two nodes A
and B of the tree have an ancestor relationship  between
them if and only if A occurs before B in the preorder
traversal and after B in the postorder traversal of the tree
[8].
Li and Moon proposed a way to determine the ancestordescendant relationship quickly and without traversal of the
data tree. However, this scheme only deals with data that
have tree-like structure [6].
In this paper, we propose a scheme that allows fast
detection of the ancestor-descendant relationship in polytrees
by exploiting the ancestral node numbering of the nodes. We
then exploit the scheme for mapping and visualisation of the
citation network.

I.  Motivation and related work
The network of scientific publications is complex and
highly-connected graph of references, co-authorship and
co-publishing relations [1]. Reference management and
online bibliographies utilise metadata, citation indexes and
social annotation to maintain personalised subsets of the
citation network. However, with the number of scientific
publications ever increasing, there is a growing need for a
new approach in reference management that would strongly
rely upon user-centricity, collaboration and interactivity to
facilitate guided navigation through publication space [2].
Visualisation of the citation relationship makes it easier for
researchers to place their publications in context within their
bibliographies, compare with other researchers and explore
broader research environment [3].
For example, consider an excerpt from a list of references
on the topic of ‘expert finding’ below:
Budanitsky, A., Hirst, G., ‘Evaluating WordNet-based measures of lexical
semantic relatedness’, Computational Linguistics, vol. 32, 2006,
pp. 13–47.
Fellbaum, C. ed., WordNet: An Electronic Lexical Database, The MIT 
Press, 1998.
Turney, P.D., Similarity of Semantic Relations, Cogprints, 2006.

An example of a citation map for these references may
look similar to the one shown in Figure  1.
Citation networks form directed acyclic graphs (dag)
as references can only point to the previously published
papers. Efficient mapping of the citation network can,
therefore, be reduced to determination of whether a pair of
nodes is bound by an ancestor-descendant relationship in
the corresponding dag. The task of detecting an ancestordescendant relationship between the nodes in digraphs is
crucial for many graph operations [4].
1550-6037/10 $26.00 © 2010 IEEE
DOI 10.1109/IV.2010.22

WordNet

1065

18

86

II.  Polytree numbering scheme
In this section, we derive a polytree numbering scheme
by examining the tree numbering suggested to Dietz [8].
We employ his idea to use tree traversal numbers in order
to determine ancestor-descendant relationship. We then
geometrically interpret and extend the scheme in order to
make it applicable to polytrees.
Directed acyclic graph (dag) is a digraph with no cycles.
A node A is an ancestor of a node B and the node B is the
descendant of the node A if there is a path from A to B .
Immediate ancestors/descendants are referred to as parents/
children respectively.
A (directed) tree is a dag whose every node has at most
one parent. A polytree is a simple digraph whose underlying
graph has no cycles. This means that for any two vertices
in a polytree, there is at most one path between them. The
term originates in the field of Bayesian networks to describe
singly connected networks which do not allow multiple paths
between any network nodes [9]. Trees can be considered as a
special case of polytrees.
A  numbering (sorting function, ordering) of a digraph
is a bijection that assigns every node of the graph a unique
number. A  numbering can be represented as an ordered
sequence of the nodes [10]. An ancestral numbering is a
numbering that assigns each node with the number smaller
than the numbers corresponding to all of its descendants.
Dag is proved to be the only type of digraphs that have an
ancestral numbering [11], [10].
A  digraph (dag, tree, polytree) is ordered if there is a
predefined sequence of parents and children of its nodes.

A  B : Ax < Bx , Ay > By

where Ax , Ay and Bx , By are preorder and postorder traversal
numbers of the nodes respectively.
Figure  2 presents an example of a tree with preorder
and postorder numbers assigned to its nodes. Node B is an
ancestor of node E , 2 ≤ 4, 3 ≥ 2 ⇒ f (B)  f (E) , but node
D

f : N  ( x, y )

tree

A  B ≡ f ( A)  f ( B ) :
tree

where ( Ax , Ay ) , ( Bx , By ) are the numbering of the nodes
A, B respectively.
From geometrical perspective, the ancestral relationship
 of the node N is represented by its descendant quadrant
with the node itself as a point of origin as shown in Figure  4.
The quadrant corresponds to a set of descendants and is
limited by the segment
[ N x , +∞), [ N y , +∞)

A

A

1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 19 10210 3
G

11

C

22
33

C
(5,5)

E
(4,2)

F
(6,4)

(6) 

We will hereafter refer to the segment (6) as an ancestral
frame of the node. One can observe that an ancestral frame of
a node includes ancestral frames of its descendants. For our
example in Figure  3b, the shaded areas originating from the
nodes represent their ancestral frames – the ancestral frame
of node B includes the ancestral frames of its descendants
D and E , but neither its ancestor A nor siblings C , F and G .
With the introduction of ancestral frames, we can now
extend the numbering scheme to polytrees.

A
(1,7)

D
(3,1)

(5) 

tree

: Ax ≤ Bx , Ay ≥ By ,

referring to a pair of preorder N x and postorder N y traversal
numbers of the node N correspondingly.
Dietz’s idea to use the preorder and postorder traversal
numbers of the nodes to test an ancestor relationship between
them can be written as follows [8]:

B
(2,3)

(4) 

where x, y are the preorder and postorder numbers of the
node N Î  respectively.
In effect, the interpretation produces a layout of the tree.
For instance, the adjusted numbering of the sample tree
from Figure  2 is shown in Figure  3a.
We define an ancestral relationship  on the tree nodes
as a partial order on the node numbering:

(2) 

N y = y,

tree

N y =  − y,

(1) 

N x = x,

tree

N x = x −1,

where 1 £ x £  , 1 £ y £  are the preorder and postorder
numbers of the node N Î  respectively and  is the size
of the node set  .
We use notations f ( N ) and ( N x , N y ) interchangeably
tree

tree

is not, 3 ≤ 4, 1 ≥ 2 ⇒ f (D)  f (E) .

We consider a geometrical interpretation of the tree
numbering and treat the numbering of a node ( N x , N y )
as 2D  coordinates of the node respectively, adjusting the
numbering of every node so that the root of the tree is
positioned in the point of origin:

A.	 Tree Numbering
For an ordered directed tree T = {V, A} , we define tree
numbering as a function that assigns each node N Î  with
a pair of its preorder and postorder numbers:
tree

(3) 

44
55

G
(7,6)

a) 6 6

F
B
E
D

4

1

4
5
b) 6

6

G

C

2
3

5

F
B
E
D

7 7 3.  Tree embedding based on tree
Figure 
7 numbering as coordinates.

Figure  2.  Tree numbering.

87

88

8

99

9

1010

10

7

8

9

10

3

4

4

5
6

5
6

7

7

8

8

Ancestors v  N
9
v10
x < N x ≤ v x + vw

Ancestors v  N

vx < N x
vy < N y

3

9
10

v y < N y ≤ v y + vh N

N
Descendants N  v

Descendants N  v

N x < vx

N x < vx ≤ N x + N w

N y < vy

N y < vy ≤ N y + Nh

Figure  4.  Tree numbering quadrants.

Figure  7.  Polytree numbering frames.

B.	 Extending Tree Numbering for Polytrees
In the previous subsection, we considered the ancestral
numbering of the ordered directed trees. While polytrees
are singly-connected like trees, the application of the tree
numbering might not be straightforward due to the fact that
polytree nodes are permitted to have multiple parents. This
may cause some nodes to have nondescendants incorrectly
included in their ancestral frames. For example, Figure  5a
shows an ordered polytree where node A must precede
node D    and node B must precede node C . According to
the numbering, both nodes A and D are ancestors of node
C and, as a result, the ancestral frame of node D wrongly
includes node C as depicted in Figure  5b.
As a solution to this problem, we considered to ignore the
original order of the nodes allowing them to be rearranged
so that the applied ancestral tree numbering is still valid. In
the example shown below, the original order of the nodes D
(Figure  6a) and B (Figure  6b) have been ignored, hence,
permitting alternative traversals of the nodes.
However, this poses a problem of finding the best way
to traverse a polytree if the order of its nodes is not known.
Similar issues arise when the polytree nodes are being added
iteratively, one at a time, as there is no indication of how
to number new nodes so that they comply with the existing
numbering. This, in turn, can lead to an undesired traversal
of the existing polytree.
We derive a solution from an observation that the above
problems are caused by overlapping of the infinite ancestral
frames (6). Instead, we propose to use finite ancestral frames

quadrant with a rectangle, as depicted in Figure  7.
The layout of the finite ancestral frames depends on the
sequence the nodes are added or traversed. They also provide
some clues on how to add new child/parent node to an
existing polytree. We considered a right/left-most approach
when implementing a prototype discussed in section III.
Figure  8 depicts finite ancestral frames for the
alternative traversals of the polytree from Figure  5b and
Figure  6a and b respectively.
The polytree numbering can be described in terms of
finite ancestral frames.

[ N x , N x + N w ], [ N y , N y + N h ]

C.	 Polytree Numbering
Given a polytree P = {V, A} , we define polytree
numbering as a function that assigns each node N Î  with
a quadruple ( N x , N y , N w , N h ) :
f (N ) : N

polytree

N x = x ′ −1,
N y =  − y ′,

D
(1,0)

1
2

(a)

B
(2,3)

C
(3,2) (b)

3

A

1

D

2

N ≺v

N h = max (v y ) − N y ,
N ≺v

where 1 ≤ x ′ ≤  , 1 ≤ y ′ ≤  are preorder and postorder
traversal numbers, 1£ w £  , 1£ h £  are the distances
between the node and its descendants, variable v takes on a
value of every node and expressions max (vx ) and max (v y )

(7) 

3

4

5

C
B

4
Figure  5.  Tree numbering applied to an ordered polytree.
5

6

7

(8) 

N w = max (vx ) − N x ,

where N w , N h represent the relative distances from the node
N x , N y that are sufficient enough to include all descendants
of the node. Geometrically, this is equivalent to replacing a
A
(0,1)

( x, y, w, h),

N v

N v

refer to right-most and left-most descendants of the node  
correspondingly.
We define an ancestral relationship  on the polytree
nodes based on the node numbering:
8

9

10

A B ≡

f ( A) 

polytree

f ( B) :

polytree

: Ax ≤ Bx ≤ Ax + Aw , Ay ≤ By ≤ Ay + Ah .

(9) 

It should be noted that the ancestral relationship for trees

D
D
D
A
A
11 22 33 44 55 66 1177 2288 3399 4410
1056
555 661
61 772
72 883
83 994
94 10
10
10
5 6161 7272 8383 9494 10
510
5 61
61 7 2
72 8 3
83 9 4
94 105
10
5 66111 77222 88333 99444 10
10
5
5 66 77 88 99 10
10
A
C
C
A
A 1 2 3 4 5
7
111
11
11
11
11
C
D
D
B
B
11
1
8
2
222
22
22
22
22
B
C
B
B
2
2 C
9
3
333
33
33
33
33
(a)
(b) 10
(a)
(b)
(c)
3
3
4
444
44
44
44
44
Figure  6.  Alternative polytree traversals.
Figure  8.  Polytree numbering depending on traversal.
4
4
5
555
55
55
55
55
5
5
6
666
66
66
66
66
6
6
7
777
77
77
77
77
7
7
88
88
888
88
88
88
88
8
99
999
99
99
99
99
9
10
10
10
10
10
10
10
1010
10
10
10
10
10

6

7

8

H
(1,0,3,10)

A
(0,4,10,6)

B
(2,8,2,2)

C
(5,6,1,1)

E
(4,9,0,0)

D
(3,10,0,0)

I
(8,1,2,4)

J
(7,2,3,3)

K
(9,3,1,2)

F
(6,7,0,0)

•	

G
(10,5,0,0)

Figure  9.  Polytree numbering.

(5) is a special case of the ancestral relationship for polytrees
(9) where the numbering is adjusted according to (4) and the
distances are set to infinity and, therefore, can be omitted.
An example of the polytree numbering is given in
Figure  9.

B.	 Scalability
We devised and implemented several algorithms for
manipulating nodes in polytrees and digraphs based on
their ancestral numbering (axly.org/research/polytree). The
retrieval requests used a pair of input nodes to perform the
following operations:
•	 Retrieve nodes along the ancestor-descendant path
(AD): {C } : ∀C ∈ , A  C  B ;
•	 Retrieve all common ancestors of the nodes (CA):
{C } : ∀C ∈ , C  A, C  B ⇒

III.  Experimental evaluation
In order to evaluate the whole framework, we used it in
a context of social bookmarking and assessed its scalability.
A.	 Social bookmarking prototype
We developed a prototype system that implements
polytree numbering to build a citation network index within
a social bookmarking framework (refmark.org). The main
features of the system are outlined below:
•	 Spanning polytree index for fast retrieval – Once a
polytree numbering index of bookmarks is build,
the traversal of the graph is no longer required in
order to determine ancestor-descendant relationship
among nodes. To accommodate the scheme for dags,
we build an index for the spanning polytree of the
graph and maintain an additional index for the arcs
that are not covered. Whilst resulting in additional
closure operations, this index is considerably smaller
than the main index. We consider optimisation
of this index as our future work. Figure  10 shows
an embidding of the polytree numbering index 
(axly.org/research/polytree/).
•	 Visualisation according to underlying structure –
cited publications provide visual cues for further
research decisions.
•	 Navigable results – good starting point for browsing
H

1

2

3

4

5

6

7

1

4
5

6

7

8
(a)

1

9
9 10
10

H

2

3

4

5

6

7

1

8

I

4
5

8
9

D

 		

(b)

10

G

C

6

E

F
B
E
D

Figure  10.  Screenshots of the prototype results: (a) polytree embedding, (b) polytree with the ancestor frames.

89

10

K

3A

7

9

J

2

B

8

	

10

F

7

5

⇒ Cx > max ( Ax , Bx ) , C y > max ( Ay , By ).
To evaluate the scalability of the mapping scheme, the
experiment was conducted in several stages:
1.	 An initial set of random polytrees each containing a
thousand nodes was generated.
2.	 All newly added nodes were indexed using the
polytree numbering and, if necessary, adjustments
made in the digraph nodes index.
3.	 A thousand of random pairs of nodes were selected
for each of the retrieval operations (AD, CA, CD)
and their execution times recorded;
4.	 The steps 2 and 3 were repeated 20 times,
subsequently adding a thousand of new nodes on
every iteration.
A comparison chart of the average times of building an

G

C

6

4

⇒ Cx < min ( Ax , Bx ) , C y < min ( Ay , By ) ;
Retrieve all common descendants of the nodes (CD):
{C } : ∀C ∈ , A  C , B  C ⇒

K

3A

3

I

9

•	

J

2

2

8

or finding a bridging publication or term that
binds otherwise disjoint publication clusters. The
network-like representation reveals the underlying
connections among the publications and, therefore,
facilitates navigation to and/or discovery of the new
papers.
‘Fuzzy browsing’ interface – the outcomes of a
keyword search, tag faceting, browsing or steps
of orienteering through the publication network
produce visually consistent results – a network of
the linked publications. This, in turn, can be used as
an input for further contextual filtering by search or
faceting. A segment of a publication map generated
by the prototype is given in Figure  11.

Figure  11.  A sample of the publication map filtered by a tag.

index and retrieval is shown in Figure  12.
As can be seen from the comparison, the cost of the
retrieval operations are significantly lower than the initial
indexing, thus making the ancestral numbering scheme
suitable for applications where the polytrees have a low
dynamic and the retrieval operations are frequent. It should
also be noted that all three retrieval operations have equally
low processing costs.

polytrees interactively and explore the scheme by laying out
the polytree nodes according to their ancestral numbering.
A series of experiments was conducted in order to estimate
an average time taken by indexing and retrieval operations.
The results reveal that the use of the proposed scheme shifts
the traversal costs to the indexing stage and significantly
reduces time of the retrieval operations.
We plan to explore various optimisation techniques
when building spanning polytrees for dags. We also consider
experiments with several structural and semantic modules
combined by a weighting function for clustered output.

Time (s)

IV.  Conclusions and future work
In this paper, we developed a new ancestral numbering
scheme for polytrees. The tree numbering proposed by
Dietz [8] was analysed, geometrically interpreted and then
extended for polytrees.
We showed the use of the polytree numbering scheme
as a means of mapping the network of reference bookmarks
within the collaborative semantic bookmarking framework.
We implemented the proposed scheme as an online
prototype system. The prototype allows create and modify

Index

500

AD

CA

400
300
248

266

11
10

12
11

287

312

325

354

388

R eferences
[1]	 M.E.J. Newman, “The structure of scientific collaboration
networks,” Proceedings of the National Academy of Sciences of the
United States of America,  vol. 98, Jan. 2001, pp. 404–409	
[web] www.pnas.org/content/98/2/404 (2 October 2009)	
 
[tags] co-authorship, citation networks, collaboration networks,
small worlds.
[2]	 S. Jupp, R. Stevens, S. Bechhofer, Y. Yesilada, and P. Kostkova,
“Knowledge Representation for Web Navigation,” Semantic Web
Applications and Tools for the Life Sciences (SWAT4LS), 2008
[tags] skos, kos, weak semantics, guiding navigation, ontologies.
[3]	 H. Small, “Visualizing science by citation mapping,” Journal of the
American society for Information Science,  vol. 50, 1999, pp. 799–813
[tags] citation networks, visualisation, co-citation, science
mapping.
[4]	 D. Shasha, J.T.L. Wang, and R. Giugno, “Algorithmics and
applications of tree and graph searching,” Proceedings of the twentyfirst ACM SIGMOD-SIGACT-SIGART symposium on Principles
of database systems,   Madison, Wisconsin: ACM, 2002, pp. 39–52
[web] portal.acm.org/citation.cfm?id=543613.543620 (17 April 2009) 
[tags] tree search, graph search.
[5]	 J. Bang-Jensen and G.Z. Gutin, Digraphs: Theory,
Algorithms and Applications, Springer, 2002	
[tags] digraphs, theory.

CD

392

420

448

487

200
100
0

13
12

14

14

15

20

17

18

18

25

13

14

15

16

17

18

19

20

Number of nodes (×1000)

Figure  12.  Comparison of indexing/retrieval time. CA/CD  represent
time taken by a thousand of common ancestors/descendants retrieval
operations, AD  – ancestor-descendant paths, Index – time to build an
index for a newly added thousand nodes.

90

[9]	 J. Pearl, Probabilistic Reasoning in Intelligent Systems:
Networks of Plausible Inference, Morgan Kaufmann, 1997	
[tags] singly connected networks.
[10]	 E. Castillo, J.M. Gutierrez, and A.S. Hadi, Expert Systems
and
Probabilistic
Network
Models,
Springer,
1997
[web] books.google.co.uk/books?id=L1kHa-Sb2y0C&lpg=PP1&dq=
0387948589&pg=PA122#v=twopage&q=&f=false	
 
[tags] graphs, polytree.
[11]	 J.L.
Gross
and
J. Yellen,
Handbook
of
Graph
Theory,  Boca Raton, Fla: CRC Press, 2004	
[tags] graphs, theory.

[6]	 Q. Li and B. Moon, “Indexing and Querying XML Data
for Regular Path Expressions,” Proceedings of the 27th
International Conference on Very Large Data Bases,
Morgan Kaufmann Publishers Inc., 2001, pp. 361–370	
 
[web] portal.acm.org/citation.cfm?id=672035 (22 April 2009) 
[tags] XML, indexing, join algorithms, tree numbering scheme.
[7]	 A. Choi and A. Darwiche, “Many-Pairs Mutual Information for Adding
Structure to Belief Propagation Approximations,” Proceedings of
the 23rd national conference on Artificial intelligence – Volume 2,  
Chicago, Illinois: AAAI Press, 2008, pp. 1031–1036	
 
[web] portal.acm.org/citation.cfm?id=1620232 (4 May 2010)	 
[tags] Bayesian networks, belief propagation, polytrees.
[8]	 P.F. Dietz, “Maintaining order in a linked list,” Proceedings of the
fourteenth annual ACM symposium on Theory of computing,   San
Francisco, California, United States: ACM, 1982, pp.  122–127 
[web] portal.acm.org/citation.cfm?doid=800070.802184 (17 Apr 2009) 
[tags] tree numbering.

91


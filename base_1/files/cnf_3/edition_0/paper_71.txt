2012 16th International Conference on Information Visualisation

Boundary labeling of graph edges using colors
ˇ
Miroslav Cerm´
ak, Jiˇr´ı Dokulil
Department of Software Engineering
Charles University
Prague, Czech Republic
(cermak,dokulil)@ksi.mff.cuni.cz

Jana Katreniakov´a
Department of Computer Science
Comenius University
Bratislava, Slovakia
katreniakova@dcs.fmph.uniba.sk

In this paper, we describe a solution, where colors are used
to facilitate the edge-label pairing. The label is displayed
with a colored background and we place a small square tag
on the line. The tag is painted the same color as the label
background.
The two main problems of this solution are the following:
(a) we should use as few colors as possible and make them as
distinct as possible, (b) the labels and edges should be placed
and colored in such a way, that their pairing is unambiguous,
i.e., for any tag, user should be able to correctly identify the
corresponding label, and for any label, the user should be
able to correctly locate the corresponding tag.
The rest of the paper is organized as follows. First, related
work is discussed in Section II. Then, Section III describes in
greater detail our method of displaying the labels, the overall
structure of the algorithm that computes the drawing, and
detailed description of the individual steps of the algorithm.
Section IV brieﬂy discusses our implementation of the
algorithm and provides an example of a drawing generated
by the implementation. Finally, the last section concludes
the paper and discusses future work.

Abstract—One of the problems of applying graph drawing
techniques to information visualization is the problem of
displaying edge labels. These labels often contain information
that is important to the user, but the displayed text can make
the drawing less clear. One solution is to put the text of the label
outside the drawing, usually at the left or right border. Then,
the main issue is connecting these texts to the corresponding
edge. In this paper, we present a solution that uses colors (color
coding) to solve this problem in such a way, that only minimal
intrusion into the drawing of the graph is necessary.
Keywords-graph drawing; edge labels; boundary labeling;
color coding

I. I NTRODUCTION
Graph drawing is mostly used for visualization of structured information. The complex information is modeled
as objects (nodes) and connections between them (edges).
Graph drawing techniques produce a layout of nodes and
routing of edges according to chosen aesthetic criteria.
However, in many applications, the objects and relations
have some textual information assigned to them. These texts
should be displayed to the user as labels of nodes and edges
in order to communicate node and edge attributes in the
most convenient way.
In this paper we deal with edge labeling. The edges are
mostly drawn as lines (line segments, polylines, curves,
etc.) and, unlike nodes, they cannot directly contain text.
We make no further assumption about the graph drawing
technique used to create the drawing of the graph, but
we assume that the graph is then viewed using a limited
viewport and scrolling.
The fact, that edges are drawn as lines means that the
text has to be placed somewhere else. The placement should
be unambiguous and clear. The labels should be clearly
assigned to exactly one edge and for each edge the label
should be easily located. The ACM Computational Geometry Impact Task Force report [1] declared label placement
to be an important research area.
Some approaches put edge labels to a side of the drawing
of the graph, rather than directly into the drawing. This
way, the labels cannot obscure parts of the drawing or be
themselves obscured by it. On the other hand, it is more
difﬁcult to associate such label with the correct edge.
1550-6037/12 $26.00 © 2012 IEEE
DOI 10.1109/IV.2012.79

II. R ELATED WORK
The labels of edges are traditionally placed somewhere
near the line representing the edge. In most graph drawing
toolkits (like GLT [2] or yEd[3]) edge labels are represented
by rectangles (a bounding box of the textual information).
According to chosen parameters, the label is placed in a
speciﬁed position relative to the edge (left, right, above,
below, or at the line), in a speciﬁed relative distance from
the source, and having orientation based on either a global
parameter or the edge direction.
In general, having a drawing of a graph and for each edge
e of the graph a ﬁnite set of candidates Ce for placement of
the label of e, the algorithm should ﬁnd such label positions,
that no two labels overlap. This is the weakest condition but
even this was shown [4] to be NP-hard. Therefore, there
are many heuristics and approximative algorithms that try
to solve the labeling problem [5], [6], [7], [2].
Similar problems arise in the area of map labeling, where
the labels should be assigned to geographic objects (e.g.,
towns or rivers) [8]. Labeling of linear map features (i.e.,
460

the label-tag pairs one of the colors. Note that at this stage,
“color” is an abstract term and our color set is just a set of
distinct items without further meaning.
In the last step, we assign concrete RGB values to each
of the abstract colors. This has to be done is such a way
that each two distinct colors look as different as possible.

rivers, roads, etc.) corresponds to the edge labeling problem
with slightly different constraints.
Since the original labeling problem is NP-hard, some
alternative solutions appeared in recent years. The boundary
labeling approach [9], [10] does not put the labels directly
into the drawing – they are placed on the boundary. For each
point that has to be labeled, there is an axis-parallel rectangular label. The labels have to be placed and connected to their
corresponding sites by polygonal lines (called leaders), such
that (a) no two labels intersect, (b) no two leaders intersect,
and (c) the labels lie outside the drawing (on the boundary
of the drawing). In boundary labeling, placing labels inside
the drawing is forbidden, however there are also approaches
where the boundary labeling is combined with the traditional
labeling.
The boundary labeling approach seems to be very good
for map labeling area, but it is not suitable for labeling of
graph edges, since the leaders make the drawing even harder
to follow. Therefore, we decided to eliminate the leaders to
get a drawing that is easier to comprehend.

A. Slot allocation
We have a set of m slots equally spaced along the yaxis. We will refer to the y-coordinate of the i-th slot as
sloty (i). We also have n visible edges Ev = {e1 , . . . , en }.
We assume that m ≤ n. If this is not true, we would have to
increase the number of slots, for example by making them
smaller or by creating two columns of labels, rather than
just one.
For each edge, we deﬁne the following:
• min(e) the minimal y-coordinate of all visible points
that form the drawing of e,
• max(e) like min(e) but for the maximal value,
• avg(e) = (min(e) + max(e))/2.
Then, for the edge e and i-th slot, we deﬁne the cost
Cost(e, i) of (e, i) like this:
• if min(e) ≤ sloty (i) ≤ max(e) then the cost is
|sloty (i) − avg(e)|,
• otherwise, the cost is 2 ∗ |sloty (i) − avg(e)|.
Then, we want to ﬁnd injective mapping μ : Ev →
{1, . . . , m} such that e∈Ev Cost(e, μ(e)) is minimal. This
can trivially be mapped to the problem of ﬁnding a minimal
weighted bipartite matching. Since that can be solved in
O(V 2 E), it can be used to solve our problem in O((m +
n)2 ∗ (m ∗ n)) which may be approximated by O(m4 ), since
n ≤ m.

III. T HE DRAWING AND THE ALGORITHM
Let us outline the way edge tags and labels are displayed,
along with the structure of the algorithm that generates the
drawing.
The labels are displayed in a vertical strip on one side of
the graph – it is not important, whether it is on left or right
side. This strip is divided vertically into slots that all have
the same height. Each slot may contain a label or be empty.
The label is displayed somewhere on the line that represents
the edge as a small colored square without any text.
The ﬁrst thing that the algorithm has to determine, is
which edges should get the tag and label. We select all edge
that are visible at the moment – at least part of the drawing
has to be within the current view and not obscured by a
drawing of a node. In other words, the user must be able to
see a part of the line that represents the edge. Should the
condition not hold, we wouldn’t be able to position a tag
onto the line.
Then comes the most difﬁcult step: we have to assign a
slot to each of the selected edges. The label of the edge is
displayed in that slot. The problem is that even if we can
easily pick the best slot for any single edge, there will most
likely be collisions, so we have to ﬁnd a global solution, that
may not necessarily be the best for each individual edge.
After slot allocation, the algorithm ﬁnds positions for the
tags. We can put the tag on any place on the drawing of
the edge, that is currently visible. This gives us much more
options than we have for positioning of labels, making the
problem easier. This is further helped by the fact, that tags
are much smaller than labels.
Then, we have to ﬁnd out how many distinct colors we
need to colorize labels and tags in such a way that their
pairing is clear to the user. We also need to assign each of

B. Tag positioning
Ideally, we would like to position the tags on the same ycoordinate as the label (labely (e)). This may not always be
possible, since we have no guarantee that any point on the
visible part of the drawing of the edge e has y-coordinate
equal to labely (e).
We decided to use a cost based approach for this problem
as well. The candidate set is the set of visible (within view
and not obscured by drawings of nodes) points that are part
of drawing of the edge. For obvious reasons, we only use a
subset of the inﬁnite number of points that form the lines.
We pick points evenly spread along the lines – in our case
about every 10 pixels.
Then, we assign cost to each point p = (px , py ) like this:
cost(p) := |px − labely (e)| + (px ∗ 100)
Then, we select the point with the lowest cost. This means
that we try to place the tag as close to the label as possible
on the y-axis, with a slight bias toward the left side (if the
label are displayed on the left).

461

During the computation, the algorithm maintains a set
of colors C = {c1 , . . . , cn } and for each of the colors a
number end(ci ). First, the intervals are sorted in ascending
order according to the start of the interval and the support
structures initialized to C := {c1 } and end(c1 ) := 0. Then,
intervals are taken in order and for each interval [lo, hi), we
ﬁnd the minimal i, such that ci ∈ C and end(ci ) = lo. If no
such i exists, we add new color cj to C and deﬁne i := j.
In both cases, we set end(ci ) := hi and assign color i to
the edge e ∈ Ev represented by the interval [lo, hi).
This way, we get the number of colors as well as the
optimal coloring. We need O(n∗log(n)) to sort the intervals
and O(n ∗ k) to assign the colors (for each of the n = |Ev |
edges we ﬁnd the minimal i by iterating through C where
|C| ≤ k).

The graph drawing algorithm may draw the edges in such
a way that the lines overlap – in that case, it would be
unclear, which of them does the tag belong to. We try not
to put the tag into such position. On the other hand, the
user’s view may be restricted in such a way, that only the
overlapping portion of the line is visible. To allow for this
situation, we increase the cost of such points by a large
enough constant (larger than any cost of a point on a nonoverlapping line).
C. Color counting and allocation
We already know where each label and tag will be placed.
For edge e, we denote labely (e) the y-coordinate of the label
and tagx (e), tagy (e) the x- and y-coordinates of the tag.
We compute inﬂuence interval inf luence(e) for the edge
e. It is an interval of y-coordinates, where the color that
will be assigned to e’s label and tag is monopolized by e
– the inf luence(e) may not overlap with another interval
belonging to an edge whose tag and label are colored the
same as e’s. The interval is computed like this:

D. Conversion of colors to RGB
This step is the well known problem of generating N
distinct RGB colors. Unfortunately, we can get an arbitrary
value of N up to the number of the visible edges.
Currently, we do not consider the label and tag positions
during this step. We generate a set of N RGB colors and
assign i-th color from this set to the label and tag that was
colored ci in the previous step.
We are using an algorithm that generates colors ﬁrst in
the HSL (hue, saturation, lightness) space and then converts
them to RGB. If there are N < 8 colors, we divide the
hue interval into N equally long sub-intervals and create the
colors using hues that are at the beginning of each subinterval, with maximal saturation and 50% lightness (i.e.,
tending neither toward black nor white). If we need eight
colors or more, we generate two sets of colors of sizes
N/2 and N/2 . In both sets, we use evenly spread hue
and 50% lightness, but the ﬁrst set uses 100% saturation and
the second 50% saturation.

distance := |labely (e) − tagy (e)|
lo := min(labely (e), tagy (e))
hi := max(labely (e), tagy (e))
distance+ := (distance) ∗ A + B
inf luence(e) := [lo − distance+ , hi + distance+ )
The exact values of constants A and B depend on the
required safety margin for color allocation and the scale of
the drawing, but A should always be at least 1 and B should
not be negative. At the moment, we use a setup where A =
1.1 and B = 50.
This deﬁnition of inﬂuence interval assures, that for any
tag, the closest label with the same color as the tag is the
correct one (they represent the same edge), and also that for
any label, the closest tag with the same color is the correct
one. Plus a certain “safety margin” (if A > 1 or B > 0).
Then we deﬁne a graph G = (Ev , E), where Ev are the
visible edges that we want labeled and E = {(e1 , e2 ) ∈
Ev × Ev : inf luence(e1 ) ∩ inf luence(e2 ) = ∅}. This
way, the problem of coloring edges and labels is transformed
into the traditional problem of graph (node) coloring. The
color assigned to the node of graph G is in fact assigned
to the edge e from Ev , thus providing us with a color for
e’s label and tag. We know that if two edges get colored
with the same color, their inﬂuence intervals do not overlap,
otherwise there would be an edge connecting those two in
G and they wouldn’t be colored by the same color (that’s
the deﬁnition of the node coloring problem).
In general, graph coloring problem is hard, but in this
case, there is a simple and efﬁcient algorithm that can ﬁnd
optimal solution in O(n ∗ log(n) + n ∗ k), where n is the
number of nodes and k the number of colors.

IV. I MPLEMENTATION AND EXAMPLE
We have implemented the proposed solution in a graph
drawing tool that was created as part of our earlier work in
the ﬁeld of edge routing [11]. It differs from the described
algorithm in the slot allocation step, since it uses a simpler,
eager algorithm, that is fast, but does not guarantee an
optimal solution.
An example of the result for a graph that is mostly
contained in the current user’s view is displayed in Figure 1.
The labels (in this case numerical identiﬁers of the edges) are
displayed on the left. Then, there is a visual representation
of the inﬂuence intervals for each edge and ﬁnally the view
of the graph.
The drawing of the graph is not ideal, since some edges
are drawn in such a way that they cannot be clearly distinguished – this is a problem of the implementation of the
edge routing algorithm and not our labeling technique. The
technique makes no assumptions about the drawing, so it
would also work for any drawing of the graph.

462

Figure 1.

An example generated by our implementation of the algorithm

V. C ONCLUSION

[4] A. Wolff, “A simple proof for the np-hardness of edge
labeling,” Institut fr Mathematik und Informatik, Universitt
Greifswald, Tech. Rep. 11/2000, September 2000.

In this paper, we presented a way in which color coding
can be used to provide edge labels for a drawing of a graph.
It provides clear labeling with minimal intrusion into the
drawing.
In the future, we would like to investigate alternative
approaches for the various steps of the algorithm (especially
slot allocation and the conversion of abstract colors to RGB).
We would also like to explore and solve situations, where
the algorithm cannot provide a satisfactory solution at the
moment: ﬁrst, if the number of visible edges is larger than
the number of available slots. Second, when the number of
colors needed is too high.

[5] B. Zhu and C. K. Poon, “Efﬁcient approximation algorithms
for multi-label map labeling,” in Proc. of the 10th International Symposium on Algorithms and Computation, ser.
ISAAC ’99. London: Springer-Verlag, 1999, pp. 143–152.
[6] F. Wagner and A. Wolff, “A practical map labeling algorithm,”
Computational Geometry: Theory and Applications, vol. 7,
pp. 387–404, 1997.
[7] U. Dogrus¨oz, K. G. Kakoulis, B. Madden, and I. G. Tollis,
“On labeling in graph visualization,” Inf. Sci., vol. 177, no. 12,
pp. 2459–2472, 2007.
[8] A. Wolff, L. Knipping, M. van Kreveld, T. Strijk, and P. K.
Agarwal, “A simple and efﬁcient algorithm for high-quality
line labeling,” in Proc. 15th European Workshop Comput.
Geom. (EWCG’99). INRIA, Sophia-Antipolis, 1999, pp. 93–
96.

ACKNOWLEDGMENT
The work was supported by the GAUK project no. 28910
and the grant VEGA 1/0979/12.

[9] M. N¨ollenburg, V. Polishchuk, and M. Sysikaski, “Dynamic
one-sided boundary labeling,” in Proceedings of the 18th
SIGSPATIAL International Conference on Advances in Geographic Information Systems, ser. GIS ’10. New York, NY,
USA: ACM, 2010, pp. 310–319.

R EFERENCES
[1] B. Chazelle and . co authors, “The computational geometry
impact task force report.” Advances in Discrete and Computational Geometry, vol. 223, p. 407463, 1999.

[10] M. A. Bekos, M. Kaufmann, A. Symvonis, and A. Wolff,
“Boundary labeling: Models and efﬁcient algorithms for
rectangular maps.” in Graph Drawing’04, 2004, pp. 49–59.

[2] U. Dogrusoz, K. G. Kakoulis, B. Madden, and I. G. Tollis,
“Edge labeling in the graph layout toolkit,” in In Proceedings
of the Symposium on Graph Drawing (GD’98. SpringerVerlag, 1998, pp. 356–363.

[11] J. Dokulil and J. Katreniakova, “Edge routing with ﬁxed node
positions,” in IV ’08: Proceedings of the 2008 12th International Conference Information Visualisation. Washington,
DC, USA: IEEE Computer Society, 2008, pp. 626–631.

[3] “yFiles,” Class library,
http://www.yworks.com/en/products yﬁles about.html.

463


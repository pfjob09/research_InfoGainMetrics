2012 16th International Conference on Information Visualisation

Fast Layout Computation of Hierarchically Clustered Networks:
Algorithmic Advances and Experimental Analysis.
Walter Didimo, Fabrizio Montecchiani
Dipartimento di Ingegneria Elettronica e dell’Informazione
Universit`a degli Studi di Perugia
Italy
[didimo,montecchiani]@diei.unipg.it

cluster regions reﬂect the inclusion relationships between
their corresponding clusters. Additionally, we take into account the following aesthetic criteria: The area of each cluster region should be proportional to the number of vertices
inside it (or to the total weight of the vertices in the cluster,
if the network has weighted vertices); clusters and vertices
should be uniformly distributed in the drawing area; the total
number of edge crossings and the number of edges that
traverse clusters should be minimized; symmetries should
be highlighted where possible. The original contribution of
the paper is twofold:

Abstract—Fast computation of two-dimensional layouts of
hierarchically clustered networks is a well-studied problem in
graph visualization. We present algorithmic and experimental
advances on the subject: (i) We propose a new drawing
algorithm that combines space-ﬁlling and fast force-directed
methods; it runs in O(n log n + m) time, where n and m are
the number of vertices and edges of the network, respectively.
This running time does not depend on the number of clusters, thus the algorithm guarantees good time performances
independently of the structure of the cluster hierarchy. As a
further advantage, the algorithm can be easily parallelized. (ii)
We present an experimental analysis aimed at understanding
which clustering algorithms can be used, in combination with
our visualization technique, to generate better quality drawings
for medium and large networks with small-world and scale-free
structure. As far as we know, no previous similar experiments
have been done in this respect.

(i): We propose a new drawing algorithm that computes 2D
layouts of hierarchically clustered networks, according to the
constraints and aesthetics described above (Sec.III). It combines space-ﬁlling and force-directed techniques in a new
fashion, and can be easily parallelized. By exploiting and
engineering fast popular layout techniques and efﬁcient datastructures, the new algorithm runs in O(n log n+m), where n
and m are the number of vertices and edges of the network,
respectively. This theoretical bound does not depend on the
number of clusters, thus the algorithm guarantees good time
performances independently of the structure of the cluster
hierarchy. Also, although the computed drawing is mainly
intended to provide an overview of the whole network
(where all nodes and edges are visible at once), it can also
be effectively adopted for interactive analysis of based on
a drill-down exploration of the clusters (see, e.g., Fig. 1(a)
and Fig. 1(b)).

Keywords-Graph Visualization, Large Graphs, Hierarchical
Clustering, Multi-scale Force-directed Algorithms, Treemap.

I. I NTRODUCTION
The visual analysis of large relational data sets is a
growing need in many application domains, such as social
sciences, biology, computer networks, and software engineering (see, e.g., [1], [2]). As a consequence, the design
of algorithms for the automatic layout of large networks
has received considerable attention in the last decade and
is currently one of the most relevant topics in graph visualization. Often, the network to be analyzed is structured
into hierarchical clusters, and in those cases an effective
visualization algorithm should clearly convey its structure
in a reasonable computation time. Other times, the input
network is not already clustered, but exhibits an intrinsic
structure of communities (i.e., dense subgraphs connected
to each other by few edges), as for many small-world and
scale-free networks [3]; also in those cases, the layout should
support users in detecting these communities.
This paper studies the problem of automatically computing 2D layouts of medium and large hierarchically clustered
networks, whose cluster hierarchy is given as part of the
input and cannot be changed. We aim at guaranteeing the
following properties: The layout ﬁts into a rectangular area
of given aspect ratio; each cluster is completely contained in
a corresponding rectangular region; inclusions between the
1550-6037/12 $26.00 © 2012 IEEE
DOI 10.1109/IV.2012.14

(ii): We present the results of an experimental analysis
aimed at understanding which clustering algorithms can be
used in combination with our technique to generate better
quality drawings for medium and large networks with smallworld and scale-free structure (Sec. IV). Our study suggests
that a recent approach speciﬁcally tailored for community
detection in small-world and scale-free networks is in fact
effective also for the visualization of these kinds of networks. As far as we know, no previous similar experiments
have been done in this respect.
Sec. II discusses previous work related to our research.
Future research is discussed in Sec. V. Due to space limitations, some details are omitted in this extended abstract.
18

(a)

(b)

(a) A clustered drawing of a social network computed with our algorithm; it gives an overview of the whole network; (b)
The same drawing used for an interactive drill-down exploration of the clusters; some clusters are contracted while others are expanded.
Thanks to the geometric information already computed, cluster contractions or expansions only require fast local changes in the drawing.

Figure 1.

cluster hierarchies and no effective heuristics (such as forcedirected algorithms) are used in order to display symmetries
and to reduce the number of edge crossings. We observe
that rectangular cluster regions have several advantages with
respect to Voroni cluster regions: They are more intuitive
for the user, easily support interactive visualizations based
on drill-down exploration of the clusters on the computed
drawing, and allow for a better control of region area and
aspect ratio.

II. R ELATED W ORKS
Visualizing hierarchically clustered networks is a wellstudied problem, for which many effective algorithms exist;
a limited list of papers and books includes [4], [5], [6],
[7]. However, these algorithms use basic force-directed or
topology-shape-metrics techniques, which do not scale well
to networks with thousands of nodes. Several approaches
that allow users to interactively analyze a large network
by drill-down exploration of the clusters are also described
(see, e.g., [8], [9], [10], [11], [12], [13], [14], [15]). To deal
with the size and the visual complexity of the layout, they
ﬁrst compute a high-level view of the network (the graph
of clusters) and then compute and display the interior of a
cluster on user’s demand.
Our research is mainly related to the works of Bourqui
et al. [16] and of Muelder and Ma [17]; the goal is the
design of fast algorithms that compute a 2D layout of a
hierarchically clustered network at a whole, where cluster
regions are clearly conveyed in the visualization. Bourqui
et al. describe an O(n2 log n)-time drawing algorithm that
recursively uses Voronoi diagrams to represent cluster regions; in each region, vertices are placed using a multilevel force-directed algorithm. The algorithm of Muelder
and Ma exploits treemaps to recursively draw the cluster
hierarchy; the vertices are placed in the center of their
regions and some heuristics are applied to slightly reduce
the edge/node overlap caused by collinear vertices and
narrow regions. As a consequence, the cluster regions are
rectangles and the computation is very fast and scalable to
huge graphs. However, the algorithm is restricted to binary

Our algorithm is designed to provide better trade-offs
between running time and drawing readability with respect
to the algorithms in [16] and [17]. Namely, it is faster than
the algorithm in [16] and, as in [17], it uses rectangular
cluster regions. Also, the combination of a multi-level forcedirected algorithm with a space-ﬁlling technique guarantees
less edge crossings and symmetry display.
We also mention that the combination of space-ﬁlling
approaches with node-link diagrams has been previously
investigated. Huang et al. [18] describe an algorithm that
ﬁrst partitions the plane into rectangular regions (representing the nodes of the cluster hierarchy), and then draws
the leaf-nodes and their connections inside the deepest
clusters using either a classical spring-embedder algorithm
or a circular drawing algorithm. Their approach has two
severe limits: (i) the clarity of the visualization and the
computational efﬁciency of the algorithm strongly depend
on the fact that the computed cluster hierarchy is balanced
(which is not always the case if it is given as input);
(ii) only the connections between clusters with the same
parent are shown, which dramatically reduces the amount

19

1). An HC-drawing of (C, r) is a straight-line drawing Γ
that respects the following constraints: (C1) Γ is contained
in a rectangular region with aspect ratio r; (C2) each
cluster V (ν ) is contained in a corresponding rectangular
region R(ν ); (C3) if V (μ ) ⊂ V (ν ) then R(μ ) ⊂ R(ν );
/ Additionally,
if V (μ ) ∩ V (ν ) = 0/ then R(μ ) ∩ R(ν ) = 0.
we attempt to optimize the following aesthetic criteria for
an HC-drawing: (A1) The area of each cluster region
R(ν ) should be proportional to ω (ν ); (A2) the number
of edge crossings should be minimized; (A3) the number
of edges that cross the boundary of a cluster region twice
should be minimized (i.e., edges connecting two vertices
that are outside that cluster region); (A4) vertices inside
each cluster region should be uniformly distributed and
symmetries should be emphasized where possible.

of data to be displayed and makes the design of the drawing
algorithm much easier. Furthermore, the time complexity
of the algorithm in the worst case is O(n3 ), and thus it
does not scale to large networks. Other algorithms in this
category do not directly compare with our research, since do
not properly focus on drawing clustered networks. Namely,
Itoh et al. [19] describe an algorithm for drawing multiplecategory graphs; they exploit a hybrid drawing technique
that has some similarity with the one presented in this
paper, but again it is tailored for hierarchies with speciﬁc
properties and produces visualizations whose requirements
are different from ours; furthermore, this technique is still
computationally more expensive than our approach. Zhao
et al. [20] present a hybrid drawing technique combining
treemaps and node-link diagrams for representing trees.

Computing HC-drawings
Our drawing algorithm combines treemaps and forcedirected techniques. The use of treemaps guarantees
(C1)-(C3) and helps to optimize (A1); force-directed
techniques are exploited to optimize (A2)-(A4). The
algorithm takes as input a hierarchically clustered network
C = (G, T ) and a positive number r, which is the desired
aspect ratio of a rectangular region containing the drawing.
In order to design an efﬁcient drawing algorithm, whose
theoretical running time does not depend on the structure
and the number of nodes of T , we exploit speciﬁc treemap
and force-directed algorithms, efﬁcient data structures for
storing and retrieving information associated with a suitable
set of quotient graphs, and we guarantee that each edge
of G is visited a constant number of times throughout the
computation. Additionally, we apply an efﬁcient reﬁnement
heuristic for further crossing reduction. Before describing
the algorithm, we give some notations and observations. Let
n and m be the number of vertices and edges of G, and let
N be the number of nodes of T other than its root. For each
internal node νi of T , denote by Qi the quotient graph of
(G(νi ), T (νi )) deﬁned by the children of νi . Let ni be the
number of vertices of Qi (i.e., the children of νi ), and let
mi be the number of edges of Qi . Clearly, ∑i ni = N. By
deﬁnition, each edge (u, v) of G is represented by exactly
one edge in the union of all Qi ; such an edge is in the graph
Qi such that νi is the nearest common ancestor of u and v
in T . Hence ∑i mi ≤ m. Since each internal node of T has
at least two children, the number of internal nodes of T is
smaller than the number of leaves of T , thus N < 2n (n
equals the number of leaves of T ). Our algorithm works in
four phases:

III. T HE D RAWING A LGORITHM
We ﬁrst recall basic deﬁnitions on hierarchically clustered
networks (see also [6]) and formally deﬁne our clustered
drawing model. Then we describe our algorithm.
HC-drawings of Clustered Networks
A hierarchically clustered network is a pair C = (G, T )
such that G = (V, E) is an undirected graph and T is a
rooted tree that describes the clusters of G and the inclusion
relationships among these clusters. T is called the inclusion
tree of C. The leaves of T correspond to the vertices of G.
Each node ν of T corresponds to a cluster of vertices of
G (the leaves of T are regarded as clusters consisting of
a single vertex); the cluster associated with ν is denoted
by V (ν ) and the subgraph induced by V (ν ) is denoted by
G(ν ). Also, T (ν ) denotes the subtree of T rooted at ν . If
ν and μ are two nodes of T such that ν is the parent of
μ , then V (μ ) ⊂ V (ν ). Observe that the vertices of a cluster
V (ν ) correspond to the leaves of T (ν ). Also, according to
the deﬁnitions above, each internal node of T has at least
two children.
Let C = (G, T ) be a hierarchically clustered network and
let V = {ν1 , ν2 , . . . , νk } be a subset of nodes of T whose
corresponding clusters partition V , i.e., V (ν1 )∪· · ·∪V (νk ) =
V . The quotient graph deﬁned by V is a graph Q = (V , E )
that describes the connections among the clusters V (νi ) (1 ≤
i ≤ k). Namely, (νi , ν j ) ∈ E if and only if there exists an edge
in G connecting a vertex in V (νi ) to a vertex in V (ν j ). If
G has weights on vertices and/or edges then: (i) The weight
of a node ν ∈ V is the sum of the weights of all vertices
in V (ν ), and is denoted as ω (ν ); (ii) the weight of an edge
(νi , ν j ) ∈ E is the sum of the weights of all edges (u, v)
such that u ∈ V (νi ) and v ∈ V (ν j ); this weight is denoted as
ω (νi , ν j ).
Let r > 0 be a given positive number and let C = (G, T )
be a hierarchically clustered network, where G has weights
on vertices and edges (if G is unweighted, we assume that
the weight of each vertex and of each edge is equal to

P HASE 1: It computes the set of graphs Qi . For every edge
e = (u, v) of G it ﬁrst compute the graph Qi in which e must
be represented. This can be done in O(m) time by using the
nearest common ancestor algorithm in [21]; this algorithm
constructs in O(N) time a suitable data-structure that makes
it possible to ﬁnd in O(1) time the nearest common ancestor

20

of any given pair of nodes. Secondly, for each edge e = (u, v)
that must be represented in Qi , we detect the children μu and
μv of νi that are ancestors of u and v in T , respectively. Note
that, μu and μv may coincide with u and v. Then, we add
to Qi the edge (μu , μv ), if such an edge does not already
exist (otherwise we just increment the weight ω (μu , μv ) by
ω (e)). This operation takes O(1) time per edge, thanks to
an O(N) preprocessing step for the level ancestor problem
(see, e.g., [22]). Thus, Phase 1 runs in O(n + m) time.

2n log n + m, the cost of Phase 2 is O(n log n + m).
P HASE 3: In order to further reduce edge crossings, it applies
a reﬁnement heuristic to the drawing of each subgraph
computed by the force-directed algorithm. The idea is to
increase the level of interaction among nodes in different
clusters. Namely, let Γi be the drawing of Qi computed
by the force-directed algorithm inside R(νi ). Let μ be a
node of Qi (i.e., a child of νi ) that is connected to some
other clusters ν1 , ν2 , . . . , νr , whose corresponding subregions
R(ν1 ), R(ν2 ), . . . , R(νr ) have been already computed. We recompute the position of μ as the barycenter of its current position and the centers of subregions R(ν1 ), R(ν2 ), . . . , R(νr );
if the barycenter is outside R(νi ), we approximate the new
position of μ with the point inside R(νi ) that is closest to
the barycenter. Note however that an edge of G might be
considered a number of times that is proportional to the
depth of the inclusion tree. To avoid this, we only consider
those connections (μ , ν j ) (1 ≤ j ≤ r) that are induced by at
least one edge e = (u, v) of G such that u ∈ V (μ ), v ∈ V (ν j ),
lev(μ )−lev(NCA(u, v)) ≤ k, and lev(ν j )−lev(NCA(u, v)) ≤
k, where lev(x) denotes the level of node x in T , NCA(u, v)
denotes the nearest common ancestor of u and v in T , and k
is an integer constant. With this strategy, each edge of G is
considered at most k +1 times in the whole computation, and
phase takes O(n + m) time. In our implementation we ﬁxed
k = 2, as we experimentally observed that with this choice
the practical running time does not increase too much, while
the number of edge crossings is highly reduced (20% in the
average) with respect to the previous drawing.

P HASE 2: It recursively draws each Qi in a top-down fashion.
A drawing Γ0 of Q0 is computed inside a region R with
aspect ratio r. Γ0 is computed by applying a suitable forcedirected algorithm. We adopt the Fast Multipole Multilevel
Method (FM3 ) [23], which runs in O(n log n + m)-time. As
experimentally proved in [24], this method is more effective
than other multi-level and algebraic approaches, since it
produces less crossings and few node overlaps. Region R
is then partitioned into rectangles, each rectangle associated
with a distinct node of Q0 . Namely, a treemap algorithm
is applied to draw a tree T0 within region R: T0 consists
of ν0 and its children. The treemap algorithm partitions R
into rectangular subregions such that each subregion has an
area proportional to the weight of its corresponding node.
The treemap algorithm is applied in such a way that it
recursively executes horizontal and vertical splits of the
drawing area, driven by the x- and y-coordinates of the
nodes of Γ0 ; when a horizontal split is executed, the leftto-right ordering of the subregions respects the left-to-right
ordering of the corresponding nodes in Γ0 ; similarly, when
a vertical split is executed, the top-to-bottom ordering of
the subregions reﬂects the top-to-bottom ordering of the
corresponding nodes in Γ0 . The rationale is that partitioning
the plane using the relative orderings induced by the xand y-coordinates of the drawing constructed by the forcedirected algorithm supports the reduction of edge crossings.
To compute treemaps, we use a variant of the so-called split
algorithm [25], which alternates horizontal and vertical splits
of the drawing area with the goal of producing subregions
with good aspect ratio; each split is done by balancing as
much as possible the weights of the nodes in each of the
two regions, while preserving a desired ordering for the
children of each node of the tree. This treemap algorithm
takes O(n log n) time in the worst case. For each node νi ,
the subregion of R associated with νi will correspond to the
region R(νi ) in the ﬁnal drawing. Then, the technique goes
recursively into each subregion R(νi ) until a full drawing of
the graph induced by V (νi ) is computed. The drawing Γi of
Qi is forced to stay inside region R(νi ) and is computed by
the force-directed algorithm on Qi . Concerning the running
time of this phase, the force-directed algorithm is applied
on each Qi and the treemap algorithm is applied on T .
Thus, the total cost is O(∑i (ni log ni + mi )) + O(n log n), and
since ∑i (ni log ni + mi ) ≤ log n ∑i ni + ∑i mi ≤ N log n + m <

P HASE 4: In the drawing computed so far, the area of
each cluster region is proportional to the total weight of
the vertices inside it. To make the cluster regions more
compact and the cluster hierarchy clearly readable, this
phase performs the following actions on the ﬁnal drawing :
(i) Visit T in post-order; when an internal node νi is visited,
the boundary of R(νi ) is reduced to the minimum bounding
box containing V (νi ) in the drawing. (ii) Each cluster region
is assigned a background color in the same color scale,
such that deeper clusters receive darker colors. This phase
is executed in O(n + m) time.
We summarize the main result of this section.
Theorem 1. Let C = (G, T ) be a hierarchically clustered
network and let r be a positive number. Let n and m denote
the number of vertices and the number of edges of G,
respectively. There exists an O(n log n + m)-time algorithm
that computes an HC-drawing of (C, r).
A further advantage of our algorithm is that it can be
easily parallelized. Each time a new node νi of the inclusion
tree T is processed and the subregions of its children have
been computed, all its child nodes can be stored in a queue
shared by a set of threads. Each thread can independently
access the queue and retrieve its ﬁrst node, which is then

21

removed by the queue and recursively processed as fast
as possible. Note however that some bottlenecks can occur
during P HASE 3. Indeed, it might happen that a thread that
is in charge of processing a node νi must wait for some other
threads to compute the subregions externally connected to
nodes inside νi .

generated 5 networks. The density of the networks varies
in the interval [4, 8]. We compare the performances of our
drawing algorithm on these networks for three different
clustering algorithms:
Blondel: A recent algorithm by Blondel et al. [28],
using a multistep technique based on a local optimization
of Newman-Girvan modularity in the neighborhood of each
vertex. The algorithm takes linear time and has been claimed
to be particularly suited for community detection in smallworld and scale-free networks (see also [27]).
Radicchi: An algorithm by Radicchi et al. [29]. It is
similar to the well-known divisive algorithm of Girvan and
Newman, but instead of cutting out edges based on their
betweenness, it uses a local measure called edge clustering
coefﬁcient, which can be calculated more efﬁciently. It is
easy to implement, provides good performances in terms of
community detection, and takes quadratic time in the number
of vertices (see also [27]).
Aslam: A variant of an algorithm by Aslam et al. [30].
It recursively computes clusters associated with the vertices
of highest degree, that are chosen as centroids of the
clusters; each cluster consists of a centroid and its neighbors.
The original linear-time version of this algorithm generates
ﬂat clustering; the recursive version generates hierarchical
clustering and takes quadratic time. It is not speciﬁcally
conceived for small-world and scale-free networks.
In our experimental setting we avoided too many clusters
of very small size (which are visually not informative for the
user). To this aim, for algorithms Blondel and Radicchi
we reduced the depth of the original inclusion tree by the last
two levels. For algorithm Aslam, we stopped the generation
procedure after four levels of recursion.
Concerning Goal 1 , all computations took less than one
second on medium-size networks and few seconds on the
larger networks. For the larger networks, the drawing algorithm ran much faster in combination with Blondel, which
typically generates less clusters and cause few bottlenecks in
P HASE 3 (it took about 6 seconds for the largest networks).
Concerning Goal 2 , we counted the number of crossings
in the drawings computed by our algorithm for the three
kinds of cluster hierarchy, and also in the case the input
graph does not have clusters (see the line labeled as Flat in
the chart). For the ﬂat case we simply applied algorithm FM3
to compute a drawing. The results show that: (i) Cluster
hierarchies computed by algorithms that have been shown
to be effective for community detection on small-world and
scale-free networks (such as, Blondel and Radicchi)
offer in fact better support for the crossing reduction in HCdrawings; conversely, hierarchies computed by clustering
algorithms like Aslam, which are not tailored for this kind
of networks, can even give rise to many more crossings than
a ﬂat representation of the network. (ii) More speciﬁcally,
the use of clustering algorithm Blondel outperforms all

Figure 2. HC-drawing of a social network with the cluster hierarchy
deﬁned by Blondel. The network has 5,835 vertices, 13,815
edges, and 286 clusters. The computation took 2.19 seconds.

IV. E XPERIMENTAL A NALYSIS
We implemented a parallel version of our algorithm with
the C# programming language, using the FM3 implementation available in the C++ library OGDF 1 as external
subroutine2 . We tested our algorithm on an Intel Core i5430M laptop with 8 GB of RAM, running the Windows
7 OS. The main goals of our experiments were: Goal 1:
Evaluating the running time of our drawing algorithm.
Goal 2: Evaluating which clustering algorithms can be used
in combination with our technique to generate better quality
drawings (in terms of edge crossings) for medium and large
networks with small-world and scale-free structure.
For the experiments the desired ratio of the drawing was
set to r = 1. The test suite consisted of 75 small-world and
scale-free networks, generated with the LFR algorithm [26],
already used in an extensive experimental work comparing
different graph clustering algorithms on this kind of networks [27]. For each n ∈ {500, 600, . . . , 1000} we generated
10 networks and for each n ∈ {5000, 10000, 15000} we
1 http://www.ogdf.net/
2 We remark that calling an external subroutine many times makes the
computation slower. The runtime of our implementation could be further
reduced by reimplementing and embedding the force-directed approach in
the main code.

22

others (with an improvement up to 40% on Radicchi,
62% on Flat, and 74% on Aslam), thus providing good
support for our visualization purposes on small-world and
scale-free networks.

[14] D. Schaffer, Z. Zuo, S. Greenberg, L. Bartram, J. Dill,
S. Dubs, and M. Roseman, “Navigating hierarchically clustered networks through ﬁsheye and full-zoom methods,” ACM
TOCHI, vol. 3, no. 2, pp. 162–188, 1996.

V. F UTURE R ESEARCH
Several research directions related to our work can be explored. Among them: (i) Designing other hybrid approaches
for HC-drawing computations, with the aim of providing
different algorithmic trade-offs between efﬁciency and effectiveness; (ii) Extending the experiments to other kinds
of networks and study how the behavior of our approach
changes if combined with other clustering algorithms other
than those that we have considered.

[15] F. van Ham and J. J. van Wijk, “Interactive visualization of
small world graphs,” in IV. IEEE, 2004, pp. 199–206.
[16] R. Bourqui, D. Auber, and P. Mary, “How to draw clustered
weighted graphs using a multilevel force-directed graph drawing algorithm,” in IV. IEEE, 2007, pp. 757–764.
[17] C. Muelder and K.-L. Ma, “A treemap based method for rapid
layout of large graphs,” in PaciﬁcVis. IEEE, 2008, pp. 231–
238.
[18] M. L. Huang and Q. Nguyen, “A space efﬁcient clustered
visualization of large graphs,” ser. ICIG ’07. IEEE, 2007,
pp. 920–927.

R EFERENCES
[1] W. Didimo and G. Liotta, Mining Graph Data. Wiley, 2007,
ch. Graph Visualization and Data Mining, pp. 35–64.

[19] T. Itoh, C. Muelder, K.-L. Ma, and J. Sese, “A hybrid
space-ﬁlling and force-directed layout method for visualizing
multiple-category graphs,” in PaciﬁcVis. IEEE, 2009, pp.
121–128.

[2] M. J¨unger and P. Mutzel, Eds., Graph Drawing Software.
Springer, 2003.

[20] S. Zhao, M. J. McGufﬁn, and M. H. Chignell, “Elastic
hierarchies: Combining treemaps and node-link diagrams,” in
IV. IEEE, 2005, p. 8.

[3] M. E. J. Newman, “The Structure and Function of Complex
Networks,” SIAM Rev., vol. 45, no. 2, pp. 167–256, 2003.
[4] U. Dogrus¨oz, E. Giral, A. Cetintas, A. Civril, and E. Demir,
“A layout algorithm for undirected compound graphs,” Inf.
Sci., vol. 179, no. 7, 2009.

[21] D. Harel and R. E. Tarjan, “Fast algorithms for ﬁnding nearest
common ancestors,” SIAM J. Comp., vol. 13, pp. 338–355,
1984.

[5] P. Eades, Q. Feng, X. Lin, and H. Nagamochi, “Straightline drawing algorithms for hierarchical graphs and clustered
graphs,” Algorithmica, vol. 44, no. 1, pp. 1–32, 2006.

[22] M. A. Bender and M. Farach-Colton, “The level ancestor
problem simpliﬁed,” TCS, vol. 321, no. 1, pp. 5–12, 2004.

[6] M. Kaufmann and D. Wagner, Eds., Drawing Graphs.
Springer, 2001.

[23] S. Hachul and M. J¨unger, “Drawing large graphs with a
potential-ﬁeld-based multilevel algorithm,” in Graph Drawing, ser. LCNS. Springer, 2005, vol. 3383, pp. 285–295.

[7] K. Sugiyama, Graph Drawing and Applications for Software
and Knowledge Engineers. Word Scientiﬁc, 2002.

[24] ——, “Large-graph layout algorithms at work: An experimental study,” JGAA, vol. 11, no. 2, pp. 345–369, 2007.

[8] J. Abello, F. van Ham, and N. Krishnan, “Ask-graphview: A
large scale graph visualization system,” IEEE TVCG, vol. 12,
no. 5, pp. 669–676, 2006.

[25] B. Engdahl, “Ordered and unordered treemap algorithms
and their applications on handheld devices,” Master’s thesis,
Royal Institute of Technology, Stockholm, Sweden, 2005.

[9] D. Archambault, T. Munzner, and D. Auber, “Grouseﬂocks:
Steerable exploration of graph hierarchy space,” IEEE TVCG,
vol. 14, no. 4, pp. 900–913, 2008.

[26] A. Lancichinetti, S. Fortunato, and F. Radicchi, “Benchmark
graphs for testing community detection algorithms,” Phys.
Rev. E, vol. 78, no. 4, 2008.

[10] D. Auber, Y. Chiricota, F. Jourdan, and G. Melanc¸on, “Multiscale visualization of small world networks,” in IV, 2003,
pp. 75–81.

[27] A. Lancichinetti and S. Fortunato, “Community detection
algorithms: A comparative analysis,” Phys. Rev. E, vol. 80,
no. 5, p. 056117, 2009.

[11] V. Batagelj, F. Brandenburg, W. Didimo, G. Liotta, P. Palladino, and M. Patrignani, “Visual analysis of large graphs using (x,y)-clustering and hybrid visualizations,” IEEE TVCG,
vol. 17, no. 11, pp. 1587–1598, 2011.

[28] V. D. Blondel, J.-L. Guillaume, R. Lambiotte, and E. Lefebvre, “Fast unfolding of communities in large networks,” J.
Stat. Mech. Theor. Exp., vol. 2008, no. 10, p. P10008, 2008.

[12] W. Didimo, G. Liotta, F. Montecchiani, and P. Palladino, “An
advanced network visualization system for ﬁnancial crime
detection,” in PaciﬁcVis. IEEE, 2011, pp. 203–210.

[29] F. Radicchi, C. Castellano, F. Cecconi, V. Loreto, and
D. Parisi, “Deﬁning and identifying communities in networks,” PNAS, vol. 101, no. 9, p. 2658, 2004.

[13] P. Eades and M. L. Huang, “Navigating clustered graphs using
force-directed methods,” JGAA, vol. 4, no. 3, pp. 157–181,
2000.

[30] J. A. Aslam, E. Pelekhov, and D. Rus, “The star clustering
algorithm for static and dynamic information organization,”
JGAA, vol. 8, no. 1, p. 95129, 2004.

23


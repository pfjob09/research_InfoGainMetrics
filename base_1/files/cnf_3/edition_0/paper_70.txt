2012 16th International Conference on Information Visualisation

A Multilevel Force-Directed Graph Drawing Algorithm Using Multilevel Global
Force Approximation

Carl Crawford, Chris Walshaw, Alan Soper
School of Computing and Mathematical Sciences
University of Greenwich
London, UK
C.J.Crawford@gre.ac.uk, C.Walshaw@gre.ac.uk, A.J.Soper@gre.ac.uk

Abstract—In this paper we discuss an efficiency saving for
multilevel force directed placement algorithms. Typically such
algorithms use a Barnes Hut octree (or sometimes a grid) in
order to approximate global repulsive forces. Here we instead
exploit the graph coarsening structure, already in place to
facilitate the multilevel scheme, in order to provide a
hierarchical approximation to the global forces. Not only is this
more efficient, but also it takes better account of the graph
structure than an octree or a grid.
Keywords-graph;
multilevel refinement

drawing;

force

directed

Most algorithms developed in recent years aim to
achieve one or more of these aesthetics criteria, in order to
maximize the usefulness and readability of the drawings
they compute.
B. Force Directed Placement
Force Directed Placement (FDP) is a method of drawing
graphs which models the data as a mechanical system of
connected points which have an energy based on their
placement. High energy configurations result from vertices
being too close together, or too far apart, and high energy is
therefore assumed to represent poor layout (bad aesthetics).
Consequently, force directed placement algorithms aim to
find the lowest possible energy by iteratively changing the
position of the vertices.
1) The Spring Embedder is the particular method of
FDP used here, which models the placement dynamics using
a mechanical system of rings and springs (vertices and
edges respectively), which exhibits the spring-like forces to
keep connected vertices from drifting too far apart, and
repulsive forces to keep vertices drifting too close to one
another – therefore reducing the energy of the graph. After
an initial placement the graph is “released”, allowing the
rings to move about freely until comfortable, low energy
positions are found.
The computationally intensive part of a spring embedder
is the calculation of global repulsive forces, potentially an
O(n²) calculation, which must take place every iteration.

placement;

I.
INTRODUCTION
Graph drawing is a technique used to represent
collections of data in a graphical way so a reader can better
understand the structure and relationships held within the
information. Typical types of graphs drawn include website
structures, communication networks, biological maps and
various physical meshes.
Large datasets are impossible to draw by hand [1] [2] [6]
and therefore, graph drawing algorithms, which embed
vertices in R² or R³, are used. Although research in this area
has been fruitful, due to the complexity of calculations
involved with generating a good drawing, many existing
algorithms still struggle to reach a layout within a
reasonable time frame. It is therefore our goal to decrease
the runtime required without losing quality.
II. A BRIEF HISTORY
A graph G, consists of a number of vertices, V,
representing data and a number of edges, E, of which each
edge connects two vertices and describes a relationship
between data elements. A graph drawing algorithm assigns a
position in 2D or 3D space to each vertex, v, within V.

C. Multilevel Paradigm
In larger graphs of more than 100 vertices, the FDP
algorithms alone are not enough to find a good layout due to
so many contradicting movements. Walshaw implemented a
means of simplifying the structure of a graph by generating
a series of approximations through coarsening [2] The result
is a hierarchy of increasingly coarse graphs, each with
approximately the same structural information as the
previous, but with fewer vertices, each of which may
represent several vertices in the original graph. These
approximations to the original graph coarsely represent the
original data provided for visualization.

A. Aesthetics
The aesthetics of a graph drawing are the qualities of the
layout which aid in the reading of the information. Research
by Purchase [5] has shown that the aesthetics which help
readers absorb information are;
• fewer edge crossings;
• high symmetry;
• fewer bends and tangles
1550-6037/12 $26.00 © 2012 IEEE
DOI 10.1109/IV.2012.78

454

B. Multilevel Algorithm
The multilevel algorithm is implemented as described by
Walshaw [2] and will continue to generate coarser graphs
until a graph with only two vertices is achieved.
1) The Coarsening Scheme finds a maximal
independent subset of edges (MISE), where each edge of the
subset is not connected to any other edge in the subset. The
edges are then contracted, forming vertices with weights
equal to the combined weight of the two vertices which
formed them. Edges that are not in the MISE are preserved
in the contraction and form a new graph in the multilevel
scheme. Each newly created vertex holds pointers to the two
vertices which formed it, both of which point to the new
vertex, forming a binary tree.
2) The Initial Layout is randomly generated by placing
the two vertices of the coarsest graph anywhere on the
viewing plane. The FDP algorithm is then run using the new
value of k which places the vertices an ideal distance apart.
The layout is then passed to the next level, where the FDP
algorithm will run again, refining the layout.
3) Incident vertices occur on vertex expansion when the
layout is interpolated to the next level and the coordinates of
a vertex are passed to the two vertices that formed it. This
will cause the two vertices to have the same position (a
distance of zero apart), therefore we add a small random
displacement to separate them and avoid zero distances, as
shown and discussed in [2] A new value for k is calculated
so the drawing of the new graph fits the output area, and
FDP is applied to refine that drawing with the new value.

2) Coarsening is a technique used to condense a graph
into a coarser, but smaller form. This is achieved by
combining pairs (or sometimes groups) of vertices to create
a new set of vertices which approximately capture the
structure of the original graph. There are a number of ways
to combine vertices, but here we use edge contraction (see
III. The Algorithm) as used in [2] .
3) Refinement of the layout is achieved by successively
applying an FDP algorithm to these coarser graphs;
interpolating the resulting layout to the finer graphs, and
finally the original, is known as multilevel refinement. It
enables the FDP algorithm (which would otherwise “tangle”
anything but the smallest graph) to find aesthetically
pleasing layouts, even for enormous graphs.
D. Approximations
Even using the multilevel paradigm, a typical FDP
algorithm still requires adequate time to calculate the new
placements for every vertex. Fruchterman & Reingold
introduced the use of approximations using a simple grid on
top of the layout, calculating forces between sections which
summed the positions and weights of their contents, [3]
Hu [1] introduced the use of the Barnes Hut octree
approximation method, [4] a more accurate technique which
splits the area into 4 or 8 sections (2D or 3D) and continues
to split those individual sections until every vertex inhabits
its own section. These splits are mapped as a tree and are
used to calculate forces between vertices and entire sections
of the graph in the same way as Fruchterman & Reingold,
albeit with more accuracy.
4) Weights of the sections are an important aspect of
maintaining the accuracy of the approximation structure.
When combining vertices to calculate long distance forces,
the weights and positions are averaged to form a centre of
mass, used to make more accurate approximations of global
repulsive forces, conserving the mass of each section.
III.

C. Global Force Approximation
Approximation of the global forces is the main idea
which sets this piece of work apart from previous research.
We propose a structure which approximates the forces via
the multilevel graph hierarchy. However, in order to
accurately compare the techniques, we also implemented the
Barnes-Hut octree.
4) The Coarsening Tree is generated during the
coarsening process: for every edge which is contracted, the
vertices at either end point to the new coarsened child
vertex, which also has pointers to its parent vertices. This
continues until the graph is fully coarsened to two vertices –
resulting in a binary tree relating to every matching that has
been made. Unlike the octree, this method exploits the
coarsening scheme and does not require an arbitrary grid
structure placed on top of the layout of the graph.
As each contraction is of a relationship, it ensures related
vertices will be drawn together, and that forces are
approximated accurately based on the graph theoretic
distance between them (the number of edges separating
them).
In order to preserve the accuracy of the repulsive forces
between individual vertices and sections of a graph, we sum
the weights of vertices during coarsening: a coarse vertex
will have the combined weight of the two vertices which
joined to form it.
5) Barnes Hut Octree is implemented using an area
larger than the view volume as the root, and then by
splitting that area into 4 (2D) or 8 (3D) sections. Each of the

THE ALGORITHM

The algorithm detailed here is a very simplistic FDP
algorithm, developed from the work in [3] using the
multilevel scheme described in [2]
The novel part of the algorithm is a new method, derived
from the multilevel scheme, for approximating the global
forces.
A. Force Directed Placement
We use the spring electrical model discussed by
Fruchterman and Reingold [3] , an expansion of [7] , to
calculate the energy of the graph and movement of vertices.
The model consists of two forces: global (electrical)
repulsive force between all vertices following an inverse
square law, and a spring force between all connected
vertices following Hooke’s law.
The forces aim to find an equilibrium state for each
vertex, whereby vertices are given a stable position an ideal
distance apart from other vertices. This ideal spring length,
k, is calculated using a function of the size of the output area
and the number of vertices. More information regarding the
forces and the spring length can be found in [3]

455

TABLE I.

CPU TIME (IN SECONDS) FOR A GENERAL FDP ALGORITHM
USING MULTILEVEL GLOBAL FORCE (MGF) AND OCTREE (OT) BASED
APPROXIMATIONS

new sections is then checked to determine the number of
vertices contained and split until each vertex inhabits only
one area. The ability to limit the levels has been included,
similar to Hu’s’ implementation, but is not used for the
results presented here. The structure of the splits is recorded
and stored as a tree for use with the FDP algorithm.
The weights of the sections are the summed weights of
its contents, and like the coarsening tree, preserve the
magnitude of forces within the graph.

Graph
2D

IV. NUMERICAL RESULTS
We measure and compare two types of results here; the
quality of a graph, determined by the number of edge
crossings, and the runtime required to find a good layout.
As mentioned earlier, the number of edge crossings has
been shown to have the most impact on the ability to read
information from a graph drawing [5] and is therefore our
primary measurable result.
The code used for testing was written in Java and has not
yet been optimized. All runtimes were measured on a
2.8GHz i7 machine.

Size
|V|

CPU
|E|

MGF

OT

3025

3025

5940

0.6

0.9

data

2851

15093

0.8

1.0

3elt

4720

13722

1.2

1.8

whitaker3

9800

28989

3.1

3.8

4elt

15606

45878

5.2

7.3

sierpinski10

88575

177147

39.2

58.0

finan512

74752

261120

60.1

63.9

dime20

224843

336024

231.6

173.2

The dimensions of the octree are determined by how
many splits are required until each vertex inhabits its own
section; experimentation showed this was, on average, 14
levels deep. In the MGF tree, however, the dimensions are
dependent on the number of graphs generated in the
multilevel algorithm (and therefore dependent on the
number of edges and the matching technique used). This
typically results in a much taller and thinner tree when using
edge contraction – ranging from 14 levels deep for a graph
of 50k edges, up to 89 levels deep for 1 million edges,
resulting in more time spent traversing the tree for larger
graphs.
Due to the effects these dimensions have on runtimes, an
exact comparison of the efficiency of each algorithm is
difficult to achieve. However, experimentation in [6] ,
suggests that with these effects taken into account, the MGF
technique is faster. Further investigation is underway to
determine how the size of a graph affects this.
Additionally, there is a further difference in runtime due
to the time taken to generate the octree structure, dependent
on the initial positioning of vertices and the size of the
graph, a process MGF has avoided through exploitation of
the coarsening process.

A. Algorithms and Parameters
In our implementations, we alter the repulsive force to
determine if there are any situations where either algorithm
performs better or worse than other algorithms, giving a
method of comparison. These alterations are quantified as a
percentage of the repulsive force function, which is
referenced as the “original strength”.
Experimentation has shown that using 5% of the
repulsive forces achieves best results for both algorithms,
and is therefore used as a default value when the algorithm
is used. Spring forces remain as normal, 100% of the
original force function.
In the following comparisons, MGF is used to refer to
the Multilevel Global Force calculation using the coarsening
tree approximation, and OT is used to refer to the OcTree
approximation. Both use the default values unless stated
otherwise. ML (n²) refers to the standard multilevel
algorithm with no approximations, calculating all n²
repulsive forces.

C. Comparison with Hu’s Algorithm
Although comparing different approximations in a
controlled environment using the same FDP and multilevel
algorithms is accurate, the results are also compared with
the state-of-the-art in order to determine their usefulness in
general. Hu’s algorithm is the most current related work and
is therefore the benchmark used here.
The results shown in Table 2 compare those of a naïve
implementation of the FDP algorithm discussed here,
against those of Hu’s Multilevel Spring-Electrical Model
MSE() with no cutoff radius for the repulsive force
calculation (the closest algorithm resembling the algorithm
developed here). As can be seen, our algorithm is slightly
faster than the results published – however, results are
biased due to a difference in the machines and environments
used to run the algorithms.

B. Comparison of Runtimes
Following the work of previous graph drawing authors,
we compare the times taken to draw a range of graphs of
different sizes. For each graph that was drawn, the table lists
the number of vertices and edges.
The results in Table 1 show that for most graphs, the
contraction approximation is faster than the octree until the
size of the graph reaches above 100k vertices. After this
point, the octree is faster due to a significant difference in
the dimensions of the tree.

456

TABLE II.

CPU TIME IN SECONDS, FOR A GENERAL FDP ALGORITHM
USING MULTILEVEL GLOBAL FORCE (MGF) APPROXIMATIONS AND THE
MULTILEVEL SPRING ELECTRICAL (MSE ())
Graph
2D

Size

E. Subjective Analysis of Drawings
Alongside the measurable results, we include our own
thoughts and perspective on a few examples of the drawings
provided by the algorithms described here, which the
numerical results may not show.
To begin with, in Fig. 2, we look at one of the simpler
graphs, 3025, a 55x55 vertex grid. The output for MGF
shows compression on two of the sides of the graph, caused
by the structure of the MGF tree. The coarsening scheme
creates a binary tree, which focuses the repulsive force in
two opposing directions, causing the stretching and
compression shown below. The octree drawing is only
slightly warped but does not suffer the compression as
forces are working in 4 or 8 directions. We are looking into
ways of overcoming this (see section 5.1).
Fig. 3 shows the same graph (3025) with two additional
edges, connecting opposite corners of the grid. As can be
seen, the drawings look identical and exhibit the same
expected folding. Additionally, the compression is less
visible, making for a clearer grid.
The next image in Fig. 4 shows the drawings for graph
4elt, showing the same structural features (this is easier to
see interactively by rotating the drawings) and preserves the
mental map. The MGF drawing appears smoother and
displays some of the same folding exhibited by the OT
drawing. Additionally, one of the arms is drawn over the
graph as opposed to stretching the body around it as seen on
the right.

CPU

|V|

|E|

MGF

MSE()

data

2851

15093

0.8

1.2

4elt

15606

45878

5.2

11.7

sierpinski10

88575

177147

39.2

44.1

finan512

74752

261120

60.1

65.1

dime20

224843

336024

231.6

290.6

D. Comparison of Edge Crossings
A comparison of the number of edge crossings in 2D
drawings is included in order to determine the difference in
quality between the layouts produced by the algorithms.
This paper assumes that the fewer edge crossings exhibited
by a graph drawing, the better its quality.
As mentioned in 4.1, to test the effectiveness of the
different techniques, we changed the strength of the
repulsive force to identify any scenario where the quality of
a graph layout would be better. In Fig. 1, the x-axis
represents the strength of the altered global repulsive force.
The chart shows the number of edge crossings exhibited
for different parameters for the graph 3elt, and shows that
the coarsening tree closely matches, if not surpasses, the
quality of the octree. As expected, running the algorithm
with no approximation yields the highest quality results, and
identifies a possible limit for the quality of the drawing
using standard FDP techniques.
Results for all other tested graphs follow this behavior,
with the ML (n²) algorithm generating drawings with fewest
edge crossings. MGF exhibits, on average, 12% more edge
crossings and OT shows 14% more. These values, however,
do not reflect the range in results; on average, OT exhibits a
range 120% greater than the range of MGF when the
repulsive force is between 5% and 0.005% its original
strength. Further explanation of these results can be found in
[6]

Figure 2. Graph 3025 drawn using MGF (left) and OT (right)

Edge Crossings

Edge Crossings Across Algorithms
20000
15000
10000
5000
0

ML (n²)
MGF
OT

Figure 3. Graph 3025 with edges connecting opposite corners of the grid,
drawn using MGF (left) and OT (right)
Figure 1. Edge crossings for the graph 3elt for variable strengths of the
repulsive force.

457

Figure 6. Graph sierpinski10 drawn usin
ng MGF (left) and OT (right)

3D drawings show the same traiits visible in 2D drawings
and show the power of the diffeerent algorithms with 3
dimensional graphs. Fig. 7 shows drawings of a 10x10x10
vertex grid, rotated so the cubic strructure of the drawing is
visible (on the left), and the unifo
ormity of the grid when
viewed from a perpendicular an
ngle (on the right). A
noticeable difference between the drawing
d
algorithms is the
influence of the peripheral effect, seen as the “bulge” in the
OT drawing (bottom), which is leess obvious in the MGF
drawing (contrary to 2D results above).
We have described an alternate means of approximating
global repulsive forces between vertices which better
models the data within a graph, and reduces the runtime of
the algorithm by generating the approximation structure
from the coarsening scheme as opposed to creating an
arbitrary grid-type structure atop thee graph.
Our results provide evidence that our algorithm is
competitive, and in most cases, better in speed when
compared to current techniques, with
w
a negligible loss of
quality for most graphs, making forr a more efficient method
of graph drawing.

Figure 4. Graph 4elt drawn using MGF (left) aand OT (right)

A much larger graph is drawn in the nexxt image, dime20,
with over 200k vertices. In these images, thhe strength of the
global repulsive force for the OT algorithm
m was dropped to
0.5% in order to minimize tangling prresent using 5%
(default). MGF continues to use the same pparameters. Fig.4
shows that the OT algorithm draws a moree uniform graph,
attempting to keep all edge lengths the samee. In comparison,
the drawing for MGF is far more compresseed but retains the
mental map. Additionally, structures of thee drawing take a
better defined shape, such as the triangle strructure on the left
of the MGF drawing, compared to the right of the OT
drawing.
Another such graph which exhibits thhis uniformity is
sierpinski10 in Fig. 6, showing a jagged draawing with better
defined triangular structures, whereas the M
MGF drawing is
stretched outwards displaying a very noticceable peripheral
effect [1] Once again, the repulsive force for OT is set to
0.5% in order to achieve an optimal draw
wing with fewer
bends.
These images display a noticeable similaarity, with only a
few differences due to the structure of thhe approximation
trees. The OT algorithm requires changes to the power of
the repulsive force as the size of the graph increases, and in
order to avoid compression, it’s likkely the MGF
approximation would require the same (iff not a change in
the output size), as the graph size increases.

Figure 7. A 3-dimensional 10x10x10 verteex grid drawn using MGF (top)
and OT (bottom) viewed from
m two directions

Figure 5. Graph dime20 drawn using MGF (leftt) and OT (right)

458

V. CONCLUSIONS
Efficiency saving comes from both a more accurate
modeling of the relationships in a graph, in respect to the
approximations used, and a more flexible data structure used
in the approximations.
Our subjective thoughts are that both algorithms
generate drawings which are clearly similar to each other,
and those drawings featured in other publications.
A. Future Work
The most noticeable pick off point for future work is to
determine how different coarsening schemes can affect the
approximation tree that is generated. For example this could
be using different types of matching scheme, such as a
maximal independent vertex subset, or by increasing the
number of edges that are collapsed in each step.
We are also interested in applying these ideas to
dynamic graphs and investigating how the structure could
be used to better visualize the drawing of graphs in real
time, as opposed to the static images aimed for here.
REFERENCES
[1]
[2]

[3]

[4]
[5]

[6]

[7]

Y.F.Hu, “Efficient, High-Quality Force-Directed Graph Drawing,”
The Mathematica Journal 10(1), 2006 pp. 37-71
C.Walshaw, “A Multilevel Algorithm for Force-Directed Graph
Drawing,” Journal of Graph Algorithms and Applications, 7(3), 2003
pp. 253-285.
T.M.J. Fruchterman and E.M.Reingold, “Graph Drawing by ForceDirected Placement,” Software – Practice and Experience, 21(11),
1991 pp. 1129-1164.
J.Barnes and P.Hut, “A Hierarchical O(n log n) Force Calculation
Algorithm,” Nature 324(4), 1986 pp. 446-449.
H.Purchase, “Which aesthetic has the greatest effect on human
understanding,” Graph Drawing 97, 1353 of Lecture Notes in
Computer Science, Spring Verlag, 1997 pp. 284-290.
C.Crawford, C.Walshaw and A.Soper, “Technical Report; A
Multilevel Force-Directed Graph Drawing Algorithm using
Multilevel Global Force Approximation”, unpublished.
P.Eades, “A Heuristic for Graph Drawing,” Congressus
Numerantium, 42, 1984, pp.149-160

459


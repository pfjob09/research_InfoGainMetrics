12th International Conference Information Visualisation

A Planar Straight-line Grid Drawing Algorithm for High Degree General
Trees with User-Specified Angular Coefficient
Adrian Rusu
Department of Computer Science
Rowan University
Glassboro, NJ 08028, USA
rusu@rowan.edu

Chu Yao
Department of Electrical and Computer Engineering
Rowan University
Glassboro, NJ 08028, USA
yaoc14@students.rowan.edu

Andrew Crowell
Department of Electrical and Computer Engineering
Rowan University
Glassboro, NJ 08028, USA
crowel57@students.rowan.edu
Abstract

a plethora of tree-drawing algorithms. Because of their
simpler structure, most of the research has been devoted
to drawing binary trees [1]. However, general trees appear more commonly in practice. Currently, there are
three main planar straight-line grid drawing algorithms
available for general trees. The level-based algorithm
by Reingold and Tilford [3], which was developed for
binary trees but can be extended for general trees, produces the most trivial tree drawing understanding (see
Figure 1). However, in addition to generating many
small angles, it has very poor area and aspect-ratio. The
general trees extension of the H-V algorithm [2] generates drawings with much better area than Level (O(n
log n) versus O(n2 )), but with a poor aspect ratio and
many small angles. The most recent drawing algorithm,
Separation [4], produces drawings with user-controlled
aspect ratio and optimal area even for high degree trees.
However, Separation also generates drawings with many
small angles (see Figure 2(a)). One of the reasons Level,
H-V, and Separation generate so many small angles is
that they only use at most two quads of the Cartesian
plane, which limits the growing space of the drawing. In
addition to limited drawing space, they both treat leaves
and subtrees in the same way, placing leaf child nodes
first and then placing subtree child nodes in a line. However this method assigns the largest angle possible between the first two allocated nodes even if they are both
leaves. The angles will then get smaller and smaller as
more and more leaves or subtrees are added.

General trees are usually displayed as planar
straight-line grid drawings which provide an easily understandable structure to the viewer. Current general
tree drawing algorithms have one common problem:
their drawings on high degree trees produce many small
angles, which makes it difficult to distinguish edges.
The algorithm we propose in this paper allows the user
to provide an angular coefficient and then employs the
‘best-effort-delivery’ to draw edges such that the angles
are above the angular coefficient. It allows the non-root
nodes to place their children within a maximum of three
quads of the Cartesian plane. When a node has too many
children, resulting in an impossibility of achieving angles above the specified angular coefficient, our algorithm distributes all remaining children evenly among
the three quads.

1 Introduction
Visualizing a tree can enhance a user’s ability in understanding its structure. Hence, much research has
been devoted to tree visualization, which has produced

Our algorithm (we call it Quad) is intended to provide
a drawing with more distinguishable edges when a node
has high degree (see Figure 2(b)). Our algorithm is able

Figure 1: Drawing of a binary tree using level algorithm
with grid showing.

1550-6037/08 $25.00 © 2008 IEEE
DOI 10.1109/IV.2008.26

600

Figure 2: (a) A drawing of a general tree generated using Separation algorithm. Edges are difficult to distinguish because of the small angles. (b) A drawing of the
general tree in (a), generated using our Quad algorithm
with angular coefficient of 1. All edges are easier to distinguish.

Figure 4: Illustration of all single quad-based directional spans in a Cartesian plane.
• Allocate a tree drawing: The process of finding a
good location for the tree in the X-Y plane.
• Level: The distance to traverse from a given node
to the root. The root is considered at level 0.
• Span: The height and width of the tree drawing Γ.
If the drawing Γ has height h and width w, then its
span is denoted as (w, h). w and h both can be zero
or positive numbers.

to draw nodes in more than one quad (see Figure 3) and
uses different procedures to place leaf nodes and subtree nodes. It first tries to place leaves in one quad, and
then, if one quad is not enough to contain all leaves with
all angles above the user-specified angular coefficient, it
will move into quad two and then quad four of a Cartesian plane (see Figure 4). Our experiments show Quad
produces drawings with better angles than all existing
general tree drawing algorithms on high degree trees.

• Directional Span: directional span is used to describe the height and width of a drawing within a
quad. The difference between Span and Directional
Span is that Directional Span’s height or width can
have sign (+/−). The sign is relative to the subtree’s root node. We use the following notations:

2 Preliminaries

– qn-x-span/qn-y-span (see Figure 4): Quad n’s
span of a tree drawing. If the sub-drawing
of Γ contained in quad n has the height h
and width w, then its qn-x-span is equal to
w when n={1,2}, or -w when n={3,4}, and
qn-y-span is equal to h when n={1,4}, or -h
when n={2,3}.
– q12-x-span (see Figure 5): X direction span
of a tree drawing in quad-1 and quad-2. If
the sub-drawing of Γ contained in quad 1 and

Throughout this paper, by the term drawing, we will
mean a planar straight-line grid drawing. We will assume that the plane is covered by an infinite rectangular
grid. A horizontal channel (vertical channel) is an infinite line parallel to X- (Y -) axis, passing through the
grid-points.
Let T be a degree-d tree and let Γ be a drawing of T .
Below is a list of terms with their definitions as they
will be used in this paper.
• Location of a tree drawing: The X-Y location of
the root of the tree.

Figure 3: Drawing of a general tree using Quad. The
drawing spreads to 4 quads.

Figure 5: Illustration of all bi-quad based directional
spans.

601

Figure 6: A quad-1 drawing which shows the direction
of growth at each level is alternating from previous level
between Y-direction-growth and X-direction-growth.
Figure 7: Each quad has different direction of growth
from others, which keeps the overall drawing square.
Quad 2, 3, 4’s drawing are the result of rotating quad
1’s drawing 90◦ , 180◦, and 270◦ counterclockwise accordingly.

quad 2 has the width w, then its q12-x-span is
equal to w.
– q23-y-span (see Figure 5): Y direction span
of a tree drawing in quad-2 and quad-3. If
the sub-drawing of Γ contained in quad 2 and
quad 3 has the height h, then its q23-y-span is
equal to −h.
– q34-x-span (see Figure 5): X direction span
of a tree drawing in quad-3 and quad-4. If
the sub-drawing of Γ contained in quad 3 and
quad 4 has the width w, then its q34-x-span is
equal to −w.
– q41-y-span (see Figure 5): Y direction span
of a tree drawing in quad-4 and quad-1. If
the sub-drawing of Γ contained in quad 4 and
quad 1 has the height h, then its q41-y-span is
equal to h.

3 Direction of growth
We introduce direction of growth as a way to have control over the overall aspect ratio of the drawing. Our algorithm mainly focuses on providing more distinguishable angles between edges, but, at the same time, we try
to achieve a good aspect ratio.
For every tree node and the subtrees rooted at its
children, if the algorithm keeps appending the subtrees’
drawings along the positive Y -axis direction, then the
output drawing will continue getting longer in the positive Y -axis direction (Y-direction-growth), which will
lead to a drawing with bad aspect ratio. In our algorithm we solve this problem by alternating the direction
of growth. If one node’s subtrees are allocated in the
positive Y -axis direction (Y-direction-growth), then its
subtrees’ subtrees will be allocated in the positive Xaxis direction (X-direction-grow). In general, for all
even level subtrees, Y-direction-growth is applied, and
for all odd level subtrees, X-direction-growth is used
(see Figure 6).
X-direction-growth and Y-direction-growth only use
the positive X and positive Y directions, which are only
within quad 1. If the drawing is intended to be drawn
in quad 2, then it is simply rotated 90◦ counterclockwise to relocate into the correct quad. What this means
to direction of growth is that if a node has Y-directiongrowth in quad 1, then after rotating 90◦ counterclockwise it will become X-direction-growth in quad 2, or rotated 90◦ clockwise it will become negative X-directiongrowth in quad 4. Since the root is considered at an odd
level, which initially allocates subtrees with Y-directiongrowth, this makes quad 2 have X-direction-growth,
quad 3 have negative Y-direction-growth, and quad 4

• Angular Coefficient: User-specified coefficient
used in determining the angles and area of a drawing. The coefficient is specified between 0 and 45
with a larger number increasing the majority of the
angles between edges and area of the drawing. For
a subtree with a relatively small number of nodes,
the angular coefficient will be the angular resolution of that particular subtree.
• Expected Shape of the drawing: Our algorithm can
produce a drawing of the tree spread to all four
quads. The user can specify what shape of drawing they want to see. Choices are quad 1, quad 1-2,
quad 1-2-3, and quad 1-2-3-4.
• Direction of growth: The size of the drawing decided by the degree of the node can either grow
along the X-axis or grow along Y -axis. Direction
of growth along X is referred to as X-directiongrowth while along Y is referred to as Y-directiongrowth.

602

have negative X-direction-growth (see Figure 7). The
purpose of changing direction of growth in each quad is
that the resulting drawing will have an aspect ratio close
to optimal.

4 General Algorithm Paradigm
Our algorithm is designed using the divide and conquer
paradigm. It recursively splits the tree and applies the
following procedures at every recursive level.
• Step 1: Draw/allocate leaves. Each leaf node is
assigned to a location relative to the location of
the parent node. This step will produce a drawing which only includes leaves and will not be performed when the parent node does not have any
leaves.

Figure 8: Quads 1, 2 and 4 are used for drawing of a
subtree within Quad 1 of the parent node. Quad 3 is left
empty for the edge to the parent.

• Step 2: Draw subtrees. Recursively obtain drawings of all subtrees rooted at children of the current node. After this step is completed, any subtree
can be represented by its root and a 1, 2, or 3 quad
shaped drawing. This step will not be performed
when the parent node does not have any subtrees.
• Step 3: Allocate subtrees. In this step, each subtree’s root will be assigned to a location relative to
the location of the parent node. This step will not
be performed when the parent node does not have
any subtrees.
During these three steps, all locations assigned to
nodes are relative locations which assume parent nodes
are at location (0, 0). When all nodes complete the three
steps, a top-down flow of process assigns a final location
which is relative to the root of the tree to each node in
the tree.
The algorithm also takes two parameters: the angular
coefficient and the quads used at root level. The angular
coefficient will be used throughout all steps to maintain
a general uniformity of angles between edges within a
single subtree. A larger angular coefficient will result
in a larger angle between edges, in turn increasing the
area of the drawing. For a subtree with a small number of nodes, relative to the specified angular coefficient,
the resulting angular resolution of the leaf nodes will be
equal to the specified angular coefficient. At the root
level, the drawing can be spread to one, two, three, or all
quads which is decided by the quads parameter given by
the user.
The drawing of a subtree is designed to only spread
to a maximum of three quads: quads 1, 2, and 4. The
reason we intentionally leave quad 3 empty, is that we
need to have a way to connect this subtree’s root to its
parent without generating any crossings or overlappings
(see Figure 8). We first draw all subtrees in quad 1, and

Figure 9: An illustration of a subtree drawing being
allocated into quad 2 of the parent node. The child is
first allocated in quad 1 and then the drawing is rotated
90◦ counterclockwise around the parent node to allocate
into quad 2.

then we rotate the drawing 90◦ clockwise or counterclockwise to produce a quad 2 or quad 4 drawing (see
Figure 9).

Figure 10: (a) Drawing of a leaf-only node with 11
leaves using Separation. The angular resolution gets
very small: only about 0.5◦ . (b) Drawing of the tree
in (a) using Quad. The angular resolution is about 3◦ .

603

Figure 12: A map of all valid leaf locations within the
square determined by points (0, 0) and (7, 7). All solid
dots are valid leaf locations, others are invalid leaf locations. Edges to a valid leaf location and a invalid leaf
location will result in overlapping.

Figure 11: Graph shows the angular resolution comparison of Separation and Quad, drawn in one quad, with
increasing number of leaves. The angular resolution of
Separation is smaller than Quad, except for the first two
leaves.

(0, 0) to (0, 2) will overlap each other (see Figure 12).
If two grid locations (a, b) and (c, d), a < c and b <
d, are collinear, then c is the result of a multiplied with
some integer constant n (n > 1) and d is the result of
b multiplied with the same integer constant n. Hence,
in order to prove grid locations p and q are not collinear
with any other location (x, y), x < p, y < q, we simply
need to verify that p and q do not have a common divider
n.

4.1 Leaf Allocation
Leaf allocation is the first step of our algorithm. We
try to assign a grid location for each leaf such that the
area occupied by them is as small as possible and no
two locations are collinear with the origin. Algorithms
H-V and Separation align all leaves along the horizontal
or vertical channels X = 1 or Y = 1, which makes the
angular resolution decrease very quickly as more children are drawn (see Figure 10 (a)). We developed an algorithm called Valid Leaf Location (VLL), which finds
valid grid locations for leaves within one quad. The angular resolution of a drawing from a leaf-only tree produced using VLL decreases at a slower pace than Separation, as more children are drawn (see Figure 10 (b)
and Figure 11). Our tree drawing algorithm uses VLL
and the user-provided angular coefficient to determine
where to place the leaves. All leaves will be attempted
to be fit into quad 1 with an angle as close as possible to
the angular coefficient. If the angular coefficient is too
large for a one-quad drawing, leaves will expand to other
quads, again being placed with edge angles as close as
possible to the angular coefficient. This will result in
a very uniform angle between leaf node edges within a
subtree.

Lemma 1 Grid location (x, y) is a valid leaf location,
if and only if x and y are relatively prime.
The algorithm Valid Leaf Location (VLL) uses the
above lemma to generate valid grid locations (see Figure 12).
VLLGenerator is the procedure we use to produce a
list of valid locations, using the VLL algorithm. The
order these locations are provided is based on counterclockwise rounds, with each round being one grid unit
further from the origin than the previous round (see Figure 13).

4.1.2 Angle check for leaves
The leaf location obtained using VLL is a valid potential location, but it might not be a location that meets
the angular coefficient requirement provided by the user.
An angle check is performed after each leaf node gets a
potential location using VLL. Assuming there is an edge
from the root to this potential location, it will be checked
for angle against all previously allocated leaves. If any
angle is smaller than the angular coefficient, the potential location for this leaf might not be used if there is a
neighboring quad available to expand to.

4.1.1 Location Generator with VLL
We need to generate a set of all grid locations
(x0 , y0 ), (x1 , y1 ), ..., (xn , yn ) connected with straight
lines to the origin (0, 0), no two locations collinear with
the origin. For example, if we pick location (0, 1) as a
valid location, then the location (0, 2) will not be a valid
location, because the lines between (0, 0) to (0, 1) and

604

Figure 15: A three-quad drawing of a node with one
leaf-only subtree. The q1-x-span = 2, q1-y-span = 2,
q2-x-span = 1, q2-y-span = −1, q4-x-span = −1, q4y-span = 1, q12-x-span = 2, q23-y-span = −1, and
q41-y-span = 2. (a) A drawing of a tree which uses all
three quads; (b) A notation representing the drawing in
each quad with the rectangle corresponding to its size.

Figure 13: The order in which locations are provided
by the VLL algorithm. Nodes 1 through 17 are children
of node 0, labeled by the order in which they are generated. The arrows show that the VLL algorithm generates
locations in a counterclockwise direction, with distance
from the origin increasing with each pass.

4.2 Subtree Allocation
After assigning locations to the leaves, we can allocate the subtrees, by assigning a relative location to the
root of each subtree. We define two cases for allocating
subtrees. Because subtree allocation does not initially
take leaf nodes into consideration, this step may result
in small angles or overlappings between leaves and subtrees. These situations are explained and handled in section 4.2.2. The two cases are defined below.

Figure 14: A drawing with angular coefficient of 5. In
(b) the 9th leaf is re-allocated in quad 2, because if it
is allocated in quad 1 in (a), the angle α between the
9th leaf with another leaf is around 4 degrees which is
smaller than angular coefficient 5 (see Figure 11).

• Case 1: Only one subtree to be allocated into one
Quad. If the current tree has only one subtree needing allocation, determining the position of its root
is trivial, dependent only upon the shape and spans
of the subtree. In the following, consider S to be
the root of the subtree needing allocation, and consider R to be the parent of S in the state it is prior
to S being allocated. Since only one subtree needs
allocation, the leaf nodes of R have already been
allocated.
– One-Quad Subtree (see Figure 16 (a)): X =
1, Y = q1-y-span(drawing of leaves) + 1.
– Two-Quad Subtree (see Figure 16 (b)): X =
1, Y = q1-y-span(drawing of leaves)+(−q2y-span)(drawing of the subtree rooted at S) +
1.
– Three-Quad Subtree (see Figure 17): X =
q4-x-span(drawing of the subtree rooted at
S) + 1, Y = q1-y-span(drawing of leaves) +
(−q2-y-span)(drawing of the subtree rooted
at S) + 1.

4.1.3 Spreading leaves to other quads
If a potential location for a leaf is found to violate
the angular coefficient, the algorithm will try to place
the leaf into another quad (see Figure 14). For example,
when a node first tries to place all leaves into quad 1 and
its (n + 1)th leaf gets a location which would create an
angle smaller than the angular coefficient with one of the
existing edges, our algorithm then will try to place the
rest of the leaves into quad 2. If after another m leaves,
there are no more valid locations with satisfiable angle
in quad 2, then quad 4 will be used to place leaves. If the
root has so many leaves that quad 4 still cannot contain
the rest of the leaves without violating the angular coefficient, then the effort of inserting leaves with an angle
equal to or greater than the angular coefficient will be
stopped, and all remaining leaves will be evenly placed
into quads 1, 2, and 4 in sequence. After all leaves are allocated, the algorithm then will compute all directional
span values based on the current stage of the drawing
(see Figure 15) .

• Case 2: Multiple subtrees to be allocated into one
Quad. If the current tree has multiple subtrees
needing allocation, the location of a subtree’s root
is determined by its shape and spans, as well as
the shape and spans of all previously allocated subtrees. In the following, consider S to be the sub-

605

– Three-Quad Subtree (see Figure 19): Y =
q1-y-span(drawing of leaves and previous
subtrees)+(−q2-y-span)(drawing of the subtree rooted at S) + 1. For a tree containing
subtrees {t1 , t2 , ..., tn }, X is a recursive function, defined as:
∗ Recursive Case: X(tm ) = q4-xspan(tm ) + X(tm+1 ), where m < n
∗ Base Case: X(tn ) = q4-x-span(tn) + 1

4.2.1 Spreading subtrees to other quads
Similar to leaf allocation, our algorithm first tries to
fit all subtrees into one quad. Because of the way we
allocate the subtrees, the edge to the furthest two subtrees from the parent forms the smallest angle. We can
find this angle by computing the locations of the last two
subtrees’ roots (see Figure 20). This angle can then be
used to compare with the angular coefficient. If the angle is too small, then the algorithm will evenly distribute
the subtrees among two quads. The angle will then be
checked, again, for both quads, and if this angle is still
too small, the subtrees will be evenly distributed among
three quads (see Figure 21). This angle can be computed
with the following formulas:
Let t1 , t2 , ..., tn be the subtrees whose roots are the
children of the tree under consideration. t1 , t2 , ..., tn
will be allocated in this order within one quad. The minimum angle can be computed by finding the locations of
the root of tn and tn−1 .

Figure 16: (a) A representation of allocation of a onequad subtree. The subtree is allocated one unit offset
from its parent’s leaves drawing, in both X and Y directions. (b) A representation of allocation of a two-quad
subtree. The subtree is allocated one unit offset from
its parent’s leaves drawing plus the subtree’s -q2-y-span,
and one unit offset from the Y-axis.

• The location of the root of tn : X = −(q4-x-span) of
n−1
tn + 1, Y = i=1 −(q2-y-span) + (q41-y-span) of
ti .
• The location of the root of tn−1 : X = −(q4-x-span)
of tn + −(q4-x-span) of tn−1 + 1, Y = n−2
i=1 −(q2y-span) + (q41-y-span) of ti .

Figure 17: Representation of allocation of a three-quad
subtree. The subtree is allocated one unit offset from
its parent’s leaves drawing plus the subtree’s -q2-y-span,
and one unit offset from the Y-axis plus the subtree’s q4-x-span.

tree needing allocation, consider R to be the parent of S in the state it is in prior to S being allocated. Since multiple subtrees need allocation, R
may or may not contain subtrees. To avoid crossings, three-quad subtrees must be allocated first
(see Figure 18).
– One-Quad Subtree: X = 1, Y =
q1-y-span(drawing of leaves and previous
subtrees) + 1.
– Two-Quad Subtree: X = 1, Y =
q1-y-span(drawing of leaves and previous
subtrees)+(−q2-y-span)(drawing of the subtree rooted at S) + 1.

Figure 18: (a) A three-quad subtree drawing; reallocation is needed for previously allocated subtrees to avoid
crossings or overlappings. (b) If the three-quad tree is
drawn first then no reallocation is needed.

606

Figure 19: For a node containing more than one
three-quad subtree, each three-quad drawing needs to
be shifted to avoid crossings or overlappings with later
three-quad subtrees.
Figure 21: The process of how subtrees are distributed
into three quads when the angular coefficient cannot be
met by one quad or two quads.

4.2.2 Small angles and overlapping conflicts
Because leaf nodes are allocated without consideration of subtree nodes, and vice versa, the algorithm may
generate small angles, and even overlappings, between
leaf edges and subtree edges. This is handled, within a
quad, by reallocating any leaf node that conflicts with a
subtree (see Figure 22).
There are two situations in which a conflict will oc-

cur. The first is when a node’s leaf edge and a subtree
edge overlap. The second situation is when a node’s leaf
edge and a subtree edge form an angle smaller than the
angular coefficient. Both of these types of conflicts are
handled as follows.
• If there is a quad which has no leafs or subtrees
allocated, the leaf node is reallocated into that open
quad.
• If there is no empty quad, then the leaf node is reallocated into the open channel, within the same
quad. That is, if the subtrees were placed in the X
direction, the conflicting leaves will be reallocated
in the Y direction where x = 1.
There is, however, one case in which a small angle
conflict (angle less than angular coefficient) is ignored.
This is when all three quads are already used.

5 Experimental Study
For an experimental study, we implemented the algorithm in C++. The algorithm was evaluated on randomly
generated general trees with high degree at the root, consisting of up to twenty thousand nodes. The experiment
evaluates the area as related to the number of nodes and
the angular coefficient.

Figure 20: A drawing of a node with several three-quad
drawing subtrees; all subtrees’ directional span values
are known, so the last two subtrees t3 and t4 ’s locations
are easy to find. The angle formed by edges from parent
node to t3 and t4 is also easy to compute.

5.1 Random general tree generation
We developed a simple program in C++ to generate
randomly structured general trees. The program takes

607

Figure 24: The projection of the X-Z plane of the graph
shown in Figure 23. The area increases as expected as
the value of n increases.

Figure 22: (a) Node 1 creates an overlap conflict; Node
2 creates a small angle conflict, but will not be reallocated since all quads are used; Node 3 creates a small
angle conflict. (b) Node 1 has been reallocated into the
open channel; Node 2 is not reallocated; Node 3 has
been reallocated into the open quad.
Figure 25: The projection of the X-Y plane of the graph
shown in Figure 23. The rate at which the area increases,
with respect to angular coefficient, increases as n increases.
from 5 to 45 in increments of 5. We then evaluate the
area performance of our algorithm.
As the result of our experimental study (see Figure 23), we found that with a relatively small n (several hundred), increasing the angular coefficient has less
of an impact on the area of the tree. As n increases,
the area increases as expected (see Figure 24), and the
rate at which the area increases, with respect to angular
coefficient, increases (see Figure 25). When n = 100,
increasing the angular coefficient from 5 to 45 has almost no impact on the area of the tree. However, when
n = 800, increasing the angular coefficient from 5 to 45
increases the area from 30, 000 to over 40, 000.

Figure 23: The performance of the algorithm on area
versus angular coefficient for randomly generated general trees with different values of n (number of nodes).

two parameters, the size of the tree which is expect to
be at least 1 and the maximum degree allowed on each
node which is also at least 1. First, the program creates
the root node of the tree, then adds a random number
of leaves to the root. Next, the program runs iterations
to add nodes to the tree until the size limit is reached.
In each iteration, a randomly selected leaf node is converted into a tree node with a random number of leaves
added to this node. The number of leaves added to a
node is restricted by the maximum degree allowed on a
node and the remaining size of the tree.

6 Conclusion
The task of creating a general tree drawing with consistent and distinguishable angles is accomplished by Quad
better than any other known existing algorithm (see Figure 26). The algorithm’s tendency to grow in four directions also naturally creates a good aspect ratio. Edge
crossings and overlappings are nonexistent in Quad, and
due to its subtree separation property, related nodes are
clustered. These three factors create an overall structure
that is easy to read and understand (see Figure 27). Quad

5.2 Evaluation
To evaluate the algorithm, we varied n up to 20, 000.
For each n, we have 10 different randomly generated
trees, and use nine different angular coefficient values,

608

Figure 28: A 100 node general tree with angular coefficient of 1. All edges are not very distinguishable, but
the area of the drawing is 648.

Figure 26: A 1-2-3-4-quad drawing of a general tree
with several high degree nodes.
avoids computationally intensive operations, allowing it
to perform the task quickly, and yet still precisely, with
desired results.
Finally, the angular coefficient provided by the user
can be used to focus the algorithm on the user’s preference of distinguishable angle or small area. A small angular coefficient will create a drawing with small area,
but will be more crowded with small angles (see Figure 28), while a larger angular coefficient will result in
larger area, but more separation between nodes (see Figure 29). This flexibility allows Quad to be user-friendly
and easily adaptable to any applications which can be
modeled as general trees.

Figure 29: Same general tree as the one in Figure 28,
with angular coefficient of 45. This drawing has distinguishable edges. However, it has an area of 864.
tion of Graphs. Prentice Hall, Upper Saddle River,
NJ, 1999.
[2] P. Crescenzi, G. Di Battista, and A. Piperno. A
note on optimal area algorithms for upward drawings of binary trees. Comput. Geom. Theory Appl.,
2(4):187–200, 1992.
[3] E. Reingold and J. Tilford. Tidier drawings of
trees. IEEE Transactions on Software Engineering,
7(2):223–228, 1981.

Figure 27: A tree with 40 leaves and two subtrees containing 10 leaves each, the angle resolution is small,
around 0.5 degrees, but the tree is still understandable,
because of subtree separation and the separation between leaves and subtrees.

[4] A. Rusu and C. Santiago. A practical algorithm for
planar straight-line grid drawings of general trees
with linear area and arbitrary aspect ratio. In IV
’07: Proceedings of the International Conference
on Information Visualisation, pages 743–750. IEEE
Computer Society, 2007.

References
[1] G. Di Battista, P. Eades, R. Tamassia, and I. G. Tollis. Graph Drawing: Algorithms for the Visualiza-

609


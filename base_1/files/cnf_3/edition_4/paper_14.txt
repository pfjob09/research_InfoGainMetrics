12th International Conference Information Visualisation

GPGPU-based Gaussian Filtering for Surface Metrological Data
Processing
Yang Su, Zhijie Xu and Xiangqian Jiang
School of Computing and Engineering, University of Huddersfield
Queensgate, Huddersfield HD1 3DH, UK
E-mail:y.su@hud.ac.uk

1. Introduction

processing here is to obtain an anticipant surface by
reserving certain wavelength components and
erasing/decreasing the amplitude of some other
components. It is essential to use filtering techniques
to establish the required wavelength regimes before
further numerical characterization. In addition,
meaningful comparison of parameters from different
surface texture measuring instruments can only be
done if filtering techniques are used to establish
identical bandwidths, i.e., a filtered reference surface
that is also known as the Mean Surface should be
established for describing and assessing surface
characteristics. The Gaussian filtered surface in
which a 2D Gaussian filter is implemented has been
recommended as an option for establishing a mean
surface by the ISO 11562-1996 and ASME B461995 standards [2, 3]. The Gaussian filter is applied
here as a low-pass filter while using a cut-off
wavelength(λc) along x- and y-directions respectively.
However, Yanagi and Hara reported that this 2D
Gaussian filter has problems on computational
efficiency despite the enormous improvements in the
capacity of microprocessors in the last decade [4].
For example, when a surface that is measured with
the sampled data points at 1024×1024 is filtered by a
2D Gaussian filter with a kernel radius of 200, it
takes MATLAB program about 20 seconds to
complete the process on a 2.6GHz PC with 2GB
memory. Yuan et al. [5] has deduced a fast recursive
algorithm for determining the Gaussian filtered
mean surface using the central limit theorem and the
approximation method. Although this method allows
a fast calculation for Gaussian filtering, it also
develops an unnatural distortion at the data terminus.

The main task for surface metrology is to obtain
and characterize the roughness, waviness and form
features on a piece of surface for engineering
purposes, which often requires measurement signal
processing. In fact, a typical engineering surface
consists of a range of spatial frequencies when
measured, where the high frequency (or short
wavelength) components are referred to as
roughness, the medium frequencies as waviness and
the low frequency as form [1]. The aim of the signal

In recent years, the rapid improvement in the
performance of PC-grade graphics processing unit
(GPU), its natural data parallelism, coupled with
improvements in its programmability, have made
GPU a competitive platform for computationally
demanding tasks in a wide variety of application
domains. Many researchers and developers have
become interested in harnessing the power of
commodity graphics hardware for general-purpose
computing, known as General Purpose Graphics

Abstract
Engineering surfaces are characterized by the
form, waviness and roughness features that are
comprised of a range of spatial wavelengths.
Filtering techniques are commonly adopted to
separate these different wavelength components into
well-defined bandwidths for further processing. The
Gaussian filtered surface in which a 2D Gaussian
filter is employed for surface assessments has been
recommended by the ISO 11562-1996 and ASME
B46-1995 standards to establish a reference surface.
For Gaussian filtering, computational efficiency is a
key problem when it is issued on a large set of
surface metrology data. In the past this problem was
tackled through reducing computation amount by
the design and adoption of some fast algorithms. In
this paper, a General Purpose Computing on GPU
(GPGPU) framework is discussed to accelerate 2D
Gaussian filtering for surface characterization. This
framework takes advantage of the GPU’s parallel
computing ability and has achieved better data
efficiency without reducing the computational
amount while maintaining the filtering quality.
Filtering results and their accuracy from this model
have been compared with the results obtained from
the MATLAB simulation kits and the satisfied
outcomes were observed.

Keywords:Gaussian filtering; Surface assessment;
General Purpose Computing on GPU

1550-6037/08 $25.00 © 2008 IEEE
DOI 10.1109/IV.2008.14

94

Processing Unit (GPGPU). As a powerful and
inexpensive solution, GPGPU has been applied in
the area such as linear algebra, differential equation
solving, physically based simulation, signal and
image processing [6]. Although progress has been
made for GPU’s hardware structure and its shading
languages, J. D. Owens [6] also pointed out that
since GPU is hardly a computational panacea, many
applications still exist for which GPUs are not well
suited. Therefore, methods to integrate GPGPU
powers into wider practical applications are still
being intensively researched.

where λxc , λyc are the cut-off wavelengths along
xand
y-directions
respectively
and
β = α 2 = ln 2 / π which guarantees the filter has an
attenuation ratio of 50% at λx = λxc with λ y = ∞ or

λ y = λ yc with λx = ∞ .
For a continuous system, the output in spatial
domain is equal to the convolution between the input
and the impulse response of the system. Thus, the
output of a 1D Gaussian filter with input u(t) is
expressed as
+∞

w(t ) = ∫ u (t − ξ )h(ξ )d ξ

(5)

−∞

In this paper, a method for implementing a
classical Gaussian filter on GPUs for surface
metrology to improve computational efficiency is
discussed. A GPGPU parallel programming
framework has been developed to illustrate some of
the key concepts developed in this project. The
remainder of this paper is structured as follows:
Section 2 gives a brief introduction to the Gaussian
filter by focusing on its transmission functions and
its discrete expressions for digital implementation on
computers. Section 3 discusses the GPU
programming framework for 2D Gaussian filtering
and the method to produce smoothed surface profiles
for visualization. Section 4 analyses the
computational results generated from GPUs with the
results produced by MATLAB simulation kits.
Section 5 concludes with future works to further
improve the filtering speed.

For an actual digital signal processing system, the
continuous input and output signal should be
discrete and finite, thus the discrete and finite form
of Equation (5) is expressed as
w(i ) =

m

∑u

k =− m

i −k

hk ∆ξ

i = m,..., n − m

(6)

1
k ∆ξ 2
exp[−π (
) ]
(7)
αλc
αλc
hk , known as “kernel”, has the kernel width 2m
where m represents kernel radius. ∆ξ is the sample
interval that has the following relationship with the
kernel radius
hk =

m = λc / ∆ξ
(8)
The sample area of a 1D Gaussian filter is limited
within [ −λc , λc ] which could be seen from
Equation (8). The computational efficiency is jointly
determined by the sample amount of input signal
u(t) and the kernel width of filter. In addition, kernel
width determines the computation accuracy. A larger
kernel width obtains higher accuracy but also results
in more computation amount.
According to the separable property of 2D
Gaussian filter, the kernel of 2D Gaussian filter can
be written as

2. Gaussian filter and its digital
implementation
ISO11562 defines the impulse response of 1D
Gaussian filter in spatial domain as follow
1
t 2
h(t ) =
exp[−π (
) ]
(1)
αλc
αλc
The corresponding amplitude-frequency response
function obtained by Fourier transform can be
depicted as

h( xk , y j ) =

αλc 2
) ]
(2)
λ
Where λc is the cut-off wavelength, ISO11562
regulates that when λ= λc, the value of G(λ) should
be 0.5 so that α = ln 2 / π = 0.4697 .
A 2D Gaussian filter can be implemented by
using two 1D Gaussian filters in a sequence of xand y-directions. Its impulse response is defined as
1
π x
y
h( x , y ) =
exp{− [( )2 + ( )2 ]} (3)
βλxc λ yc
β λxc
λyc
Then its corresponding amplitude-frequency
response function is
λyc
λ
G (λx , λy ) = exp{−πβ [( xc )2 + ( )2 ]} (4)
λx
λy
G (λ ) = exp[−π (

1

βλxc λyc
1

=

β λxc

exp{−

j ∆ξ y 2
π k ∆ξ x 2
[(
) +(
) ]}
β λxc
λ yc

exp[−π (

k ∆ξ x

β λxc

1

)]2 i

β λyc

exp[−π (

j∆ξ y

β λyc

)]2

= hk ( x )ih j ( y )

(9)
where k and j denote the kth and jth sample points
along x- and y-directions respectively.
Similarly, for an input u(x,y), the output of 2D
Gaussian filter is
w( xi , ys ) =
=

m

n

∑ ∑ u( x

k = − m j =− n

i −k

m

, y s − j )ih( xk , y j )i ∆ξ x i ∆ξ y
n

∑ h( x )∆ξ ∑ u ( x
k

k = −m

x

j =− n

(i = m,..., p − m

95

i−k

, ys − j )i h( y j )i ∆ξ y

s = n,..., q − n)
(10)

Where i, s are the number of sample point of
u(x,y) along x- and y-directions respectively, and m,
n are kernel radius of h( xk , y j ) along x- and y-

3. GPGPU-based Gaussian filtering
3.1. Comparisons of CPU and GPU
programming paradigms

directions respectively. Similarly, m = λxc / ∆ξ x and
n = λyc / ∆ξ y .
When the input signal u(x,y) is filtered by a 2D
Gaussian filter, the convolution computation is first
issued along x direction then along y direction, or
first along y direction then along x direction. This is
in consistent with the separable property of 2D
Gaussian filter.
With the development of measurement
instrument, the accuracy of surface metrology has
been improved enormously, even to the level of
nano-meter [7]. The number of sampled points is
growing rapidly which brings a large computation
load when using 2D Gaussian filter to obtain the
mean surface. At this time CPU’s serial computing
model restricts the implementation of Gaussian filter
for the following reasons:
(1) Most of CPU’s operation still adopts the style
of operating on and executing one instruction on just
one or two pieces of data at a time. This data
processing style gives rise to an inherent inefficiency
in CPUs. Since only one instruction is executed at a
time, the entire CPU must wait for that instruction to
complete before proceeding to the next instruction.
As a result a CPU has to get "hung up" on
instructions which take more than one clock cycle to
complete execution [8];
(2) Although instruction level parallelism and
thread level parallelism have been taken into account
in the design of scalar processor, vector processor,
or array processor, a specialized CPU to run
mathematical operations on multiple data elements
simultaneously are still problematic, for inatance,
operating on floating point number, and in
controlling the complexity of the decoders in vector
processor [9]. These problems limit the extensive
application of the vector processor in practical.
Different from CPUs, modern GPUs are designed
as fast streaming processors with built-in data
parallelism, which means multiple data streams with
same data processing tasks can be processed in
parallel. This characteristic is well suited for linear
algebraic operations such as convolving computation
[10].

In contrast to CPU programming model that is
based on instruction stream programming, GPU
programming model is based on data stream
processing. The core of the latter processing style is
that the processor is first configured by the
instructions and then a data stream is processed by a
number of depth-parallel units in a pipeline. Given
sufficient memory bandwidth and multiple
processing pipelines, data processing can also be
parallelized in breadth by distributing the execution
among several pipelines. Commodity GPUs adopt
breadth parallelism using Single Instruction Multiple
Data (SIMD) processing units with multiplecomponent vectors. Their pipeline arrangements are
similar to vector processors with multiple pipelines
[11]. The difference between instruction stream
programming and data stream processing is
highlighted in Fig. 1 and Fig.2.

Figure 1. Instruction stream processing in CPU

programming model

Figure 2. Data stream processing in GPU

programming model

3.2 Gaussian filtering on GPU
The GPGPU framework developed in this project
for Gaussian filtering can be depicted by Fig. 3.

Figure 3. Framework of GPGPU-based Gaussian filtering

96

To illustrate the processes comprised in the
framework, a primitive surface was used as an
example, which was sampled at the size of
1024×1024. The original measured data varies in the
range of 10-6 meter and was firstly stored in a
1024×1024 array. Fig.4 shows the surface profile
that was initially visualized in MATLAB.

vertex array will be used as the height map for a 3D
geometry representing the target surface and be
specified as y- coordinates in the Cartesian
coordinate system in the Model Space. After
specifying the normal vector of each vertex and the
corresponding modelview and projection matrices,
the 3D representations of filtered surface profile can
be displayed by rendering the mesh on the
framebuffer.
float
filtering (uniform samplerRECT data :
TEXUNIT0, // the metrology data
uniform samplerRECT kernel:
TEXUNIT1, // Gaussian filter’s kernel

Figure 4. A primitive surface profile

uniform int kernel_width,

The Gaussian filter’s cut-off wavelength in x- and
y-directions were set to λx = 0.8 and λ y = 0.8 . The
sample interval of λx and λy were both set to 0.016,
thus the kernel width of 2D Gaussian filter along xand y-directions were both 100. Therefore, the
filter’s kernel was first characterized by a 101×101
array.
The software prototype for GPGPU-based
Gaussian filtering was developed using the OpenGL
Graphics API and the Cg shading language from
Nvidia. The first step of the program is to configure
parameters for Cg code. It is carried out at the stage
of initialization as shown in Fig.3. The initialization
operations mainly include initializing the parameter
‘CGcontext’ that is used as a container for Cg
programs in vertex and/or fragment shaders, setting
up the entry point for Cg programs, and then
assigning parameter values to Cg programs.
The Gaussian filtering process is actually
performed in the fragment shader with two ‘pbuffers’ data structures allocated for the original
surface metrology data and the kernel of Gaussian
filter. They are all viewed as the input data streams.
The binding of input data stream with GPU texture
memories is achieved through the default OpenGL
instruction- ‘glTexImage2D()’.
A list of pseudo-code for explaining the processes
invoked in a GPU’s fragment processor is shown in
Fig.5. The fragment program convolves the
primitive surface metrology data stored in a texture
unit with the kernel of 2D Gaussian filter stored in a
separate texture unit. The kernel offset that is
represented by 2 floating numbers denotes the
negative distance along x- and y-direction from
kernel’s edge to kernel’s center.
In this project, the task of visualizing filtering
results is achieved through a technique called
render-to-vertex-array. At this step, filtering results
stored in the framebuffer on a GPU will be
transferred back to CPU’s vertex array by invoking
OpenGL instruction ‘glReadPixels()’. The filled

// kernel width in x- direction
uniform int kernel_height,
// kernel height in y-direction
uniform float2 kernel_offset,
// kernel offset
float2 pos : TEXCOORD0
// texel position in TEXUNIT0
) : COLOR
{
float c = 0;
for(int y=0; y<kernel_height; y++) {
for(int x=0; x<kernel_width; x++) {
float weight=texRECT(kernel, float2(x, y)).r;
c += texRECT( data, pos + float2(x, y)
+ kernel_offset).r * weight;
}
}
return c;
}
Figure 5. Pseudo-code of fragment program

4. Result analysis
The Gaussian filtering results on MATLAB
using the same set of surface metrology data is
shown in Fig.6, whilst Fig.7 shows the result of
same operations implemented on a Nvidia’s
GeForce 7900 GPU. In Fig.6 and Fig.7, the edges of
the filtered surface profiles were both expanded to
the size of 1124×1124, which is caused by the edge
expansion effect of convolution where a vector A

97

Table 1. Rate testing of Gaussian filtering on the

with the dimensional size m1×n1 convolves with a
vector B of the dimensional size m2×n2 will generate
a vector C of the dimensional size (m1+ m2-1)× (n1+
n2-1). The central part of the resulting vector of the
size m1×n1 can also be extracted to guarantee that
vector C has the same size with vector A, which has
proven valuable in image processing to avoid edge
distortion of the filtered images. Fig.8 shows the
surface profile of the size 1024×1024 that is
extracted from the GPU filtering results.

developed GPGPU program and MATLAB
GPGPU
Transferring data
from CPU to GPU
Issuing convolution

0.62s
0.41 s

MATLAB
Not
required
4.94s

5. Future work
Up to now, the developed software model for the
proposed GPGPU Gaussian filtering framework has
to transfer data from GPU core back to CPU for
visualizing the computation results. This is a known
bottleneck [12] since in contrast to the enormous
GPU memory bandwidth, the bandwidth of
PCI/AGP bus that interconnects CPU and GPU
seems like the “tortoise” speed. The run time of the
entire application is unavoidably delayed by this
bottleneck. In the worst case scenario, a 1124×1124
data read-back from GPU to CPU can take up to 5.5
seconds on a PC with 2.6GHz dual-core processor
and 2GB memory.
The next stage of this research will explore the
so-called “vertex texture” to visualize the filtered
data directly from GPU. This relatively new
technique has been supported since Nvidia GeForce
6000 and series onwards. It allows vertex shaders to
read data directly from textures, just like in fragment
shaders[13]. Based on it, a vertex shader program
that is designed for mesh drawing will be added to
the present framework of GPGPU Gaussian filtering,
with the aim to further accelerate the process of
Gaussian filtering.
Except the computational efficiency, another
problem for Gaussian filter to be applied in
establishing the mean surface is that an unnatural
distortion might occur as an end effect at the data
terminus. To solve this problem, Spline filters and
Gaussian regression filters have been proposed.
However, when these filters are used for the
computation of 3D surface assessment, the amount
of computation becomes even larger than that of
Gaussian filtering [14]. Making use of GPU’s
characteristic of hardware acceleration, the GPGPUbased software prototype might provide a solution
for the hybrid Spline filter and Gaussian regression
filter approach to consummate the filtering
technologies used in 3D surface metrology.
GPGPU is a recent research area and there are
several published solutions. It is believed that
approaches in increasing numbers will be presented
for GPGPU with the development of GPU’s
hardware and its shading languages.

Figure 6. Result of Gaussian filtering issued by

MATLAB at 1124×1124.

Figure 7. Result of GPGPU-based Gaussian

filtering at 1124×1124.

Figure 8. Extracted results from GPGPU-based

Gaussian filtering at 1024×1024.

In addition to filtering accuracy, by repeatedly
running the GPGPU software model on various size
of sampled surface metrology data sets, a steady
speed gain has also been observed. Table 1 lists the
running time of the main steps of GPGPU-based
Gaussian filtering in comparison with corresponding
MATLAB simulation programs. In average, the
GPGPU approach has a speed up factor up to 4.8.

98

Reference

[8]

[1] Raja J., Muralikrishnan B., Fu Shengyu. Recent
advances in separation of roughness, waviness and
form. Journal of the International Societies for
Precision
Engineering
and
Nanotechnology,
26(2002):222-235.

Joseph D. D.. Computer architecture :
fundamentals and principles of computer design,
Boca Raton, Fla. ; London, 2006.

[9]

William S.. Computer organization and
architecture : designing for performance, Upper
Saddle River, N.J. : Pearson Prentice Hall,
2006.

[2] ISO 11562:Geometrical product specification(GPS)—
surface texture: profile method—metrological
characteristics of phase correct filters. Geneva:
International Organization for Standardization,1996.

[10] Owens J. D., Luebke D., Govindaraju N., et al. A
Survey of General-Purpose Computation on Graphics
Hardware,
State-of-the-art
Report
in
EUROGRAPHICS 2005 : 1-51.

[3] ASME B46.1:Surface Texture: Surface Roughness,
Waviness, and Lay. New York: American Society of
Mechanical Engineers,1995.

[11] Strzodka R., Doggett M., Kolb A.. Scientific
Computation for Simulation on programmable
Graphics Hardware, Simulation Modelling Practice
and Theory, 2005, 13(8):667-681.

[4] Yanagi K, Hara S. Technical committee for
standardizing the software to characterize surface
topographic data—in concert with the geometrical
product specifications: surface texture in ISO. J Jpn
Soc Precision Eng 2003,69(8):1057–1060.

[12] Dudash B.. Next Generation Shading and Rendering,
Available on:

ftp://download.nvidia.com/developer/presentati
ons/

[5] Yuan Y. B., Piao W. Y., and Xu J. B.. A fast Gaussian
filtering algorithm for three-dimensional surface
roughness measurements. Journal of Physics:
Conference Series 48 (2006):1401-1406.

[13] Gerasimov P., Fernando R., Green S.. Nvidia
Whitepaper: Shader Model 3.0 and Using Vertex
Textures, Available on:
http://developer.nvidia.com/object/using_vertex_text
ures.html

[6] Owens J. D., Luebke D., Govindaraju N., et al. A
Survey of General-Purpose Computation on Graphics
Hardware, Computer Graphics Forum, 2007, 26 (1):
80 -113.

[14] Numada M., Nonura T., Kamiya K., et al. Filter with
variable
transmission
characteristics
for
determination of three-dimensional roughness,
Precision Engineering, 30(2006):431-442.

[7] Blunt L., Jiang X. Q.. Advanced techniques for
assessment surface topography: Development of a
basis
for
3D
surface
texture
standards
‘SURFSTAND’, Kogan Page Science, London, 2003.

99


Interactive Reﬁnement of Multi-scale Network Clusterings
David Auber,
LaBRI, Universit´e Bordeaux I
351 Cours de la lib´eration
33405 Talence CEDEX, France
david.auber@labri.fr

Fabien Jourdan
LIRMM, UMR 5506
161 rue Ada
34392 Montpellier CEDEX 5, France
fjourdan@lirmm.fr

Abstract
Insight of multiscale networks could be accessed through
the visualization of automatic multiscale clusterings. But results of these methods do not necessarily fulﬁll user expectations since they don’t provide error prone clusterings. In
this article we propose a way to reﬁne interactively these results by the use of multiscale grouping and ungrouping interactions. This approach revealed to give very good results
on common networks, especially on Small World networks.
Moreover, the linear algorithm makes that the method remains interactive on huge graphs with thousand of nodes.

1. Introduction
1.1. Motivations
Common networks, such as small world networks [23],
can be divided into sub-networks to show the relevant communities they are made of [15, 7, 16]. For instance, the right
part of ﬁgure 1 presents a community view (quotient graph
representation) of the social network on the left (a movie
actor network), thereby improving navigation. In fact, this
synthetic representation makes network navigation easier
since user can act on set of nodes before dealing with detailed visualization (as mentioned by Shneiderman mantra
”Overview ﬁrst, zoom and ﬁlter, then details on demand”
[17]). Furthermore, Adamic noticed that large small world
sub-networks also presents the small world property [1].
Based on this assumption, Auber et al. proposed, in 2003
[4], to apply recursively a clustering algorithm on the subnetworks. Right part of ﬁgure 1 is an output of this method.
For instance, the central community is also made of interconnected sub-networks.
These kind of heuristical clustering methods not necessarily provide the graph hierarchy expected by the user. That
is nodes or group of nodes could be located in a not relevant sub-network. Consequently user may want to merge

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

Figure 1. Two representations of a movie
actor network. First one is obtained with a
spring embedder layout. Second one is a
quotient graph representation produced by a
multi-scale small world clustering algorithm.

(group) or divide (ungroup) clusters. In an attempt to provide these kind of interactions, we propose grouping and
ungrouping algorithms.
Since these manual grouping and ungrouping methods
will be used in an interactive process, user action feedback
has to be immediate even on very large graphs. For this purpose we propose a low time computation cost algorithm
(linear complexity).
Last criteria we will argue is drawing aesthetic aspect.
Indeed, group or ungroup modify the quotient graph structure by adding or removing node and edges. Hence elements
may overlap in the new quotient graph representation. To ﬁx
the overlapping problem we propose and argue two drawing
methods.

1.2. Concrete use of clustering edition
A relevant example is given by software engineering
graph decomposition [15, 20]. These methods are generally
used to re-engineer large softwares, that is to propose an organization of software components. In [7], Chiricota et al.
proposed an algorithm to automatically compute the access

graph decompositions 1 [2, 11]. Figure 2 presents the result of this method on a Java software called ResynAssistant2

Figure 3. Detailed view of the ﬁgure 2 top left
cluster. Two set of nodes with a different software purpose are merged. Nodes on the left
deal with transformations while others deal
with perception.
Figure 2. A quotient graph of a software
(ResynAssistant) access graph.

ResynAssistant developers validated this clustering by
easily associating a software role to each cluster. Except for
one cluster (the top left one in ﬁgure 2) which contains elements with different roles (see ﬁgure 3). Accordingly, the
cluster should have been divided again into two clusters :
one for transformation classes and one for perception ones.
By itself, the automatically decomposition provides a
satisfying clustering.But to advance the understanding of
software structure the clustering should be reﬁned. In the
next section we will present how, with our method, the user
can interactively reach this purpose.

1.3. Computational and drawing issues
Dealing with large information spaces required to take
care of time computation costs. Indeed, common networks,
such as social networks, often contain thousands of nodes.
Preserving interactivity during navigation of these huge
datasets require linear (more generally sub-quadratic) algorithms. Based on Tulip library [3], we propose a linear way
to group (resp. ungroup) set of nodes or clusters.
After graph structure transformation, nodes that are not
in a group may be drawn inside the border of it. To prevent
1
2

It exists a link between two java classes if access is allowed from one
class to the other one.
This software, dedicated to analysis and storage of chemical data, is
developed in the LIRMM.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

this overlapping problem, we propose and argue two solutions. First one is based on a scale transformation and second one uses a force directed embedding method. Both were
implemented in Tulip and compared.
In the next section we describe the multi-scale reﬁnement process. In section 3, grouping and ungrouping algorithm are presented, then we discuss the overlapping problem.

2. Multi-scale clustering reﬁnement process
Our grouping and ungrouping method strength consists
in the ability to be applied both to one-scale and multi-scale
clusterings. We will say one-scale clustering when clusters
have no sub-clusters (for instance Resyn Assistant decomposition). In contrast, a multi-scale clustering will be made
of cluster containing other clusters (as in large actor networks). In this section we will present the way to reﬁne clustering in these two conﬁgurations.

2.1. Reﬁning one-scale clustering
Figure 4 shows the interactive process used to reﬁne the
one-scale clustering of ResynAssistant. First, the incriminate cluster is ungrouped (picture 1 to picture 2), then same
role classes are selected (picture 3) and merged by a call to
the group routine (picture 4). Finally, by selecting the other
nodes (picture 5) the appropriate clustering is created (picture 6).
This example shows that the interaction process for
grouping and ungrouping nodes is quite easy and intu-

problem. The user will interact on the hierarchical clustering with exactly the same interactors : group and ungroup. Main difference with previous example consists in
that these actions can be done inside the clusters.
In the next section we present the grouping and ungrouping algorithms.

3. Grouping and ungrouping algorithms
3.1. Grouping
Let G(V, E) be a graph where V is the set of nodes in
G and E the set of edges, for ease of reading we will note
e(u, v) an edge e that link nodes u and v. The ﬁrst operation we need to implement is the possibility to group a
set of nodes, S, into a cluster C. This operation consists in
the creation of a new node n that will represent the cluster C. Consequently, it will require to create edges between
n (the cluster) and each node in V /S (node outside the cluster). This edge will be created when it exists an edge e(u, v)
with u in S and v in V /S, or with v in S and u in V /S. Note
that, we insert at most one edge between a node of V /S and
n. This operation can be seen as a quotient graph computation.
We obtain the cluster C by extracting the induced subgraph of G by S. An induced subgraph of a graph G(V, E)
by a set of nodes S ∈ V is a subgraph G (V , E ) such that
V = S and :
E = {e(u, v) ∈ E|u, v ∈ V }
Figure 4. From the graph presented on ﬁgure
3 a more suitable clustering is interactively
produced. Steps 1 to 6 show user grouping
and ungrouping actions to reﬁne clustering.

The ﬁnal operation consists in placing the induced subgraph
C into n. In the following, such a node, containing a subgraph, will be called a metanode. Finally, all nodes in S are
removed from G. After grouping, one can redo the grouping
method, it enables to create cluster of clusters. Figures 5, 6
and 7 show a graph and two clustering steps.

itive. Both are two time interactions, ﬁrst the user select
objects to group (resp. ungroup) then launches the grouping (resp. ungrouping) operation. Notice that user only acts
on nodes, edge transformations are managed by the algorithm. For instance, in step 6, when the second cluster is
built, the quotient graph edge linking the two new clusters is automatically computed (for instance no edge link
the left cluster to the rest of the quotient graph).

2.2. Reﬁning multi-scale clustering
As it was mentioned in introduction, many large networks accept a multi-scale decomposition. This cluster hierarchy could also required a reﬁnement, for instance by
creating one or more sub-clusters into one cluster. On the
other hand, automatic clustering may divide a cluster when
it is not meaningful. Our method is also made to assess this

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

Figure 5. The original graph.

The grouping operation can be implemented efﬁciently
in O(|V | + |E|) using a suitable data structure. In this work
we use the Tulip library [3] that enables to deal easily and

Figure 6. Grouping round nodes.

time by using hash map of hash set data structure.
The ﬁgure 8 shows the hierarchy graphs used in order
to represent the graph of the ﬁgure 7. In this ﬁgure the red
edges correspond to the ones added during the grouping operation. In ﬁgure 8, notice that the original edges of the
graph are always preserved in the root graph, it will enable
to ungroup cluster later when needed. Moreover we do not
need to keep the edges between nodes and metanodes that
link Gview to Gclust . That is why the root graph of the ﬁgure 8 only contains two edges of the three edges created at
the ﬁrst grouping operation shown in ﬁgure 6.
Metanode

Root

View

Subgraph

Figure 7. Groups of groups.

Subgraph

Contain

Subgraph

efﬁciently with a hierarchy of sub-graphs. First we store the
original graph Groot at the top of the hierarchy and we use
a sub-graph Gview of this graph for display. If no cluster
has been built Groot = Gview . When one wants to build
a cluster it must be a sub-graph of Gview (also a subgraph
of Groot ). After the grouping operation Gview do not contains anymore the nodes and the edges belonging to the
new group but a new node nmeta representing this cluster
(group). Thus, we create a sub-graph Gclust as a children
of Groot and we create a new metanode nmeta in Gview .
Due to the sub-graph relation in the hierarchy of graphs,
one must notice that nmeta is also added in Groot .
The main problem of grouping is to create the new edges
between nmeta and the other nodes in Gview , such that
Gview keeps being a quotient graph of the original graph.
One can build efﬁciently these new edges by iterating all
the edges e(u, v) of Groot and by creating an edge between
the node u (respectively v) and nmeta if u ∈ Gview and
v ∈ Gclust (respectively v ∈ Gview and u ∈ Gclust ). Even
if it does not change the theoretical complexity (O(|E|) in
the worst case, this operation can be improved if it is done
during the step of deletion. In that case,the exact complexity is
degG (v)
v∈Gclust

To prevent the creation of multiple edges (several edges that
link the same nodes), one must check if the edge to add already exists. This operation can be done in average constant

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

Cluster 2

Cluster 1

Contain

Figure 8. Hierarchy of graphs. Note that all information is contained in Root graph.

3.2. UnGrouping
The ungrouping operation is more complex but can also
be achieved in O(|V | + |E| + c) where c is the number of
clusters. Let G (V , E ) be a clustered graph ( the one called
View in the ﬁgure 8), that represents G(V, E) ( graph of the
ﬁgure 5 ), and nmeta ∈ V a metanode that one wants to
open (ungroup). Let G (V , E ) be the graph represented
by the metanode nmeta (the graph called cluster2 in ﬁgure 8). Ungrouping a node corresponds to add all nodes
x ∈ V in V and all edges e ∈ E in E , then to create links between nodes of V and V according to the original links in G(V, E). For ease of read and without lost of
generality, in the following we use the graphs given in the
ﬁgure 8.

Deﬁnition 1 Accessibility: Let u a node or a metanode, accessibility is deﬁned recursively using the following properties :
• if u is a node : u is accessible from u,
• if u is a metanode : let Gmeta be the graph represented
by u, x is accessible from u if x = u or if it exists v ∈
Gmeta such that x is accessible from v.
Let A be the set of all nodes of Groot accessible from
neighborhood nodes of nmeta in Gview . Let B be the set of
nodes accessible from nodes in Gcluster2 . Let
Ec = {e(u, v) ∈ Groot |(u ∈ A, v ∈ B)or(v ∈ A, u ∈ B)}
, be the set of edges that should be analyzed in order to reconnect nodes from V and V .
φ
Let A −→ V be the function that associates to each
node x ∈ A a node x ∈ V such that x is accessible from
x (x is unique because the grouping operation ensures to
β

have a partition of nodes). Let B −→ V deﬁned in the
same manner. For all edge e(u, v) in Ec , if φ(u) and β(v)
are not metanodes we add e in G else, if we do not create multiple edges, we create a new edge e (φ(u), β(v)) in
Gview .
Theorem 1 The ungrouping operation can be achieved in
O(|V | + |E| + c).
Proof 1 The construction of sets A and B can be done in
linear time according to the number of nodes because the
set of clusters deﬁne a partition of V (|A| + |B| < |V | + c).
Same assumption could be done for functions φ and β. Using hash map data structure one can test in O(1) whether
or not a node is in a set and whether or not an edge exist. Thus the complexity is O(|V | + |E| + c) where c is the
number of clusters.

Figure 9. Overlapping
3.3.1. Scaling: One solution to this problem is to scale
down the drawing of the clustered graph until it ﬁts inside
a box that do not overlap any other nodes inside the original drawing. The main advantage of this method is that
we do not change neither the topology, neither the shape,
but only the metrics of the so-called topology-shape-metric
approach [5]. This property enables the user to recognize,
without too much cognitive processing, its new cluster and
to preserve exactly the same drawing for other nodes. Furthermore, the straightforward algorithm that consists to ﬁnd
the nearest node that overlaps the bounding box can be implemented in O(|N |) time. Figure 10 presents the result of
applying scaling solution on ﬁgure 9 problem.

3.3. Management of node overlapping
According to the closure principle of the Gestalt law [14,
22] if one wants the user to perceive visually the group,
cluster should be displayed inside a rectangle, or at least inside a Jordan Curve (closed contour). The main problem of
using a closed contour is that, according to initial node position, those that do not belong to a cluster can be embedded
inside the closed contour. Such problem makes the visualization almost unusable since the user may think that nodes
belong to a cluster when it is not the case. In ﬁgure 9, the
bounding box of red nodes, used in order to display the cluster, contains blue nodes that do not belong to this cluster. In
our work, we implemented and experimented the two methods presented bellow in order to prevent overlapping.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

Figure 10. Scaling

3.3.2. Force directed: Another way to prevent overlapping is to move nodes that overlaps the cluster representation. However, moving a node to another position can produce new overlapping. Thus, this operation can lead to the
modiﬁcation of all node positions. In our work, we used
a force directed algorithm in order to solve this problem.
It is a modiﬁcation of the so-called spring embedder algorithm [8] that enables to manage node of non uniform sizes.
For more information on drawing graph with non uniform
vertices one can refer to [13]. Another approach that can be
used is the one proposed in [21] which modiﬁes node positions and the drawing of the graph inside the cluster. Figure 11 presents the result of applying our spring embedder
like algorithm on the clustered graph of the ﬁgure 9.
The main drawback of this solution is that applying such
algorithm can completely change the representation. That
is, the user mental image (or map) of the data needs to be reconstruct. Thus, even when we use morphing between representations, we noticed during our experimentations with
different kind of starting layout that this method doesn’t
seem to be an efﬁcient solution in the general case. Moreover, the complexity of these algorithms, even if one uses
more efﬁcient ones [9, 10], are in O(|V |3 ) that makes them
almost unusable in an interactive system when the size of
graphs is higher than 1.000 nodes.

Figure 11. Force repulsion

We also studied other methods in order to manage overlapping when the original graph layout has not been done using a force directed algorithm. In fact, the main problem
is that the grouping operation can change the topological
characteristics of the original graph and then, re-applying
the graph drawing algorithm on the quotient graph is not
always possible or the result can be completely different.
During our experimentations using hierarchical graph layout [18], tree layout [6] or planar layout [12] we wer not
able to ﬁnd a solution that works correctly. However, if we
restrict the grouping operation of the user in order to preserve topological characteristics of the original graph it is
possible to ﬁnd a speciﬁc solution for each of the cited algorithm. This solution consists to modify each of these algorithms in order to manage node of non uniform size.

4. Conclusion and future works
In this article, we present an efﬁcient way to interactively
reﬁne multi-scale clustering. In concrete cases, as software re-engineering, this method revealed to be very useful since user need correct clusterings to present their software. Moreover, since datasets become larger and larger, we
also focused on proposing low time computation cost algorithms. We proves that group and ungroup could be done
in linear time with a suitable multi-scale clustering description format. Consequently, interaction feedback keeps immediate even with graphs containing 100.000 elements. Finally we solve the problem of overlapping nodes, for keeping readability.
In a next future, this method should be improved by
adding shortcuts in the reﬁnement process. In fact to make
one cluster from nodes contained in two clusters we need
to ﬁrst ungroup the two clusters and then to group all the
nodes. Adding a join operation will be a way to lower the
number of interactions during the reﬁnement process. Combination of all these interactions will raised combinatorial
question on the faster way to turn a clustering in another
[19]. For instance we can identify the difference between
the optimal and the effective number of operations done by
the user.

5. Acknoledgements
Supported by ACI JC : Cubes de donnes construction et
navigation interactive grant.

3.3.3. Discussion: Due to the limitation of the force directed approach, in our system we use the scaling algorithm
by default. However, when the size of graphs is small and
when the original graph layout has been made using a force
directed algorithm the second method is very efﬁcient. That
is why, in our system, we kept this functionality available.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

References
[1] Adamic. The small world web. Technical report, Xerox Palo
Alto Research Center, Los Angeles, 1999.
[2] Ardourel and Huchard. AGATE: Access Graph bAsed
Tools handling Encapsulation. In IEEE International con-

[3]

[4]

[5]

[6]

[7]

[8]
[9]

[10]

[11]

[12]

[13]

[14]
[15]

[16]
[17]

[18]

ference on Automated Software Engineering, (ASE’2001),
pages 311–314, 2001.
D. Auber. Graph Drawing Software, chapter Tulip- A Huge
Graph Visualization Framework, pages 105–126. Mathematics and Visualization series. Springer-Verlag, 2003.
D. Auber, Y. Chiricota, F. Jourdan, and G. Melanc¸on. Multiscale visualization of small world networks. In S. C. North
and T. Munzner, editors, IEEE Symposium on Information
Visualization, pages 75–81. IEEE, 2003.
G. Battista, P. Eades, R. Tamassia, I. Tollis, and G. Tollis.
Graph Drawing : Algorithms for the Visualization of Graphs.
Prentice-Hall, 1999.
C. Buchheim, M. J¨unger, and S. Leipert. Improving walker’s
algorithm to run in linear time. Technical report, Zentrum f¨ur
Angewandte Informatik K¨oln, Lehrstuhl J¨unger, April 2002.
Y. Chiricota, F. Jourdan, and G. Melanc¸on. Software components capture using graph clustering. In 11th IEEE International Workshop on Program Comprehension, Portland, Oregon, 2003. IEEE / ACM.
P. Eades. A heuristic for graph drawing. In Congressus Numerantium, volume 42, pages 149–160, 1984.
A. Frick, H. Mehldau, and A. Ludwig. A fast adaptive layout
algorithm for undirected graphs. In R. Tamassia and I. Tollis,
editors, 2nd Symp. Graph Drawing, Lecture Notes in Computer Science, 894, pages 388–403. Springer-Verlag, 1994.
T. Fruchterman and E. Reingold. Graph drawing by forcedirected placement. Software Practice and Experience,
21(11):1129–1164, 1991.
O. Gout, G. Ardourel, and M. Huchard. Access graph visualization: A step towards better understanding of static access
control. In T. Mens, A. Schrr, and G. Taentzer, editors, Electronic Notes in Theoretical Computer Science, volume 72.
Elsevier, 2002.
C. Gutwenger and P. Mutzel. Planar polyline drawings with
good angular resolution. In S. Whitesides, editor, 6th Symp.
Graph Drawing, Lecture Notes in Computer Science, 1547,
pages 167–182. Springer-Verlag, 1998.
D. Harel and Y. Koren. Drawing graphs with non-uniform
vertices. In Proc. Working Conf. on Advanced Visual Interfaces (AVI’2002 ), pages 157–166. ACM Press, 2002.
K. Kofka. Principles of Gestalt Psychology. Harcourt Brace,
New York, 1935.
S. Mancoridis, B. S. Mitchell, Y.-F. Chen, and E. R. Gansner.
Bunch: A clustering tool for the recovery and maintenance
of software system structures. In ICSM, pages 50–, 1999.
A. Noack. An energy model for visual graph clustering. In
Graph Drawing, pages 425–436, 2003.
B. Shneiderman. The eyes have it: A task by data type
taxonomy for information visualizations. Technical Report
UMCP-CSD CS-TR-3665, College Park, Maryland 20742,
U.S.A., 1996.
Sugiyama, Tagawa, and Toda. Methods for visual understanding of hierarchical system structures. IEEE Transactions on Systems, Man, and Cybernetics, 11(2):109–125,
1981.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

[19] V. Tzerpos and R. C. Holt. Mojo: A distance metric for software clusterings. In Working Conference on Reverse Engineering, pages 187–, 1999.
[20] V. Tzerpos and R. C. Holt. Automatic architectual clustering
of software. pages 159–176, 2002.
[21] X. Wang and I. Miyamoto. Generating customized layouts.
In GD ’95: Proceedings of the Symposium on Graph Drawing, pages 504–515. Springer-Verlag, 1996.
[22] C. Ware. Information Visualization: Perception for design.
Interactive Technologies. Moragn Kaufmann, 2000.
[23] D. Watts and S. H. Strogatz. Collective dynamics of ”smallworld” networks. Nature, 393:440–442, 1998.


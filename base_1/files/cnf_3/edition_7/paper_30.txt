Visualization for Management of Electronics Product Composition
Kenichi Iwata, Mariko Sasakura, Susumu Yamasaki
Department of Computer Science,
Graduate School of Natural Science and Technology, Okayama University
{iwa, sasakura, yamasaki}@momo.it.okayama-u.ac.jp
Abstract
There are some systems called Supply Chain Management system or Value Chain Management system that manage production. It is a powerful tool in normal cases, but
in a problem such that some parts are out of stock, it can
solve the problem only by simple solutions, like postponing
shipping of the product. Because it does not have enough
information about production and functions to use the various information. Our research is concerned with a system to
integrate information about production and show a solution
to help users to judge which way is better to solve the problem. We implemented a prototype system. It takes inputs
of some information that were not integrated in one place
in former systems, but distributed among systems, people,
or sections. It shows a solution for a problem making use
of the information integrated in the system. The solution
comes as process of reasoning to help user to judge what
is the best to do in the case. We also implemented the user
interface to show the process of reasoning.

1. Introduction
We already have several commercial systems to support
production in factories. They are called Supply Chain Management system (SCM) or Value Chain Management System. They manage accepting an order, arranging various
parts, composing a production, ensuring the date of delivery
and shipping it to a customer. They reduce inventories, provide productions to market speedy and improve customer’s
satisfaction.
These systems support the best suited production when
everything is going well. However, when a problem is occurred in any place of production process, it will be hard to
judge what is the best solution for the problem.
Now we think about an example. If a kind of parts were
out of stock, how does it solved? The factory can just postpone to compose a product, or they also can use other part
that is compatible with the part. The decision have to be

done by the business policy, but it was almost impossible
and tend to be stuck into a local optimality, because of lack
of information about production for a manager.
In this research, we propose a system to stock and manage information about production, to help judging the best
solution in the production process. We also provide an interface to show the result visually to help users understand the
reason why the system propose the solution as the best one.
We now present a prototype system based on our proposal
in this paper.
Our research is based on reasoning procedure is given
in [14], which follows the notation of [6] in relation to the
ﬁxpoint semantics as in [13] and [16]. We have studied an
application of the reasoning [9]. It assists to choose a way
of parallelizing a program based on knowledge for parallelizing compilers [1].
The construction of a managing system with reference to
PC composition processes is brieﬂy formulated in [15]. The
paper demonstrates abstract structures of its semantics and
visualization. In this paper, we develop a prototype system
based on the structure with another visualization.
In our system, the user interface is important. To let users
judge if the result is reasonable, and choose the best solution
that is suited to the administrative policy, we demonstrate
the process of reasoning as a set of trees.
There are various researches about visualization of trees
[2], [7], [8], [10], [11], [12]. In the system that we describe
in this paper, we use GraphViz [3], [4] to visualize trees.
It is a group of tools implemented by various methods of
visualization. The ﬁgures of a tree we show in this paper
are displayed by ZGRViewer1 .

1 It is developed by Dr. Emmanuel Pietriga.
http://zvtm.sourceforge.net/zgrviewer.html

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

2. Management of Electronics Product Composition

The system has four subsystems which deal with the following information as their databases respectively.

2.1. Aspects of Electronics Production Area
In this paper, we think about the electronics production
area. A speciﬁc characteristic in this area is that semiconductor parts need huge investment to be produced. Therefore, the most of vendors of the parts are big companies,
compared with other area like the car production.
There is a method called “kanban” system [5] in order
to compress inventories, and also reduce the risk to run out
of parts. It is mainly used in the car production area. A car
producer has only few parts stocks, usually just for one or
two days production. Every part comes with a tag called
“kanban”, and when a part is used on a production line, the
kanban is collected. The collected kanbans will be sent to
parts vendors, then they receive kanbans and start producing parts, bringing them to the production line very often to
avoid shortage of parts.
In the area of electronics production, the “kanban” system has difﬁculty to be applied. Because the most of parts
vendors are too big to follow the system.
Therefore when producers compress inventories, they
will have risks of running out of parts. This can be a problem on the production line.

2.2. The Work Flow of the System
Being out of stock of a part results in delay of ﬁnishing products composition. To solve this problem, there are
some solutions at accepting an order, production or shipping.
The ﬁrst solution is to absorb the problem at the accepting an order. It means asking the customer to agree the
delay of the product. If the customer accepts the delay of
the ordered product, the problem will be solved.
Another solution is to absorb it at the production section. When the design of the product is being done, designers make sets of compatible parts for a part. The set
contains some parts which are compatible, such as some
resistors that have the same resistance with different accuracy, memory boards that have various speed memory chips,
and CPUs with different clock-speeds. In a normal case,
the production section uses the “default” part, which is the
cheapest one. When the default part is out of stock, they
can choose another part from the set, usually it is of higher
grade and more expensive than the default part.
Yet another solution is to absorb it at the shipping section. A higher speed shipping way, like express mail, can
solve the delay of production.
In this research, we handle the case of problem that is
out of stock.

• Design information
• Order
• Shipping information
• Inventory information
The design information contains a parts list for a product,
and also information about part compatibility.
The order means what product is ordered.
The shipping information is the number of days and the
cost that are needed to ship a product from the factory to the
customer.
The inventory information is a quantity of every kind of
parts that are stocked in the factory.
The output of the system is a set of solutions for an order.
If there is no problem on producing the ordered product,
the system shows a solution without condition. If there is a
problem, the system shows the candidates for the solution
with conditions which indicate a shortage of parts. A manager who has the responsibility for the product can know the
situation about the production, and judge which solution is
the best suited to the administrative policy. The administrative policy would be like the priority among many candidates such as the cheaper cost, the quicker delivery, and so
on.

2.3. An Example of the System Flow
Our system handles information as a logic program. We
use the way to write a logic program as in [14]. We give an
example in this subsection.

The design information
We think of a personal computer. A PC has some parts
to be built. The following clause states that:
PC ←

board, power supply,
body case, hard drive,
CDROM drive, keyboard, mouse

The each part has some parts to be built.
board ←

bare board, A1 , A2 , chip resistor,
CP U, bus bridge, memory, powerpod,
U SB controller

where A1 is a bypass condenser for a place on a board, and
A2 is a bypass condenser placed for another place on the
board.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

Some parts have a list including more than one part to be
applicable. The top item of the list is the default part. In the
following, the negation sign “∼” is operationally interpreted
as “negation as failure” as studied in [6]
← a21
← a22 , ∼ a21
← a23 , ∼ a22
← a24 , ∼ a23

(1)

A2 ← a22
A2 ← a23 , ∼ a22
A2 ← a24 , ∼ a23

(2)

A1
A1
A1
A1

where a21 ,a22 ,a23 ,a24 are all chip condensers with different
accuracy. The item in a lower place in the list has ﬁner
accuracy and higher price. a21 is the default for A1 , a22 is
the default for A2 .
There must be similar rules for another part. However,
we omit them in this paper.

Order
An order will be placed from the interface shown as Figure 1. It is implemented on the www system. We have a
subsystem to translate the order from the www interface to
a logic program. The order from Figure 1 is represented by
a logic program as follows:
PC ←

SpaceSavingCase, P rocesserA3G,
P C1300256M B, AT A120GB,
CDRW wDV D, W irelessKBM

Inventory information
About inventory information, we have a subsystem that
handles numbers of stocked parts. It returns an answer to a
query from the system. The answer is given like the following.
a21 ←
a22 ←
These are given only for parts in stock. Parts that are out of
stock will not be shown in a list.

Shipping information
We also have a subsystem to handle shipping information. The system sends a query to the subsystem, and receives an answer. The answer is like the following.
Ship a21 ←
Ship a22 ←

Figure 1. An interface to accept an order.

These mean that the product will reach a customer on the
date promised when the customer made an order, even if the
factory waits for a part a21 and a22 . If they cannot send a
product on the date with waiting for a part a23 , the entry for
a23 will not be generated.
When we receive an order for the normal case, that is,
there are enough stock of parts to build an ordered product,
the system just chooses default parts, then outputs an instruction to build a product with the default parts, reserves
shipping and answers the customer the date of delivery.
On the other hand, if there are parts out of stock, it is
another problem. In this case, the system shows candidates
for solutions.

3. How to Visualize a Result of the System
We implement a management system to derive the solution from an order and other information. The system consists of the derivation engine and four subsystems to manage
information. These engine and subsystems are implemented
by Java. Its formal description is brieﬂy described in Section 4. The system has an interface to accept an order, and
has a function to show the result visually. The result will be
shown as a process of reasoning, in a form of a tree.
An example is shown as in Figure 2. Nodes in the ﬁgure
are goals. The ﬁnal goal is the target to be built in a factory.
It is shown as the root node which is placed at the top of
Figure 2. It will be broken in subgoals that are conditions
to make the ﬁnal goal succeeded. The ﬁgure is an overview,
each part of the tree can be magniﬁed to see its detail on
demand.
The system will break the ﬁnal goal to subgoals, then it

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

Figure 2. An overview of a result.

Figure 3. A case succeeded with a default part.

will reach the leaf that cannot be broken anymore. After it
reached the leaf, the system will know if the subtree is succeeded or failed. The white nodes are succeeded goals. The
colored nodes are failed goals. The oval node means that if
the condition written on the node is succeeded, the goal of
the node is also succeeded. Oppositely, the rectangle node
means that if the condition written on the node is failed, the
goal of the node is succeeded.

failed with it, but the other solutions are shown. We can get
the ﬁgure from the following logic program (3) with A2 as
a goal.
A2 ← a21
A2 ← a22 , ∼ a21
A2 ← Ship a21 , ∼ a21
(3)
a22 ←
Ship a21 ←

Now we see small examples in Figures 3, 4 and 5. Figure
3 shows an illustration that the goal is succeeded with a default part a21 . We can get the ﬁgure from the logic program
(1) with A1 as a goal. The root node is white, it indicates
that the goal is succeeded, with the white child node on the
left end.

We can see the result, and know that both of the white child
nodes are possible solutions. The manager can judge which
one is better suited to the administrative policy and choose
one of them. The system will issue an instruction with the
solution the manager chooses.
Figure 5 shows that the all alternative solutions were
failed. We can get the ﬁgure from the logic program (3)

Figure 4 shows that the default part is out of stock and

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

Figure 5. A case failed in all alternative solutions.

Figure 4. A case succeeded with an alternative part or rapid shipping.

except the last two lines. The manager must postpone the
shipping of the product, and ask the customer to be late to
receive the product they ordered basically. But the system
shows that the reason why the derivation was failed. In this
case, a part a21 and a22 are both out of stock, and use a
rapid shipment with waiting for a part a21 is also failed.
Therefore the manager can know what should be ﬁxed to
solve this stuck situation. The manager can ask a part vendor if they can provide the part a21 or a22 . If it is possible,
the manager can input the new condition to the system, and
have a new solution after the system is derived again.

ordering and a database (which is a union of customer’s inventory and shipping information, and
management’s design information).
With the notations in [14] for the normal logic program
and the goal, and with the basic domains:
(i) Database: a set of databases (described by normal
logic programs),
(ii) Goal: a set of goals, and
(iii) 2S : the powerset of sets of negative literals (i.e.
negated atoms),

4. Design and Semantics of Management
we deﬁne the semantic functions as follows:
In this section, we sketch a formal design of management
in terms of semantic functions, with reference to the paper
regarding the normal logic program semantics as in [14].
The management for the order of a customer is interpreted by the (semantic) functions, where:
(a) The customer ordering is captured by the function
Client whose income is for inventory and shipping
information described as a database (by a logic program), and whose outcome is for the acquired knowledge that is a set of candidates for a solution.
(b) The management is regarded as the function
Consultant which gets design information described as a database (by a logic program) from an
operation.

Client : Income → Database,
Client : Outcome → Database → Goal → 2S ,
Consultant : Operation → Database,
Acquisition : Goal → Database → 2S ,
where on condition that we let
Client[[Income]]= P1 ,
Consultant[[Operation]]= P2 ,
we have:
∆ ∈ Client[[Outcome]](P1 ∪ P2 )g
⇔ ∆ ∈ Acquisition[[g]](P1 ∪ P2 ).
Note that we must deﬁne the predicate:

(c) The management implements the function
Acquisition for a query in accordance with the

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

∆ ∈ Acquisition[[g]]P

by means of the relation deﬁnition of [14] iff sucp (g; ∅; ∆),
that is, the goal g induces the set ∆ (by negation as failure)
for a given problem P.
Theorem [14]: If we have the predicate sucp (g; ∅; ∆),
then the reasoning is consistently sound.
As well, a management is made by the semantic function
Acquisition. By the deﬁnition, we have:
P roposition :
∆ ∈ Client[[Outcome]](P1 ∪ P2 )g ⇔ sucP1 ∪P2 (g; ∅; ∆),
where
P1 = Client[[income]],
P2 = Consultant[[Outcome]].
Note that the predicate ∆ ∈ Client[[Outcome]]P g
means the suggestive set ∆ for a program P and a goal g
(in relation to the query).
The set ∆ is the one gained as acquired knowledge by
means of the management for the customer ordering.

5. Concluding Remarks
We show a system that integrates information about production, and help managers to solve problem cases, with
showing candidates for solutions and the process by which
the system derives the solution.
We introduced the system we implemented as a prototype. It contains
• a derivation engine,
• www-type user interface for ordering,
• four subsystems which handle order, design, inventories and shipping information, respectively, and
• a system to visualize the result.
The result is displayed as a tree of process of reasoning.
We show also that the system is useful to help managers
recognizing the situation of problems.
We also show through the system that it is important to
show the process to derive the solution, to help the manager judge which is the best suited solution to their administrative policy. The manager can have a key to solve the
problem to which the system cannot ﬁnd the solution.

[2] G. D. Battista, P. Eades, R. Tamassia, and I. G. Tollis. Graph
Drawing. Prentice Hall, 1999.
[3] J. Ellson, E. Gansner, L. Koutsoﬁos, S. North, and G. Woodhull. Graphviz - open source graph drawing tools. Graph
Drawing. 9th International Symposium, GD 2001. Revised
Papers (Lecture Notes in Computer Science Vol.2265), pages
483–484, 2002.
[4] E. Gansner and S. North. An open graph visualization system and its applications to software engineering. Softw. Pract. Exp., 30(11):1203–1233, 2000.
[5] Japan Management Association, editor. Kanban just-in-time
at Toyota:management begins at the workplace. Productivity Press Inc., 1989.
[6] K.Kunen. Signed data dependencies in logic programs.
Journal of Logic Programming, 7:231–245, 1989.
[7] M. Raitner. HGV: A library for hierarchies, graphs, and
views. GD2002, LNCS 2528, pages 236–243, 2002.
[8] M. Sasakura. Concentric circle diagrams for visualizing a reasoning process on an extended logic program.
PDPTA’02, I:253–259, 2002.
[9] M. Sasakura and S. Yamasaki. An explanation reasoning
procedure applicable to loop transformation in compiler.
Proc. of ACM ESEC/FSE International Workshop on Intelligent Technologies for Software Engineering, WITSE 03,
pages 34–39, 2003.
[10] M. Sasakura and S. Yamasaki. Visualization with hierarchically structured trees for an explanation reasoning system.
Proceedings of Eighth International Conference on Information Visualization(IV04), pages 893–898, 2004.
[11] R. Spence. Information visualization. Addison-Wesley,
2001.
[12] S. Sugiyama and K. Misue. Visualization of structural information: automatic drawing of compound digraphs. IEEE
Transaction on Systems, Man and Cybernetics, 21(4):876–
892, 1991.
[13] A. Van Gelder. The alternating ﬁxpoint of logic programs
with negation. Journal of Computer and System Science,
47:185–221, 1993.
[14] S. Yamasaki. Semantics of normal goals as acquisitors
caused by negation as failure. IEICE Transactions on Information and Systems, E86-D(6):993–1000, 2003.
[15] S. Yamasaki, K. Iwata, and M. Sasakura. Reasoning procedure and implementation for logic programs as managing
schemes to extract demand. IPSI Transactions on Advanced
Research, 1(1):83–90, 2005.
[16] S. Yamasaki and Y. Kurose. A sound and complete procedure for a general logic program in non-ﬂoundering derivations with respect to the 3-valued stable model semantics.
Theoretical Computer Science, 266:489–512, 2001.

References
[1] D. F. Bacon, S. L. Graham, and O. J. Sharp. Compiler transformations for high-performance computing. ACM Computing Survey, 26(4):345–420, 1994.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE


Visualization of Self-stabilizing Distributed Algorithms

LaBRI
ENSEIRB - University of Bordeaux-1
F-33405 Talence Cedex, France
Email: hamid@labri.fr

Abstract
I n this paper, we present a method to build a n homogeneous and interactive visualization of
distributed algorithms using Visidia platform.
approach developed in this work allows t o simulate
transient failures and their correction mechanism. W e
use local computations t o encode self-stabilizing algorithms like the distributed algorithms implemented in
Visidia. The resulting interface is able to select some
processes and incorrectly change their states t o show
the transient failures. The system detects and corrects
these transient failures by applying correction rules.
Many examples of self-stabilizing distributed algorithms
are implemented.

1 Introduction
Distributed computing systems are becoming larger
and larger, heterogeneous and complex. Since the applications running on these systems require the cooperation of many components, they are prone t o failures
and errors of many different types, leading to inconsistent executions. Hence, a desirable feature of a computation in a distributed system is fault-tolerance. A
particularly suitable approach to deal with such a feature is to design self-stabilizing algorithms [ 5 , 14,
Informally, self-stabilizing algorithms ensure that after
any failure, the system will automatically recover t o
reach a correct configuration in a finite time. In general, self-stabilizing algorithms are constructed in such
a way that a given process will continue t o function
correctly in spite of intermittent failures.
Simulation and visualization of the distributed algorithms are very important since their understanding and teaching are complicated. Each execution involves many processes and a large quantity of messages. Animation and visualization of the algorithm

Mohamed Mosbah
LaBRI
ENSEIRB - University of Bordeaux-1
F-33405 Talence Cedex, France
Email: mosbah@labri.fr

makes easier its understanding and its study. In fact,
software visualization systems seem useful for teaching and for software development. However, very few
studies have shown conclusively that they are effective
We will examine in this work the visualization
of self-stabilizing distributed algorithms encoded by local computations.
Local computations
have been introduced
a
suitable and a general model to encode distributed algorithms, to prove their correctness and t o understand
their power. A large family of classical distributed algorithms encoded by graph relabeling systems is given in
Moreover, such algorithms can be implemented in a
unified way on a platform called
11,
It is a tool t o implement, simulate, test and visualize
distributed algorithms. It is motivated by the important theoretical results on the use of graph relabeling
systems to encode distributed algorithms.
In this work, we build the animations of selfstabilizing distributed algorithms encoded by local
computations. The interface developed is based on the
and on the Visidia platform. The
formal framework
graph relabeling system encoding the self-stabilizing
distributed algorithm is implemented by high level
primitives of Visidia. An interface allows the user to
change the state of the processes and t o simulate transient failures. This paper gives a set of techniques to
demonstrate the functionalities of the algorithms, their
behavior under the asynchronous distributed system
model with transient failures.
The paper is organized as follows. The model of distributed system and the model to encode distributed
algorithms are given in Section 2. We present in Section 3 the Visidia platform and the visualization of selfstabilizing algorithms. Section 4 gives an example of
self-stabilizing spanning tree and P I F algorithm. Finally Section 5 concludes the paper.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

2

Preliminaries

2.1 The Model of Distributed System
A distributed system is modeled by a graph G =
where V is the set of nodes and E is the set of
edges. Nodes represent processes and edges represent
bidirectional communication links. Processes communicate and synchronize by sending and receiving messages through the links. There is no assumption about
the relative speed of processes or message transfer delay, the networks are asynchronous. The topology is
unknown and each node communicates only with its
neighbors. The links are reliable and the process can
fail and recover in a finite time. The failures that are
tolerated in such a system are the transient failures of
processes.
The stabilizing algorithms are optimistic, they guarantee a return t o a correct behavior within a finite time
after all faulty behaviors cease. Self-stabilizing algorithms protect against transient failures, since they can
automatically repair any fault in the system. The term
refers to failure. Therefore, this assumption allows
us to give up the use of unreliable failure detectors [8]
or robust algorithms (probabilistic)
and a bound
on the number of failures.

2.2 Graph Relabeling Systems (GRS) to Encode
Distributed Algorithms
Local computations, and particularly graph relabeling
systems are a powerful model which provides general
tools to encode distributed algorithms, to prove their
correctness and t o understand their power. In such a
model we consider a network of processes with arbitrary topology represented as a connected, undirected
graph where vertices denote processes, and edges denote communication links. Every time, each vertex and
each edge is in some particular state and this state will
be encoded by a vertex label or a n edge label. According to its own state arid to the states of its neighbors,
each vertex may decide to realize an elementary computation step. After this step, the states of this vertex, of
its neighbors and of the corresponding edges may have
changed according to some specific computation
Let us recall that graph relabeling systems satisfy the
following requirements:
they do not change the underlying graph but only
the labeling of its components (edges and/or vertices), the final labeling being the result,
they are local, that is, each relabeling changes only
a connected subgraph of a fixed size in the underlying graph,

(C3) they are locally generated, that is, the applicability condition of the relabeling only depends on the
local context of the relabeled subgraph.
Let L be a n alphabet and let G be a graph. We denote by
a graph G with a relabeling function
:
L. A graph relabeling system
is a triple
= ( L ,I , P ) where L is a set of labels, I
is a subset of L called the set of initial labels and P
a finite set of relabeling rules. Consider an arbitrary
system = ( L ,I , P ) and a labeling function A. A
labeling step will be denoted by (G,
(G,
The
notion of computation then corresponds t o the notion
of relabeling sequence. A relabeling sequence will be
denoted by (G,
(G,
use the following
notations:

(i)
(ii)

(iii)

:

the labels of node

: the labels of the edge connecting node
and node

1) : the set of the neighbors of node
For
simplicity, we may also write this set
as we
shall mainly deal with balls of radius 1.

The program is encoded by a graph relabeling system = ( L ,I , P ) . The labels of each process represent
the values of its variables. Each rule in set P is of the
following form:
:

Precondition}{Relabeling}

denotes the number of the rule and
is the
name of the rule. The Precondition part of a rule in
is a boolean expression (predicate)
the program of
involving the labels of and the labels of its neighbors.
The Relabeling part of a rule of
updates one or
more labels of
and its neighbors. A rule can be
executed only if its precondition is true. The rules are
atomically executed, meaning that, the evaluation of
a precondition and the execution of its corresponding
relabeling, if the precondition is true, are done in one
atomic step.

2.3 Self-stabilizing Graph Relabeling Systems
An algorithm is called self-stabilizing if it eventually
starts to behave correctly regardless of its initial configuration
A local configuration of a process is composed by its
state , the states of its neighbors and the states of its
communication links. In this work, we will be interested in local illegitimate configurations
Transient faults cause processes to change their

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

states yielding illegitimate local configurations and
therefore an illegitimate global configuration. A selfstabilizing system will be able t o destroy such a fault
by eventually stabilizing into a correct global configuration without restarting the system. A local stabilizing
graph relabeling system is a triple = ( L ,P ,
where
L is a set of labels, a finite set of relabeling rules and
is a set of illegitimate local configurations
A local stabilizing graph relabeling system must satisfy the
two following properties:

Closure

:

Convergence
A)

if

:

( G ,A)
(G,

then

an integer k ,

:

As for self-stabilizing algorithms, the closure property stipulates the correctness of the relabeling system.
A computation beginning in a correct state remains
correct until the terminal state. The convergence however provides the ability of the relabeling system t o
recover automatically within a finite time (finite sequence of relabeling steps).
If = ( L ,I ,
is a graph relabeling system with
illegitimate configurations
then it can be transformed into an equivalent local stabilizing graph relabeling system
=
The set
is composed of set P and some correction rules t o detect and
eliminate each illegitimate configuration of
The correction rules have higher priority than the rules in P .
Since this paper presents the visualization of selfstabilizing algorithms, we avoid formal and theoretical
definitions which can be found in

3

Visualization of the Self-stabilizing
Systems

3.1 Visidia: A Platform to Visualize Distributed
Algorithms
is an environment which provides a library
with an easy interface to implement and to visualize
distributed algorithms described by means of local
computations. A stage of computation
is carried
out after some synchronization, which can be achieved
by using probabilistic procedures
The processes
are simulated by Java threads. A high level primitives
including the synchronization procedures allows the
user to implement local computations.
There are three types of local computations. The
implementation of these local computation in an

Communications
Simulator

Algorithms

Figure 1. Visidia architecture

asynchronous message passing system is base on the
use of randomized synchronizations. A randomized
synchronization procedure is associated to each type
of local computation given in the following:
there is a rendezvous between
we say that and
vertex and its neighbor
are synchronized. Then v and
exchange messages
and allows the two nodes to change their labels.
(local computation 1): the vertex v is elected in
the star centered on v denoted b,. The computation
is allowed on b,: the center v collects the labels of its
change its label.
neighbors
Computation
the vertex v is elected
in the star centered on v of radius 2 denoted b,. The
computation is allowed on b,: the nodes of b, exchange
their labels; and the center updates its state and the
states of its neighbors.
Visidia is composed of three components (see Figure
1). The graphical interface component GUI to visualize
the execution of the distributed algorithms. The Algorithm component where the distributed algorithms are
executed. The Simulator component which ensures the
visualization of the state of the distributed algorithm
execution on the GUI. To visualize a distributed algorithm encoded by local computations follows the steps:
1. Create a graph modeling the network by using the

GUI,
2. Customize the visual attributes of the nodes which
represent the labels, if necessary,
3. Select the simulation action,

4. Select the distributed algorithm to visualize,

5 . Start the simulation.
This tool can be used to visualize and experiment
distributed algorithms, and therefore helps in their design and their validation. Several distributed algorithms have been already implemented and can be directly animated. The distributed system of Visidia is

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

based on asynchronous message passings. However, it
has been assumed t h a t components of such a system
do not fail.

3.2 The

in Visidia)

In the presence of transients faults, the self-stabilizing
property allows t o tolerate this failure. The user
can simulate the transient fault of a process with
the graphical user interface before the start of the
simulation or during the simulation:

Examples

4

4.1 Computation of a Spanning tree
We start by defining the graph relabeling system
to
encode a self-stabilizing distributed algorithm t o compute a spanning tree. We assume in this system the
existence of a distinguished node which is initially labeled A and which is usually correct.
=
We define the relabeling system
where
=
and
=
Rcl,
such t h a t Rcl,
:

Spanning rule

Precondition :

0 By starting the execution of the algorithm with
a randomized value of the variables of the program
(labels). This is possible because a local stabilizing
graph relabeling system can have arbitrary initial
values.
0 By using the mouse through a graphical user interface, the user can simulate the failure of a process by
selecting a node of the graph representing the network.
the user selects the node in
In Figure 2 , at step
which the transient fault will be introduced. In step
the user opens the view t o change the state of the
( 3 ) changes the state and step (4)
selected node.
validates this operation.

-

-

:

N

3

Relabeling

:

:=A
:= 1

Correction rule 1

Precondition :
-

- 3

N,

Relabeling
-

:= 0

: Correction rule 2

-

3

A,
A,

-

Relabeling
-

0

:

:= 1

4.2

Figure 2. Error introduced by the user to simulate a transient failure

Chang [3] defined the concept of Propagation of
Information with Feedback (PIF) also called waue
To encode the self-stabilizing PIF
propagation[
algorithm by local computations, we use the following system:
=
defined as
=
x
and
=
R2, R3, Rcl,
The state of a node
is determined by the labeling
where
and
The number
k =
is used t o encode the orientation parent-son;
the relation:
parent of
where
denotes

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

the modulo operation allows to encode this relation.
1 to denote
T h e rules Ri with
We use k
{
are the main rules used to code the
P I F algorithm whereas the rules Rcj with j
{
are correction rules. T h e description of t h e set of rules
is given as follows:
1. Main rules:

(a)

Root diffusion
(b) R2: Node diffusion
(c) R3: Node feedback
(d) R4: Root detection of the end of a cycle
(e) R5: Node clean
(f) R6: Root restart a new cycle
2. Correction rilles:

(a) Rcl: Change from state F t o B
(b)

Change from state N t o
Change from state N to F

Figure 3. Error introduced by the user at a
specified node 8

Now, we present an execution of a local
stabilizing PIF algorithm on Visidia. Figure 3 shows
an example where the process of node 8 has been set in
a fault state. In Figure 4, the execution of the correction rule
Figure 5 shows the execution until the
end of the cycle and in Figure 6 we have a new cycle
which starts from an initial graph where all nodes are

Figure 5. Execution until the end of the cycle
(and having an initial graph)

labeled
except t h e root which is labeled A and all
edges are labeled 0.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

131 EJH. Chang. Echo algorithms: (depth) parallel operations on general graphs. I E E E
on Software
1982.
141 B. Derbel and M. Mosbah. Distributing the execution
Sevof a distributed algorithm over a network.
enth International Conference on Information Visualization, I V 2003, London,
pages 485-490. IEEE
Computer Society, 2003.
E.W. Dijkstra. Self stabilizing systems in spite of
distributed control. Communications of the ACM,
1974.

I. Fischer, M. Koch, G. Taentzer, and V.
Distributed graph transformation with application to
design of distributed systems. Handbook of
and computing b y
transformagraph
tion:
3:
parallelism, and distribution, pages 269-340, 1999.

Figure 6. A new cycle which is started from
an initial graph

In this paper, we have presented a powerful method to
build an homogeneous interactive visualization of
stabilizing distributed algorithms. This method will
help t h e s t u d y and the complexity analysis of such algorithms. T h e approach allows t o simulate t h e transient
failures a n d their tolerating mechanism. We use local computations to encode self-stabilizing algorithms
like t h e distributed algorithms implemented in Visidia.
T h e resulting interface is able to select some processes
a n d incorrectly change their s t a t e s to show the transient failures. T h e n , the system detects a n d corrects
these transient failures by applying correction rules.

References
M. Bauderon, Y . Metivier, M. Mosbah, and A.
From local computation t o asynchronous message passing systems. Technical Report RR-1271-02,
- University of Bordeaux 1, 2002.

M. Bauderon and A. Sellami Y .
Mosbah.
systems : 4 tool for encoding, provGraph
ing, studying and visualizing distributed algorithms.
Notes an Theoretical Computer Science, 51,
2001.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

B. Hamid and M. Mosbah. An
approach
to self-stabilization. In 6th A C I S International Conference
Software
Artificial Intelligence, Networking, and
Computing
Baltimore, USA (to appear), May
2005.
B. Hamid
M. Mosbah. An implementation of a
failure detector for local
in graphs. In
of the 23rd I A S T E D International
conference o n
and
computing and
networks, February 2005.
I. Litovsky, Y .
and E. Sopena. Graph
ing systems and distributed algorithms. In World Scientific Pnblishing, editor,
of graph grammars
and
b y graph transformation, volume
Eds. H. Ehrig, H.J. Kreowski, U. Montanari and
G. Rozenberg, pages 1-56, 1999.

M. Mosbah and A. Sellami. Visidia:
the
and
of
rithms. http://www.labri.fr/visidia/.

A tool for
Algo-

M. Mosbah and A. Sellami. Implementation of an enumeration protocol algorithm
local graph
putations. In Elsevier, editor, Second International
and Visual ModWorkshop on Graph
eling Techniques, volume 50 of
Notes in
Theoretical Computer Science, 2001.

Y. Metivier, N. Saheb, and A. Zemmari. Randomized rendezvous. In Birkhauser, editor,
on
mnthernatics and computer science: algorithms, trees,
and probabilities, Trends in mathematics, pages
2000.

J. T . Stasko. The parade environment for
ing parallel program executions: A progress report.
Technical Report GIT-GVU-95-03, Georgia Institute
of Technology, 1995.

G.

Introduction, to distributed
bridge University Press, second edition, 2000.

Cam-


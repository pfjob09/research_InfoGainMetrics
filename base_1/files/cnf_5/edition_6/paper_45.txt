Adaptive Polygonisation of Non-Manifold Implicit Surfaces
R.J. Balsys,
Faculty of Informatics & Communication,
Central Queensland University,
Rockhampton M.C., Qld. 4702. Australia.
K.G. Suffern,
Faculty of Information Technology,
University Technology, Sydney. PO Box 123, Broadway
NSW. 2007 Australia.
{balsys@cqu.edu.au, kevin@it.uts.edu.au}
Abstract
We discuss the polygonisation and rendering of non-manifold implicit surfaces using adaptive octree
subdivision and interval arithmetic for surface exclusion
in octree nodes. We present a new algorithm that
polygonises some surfaces that self intersect, or have
other non-manifold features such as separate sections
that meet at points. Gradient information is used to
resolve ambiguous polygonisations in plotting nodes. A
line-stitching algorithm is discussed that allows for
multiple polygons to be in a plotting node. We illustrate
the algorithm with a number of surfaces that
demonstrate its capabilities and limitations.
.
Keywords--- implicit surfaces, non-manifold,
octrees, intervals, polygonisation, line-stitching.

1. Introduction
An implicit surface S is the zero set of a function

f :

3

{

:S = p

3

}

| f ( p) = 0 . The function f (p)

= f (x, y, z), can be defined by polynomial functions in x,
y, and z, in which case the surface is algebraic, or defined
by arbitrary non-polynomial functions. The surfaces can
also be regular or non-manifold. Regular surfaces are
locally Euclidian everywhere, and therefore everywhere
homomorphic to a 2D disk. Non-manifold surfaces are
not Euclidean everywhere, and include surfaces that self
intersect, or have cusp points where their local curvature
is infinite. The Klein bottle and Steiner’s Roman surface
are famous examples of non-manifold surfaces. A
general reference on implicit surfaces is Bloomenthal’s
book [1].

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE

Algorithms for rendering implicit surfaces must first
locate the surfaces before they can be rendered. The
robustness of the location process is critical because
there may be little or no a priori information about the
location of the surfaces, and implicit surfaces can also
consist of an arbitrary number of disconnected sections.
A number of authors have developed algorithms for
rendering regular implicit surfaces using octree based
adaptive subdivision techniques, starting with
Bloomenthal’s classic paper [2]. This was followed by
algorithms by Suffern [3], [4] [5], Suffern and Fackerell
[6], Schmidt [7] and Balsys and Suffern [8]. These
algorithms start with a user specified search cube that is
recursively subdivided in an octree fashion while the
surface is present in an octant. The subdivision is
stopped when certain flatness criteria for the surface are
met, or some maximum recursion depth is reached. The
result is a series of cubes (called plotting nodes) that
contain the surface, and in which it can be represented
for rendering purposes by a polygon.
The early algorithms used point sampling to detect
the surfaces, a process that is not robust, and can lead to
the algorithms missing parts of the surfaces [3], [4].
Suffern and Fackerell [6] therefore supplemented the
point sampling with interval arithmetic techniques [9][13], to improve the robustness of the detection process.
Since the plotting nodes can be at different depths in the
octree, cracks can appear in the surface between adjacent
nodes at different depths. Bloomenthal [2] and Balsys
and Suffern [8] developed algorithms to fix these cracks.
Non-manifold features can create problems for
polygonisation algorithms, where self-intersections
complicate the polygonisation process, and cusp points
are essentially non-polygonisable. Few papers have been
published on the polygonisation of non-manifold implicit
surfaces. Schmidt [7] discusses adaptive polygonisation
of self-intersecting implicit surfaces. He performs a

tetrahedral volume splitting of any plotting nodes at the
maximum subdivision depth that contain the surface but
have not been unambiguously resolved into a single
polygon. This occurs along the curves of selfintersection.
Bloomenthal and Ferguson [14] provide an
extensive discussion of the polygonisation of nonmanifold implicit surfaces using uniform subdivision of
the search cube to a maximum depth. Again, nodes that
contain the surface, but have not been resolved, are
subdivided into tetrahedra for polygonisation. They
describe a number of problems in doing this, including
finding roots on tetrahedral edges and methods to
disambiguate the resulting lines on tetrahedral faces.
We present here a new algorithm that adaptively
polygonises some surfaces that self intersect, or have
other non-manifold features that occur on plotting cell
faces. Due to the length of the algorithm we do not give
it here but it can be found on the authors web site [15].
Our method uses an octree spatial data structure, interval
arithmetic as an exclusion test for the adaptive
subdivision, and uses the divergence of node vertices and
point sampling to drive the subdivision process. Our
method requires that at most two approximately planar
sections of the surface exist in the plotting node, see
Figure 1.
This involves a new root finding technique to handle
the case where more than one root lies on a plotting node
edge. In this case we use the gradient of the surface at
the vertices of the plotting node to help find the roots.
Our algorithm correctly handles the case in Figure 1(a)
where the surface self intersects, although it doesn’t split
the polygons along the line of self-intersection.
After discussing the subdivision and polygon
reconstruction aspects of the algorithm in the following
two sections, we apply the algorithm to several surfaces
that have been difficult to polygonise in the past. These
include a horned cycloid, the Klein bottle, and
Kummer’s surfaces. We also discuss the limitations of
the algorithm.

2. Adaptive subdivision and polygonisation
We start with a brief review of our self-intersection
adaptive subdivision algorithm. This algorithm is an
adaptation of a similar algorithm in [8] where we specify
a search cube that defines the space in which we search
for the surface, and then render it. This cube is the root
node for the octree based adaptive subdivision algorithm.
We also specify minimum and maximum subdivision
depths, as the minimum depth can be used to force the
subdivision of nodes to a minimum depth, and the
maximum depth is used to stop the subdivision in regions
of extreme curvature. We use the interval extension of
the function to exclude nodes that don’t contain the
surface, as in Suffern and Fackerell [6]. If the surface is
not present in any of the eight sub-nodes of a parent
node, we return; otherwise we check if the minimum
subdivision depth has been reached. If not, we subdivide
until the minimum depth is reached.

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE

Having reached the minimum subdivision depth, we
use a function CreatePolygons which attempts to create
polygons in the node. If a valid polygonisation occurs,
CreatePolygons returns true and the polygons are
returned in a Polygons array. The relative flatness of the
polygons are checked in PolygonFlat using criteria as
given in [2] and [8]. If the polygons pass the flatness test
they are tested for "cracks" and "repaired" if necessary
(see [2] and [8]) using function FixHoles . Finally, the
polygons are inserted into the polygon display list using
an InsertPolygons function.

Figure 1. (a) polygons self intersect in a plotting
node and (b) polygons do not intersect in node, show the
two ways in which two lines on a face can be used to
produce two polygons from vertex points in a node. The
gradient function f is used to disambiguate the two
cases, as discussed in the text.
In CreatePolygons a further subdivision criteria
occurs. The function sign test will fail when there is
more than one root of the function along a plotting node
edge. We assume that there is a maximum of two such
roots along an edge. This will be true only if a maximum
of two sections of the surface occur along the edge of a
plotting node. If more than two roots occur our algorithm
fails to polygonise the surface correctly.
If a plotting node contains two nearly planar sections
of the surface, we return the two polygons.
CreatePolygons uses the node information and the
surface f and gradient g = f information, to return the
polygons. In plotting nodes where the sequence of roots
on the node edges can be polygonised in two ways, we
need criteria to determine the correct outcome. The two
possibilities are that the surface self intersects as in

Figure 1(a) or the surface sections do not intersect, as in
Figure 1(b).
We now discuss the implementation of
CreatePolygons . This constructs the polygons in a
plotting node, and is different from the techniques used
in previous papers [2], [4], [7], [8] and [14]. In
CreatePolygons we have the following information: the
minimum coordinates (x, y, z) of the plotting node and its
width d, the surface function f, and the gradient function
g = f The function returns the number of polygons, if
any, found in the plotting node, and the arrays of points
defining those polygons.
In CreatePolygons we extend the definition of
polygonisable cells given in [6] to include cases where a
surface segment crosses an edge of the face of the
plotting node at most twice and is locally flat as given by
planarity and divergence criteria of Bloomenthal [2]. If
the surface crosses an edge of a plotting node more than
twice, it will fail to polygonise correctly. We come back
to this point later.
Each edge of each face of the plotting node must be
considered in turn. For a particular [face][edge] pair, a
sign and gradient test are performed. These tests are:
Sign Test:
( f a * f b > 0)
Gradient Test:
(1)
( g a g b > 0.9)
Where fa and fb are the values of f at the endpoints a and
b, of the edge being tested, and ga and gb are the
corresponding gradient functions. The value 0.9
corresponds to an angle of about 25° between the
gradient vectors and we have found this gives
satisfactory results.
The following logical expression is then evaluated
for each edge of the face:
Subdivision Test:
(2)
( f a * f b > 0) AND ( g a g b > 0.9)
If the sign and gradient test in Equation (2)
contradict one another along an edge, we consider the
following four possibilities:
(1) No intersection along an edge. This occurs when
the level surface f = 0 does not intersect the edge.
(2) One intersection along the edge. This occurs when
f = 0 lies on the edge.
(3) Two intersections on an edge. This occurs when f
= 0 cuts the edge twice as in Figure 2(a).
(4) More than two intersections along the edge. This
occurs when there are more than 2 roots along the
edge.
Our algorithm handles cases (1)-(3). When zero
intersections are found on the edge there is no
contribution to lines on the face for that edge. How close
can a surface come to making contact with the edge
before we accept that case (2) has occurred? We use a
zero tolerance for this to preserve the topology of the
situation where two parts of a surface closely approach
(but do not touch) a single node face.
In the cases (2) and (3) where we have 1 or 2 roots
on an edge, we wish to find a point C as shown in Figure
2. For the single intersect case we wish to find the point

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE

C which, to within , represents the minimum signed
distance between the intersects in Figure 2(a) before we
consider that the two roots can be replaced by one as in
Figure 2(b).

Figure 2. Cross section of surface f = 0 on a face of the
plotting node. (a) Two intersections on an edge where the sign
and gradient tests do not agree, (b) one intersection on an edge
where the sign and gradient tests do not agree. The + and symbols are the signs of f.

In case (2), we find the single root on an edge with
regula falsi but in case (3) we can’t initially use this
technique to find the two roots because the function
values at the ends of the edge, A and B, have the same
signs. Instead, we use binary interval subdivision,
combined with a constraint based on the magnitude of
the function. The approach is as follows. The function
value f is calculated at a = A, b = B and c = (A + B) / 2
resulting in values f(a), f(b), and f(c) on the edge. The
products f(a)* f(c) and f(b) * f(c) are calculated and if
either is negative we return the point C = c, and 2 as the
number of roots. In this case C is a point in the interval
for which regula falsi will find roots in intervals AC and
CB. If however, | f(c)| < , we have found a double root
of f on the edge at c, so we return C = c and one root of
the function, even if the products indicate otherwise.
If no solution is found, the method iterates a set
number of times. If abs(f(a) * f(c) < abs(f(c) * f(b) the
method iterates with B = c; otherwise it iterates with A =
c. If no root is found within the required number of
iterations, the method returns with C undefined, and the
number of roots set to zero. We used a maximum of 25
iterations with = 1e-9 with satisfactory results.
A number of combinations of lines on a face can
occur when there are two intersections on two edges of a
face. DoubleIntersectsOnEdges is the algorithm that we
use to form lines out of the roots on edges in these cases,
and an example is given in Figure 3 (a). We can
determine which combinations of lines to use with the
dot products of the gradients at the two intersections, and
the other two roots.
A further possibility can occur when the distance
between both roots on both edges becomes less than
some small value . In this case the line of selfintersection of the surface lies on the face of the plotting
node, as shown in Figure 3 (b). Such lines belong to two
polygons in the plotting node and so two corresponding
lines are put into an array for the polygon stitching
routine.
We also have to deal with a number of other special
cases. The possibility exists that the surface passes
exactly through one or more plotting node vertices. This

situation complicates the correct polygonisation of the
node. In this case f(A) * f(B) = 0.0 for a edge, and we
count the number of zero vertices on a face. If there is
more than one such vertex, we call a function
L i n e O n F a c e A n d E d g e , as shown in Figure 3 (c).
Otherwise, if we have a face that has two edge roots
found with the sign and gradient test, we call
DoubleIntersectsOnEdge. Finally we have the possibility
of a single line on the face, as in Figure 3 (d), and we call
LineOnFace . In these functions the points found on the
edges of the face are used to form lines on the face,
which in turn become the segments of the polygon in the
plotting node.

(a)

(b)

(c)

(d)

3. Polygonisation by Line Stitching
The procedure used here is similar to that described
in [9], but in this work two arrays line and nonManLine
hold line values. The StitchPolygon function creates a
polygon at a time by joining lines when they have exact
matching end coordinates. A polygon is complete when
we add a line to the polygon line list that has the same
start and end coordinates as the start and end coordinates
of the polygon list being constructed.
The most common case that StitchPolygon has to
deal with is a single polygon in the plotting node. The
next most common case is where there are two polygons,
as in Figure 1. In this case, StitchPolygon returns the two
polygons, whether they intersect, as in part (a), or don’t
intersect, as in part (b). Specifically, we currently don’t
find the line of intersection and split the polygons along
this line, because this would further complicate the
already complex StitchPolygon code. As it turns out, a
lot of the interesting self-intersecting surfaces have
curves of self-intersection in the coordinate planes, and
can therefore be handled by the situation illustrated in
Figure 3.

Figure 3. Combinations of lines on faces. (a) 2 lines with
intersects on two edges, (b) 2 lines within of each other on
face, (c) line on face with endpoints on vertex and (d) single
line on face.

In functions LineOnFace, LineOnFaceAndEdge, and
DoubleIntersectsOnEdge, edges that are shared by two
polygons are placed in a nonManLine array, whereas
those that only occur in only a single polygon are placed
in a line array. The arrays nonManPlane and plane are
used to store the face numbers of the lines in the
nonManLine and line arrays. The total numbers of lines
in the n o n M a n L i n e and line arrays are stored in
numNonManLines and numLines variables respectively.
When all faces of the plotting node have been
treated in this manner we end up with two arrays, line
and nonManLine, that hold coordinates for the lines on
the faces, and corresponding arrays that hold the face
numbers. The face number is used in the FixHoles
function and polygon outline functions as discussed in
[8]. The following section details how we use the
information in these variables to create polygons in the
plotting node.
The above criteria, although extensive in the number
of special cases, produce good results when used to
polygonise self-intersecting surfaces and surfaces with
cusp points and infinitely thin sections, such as
Kummer’s surface (Figure 5), the cyclide surface (Figure
6), the the Klein Bottle (Figure 7), and Steiner’s surface
(Figure 8).

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE

Figure 4. Two polygons intersect along the black
line on the top face of plotting node. The + and – are the
signs of f=0 at plotting node vertices.
When we have two polygons in the plotting node we
use a line in the line array as the starting point, and then
iteratively process the rest of the lines in the array. In
each iteration we test both end coordinates of the line to
see if they join to the start or the end of the polygon point
values. In some cases this requires that we swap the end
coordinates of the line so that a match can be made. The
tests need to be defined to within some > 0. We use an
that’s within 1/1000th of the length of the plotting node
size to maintain a constant precision with respect to the
size of the node being polygonised. When a match is
found, the line’s coordinates are removed from the line
array. If a match can’t be found, the line is left in the line
array, and all the other lines are checked in turn.
After a match is found from the line array, we check
the lines in the nonManLine array, provided it’s not
empty, to see if a match that closes the polygon list can
be found. See Figure 4. Since the black line on the face is

shared by two polygons in the plotting node, two
versions of the line are kept in the nonManLine array.
Polygonisation starts with any of the non-shared edges in
the plotting node. Successive lines are joined by
matching end coordinates until the point is reached when
the black line from the nonManLine array joins the start
to the end of the polygon. At the end of this sample
process the nonManLine array has one less line in it and
the line array has two or more fewer lines in it. In Figure
4 a new polygon defined by a sequence of four points is
created in the process.

4. Surface Examples
In this section we use a number of example surfaces
to illustrate our algorithm’s capabilites and limitations
for polygonising surfaces with non-manifold features.
All polygon rendering is performed with the painter’s
algorithm.
The first example is Kummer’s large family of
quartic surfaces [16]. These are given by the algebraic
equation

(x2 + y2 + z2
=

2
u2 2

)

3u 2 1

pqrs = 0

(

(

2

)(

) ( )(
f 2 ) + 8afrx + ( a 2

(

)

x2 + y2 + z2 r2
2 y2 z2 a2

2 x2 + r2 f 2 + a2
f2

)

2

)
= 0.

(4)

When a = 10, r = 2, and f = 2, we have a horned
cycloid that becomes infinitely thin at a point. As Figure
6 (a) shows, our previous algorithm [8] had difficulty
polygonising the surface near this point. But as the
results in Figure 6 (b) show, our current algorithm can
correctly render this part of the surface, at least to the
pixel resolution of the image. There are two reasons why
the polygonisation works in this case. The first is that the
horns meet at a plotting node vertex, and second is that
the thin sections lie along plotting node edges. See the
discussion below on Steiner’s Roman surface.
The Klein bottle surface, which can be expressed
implicitly as

f ( x, y,z ) = x 2 + y 2 + z 2 + 2y 1

(x2 + y2 + z2

)

2y 1

2

(6)
f ( x, y, z ) = x 2 y 2 + y 2 z 2 + x 2 z 2 + xyz = 0,
in Figure 7, we found that in some plotting nodes one
line remains in the nonManLine or line arrays after the
final complete polygon was found. These nodes had a
coordinate axis along an edge, and the extra lines were
caused by the double lines along x = 0, y = 0, z = 0. As a
result, we allow for the creation of degenerate polygons
in our algorithm. Such polygons have one edge and no
area but are still rendered.

(3)

, p , q , r , and s are the tetrahedral
3 u2
coordinates:
p=
z
2x ,
q=
z + 2x ,
is like
r = + z + 2y , s = + z
2 y . In addition,
a scaling parameter which we take to be unity. The
parameter u > 0 controls the number of double points for
the surface. These are singular points where separate
parts of the surfaces meet. Figure 5 shows two Kummer
surfaces with different numbers of singular points. These
surfaces have been difficult to render with previous
polygonisation algorithms, but as Figure 5 illustrates, our
current algorithm is able to successfully render the
surfaces near the singular points.
Another family of surfaces that can have nonmanifold features are the cycloids [17], given by
where

self intersects. Figure 7 (a) shows the outside of this
surface and Figure 7 (b) shows a cross section to reveal
its inner structure. Our algorithm correctly renders this
surface along the curve of self-intersection because it lies
in the (x, y) plane. This results in the two polygons in the
plotting nodes intersecting in the node faces, as in Figure
4.
When we rendered Steiner’s Roman surface,

8z 2 +

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE

Figure 8. Steiner’s Roman surface (6) showing the 3
double lines (clipped to the view volume) along the
Cartesian axes.
This approach allows us to render the three double
lines of Steiner’s surface. However, we note that these
lines are only detected because they lie along edges of
plotting nodes. Although these lines go to infinity, they
are clipped to the view volume in Figure 8. Sederburg
and Zundel's [18] scan-line algorithm also found and
rendered these double lines.
Steiner’s surface also self intersects along the
coordinate axes, which allows us to correctly render this
surface along these lines. The polygons again intersect
along plotting node edges.
Because of the self-intersections along the
coordinate axes, the curved outer section becomes cusplike as it crosses the axes. This creates the jagged
appearance at the top of the surface in Figure 8.
Although this isn’t particularly accurate or attractive, our
algorithm has still rendered Steiner’s surface as a closed
surface.

5. Summary and Future Work

[2]

In this work we make the following contributions to
the polygonisation and rendering of non-manifold
implicit surfaces with adaptive subdivision.
• A new subdivision criteria for adaptive
polygonisation based on a combination of function
values at node vertices and the divergence of the
gradients of the surface at node vertices.
• A polygon stitching algorithm that can be used when
up to two surface sections are in a plotting node.
• A method for calculating function roots along edges
of a plotting node when two function zeroes occur
along the edge.
The above algorithm can also handle cases where
function zeroes lie on one or more plotting node vertices.
Using the algorithm, we have been able to
successfully polygonise and render a number of nonmanifold surfaces that have been difficult to render with
previous polygonisation algorithms.
The algorithm needs to be extended to split the
intersecting polygons in Figure 1 (a) into four polygons.
This would allow the painter’s algorithm to correctly
render surfaces that self intersect along arbitrary curves.
It would also be useful to extend the algorithm so
that it could correctly polygonise the more general case
of rendering self-intersections where the lines of selfintersection lie inside the plotting node itself. (Isn’t this
the same as the previous paragraph?) Finally it would
also be useful to extend the algorithm so that it could
correctly polygonise C° surfaces where ridges lie inside
the plotting nodes. It can currently only do this when a
ridge coincides with plotting node faces or edges.

[3]

[4]

[5]

[6]

[7]

[8]

[9]
[10]
[11]
[12]
[13]

[14]

Acknowledgements

[15]

The authors will like to acknowledge the support
given by their respective universities of this work.

[16]
[17]

References
[1]

Bloomenthal, J. (Ed.) 1997. Introduction to Implicit
Surfaces. Morgan Kaufmann Publishers.

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE

[18]

Bloomenthal J. Polygonization of Implicit Surfaces.
Computer Aided Geometric Design 1998; 5: 341-355.
Suffern KG. An Octree Algorithm for Displaying
Implicitly Defined Mathematical Functions. School of
Computing Sciences, University of Technology, Sydney,
Technical Report 87.9, 1987.
Suffern KG. Recursive Space Subdivision Techniques
for Displaying Implicitly Defined Surfaces. In
Proceedings of the Ausgraph 89 Conference 1989, pp.
239-249.
Suffern KG. An Octree Algorithm for Displaying
Implicitly Defined Mathematical Functions. The
Australian Computer Journal 1990; 22: 2-10.
Suffern KG, Fackerell ED. Interval Methods in
Computer Graphics. Computers & Graphics 1991; 15:
331-340.
Schmidt MFW. Cutting cubes – visualizing implicit
surfaces by adaptive polygonization. The Visual
Computer 1990; 10: 101-115.
Balsys RJ, Suffern KG, Visualisation of implicit
surfaces, Computers & Graphics, Vol. 25, No. 1, pp 89107, 2001.
Moore RE. Interval Analysis. New Jersey: Prentice-Hall,
1966.
Ratschek H, Rokne J. Computer Methods for the Range
of Functions. Ellis Horwood, 1984.
Ratschek H, Rokne J. New Computer Methods for Global
Optimization. Ellis Horwood, 1988.
Synder JM. Generative Modelling for Computer
Graphics and CAD. Boston: Academic
Press, 1992.
Comba J. L. D., Stolfi, J., Affine arithmetic and its
applications to computer graphics. Proceedings of
SIBGRAPI'93, pp. 9-18, Oct. 1993.
Bloomenthal J., Ferguson, K., Polygonization of NonManifold Surfaces. Research Rep. 95-541-10, Dept.
Computer Science, The University of Calgary, June
1994.
http://www.infocom.cqu.EDU.AU/Staff/Ron_Balsys/Pub
lications/balsysCGIV05.pdf. Full version of paper.
Hudson, R.W.H., 1990. Kummer's Quartic Surface.
Cambridge University Press.
Chandru V, Dutta D, Hoffmann CM. On the geometry of
Dupin cyclides. The Visual Computer, 1989; 5: 277-290.
Sederberg TW, Zundel AK. Scan Line Display of
Algebraic Surfaces. In Proceedings of the SIGGRAPH
'89 Conference, 31 Jul. - 4 Aug. 1989, pp. 147-156.

(a)
(b)
Figure 5. Kummer sufaces (a) = 2/3, = 1 depth = 8, cutaway by plotting node to reveal inner detail, 4 double points,
(b) = 2 , = 1, maximum plot depth = 9, 15 double points.

(a)

(b)

Figure 6. The cyclide surface (4) with a = 10, r = 2 and f = 2. (a) Previous work [8]. (b) Current work.

(a)

Figure 7. (a) Klein bottle (5) surface, (b) cross-section.

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE

(b)


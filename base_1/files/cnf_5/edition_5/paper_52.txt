Variants of a New Volumetric Model for Dust Cloud Representation
and Their Comparison to Existing Methods
David N. Carr, Jim Geyer
Centre for Research in Complex Systems, Charles Sturt University
{dcarr@csu.edu.au}
Abstract
To date, the techniques used in most real-time
graphics applications (eg. computer games) for
modelling and representing dust clouds, centre around
the use of flat, pre-drawn sprites, layered onto the screen
as ‘billboards’. While this can produce an adequate
effect, it is not a very realistic representation. This paper
presents a new method, based on an octree spacepartitioning scheme for fast and memory-efficient
storage of volumetric data. This approach differs from
the billboards-based methods previously used, in that it
attempts to properly represent the three-dimensional
volume of the cloud. Two variants are presented, that
differ in the algorithm used to construct the volumetric
representation. Models visualising the dust cloud created
by a fast travelling vehicle, are implemented and
compared with the existing real-time methods.
Keywords--- Computer graphics, visualization,
dust clouds, computational modelling.

the technique of ‘billboards’ [3], in which multiples of
flat two-dimensional images are arranged to represent the
appearance of a cloud. The exact positioning and
animation of the billboards is often handled by a particle
system [4]. This kind of system is attractive because of
its very low computational cost, but its qualitative visual
results are ultimately only a representive treatment of the
appearance and behaviour of a dust cloud. The new
model presented takes a different approach by providing
a volumetric representation of the space occupied by the
body of the dust cloud. It uses an octree scheme, that
partitions space into volumetric units, while still
featuring a low computational cost.
Two variants of the octree model are presented that
employ different partitioning algorithms: the first uses a
process of recursion to produce a voxelization of space
and generate the rendering data, while the second
employs an algorithm based on the principle of searching
in an octree.

2. Modelling methods
1. Introduction

2.1. Particle systems

Billowing clouds of dust are a ubiquitous effect in
many scenes featuring outdoor environments, be they
thrown up by vehicles moving on unsealed ground
surfaces, creatures stampeding, impacts from falling
bodies and objects, blasts of air and explosions, and
many other causes of impulse. As computers and their
graphics hardware have become increasingly powerful,
the trend has been to simulate many real-life phenomena
as closely as possible. To date, clouds of dust have not
been simulated accurately or rendered realistically in
real-time computer applications, such as games and
simulation software; and there are few published
modelling and simulation techniques for realistic dust
behaviour [2].
This paper describes a novel modelling and
representation method that is useful for representing the
body of a dust cloud generated by a moving vehicle on
an unpaved surface, for use in real-time applications such
as computer games and interactive simulation. The
previous state of the art [1] is predominantly based on

Both of the methods discussed – billboards and the
new octree space-partitioning scheme – are based on or
incorporate computational particle systems.
The particle systems modelling technique was first
introduced to computer graphics in 1983 by William
Reeves [2]. They are useful in modelling ‘fuzzy’ objects
– dynamic phenomena that are irregular or ill-defined,
such as dust, smoke, water spray, fire, or clouds [4].
Particle systems model dynamic objects as a cloud
of particle primitives. A particle’s set of attributes may
include location (x, y, z) and orientation in 3D space;
current velocity (speed and direction); colour (RGB) and
transparency (alpha); size and shape; mass; and age or
lifetime value.
Particles may be generated into a particle system
from one or more emitter objects. To compute each
frame in a simulation sequence, the following actions are
performed [1]-[4]:
1. The parameters or range of activities of the
emitter(s) are updated according to a rule base

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

(changing position, and/or rules of how many
particles to create and the range of velocity
values with which to initialise them);
2. For each emitter, new particles are generated
and initialised according to the emitter’s rules;
3. Any particles that have existed beyond their
prescribed lifetime (or other criteria, e.g. out of
bounds) are removed;
4. The remaining particles have their parameters
updated according to a rule base (individual
particles have their positions updated according
to their respective velocities, their age values
incremented, and may have other attributes
changed as well);
5. An image of the particle system is rendered.
In the context of the dust clouds being generated by
a fast moving car, the particle system used has its
emitters matched to the locations of the car’s wheels.
The rate at which new particles are created is varied with
the car’s speed. Each particle’s starting velocity is
generated randomly from a range of values scaled
proportionately to the speed of the car.

2.2. Billboards
In 3D computer graphics applications, a billboard
object is one that is rotated to always face the camera
(the user's viewpoint) when rendering. They are typically
used to display a 2-dimensional image texture-mapped to
a rectangular polygon, rotated to always face the viewer.
Billboards have long been used in real-time graphics
applications and computer games as a fast and simple
means of rendering visual effects that would be too
complex using other methods – including clouds of dust
or smoke. For example, while a computational particle
system can provide a ‘natural’ match for simulating the
behaviours of individual particles of a dust cloud,
replicating the numbers of particles involved in the
reality is not feasible; therefore, billboards may be used
to create the appearance of a cloud that is more than the
sum of the number of computational particles. The
typical approach is to use a pre-drawn image
representing a ‘puff’ or small cloud of dust for each
billboard, making use of translucency and transparency
(through alpha-blending) for realism. Multiples of these
billboards can then be scaled and arranged into a variety
of configurations, to produce clouds of any size and
shape that also move and change over time. The
billboarded model presented here uses such a particle
system, where the particles define the positions and
movement of individual billboards.
In a system such as this, the visual results often
exhibit a common group of flaws. The appearance can
look contrived due to recognizable self-similarity
between individual billboard ‘puffs’. Refinements can
improve on this – such as having a set of several textures
to make an animation sequence of a dispersing puff, and
then using multiple varied animation sequences across
the billboards that make up a cloud – but it is very hard

to adequately disguise in all the situations that may arise
in a game or simulation.
This problem is exacerbated when the polygonal
billboards intersect with other polygon surfaces (such as
the ground or an object within the cloud): this causes
occlusion and ‘cutting-off’ of the polygons where they
intersect [8]. For a puff of dust or smoke, we find the soft
and blended shape suddenly has a line cutting through it
and creating a sharp edge, which emphasises the
individual billboards further and reduces the sense of
depth and volume in the cloud.

2.3. Volumetric representations and octree
space-partitioning
In volumetric representations the “unit of currency”
is the volume element or voxel. A voxel can be viewed
as the three-dimensional equivalent to the 2D pixel
(picture element); where a pixel represents a unit square
on the 2D computer screen surface, a voxel represents a
unit cube in 3D space. To represent a 3D object, we
construct a three-dimensional grid of these cubes and fill
in (colour) the ones corresponding to the object, leaving
the rest empty (transparent). Thus voxels differ from the
other approach of modelling 3D objects – polygons – as
they represent the volume the object fills, whereas
polygonal methods represent surfaces.
Voxels provide a number of advantages over
polygons in that much more detail is generally possible
without greatly increasing the amount of processing
power needed for rendering. The simplest way to store a
grid of voxels in computer memory is as a threedimensional array known as a volume buffer, but this
does require a great deal ( O(n3) ) of memory [5].

Figure 1 Multiple partitioning of threedimensional space in an octree
Octree space-partitioning [6] is a means of
representing volumetric data in a more memory-efficient
way. Given a 3-dimensional volume, an octree
subdivides along the three axes to produce eight cubes;
any or all of those cubes may themselves be subdivided
into a further eight cubes, and so on down to the required
depth of the tree or final size of the voxels [7] (Figure 1).

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

Represented as a tree diagram with a singular root node,
each node in the tree can have up to eight children (hence
the term octree). Because an octree structure only
describes those voxels that make up the shape we are
interested in, they are very space efficient when most of
the volume space remains empty [6].

3. Model implementation and evaluation
The application developed allows the user to drive a
virtual car around a flat terrain, and see the results of a
dust cloud being formed and dispersing in response.
Models were implemented using C++ with the DirectX 9
API for high-performance graphics [9].
Models were compared both on aesthetic grounds,
and on the performance of the application employing
them to render an interactive scene. Performance was
measured by a count of the number of frames drawn per
second (FPS), where one frame encompasses a complete
application cycle of getting user input, updating the
simulation state and rendering. Data (collated in section
4) were recorded on a Windows XP PC with an Intel
Pentium 4 2.0GHz CPU, 512 MB of RAM and an
NVIDIA GeForce4-based graphics card.

3.1. Established modelling method - billboards
The billboard model implements the techniques
currently widely used in games and other applications.
The model is based on a basic particle system; as the
vehicle moves, particles are ejected from around its
wheels with randomly generated (small) velocities. This
makes the particle cloud gradually spread and expand
behind the car. For rendering a frame, a process iterates
through the particles and prepares data to draw a textured
billboard (each representing a ‘puff’ of dust) at the
location of each particle.
In rendering, the 3D scene data is computed to draw
each object in pixels. Modern graphics APIs employ Zbuffering to ensure that far objects are not drawn over
the top of nearer ones already rendered, which would
obviously produce a graphical error. Because the
billboards used for dust are transparent/translucent, care
must be taken to avoid artefacts (visual errors) being
created due to the Z-buffering. A solution is to sort the
billboards so that they are always rendered in order from
farthest to nearest: this is known as depth-sorting. The
model implemented here used a quicksort algorithm
(taken from [10]) to swiftly sort the billboards into the
required far-to-near order.

3.2. New modelling method – octree spacepartitioning
The two variants of this model also each employ a
particle system to model the underlying behaviour of the
dust cloud. Additionally, billboards were also used in the
rendering, although this was as a matter of convenience
to simplify development and not intended as a feature of
a finalised system.

Figure 2 Representation of a dust cloud using
the octree space-partitioning model
The difference in philosophy of this model with the
one previously described, is in the way this model
represents the shape and volume of the dust cloud. Here,
an octree space-partioning scheme is used to describe the
volume of the cloud and define the positions and manner
for billboards to be rendered.
The octree space-partitioning scheme encompasses
the entire virtual world simulation space in its a
stationary framework. As particles representing a dust
cloud drift about in this world, the partitioning scheme
‘captures’ them into voxels that represent a localised
volume of dust cloud; the octree dynamically rebuilds as
the particles move on each update processing cycle, so
that the voxelisation approximates the current volume
occupied by the cloud. This volumetric approximation is
then rendered; this is as opposed to the previous model
that rendered by the positions of individual particles.
Each voxel stores an opacity value, which is used in
rendering to modify the translucency of the rendered
volume. The opacity is set according to the age of the
particle captured within it: ‘young’ particles giving a
moderate translucency, and becoming more and more
transparent until the point where particles that have
ended their lifespans are removed from the system.
As the octree produces cubes at each subdivision
that are half the dimensions of the 'parent' cube
partitioned, we can conveniently create voxels of varying
sizes (Figure 2). Starting from the voxels at the deepest
level of the tree (which are the smallest and all of
uniform size), we can also create larger voxels (whose
dimensions are 2, 4, 8… etc. multiples of the smallest
voxels) by assigning progressively further up the tree.
This was used in these models to represent the expansion
of the dust cloud over time: as particles age, they are
approximated by progressively larger voxels. Together
with the opacity control previously described, these give
the impression of the dust cloud dispersing.
The two variant algorithms that build up the octree
representation are described in the following sections.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

3.3 Variant 1 – recursive construction
In this method, the octree is constructed over a
sequence of recursive processes.
1. Firstly, a list of all the active particles in the
system is created, and the root node (which
encompasses the entire simulation space) is
selected for subdivision.
2. The space enclosed by the selected node is
subdivided into eight cubes. Each cube is stores
a list to be filled with the particles within it.
3. Each particle in the ‘parent’ list is considered in
turn; its coordinates will place it into one of the
eight cubes created. The particle’s age is tested,
and if it is the ‘right’ age for this level of the
subdivision (or we are at the bottommost level),
then a voxel is assigned, with an opacity value
calculated from the particle’s age. Otherwise,
the particle is copied into the list associated
with the cube it is found to be in.
4. Each of the cubes is now considered in turn. If
the cube’s list contains no particles, it is
ignored. If the list does contain particles, then
the cube is selected as the current node, and the
cycle returns to step 2.
Coded as a recursive function, this process will
traverse a single path down the levels of the tree,
operating on smaller and smaller lists of particles. When
the depth limit is reached or there are no more particles
left in the list, it will return to the previous node in the
line that still has particles to investigate, and then branch
off from there; again tracing a path down until the depth
limit has been reached or the list of particles is
exhausted. Then it will return upwards and branch off
again, and so on until leaf nodes have been allocated for
all particles and the entire tree is filled in.

3.4 Variant 2 – search-principle construction
Octrees have the interesting property that the
position where an object belongs in the tree can be
inferred from its coordinate location in the world, and
vice versa [6]. This allows fast searching of the octree.

Figure 3 shows the correspondence between the data
structure in memory (left) and its representation in threedimensional space (right). Concatenating the bits of the
coordinates shown in the table gives the indices used to
traverse the tree and to find the searched voxel.
This property was implemented for the construction
process in a second version of the octree model.
1. A list of active particles is prepared.
2. Each particle in the list is processed; its
coordinate values (and age) are inspected to
determine precisely where in the octree the
particle should go. If the required path does not
yet exist in the tree, nodes are added as
necessary to create it. With the path in place, a
leaf node (voxel) is assigned, and an opacity
value is stored relative to the age of the particle.
Using this method, the octree can be constructed by
a single pass of the particle list, rather than multiple
passes through various lists at each node.

3.5 Octree rendering
To render the dust cloud we need to render the
voxels describing it. As a compromise toward simplicity,
the individual voxels were rendered using a billboard
rather than a six-faceted cube [5]. Whereas the texture
used for the billboards model represents a spherical puff,
and is shadowed and somewhat detailed, the texture used
for this model is plainer: a coloured and smoothly faded
circle. The opacity of the billboards is varied so that the
expanding cloud also appears to fade away and disperse.
The billboards are prepared in a list, and then the list
is rendered. In the model employing the recursive
construction algorithm, this list can be prepared during
the octree construction process, since the construction
process conveniently performs a complete traversal of
the tree, visiting each node exactly once. In the
alternative search-principle construction algorithm, the
construction process works across the entire tree to
process the particles, meaning some nodes may be
traversed more than once. Therefore, we perform a
separate full traversal of the octree after construction is
completed, to build up the billboard list.

4. Results
4.1. Billboard-based model

Figure 3 Principle to seach a given voxel in an
octree (Image from [6].)

The visual results of this implementation (Figure 4)
are consistent with what can be seen in games that
employ this type of system. When rendered at the
particle locations, the arrangement and overlapping of
the textured billboards (generally) gives the impression
of a single voluminous cloud, and the movement of the
particles makes the individual ‘puff’ elements drift and
disperse over time. The cloud animates more-or-less
appropriately, albeit not entirely convincingly. The
layering of the puffball texture goes some way to
resembling the self-similar detail in a real dust cloud.
Specific to this implementation, only one texture was

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

used for of all the billboards. This leads to an appearance
of static sameness to the cloud, and a lack of dynamism.
The model exhibits the same sorts of general flaws
inherent with implementations of billboard cloud effects.
As the vehicle increases in speed, the billboard puffs
start to become strung out over greater and greater
distance. This starts to make them become very obvious
as individual puffs, and at high car speed the appearance
of a single voluminous cloud breaks down. The image
also strongly demonstrates the occlusion effect with
billboards intersecting the ground surface, which makes
the puffs appear very two-dimensional.
In terms of computational load, the billboard dust
system is very lightweight. The factor that has the
biggest effect on the frame rate of the application (Figure
5) is the rendering process itself, indicating that the
model is fast to compute, and any bottleneck is occurring
first on the video card.

Figure 4 Visual appearance of a dust cloud in
the billboards-based model

4.2. Octree-based model
The octree-based model (Figure 6) similarly only
uses one texture on the billboards representing its voxels.
Overall, the visual appearance of the cloud is good, but
still falls short of a truly realistic representation.
However, despite the added complexity of the
partitioning scheme, both variants of the model are still
quite fast on consumer hardware; general performance
data is given in Figure 7. The graph shows the more
straightforward recursive construction process is faster
than the search-principle alternative, although both are
still fast enough for real-time.
Use of voxels creates a good (truly volumetric)
representation of a cloud. It successfully addresses some
of the issues identified with billboard rendering. The
regular spacing and order of the voxelisation greatly
limits the manifestation of gaps in the cloud that
occurred in the billboard model, and does so using far
fewer billboards than the ‘plain’ billboarding model
would need. Occlusion of billboards with the ground
surface is also reduced; however, occlusion problems
could still occur with objects within the cloud. Selfsimilarity of billboards is also still somewhat evident,
although reduced mainly because the texture used is
plain and deliberately vague.
The model does not animate well, however: because
the voxels are at discrete locations in the world space,
however, there tends to be a lot of ‘popping’ from one
cell to another, instead of the smooth motion we would
see in real life. This is most noticeable with the larger
voxels; fortunately these are usually at the end of the
cloud ‘train’, farthest from the vehicle, so their jerking
motion is usually no more distracting than the little
jumps of the small voxels immediately behind the
vehicle. The fact remains however, that the model is
lacking in this respect for interactive graphics.

Figure 5 Performance of the billboard model

Figure 6 Visual appearance of a dust cloud in
the octree space-partitioning model

Figure 7 Performance of the octree model(s)

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006

5. Discussion

References

The basic billboards-based dust cloud system utilises
only one texture for the billboards. This creates a static
self-similar appearance; a more polished version could
employ animation of multiple different shapes and
colours, or dynamically generated noise [11], for
variance. Regardless, it demonstrates the common
effects, advantages and drawbacks.
With the volumetric model described, an attempt
was made to sever the reliance on the positions and
movement of individual particles forming the cloud,
instead representing the cloud as a volume. The octree
models combine a memory-efficient volumetric
representation technique with the particle system
approach for fast computation of the movement of the
cloud; however, the use of billboards in the rendering
process of this model was a necessary evil and imposes
inescapable limitations. Although the ordering of the
voxelisation helps limit the appearance of gaps and
occlusion in the billboard ‘cloud’, future work should
focus on devising an altogether different and improved
rendering technique. The discrete voxel representation of
the space occupied by the cloud would allow more
information about its structure to be inferred, which
offers great potential for further development to employ
lighting, shadowing, detail and fluid flow techniques
(e.g. [12], [13]), possibly also using noise [11]. The
problem of the clunky animation could be solved by
storing the volumetric structure from frame to frame, and
interpolating or cross-fading [14] between frames.
All of the models presented use weighted
randomness as the basis of the particle system
simulation. This is not realistic, but they still obtain
adequate results; and the use of the particle system
makes it easy to modify the overall behaviour of the
model just by adjusting the rule base for the particles.

[1]

Conclusions

[11]

Billboard systems are a popular method for
displaying complex phenomena such as these dust clouds
because they are easy to implement and impose little
computational overhead. However, the visual problems
of occlusion, gaps in groups meant to represent a
coherent cloud, and recognisable self-similarities, are
difficult to avoid.
Our alternative modelling approach, based on
voxelisation and octree space-partitioning, provides
efficient volumetric representation of a cloud, which runs
in real-time. Two variants were presented, implementing
alternative construction algorithms, and the faster of the
two identified. The new model removes most of the
visual flaws that occur in most billboard particle systems.

[2]

[3]

[4]

[5]

[6]
[7]

[8]

[9]

[10]

[12]

[13]

[14]

D. N. Carr, “Simulation and Representation of Dust
Clouds for use in Real-Time Computer Graphics
Applications” (Honours thesis, Charles Sturt University),
2004.
J. X. Chen, X. Fu, and E. J. Wegman, “Real-Time
Simulation of Dust Behaviour Generated by a Fast
Travelling Vehicle,” in ACM Transactions on Modeling
and Computer Simulation, Vol. 9, No. 2, 1999, pp. 81–
104.
I. Kayne, “DirectX 9 Tutorial Series”, from 32bits.co.uk
– Coding for real people!, http://www.32bits.co.uk/
modules.php?name=Content&pa=list_pages_categories
&cid=4 (accessed April through November 2004), 2004.
L. J. McConaghey, “Simulation of Boats For Use in
Real-time Computer Graphics Applications” (Honours
thesis, Charles Sturt University), 2002.
A. Stevenson, “Voxels and Volumetric Representation”,
http://www3.telus.net/ah/voxels/voxels.htm (accessed 20
August 2004), 1996.
N. Stolte, “Octree – Overview”, http://nilo.stolte.free.fr/
octree.html (accessed 20 August 2004), 2003.
B.
Humphrey,
“Octree
Tutorial”,
from
www.GameTutorials.com,
http://www.gametutorials.com/Tutorials/OpenGL/Octree
.htm (accessed 20 August 2004), 2001.
M. J. Harris, “Real-Time Cloud Rendering for Games”,
in Game Developers Conference 2002 Proceedings,
2002.
D. Carr and J. Geyer, “A Study of Simulation and
Representation Methods of Dust Clouds for Real-Time
Graphics Applications,” in Proceedings of the Second
Australian Undergraduate Students’ Computing
Conference, G. Abraham and B. I. P. Rubinstein, Eds.
Melbourne: Australian Undergraduate Students’
Computing Conference, December 2004, pp. 17-22.
Microsoft Corporation, Microsoft DirectX 9.0 Software
Development Kit (SDK), 2002. Downloadable from
http://www.microsoft.com/downloads/search.aspx?
displaylang=en&categoryid=2
Hugo Elias, “Perlin Noise”, from The good-looking
textured light-sourced bouncy fun smart and stretchy
page,
http://freespace.virgin.net/hugo.elias/models/
m_perlin.htm (accessed 9 August 2004), 2000.
M. J. Harris, W. V. Baxter III, T. Scheuermann, and A.
Lastra, “Simulation of Cloud Dynamics on Graphics
Hardware”, in Graphics Hardware (2003), The
Eurographics Association, 2003.
R. Mizuno, Y. Dobashi, B. Chen, and T. Nishita,
“Physics Motivated Modeling of Volcanic Clouds as a
Two Fluids Model”, in Proceedings of the 11th Pacific
Conference on Computer Graphics and Applications
(PG’03), IEEE Computer Society, 2003.
N. Wang, “Let There be Clouds! Fast, Realistic CloudRendering in Microsoft Flight Simulator 2004: A
Century
of
Flight,”
from
Gamasutra,
http://www.gamasutra.com/features/20040114/wang_pfv
.htm (accessed 29 February 2004), 2004.

Acknowledgements
This work was funded by a Charles Sturt University
Foundation Honours Scholarship.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualisation (CGIV'06)
0-7695-2606-3/06 $20.00 © 2006


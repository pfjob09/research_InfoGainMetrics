E ectiv e Graph Visualization
Via Node Grouping
Janet M. Six and Ioannis G. T ollis

CAD & Visualization L ab
Computer Science Department
The University of Texas at Dallas
P.O. Box 830688, EC 31
Richardson, TX 75083-0688
fjanet,tollisg@utdallas.edu

Abstract
We discuss four methodologies for the application
of node grouping in graph visualization. In addition,
we introduce techniques for force-directed and orthogonal drawing which use node grouping information and
have been shown in experiments to perform better than
previous techniques. Not only do these techniques have
signi cantly improved performance with respect to standard aesthetic measures, but they also attain qualitative
improvement.
Keywords | Graph Dra wing, Graph Visualiza-

tion, Force-Directed Drawing, Orthogonal Drawing,
Node Grouping, Experimen tal Studies

1 Introduction
The information structures used in today's realworld applications are becoming increasingly large and
complex. Although many graph drawing techniques
4, 5] exist to embed these structures nicely onto a two
or three dimensional surface, the resulting drawings
can overwhelm the viewers' senses with the enormity of
the information structure. After studying many drawings, we noticed that small, complete subgraphs (K3 ,
K4 , K5 ) or almost complete subgraphs appeared often in the typical structures laid out by graph visualization tools. It became quite clear that the abstraction of these small node-disjoint groups would lessen
the visual complexity of resulting drawings. Our approach creates a less complicated visualization withThe research was supported in part by the Texas Advanced
Research Program under grant number 009741-040and a stipend
from the Provost's O ce at the University of Texas at Dallas.

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

out losing connectivity information by automatically
abstracting small node-disjoint cliques or subgraphs
which are almost complete graphs (almost-cliques). W e
call this type of abstraction node grouping and will
collectively refer to node-disjoint cliques and almostcliques as groups. Our approach has been designed to
help in the visualization of graphs of all sizes by abstracting groups, which are a common elemen t in many
graphs. The techniques we use to nd the small groups
must be very fast so that they can be an e ective complement to graph visualization algorithms as opposed
to a computationally expensive component which requires more time than the graph visualization techniques themselves. Given the knowledge that groups
exist in a given graph, the techniques we present in
this paper place the nodes and edges such that (a) the
groups are easily recognizable and (b) standard aesthetic measures 5] are improved when compared to
other techniques.

2 Previous Work
Before we produce drawings which abstract groups,
we need to nd the groups. Corneil proves the general clique packing problem to be NP-Complete in 3].
The problem of nding small node-disjoint cliques falls
within the general clique packing problem and therefore is also NP-Complete. As discussed in Section 1, it
is important to nd the groups in a fast manner in order
to make node grouping practical. Two fast techniques
which nd small node-disjoint cliques are discussed in
26]. The Triangle Technique nds triangles in a graph
and then explores those triangles to nd node-disjoint
K4 s and K5 s in the graph. P
The time required for
the Triangle Technique is O(( e2E minDegree(e))

avgDegree), where minDegree(e) is the minimum degree of the two nodes which are incident to the edge e,
E is the set of all edges, and avgDegree is the average
degree of all the nodes. The Coloring Technique uses
a coloring of the complement graph G to nd cliques.
The time required for the Coloring Technique is dependent on the time required for nding a coloring. Heuristic techniques require polynomial time. The Triangle
and Coloring Techniques can be extended to also nd
almost-cliques. Techniques for clique nding and subgraph packing can be modi ed to nd groups, however
these techniques are too complex and nd more information than is needed for the task at hand. Further
discussion can be found in 26].
Many graph drawing techniques which show clustered views of graphs have appeared in the literature.
Circular graph drawing techniques 7, 17, 18, 27, 28, 29]
place nodes of a group on the periphery of an embedding circle. Brandenburg describes an approach to determine whether or not a graph is a path, cycle, or
tree of cliques and if so to compute a representation in
1, 2].
Feng and Eades present several cluster drawing techniques which produce drawings of clustered graphs in
several styles 11, 12, 13]. Eades and Huang present a
technique and tool for visualizing clustered graphs in a
force-directed style in 16]. However, these techniques
have di erent objectives: (a) they work with planar
graphs, and/or (b) they work with clusters of nodes
which are de ned by the user. There are other clustering techniques which use various methods to nd
clusters 8, 9, 20, 25, 30]. However, again their use
of clusters has di erent objectives. Ostry described
an approach similar to the total abstraction methodology discussed in Section 3 in 21]. Ostry's technique is
limited to abstracting cliques only and requires O(n3)
time, where n is the number of nodes, to nd the
cliques.

3 Methodologies for the Application of
Node Grouping in Graph Drawing
In this section, we discuss four methodologies for
applying of node grouping to any type of graph
visualization: total abstraction, proximity abstraction, explicit proximity abstraction, and interactive abstraction. These methodologies are similar to the
white/grey/black box settings described in 24] and give
options to the user regarding the level of detail shown
in the resulting visualizations. Given a node grouping
of a graph G, the user may or may not wish to see
all the nodes and edges of each group. The following
methodologies facilitate ways in which a visualization

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

can show the existence of groups with varying levels of
visual complexity.
Visualizations created with the total abstraction
methodology represent each abstracted group with a
supernode. The nodes of the group are hidden as are
all the edges incident to two members of the group.
Edges which are incident to members of the abstracted
group and to nodes outside the group are replaced with
edges incident to the supernode which represents the
group. The new graph may then be sent to any layout algorithm. Ostry described a similar approach with
cliques in 21]. The new visualization will inherently be
simpler because the graph is now less dense. However,
the visualization loses some details of the information
structure. If the given graph is very large, a visualization created with the total abstraction methodology
will hide some visual complexity caused by the groups
while showing the essence of the structure. Given a
node grouping, nding a total abstraction visualization
is trivial.
With the pro ximity abstraction methodology all the
nodes, but none of the edges of each abstracted group
are shown. Also, the nodes of an abstracted group
appear very close to each other and no other node
is placed within some concave perimeter around the
nodes of the abstracted group. The visualization is simpli ed since the edges within an abstracted group are
not shown. Those edges are implied by the closeness of
those elements and some visual perimeter around those
nodes denoting they form a group.
Visualizations created with the explicit proximity
abstraction methodology are very similar to those created with proximity abstraction except that the edges
of the abstracted groups are shown.
The interactive abstraction methodology is a hybrid
of the other three methodologies we have discussed.
First, a visualization of a given graph is created with
the total, proximity, or explicit proximity abstraction
methodology. Then the user can interact through a
graphical user interface with the visualization to unabstract groups or abstract them with a di erent methodology. The visualization would not necessarily have the
same type of group abstraction over the entire drawing.
This would allow the user to be able to see the superstructure of the graph and then facilitate exploration
into the part of the graph most pertinent. However, the
essence of the entire structure would always be shown.

4 Applying Node Grouping to ForceDirected Dra wing
We now present a technique for the application of
node grouping to force-directed drawing which is de-

signed to be used with the proximity, explicit proximity, or interactive abstraction methodologies.
The algorithm takes as input a graph, G, and rst
nds a node grouping of G. Then each group is replaced with a supernode as discussed in Section 3: this
simpli ed graph is called the superstructure Gs . W e
will apply a force-directed layout technique 5, 10] to
Gs in order to obtain a layout, ;1 , of a graph which has
fewer nodes, edges, and highly connected subgraphs
and therefore is easier to layout than G. Then we will
replace each supernode in Gs with its respective group.
The nodes of each group will need to be given some position in ;1. In order for the nodes of each group to be
placed close to each other and to prevent other nodes
or edges from occluding the placement of the group,
we will place the nodes of the group very close to each
other at the placement of its respective supernode as
calculated in the force-directed layout. See Figure 1.
The illustration on the left shows a supernode as placed
in the layout of the superstructure, ;1 . The illustration on the right shows how the group nodes are placed
at the position of the supernode. For quadrant 1 (respective to the placement of the supernode in ;1 ) the
group node with the most neighbors in quadrant 1 is
placed at (x+i, y +i), where (x, y) is the placement of
the supernode and i is a small constant. This process
is repeated for the other three quadrants. This example shows the replacement of a supernode with a K4 ,
but this process could easily be expanded for groups
of greater size. Given a group of size k we place the
center of an in nite-radius circle at the placement of
the supernode in ;1 and radially divide the circle into
k evenly-sized pie sections. Then for each section ,
the group node with the most neighbors in will be
placed in that section very close to the location of the
supernode. The result is that the group nodes will be
placed in a ring around the placement of the supernode
in ;1 .
(x, y)

(a)

(x-i, y+i)

(x+i, y+i)

(x-i, y-i)

(x+i, y-i)

(b)

Figure 1. The illustration on the left shows
a supernode and the coordinates of its location. The illustration on the right demonstrates how the supernode is replaced with
the nodes of its respective group and also
their coordinates. The variable i is a small
constant.

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

After all the supernodes are replaced with their respective groups, we apply a force-directed algorithm in
which the attractive forces between nodes of the same
group are stronger than the attractive forces elsewhere.
The second and nal layout, ;, produced in this algorithm is expected to be very similar to ;1 with the replacement of the supernodes with group nodes and the
ne-tuning of the placement of the rings. The layout
; will be in the style of the explicit proximity methodology. The group edges can be removed from the visualization in order to create a proximity methodology
drawing. A visualization in the style of the interactive abstraction methodology can be created by showing unabstracted groups as they appear in ; and abstracted groups as supernodes placed in the center of
their respective rings in ;.

Algorithm 1 Force-DirectedWithNo deGrouping
Input: A graph, G = (V E).
Output: A Force-directed drawing, ;, of G.
1. Find a node grouping of G.
2. Use the node grouping to totally abstract the
groups into supernodes, thus obtaining the graph
Gs .
3. Give the nodes of Gs an initial placement and apply a force-directed technique to obtain a layout,
;1 .
4. Replace each supernode in Gs with the group it
represents and place the nodes of the group close
to each other at the position of the supernode in
;1 .
5. Apply a force-directed technique to G such that
the attractive forces applied to nodes of the same
group are stronger than those of others.
The time required for this algorithm is dependent on
the time needed to nd the node grouping and the time
required to execute the force-directed technique. As
discussed in Section
P 2, the time needed to nd the node
grouping is O(( e2E minDegree(e)) avgDegree). As
shown in previous works, force-directed techniques require O(n3) time, where n is the number of nodes. See
5, 10] for more information on force-directed graph
drawing.
Algorithm 1 is di erent from the technique in 16],
which is designed to navigate huge clustered graphs,
in that it is a two-phased approach. In Algorithm 1,
we rst layout the superstructure and then place the
nodes of each group and ne-tune the layout to obtain

the nal drawing. Due to this construction of the algorithm, the nodes of each group must be placed close to
each other since the algorithm knows that these nodes
are members of the same group. The technique in 16]
does not know which nodes are members of a group,
only which nodes have been grouped by the user.
There is also a repulsive force acting between all
pairs of nodes. The nodes of each cluster are pulled
together during the gathering operation in which the
attractive spring forces are increased. However, the
classical force-directed layout problem of a node u being placed on the wrong side of a block of nodes
(caused by the attractive forces acting on u not being
able to overcome the repulsive forces emitted by the
nodes in ) could occur in multiple places within the
layout. These problems may be resolvable if the attractive forces are increased an undetermined amount.
In drawings created by the technique in 16] the nodes
of each group may be placed in close proximity to each
other, but it is not guaranteed.
The fast force-directed algorithms tailored for drawing large graphs in 14, 15] use a di erent type of clustering to save execution time. Both techniques successively group the nodes via graph-theoretic distances
with respect to either independent sets 14] or graph
centers 15]. The force calculations are then calculated
within neighborhoods of the graph as opposed to the
entire graph. The resulting drawings appear as regular force-directed drawings as opposed to Algorithm 1
which produces drawings that highlight the existence
of small node-disjoint groups.
We have implemented Algorithm 1 in C++ and run
experiments over a set of 595 graphs for which we know
the number of small node-disjoint cliques. The groups
found in Step 1 are small node-disjoint cliques found
with one of the techniques in 26]. We compare our
implementation of Algorithm 1 with our implementation of the algorithm in 10]. The force-directed
technique we use in Steps 3 and 5 of Algorithm 1 is
also that of 10] with the force modi cations for Step
5. Of course, any force-directed technique may be
used during these steps. Algorithm 1 achieved the following improvements over our implementation of the
force-directed technique in 10]: 22% in edge crossings, 17% in average edge length, 12% in maximum
edge length, 17% in total edge length, 35% in average
clique edge length,Pand
15% in average neighborhood
k

P

n

j

=1 length

(

of ej which is incident to ui

)

# of edges incident to ui
edge length i=1
.
n
The average area was approximately the same for both
techniques: Algorithm 1 does not necessarily make a
smaller drawing than other force-directed techniques,
but according to other quantitative measures, it is able

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

to use about the same amount of space while producing
a more clear layout. Approximately the same amoun t
of execution time was needed for both our implementation of the basic force-directed technique of 10] and
for our implementation of Algorithm 1, which includes
nding the node grouping and two applications of the
force-directed technique of 10]. Algorithm 1 required
approximately the same amount of time as 10] due
to Step 3 being performed on a superstructure (as opposed to the original graph) and Step 5 being applied
to a layout which is almost converged.
Sample drawings from our experimental study are
included in Figure 2. W e found in our experimental study that in addition to achieving improvement
in the quantitative measures of crossings, average edge
length, maximum edge length, total edge length, clique
edge length, and neighborhood edge length, Algorithm
1 also produces drawings of a higher quality with respect to the following properties:
Clarity of Groups - The nodes of each clique are
connected to each other with short, almost uniform edges and therefore appear in an easily recognizable form. Also, the shortness of edges within a
clique highlight these edges as di erent from edges
which are not part of a clique.
Separation of Groups From Other Portions of the
Graph - Due to the construction of our technique,
it is unlikely that the visualization of a clique will
occlude any other part of the layout.
Better Layout of the Superstructure - Step 2 of Algorithm 1 transforms the graph into its less dense
superstructure. The task of visualizing the superstructure will then be easier than the same task
in a regular force-directed layout since we are processing a simpler graph.
Ease of Seeing Some Structure In Drawings of
Larger Graphs - In a node grouped force-directed
drawing, it will be easier to see the cliques due to
their placement. The ease in which these dense
subgraphs can be located could be an aid to large
graph navigation.
Ease of Seeing Flow into and out of the Groups Due to the placement of the nodes in each clique,
it is easy to see how the nodes within a clique are
related to nodes outside that clique.
Due to the above properties, both high and low level
details can be seen simultaneously in layouts produced
by Algorithm 1. The composition of the superstructure
is highlighted, yet no details of the individual edges are
lost.

5 Applying Node Grouping to
Orthogonal Dra wing

41
31

29

0
80

57
79

90

13

25

10
44
40

70

43
35

91

51

58

3

18

28
14

33

19

5

34

54
24

32

86
36

38

59

23

77

55

48
74

62

12

60

47

17

6

1
53

16

69

2

37
84

85

66

15

46

64

72

87

56

7
67

26

45

42

11

39

20

30

89

65

8

81

76

50

61

9

73

22
78
75

68
4
71

49

27
83

88

82

63
52

28

14
91

54
51
37

21

44

62

53
13

84
35

20
32

34
69

18

77

45
16
26

19

59

76
89

86

33

36

65
61

48

60
43
50

4

88

85
90

49

27

66

0

41

7

31

75

80

71

8
22
9

17
78
12
63

6

40

55

73

1

58
52
21

3

5

2

83

70

82
68

81

25
79
29
57
10

72

46

39
74
56
64

15

24
23

47
38

11
30
67

42
87

Figure 2. The drawing on the top is created with a force-directed graph drawing algorithm. The drawing on the bottom is of the
same 92 node, 156 edge graph produced by
Algorithm 1 and has the following improvements over the drawing on the top: 31% in
crossings, 20% in average edge length, 20%
in maximum edge length, 20% in total edge
length, 34% in average clique edge length,
17% in neighborhood edge length.

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

We now introduce an algorithm which produces orthogonal drawings that utilizes node grouping information. This technique is designed to be used with the
proximity, explicit proximity, or interactive abstraction
methodologies.
The technique rst will nd a node grouping of the
input graph G and make a superstructure Gs as discussed in Section 4. Next, we will create an orthogonal
layout 5, 22], ;1, of Gs . Then, in order to replace
each supernode with its respective group, we place the
group nodes very similarly to Algorithm 1. Again, the
group nodes will be placed in a ring, and in order to
avoid occluding other graph elements, we insert rows
and columns as necessary to avert any overlaps. Dependent on the size of the group, some group nodes
will be placed in a row or column which exists in ;1
while others will be placed in a new row or column.
Next we will route the edges incident to the group
nodes. Edges incident to nodes of the same group will
be drawn as straight lines in order to save space and
also to highlight that these edges are members of a
group. Unrouted edges incident to two nodes which
are not members of the same group will then be routed
with a VLSI-inspired line searching algorithm 19]. The
rst set of searching lines are grown out of the group
nodes in the directions away from the center of the
group ring and out of non-group nodes in the directions in which the orthogonal drawing algorithm will
allow (dependent on technique and implementation).
The directions in which the search lines are grown are
called the open directions of the node. Collision points
of these search lines are noted and a search line which
contains collision points with search lines from both
nodes incident to an edge and contain no obstacles
(graph elements already placed in that section of row or
column) will be used in an edge routing. These search
lines are called successful. If the rst set of search lines
has a successful search line, then we can route the edge
along the successful search line and the lines with which
it intersects. It may be necessary to expand one of the
incident nodes, if there is no space for an edge to be
routed along that side. Bends will be placed at the
collision points on the successful search line.
If there are no successful search lines, we grow new
searching lines perpendicular to the rst set. For each
search line in the rst set, if the search line is incident to
a non-group node, then we place a search line one grid
unit from the node in the open direction. Otherwise,
we place the new search line one grid unit outside the
placement of the ring in the open direction, see Figure

3. The second set of search lines represent the possible

u

Figure 3. Example of growing a second set of
search lines (the dashed lines) from the node
u.

new row or column insertions needed to route the edge
with a small number of bends. After the creation of
the second search line set, we must have a search line
which contains collision points for both nodes incident
to the edge. W e know that we will have success at this
point for the following reason: for any edge, (u, v), if
we insert new rows or columns next to both u and v
in their open directions there must exist some route
without obstacles between u and v along the new rows
or columns and the search lines emanating from u and
v. Again, we route the edge along a successful search
line and the lines with which it intersects and nodes
are expanded as needed. If there are multiple successful search lines, we choose one which will induce the
least number of bends. Since we have four directions
in orthogonal drawing (North, East, South, and W est)
the routing for each edge can be classi ed in one of four
ways:
1. Same Row/Column - the incident nodes share a
row or column.
2. Share Direction - the incident nodes share an open
direction.
3. Opposite And Towards - the incident nodes have
di erent open directions and, due to node placement, the rst set of searching lines intersect.
4. Opposite And Apart - the incident nodes have different open directions and, due to node placement,
the rst set of searching lines can not intersect.
Dependent on the classi cation of each edge to be
routed and the location of obstacles in the visualization
we know the number of bends and rows or columns
added for each edge routing.
No Obstacles
Obstacles
Class bends row/col bends row/col
1
0
0
2
1
2
2
1
4
3
3
1
0
3
2
4
3
2
3
2

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

The result of the edge routing step is a second layout, ;, which is a drawing of the input graph, G under
the explicit proximity methodology. As with Algorithm
1, ; can easily be modi ed to a visualization in the style
of proximity or interactive abstraction methodologies.

Algorithm 2 OrthogonalWithNo deGrouping
Input: A graph, G = (V E).
Output: An orthogonal drawing, ;, of G.
1. Find a node grouping of G.
2. Use the node grouping to totally abstract the
nodes into supernodes, thus obtaining the graph
Gs .
3. Apply an orthogonal graph drawing technique to
Gs to obtain a layout, ;1.
4. Replace each supernode in Gs with the group it
represents and place the nodes of the group close
to each other at the position of the supernode in
;1 .
5. Route the edges which are incident to group nodes.
The time required for this algorithm is dependent
on the time needed to nd the node grouping and the
time required to execute the orthogonal drawing technique. As discussed in SectionP2, the time needed to
nd the node grouping is O(( e2E minDegree(e))
avgDegree). The time required for Step 3 is O(n) if
we use 23]. The time required for Algorithm 2 is dependent on the choice of these two techniques. See 5]
for discussion of orthogonal graph drawing algorithms.
The algorithm in 13] produces an orthogonal grid
rectangle cluster drawing given a connected clustered
graph of maximum degree four and a c-planar embedding (one in which there are no edge crossings or an
edge crossing the bounding box of a cluster to which
it does not belong). This technique rst creates a visibility representation 5, 6], ;v , and then performs an
orthogonalization 5, 31] on ;v to obtain an orthogonal
drawing. This technique is for planar graphs of maximum degree four. The authors of 13] suggest that
this technique can somehow be expanded to non planar graphs, although they give no details. They also
suggest that nodes of degree higher than four can be
represented with a cluster of nodes of maximum degree
four.
We have implemented Algorithm 2 in C++ and run
experiments over the same the set of graphs used in
Section 4. The groups found in Step 1 are small nodedisjoint cliques found with one of the techniques in 26].
W e compare our implementation of Algorithm 2 with

our implementation of an algorithm based on 23]. This
algorithm is also used in Step 3 of our implem entation
of Algorithm 2. Algorithm 2 achieved the following improvements: 52% in area, 60% in bends, 45% in edge
crossings, 59% in the average edge length, 38% in maximum edge length, 59% in total edge length, 90% in
average clique edge length, 89% in average Cartesian
clique edge length (the Cartesian distance between the
placement of two nodes incident to a clique edge), and
52% in the average neighborhood edge length. The
execution time required by Algorithm 2 was slightly
more on average, however both techniques produced
drawings quickly.
Sample drawings from our experimental study are
included in Figure 4. W e found in our experimental
study that Algorithm 2 achieves improvement in the
quantitative measures of area, bends, crossings, average edge length, maximum edge length, total edge
length, clique edge length, and neighborhood edge
length. These improvements could likely be increased
with the application of the re nement techniques from
26]. Like Algorithm 1, Algorithm 2 also produces
drawings with better clarity of groups, separation of
groups from other portions of the graph, better layout
of the superstructure, ease of seeing some structure in
drawings of larger graphs, and ease of seeing ow into
and out of groups.

15
65
25

28
39

48

57
56

5

46
19
42

59

23
63

31

69
61
24

0

68

7

40

49

37
20

47
29
21

36

18

73
6

9
58
10
64

26

52

72

13

1
60

53

66
32
67

43

74
22
30
16
4

2

34
12

8

51
54
35

38

44

33

41

11

62

27

45
71

12

8

16

51

2

4
42
50

19

55

56

36
26

3

67

21

73

6

72

1

9

43
0

References

68
23

74
5

61

69

24

63

46
31
7

49
14

15

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

3

17
70

59

1] F. Brandenburg, Graph Clustering 1: Cycles of
Cliques, Proc. GD '97, LNCS 1353, SpringerVerlag, pp. 158-168, 1997.
2] F. Brandenburg and A. Sen, Graph Clustering II:
Trees of Cliques with Size Bounds, Proc. of GD
'99, LNCS 1731, Springer-Verlag, pp. 158-168,
1999.
3] Corneil, The Complexity of Generalized CliquePacking, Discrete Applied Mathematics, 12(85),
pp.233-239, 1985.
4] G. Di Battista, P. Eades, R. Tamassiaand I. Tollis,
Algorithms for Drawing Graphs: An Annotated
Bibliography, Computational Geometry: Theory
and Applications, 4(5), pp. 235-282, 1994.
5] G. Di Battista, P. Eades, R. Tamassia and I. G.
Tollis, Graph Drawing: Algorithms for the Visualization of Graphs, Prentice-Hall, 1999.
6] G. Di Battista, R. Tamassia and I. G. Tollis,
Constrained Visibility Representations of Graphs,

50

55

14

28
39

25

48

44

65
57
22

30

38

35

34

13
37
20

47

29

40

10
17

58

32
54

62

27

53

64
52
41

45

11

18

70

33

66

71

60

Figure 4. The drawing on the top is created
with an orthogonal graph drawing algorithm.
The drawing on the bottom is of the same
75 node, 129 edge graph produced by Algorithm 2 and has the following improvements
over the drawing on the top: 57% in area,
66% in bends, 58% in crossings, 60% in average edge length, 41% in maximum edge
length, 60% in total edge length, 86% in average clique edge length, 84% in average Cartesian clique edge length, and 56% in neighborhood edge length.

7]

8]

9]

10]
11]

12]
13]

14]

15]

16]

17]
18]

Theoretical Computer Science, 61, pp. 175-198,
1988.
U. Dogrusoz, B. Madden and P. Madden, Circular Layout in the Graph Layout Toolkit, Proc.
GD '96, LNCS 1190, Springer-Verlag, pp. 92-100,
1997.
C. A. Duncan, M. T. Goodrich and S. G.
Kobourov, Balanced Aspect Ratio Trees and Their
Use for Drawing Very Large Graphs, Proc. GD
'98, LNCS 1547, Springer-Verlag, 1998.
C. A. Duncan, M. T. Goodrich and S. G.
Kobourov, Planarity-Preserving Clustering and
Embedding for Large Planar Graphs, Proc. GD
'99, LNCS 1731, Springer-Verlag, pp.186-196,
1999.
P. Eades, A Heuristic for Graph Drawing, Congr.
Numer., 42, pp. 149-160, 1984.
P. Eades, Q. Feng and X. Lin, Straight-Line
Drawing Algorithms for Hierarchical Graphs and
Clustered Graphs, Proc. GD '96, LNCS 1190,
Springer-Verlag, pp. 113-128, 1997.
P. Eades and Q. W. F eng, Multilevel Visualization
of Clustered Graphs, Proc. GD '96, LNCS 1190,
Springer-Verlag, pp. 101-112, 1997.
P. Eades, Q. W. Feng and H. Nagamochi, Drawing
Clustered Graphs on an Orthogonal Grid, Jrnl.
of Graph Algorithms and Applications, pp. 3-29,
1999.
P. Gajer, M. T. Goodrich and S. G. Kobourov,
A Fast Multi-Dimensional Algorithm for Dra wing
Large Graphs, Proc. GD 2000, LNCS 1984, pp.
211-221, 2001.
D. Harel and Y. Koren, A Fast Multi-Scale
Method for Drawing Large Graphs, Research Report MCS99-21, W eizmann Institute of Science,
November 1999.
M. L. Huang and P. Eades, A Fully Animated
Interactive System for Clustering and Navigating Huge Graphs, Proc. of GD '98, LNCS 1547,
Springer-Verlag, pp. 107-116, 1998.
G. Kar, B. Madden and R. Gilbert, Heuristic Layout Algorithms for Network Presentation Services,
IEEE Network, 11, pp. 29-36, 1988.
V. Krebs, Visualizing Human Networks, Release
1.0: Esther Dyson's Monthly Report, pp. 1-25,
February 12, 1996.

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

19] T. Lengauer, Combinatorial Algorithms for Integrated Circuit Layout, John Wiley and Sons, 1990.
20] F. J. Newbery, Edge Concentration: A Method
for Clustering Directed Graphs, Proc. 2nd Intl.

Workshop on Softwar e Con guration Management, pp.76-85, 1989.
21] D. Ostry, Some Three-Dimensional Graph Drawing Algorithms, Master's Thesis, University of

Newcastle, October 1996.
22] A. Papakostas, Information Visualization: Orthogonal Drawings of Graphs, Ph.D. Thesis, University of Texas at Dallas, 1996.
23] A. Papakostas and I. G. Tollis, Interactive Orthogonal Graph Drawing, IEEE Trans. Computers, 47(11), pp. 1297, 1998.
24] F. N. Paulisch, EDGE: An Extendible Graph Editor, Soft. Prac. and Exp., 20(S1), pp. S163-88,
1990.
25] R. Sablowski and A. Frick, Automatic Graph
Clustering, Proc. GD '96, LNCS 1190, SpringerVerlag, 1997.
26] J. M. Six, Vistool: A Tool For Visualizing Graphs,
Ph.D. Thesis, The University of Texas at Dallas,
2000.
27] J. M. Six and I. G. Tollis, Circular Drawings of Biconnected Graphs, Proc. of ALENEX '99, LNCS
1619, Springer-Verlag, pp. 57-73, 1999.
28] J. M. Six and I. G. Tollis, Circular Drawings of
Telecommunication Networks, Proc. 7th Hellenic
Conference on Informatics, pp. II.124-131, 1999.
29] J. M. Six and I. G. Tollis, A Framework for Circular Drawings of Networks, Proc. of GD '99, LNCS
1731, Springer-Verlag, pp. 107-116, 1999.
30] K. Sugiyama and K. Misue, Visualization of Structural Information: Automatic Drawing of Compound Digraphs, IEEE Trans. Soft. Eng., 21(4),
pp. 876-892, 1991.
31] R. Tamassia and I. G. Tollis, Planar Grid Embeddings in Linear Time, IEEE Trans. on Circuits
and Systems, CAS-36(9), pp.1230-1234, 1987.


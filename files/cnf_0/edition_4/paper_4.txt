Technical Note: Visually Encoding Program Test Information
to Find Faults in Software
James Eagan, Mary Jean Harrold, James A. Jones, and John Stasko
College of Computing / GVU Center
Georgia Institute of Technology
Atlanta, GA 30332-0280
eaganj,harrold,jjones,stasko @cc.gatech.edu

Abstract
Large test suites are frequently used to evaluate software
systems and to locate errors. Unfortunately, this process
can generate a huge amount of data that is difficult to interpret manually. We have created a system, TARANTULA,
that visually encodes test data to help find program errors.
The system uses a principled color mapping to represent
source lines in passed and failed tests. It also provides a
flexible user interface for examining different perspectives
that show the behavior of the source code on test sets, ranging from individual tests, to important subsets such as the
set of failed tests, to the entire test suite.

1. Introduction
Software errors significantly impact software productivity and quality. Attempts to reduce the number of delivered
faults are estimated to consume 50% to 80% of the development and maintenance effort [2]. Debugging is one of the
most time-consuming tasks required to reduce the number
of delivered faults in a program. Thus, researchers have investigated techniques to assist with debugging (e.g., [1, 4]).
However, these techniques often do not scale to large programs or they require extensive manual intervention. This
lack of effective techniques hinders the development and
maintenance process.
Studies show that locating the errors 1 is the most difficult
and time-consuming component of the debugging process
(e.g., [5]). Typically, programmers use debugging tools to
manually trace a program, encounter a point of failure, and
then backtrack to find related entities and potential causes.
Although this technique can help programmers locate
faults, there are several aspects of the process that can be
improved. First, even with source-code debuggers, the manual process of identifying the locations of the faults can be
1 In

our discussion, we use errors, bugs, and faults interchangeably.

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

very time consuming. A technique that can automate, or
partially automate, the process can provide significant savings. Second, because these tools lead developers to focus
their attention locally instead of providing a global view of
the software, interacting faults are difficult to detect. An
approach that provides a developer with a global view of
the software, while still giving access to the local view, can
provide the developer with more useful information. Third,
the tools use results of only one execution of the program
instead of using information provided by many executions
of the program. A tool that provides information about
many executions of the program lets the developer understand more complex relationships in the system. However,
with large programs and large test suites, the huge amount
of data produced by such an approach, if reported in a textual form, may be difficult to interpret.
We are using information visualization techniques, together with data from program testing, to help software developers and maintainers locate faults in their code. Our
techniques are more global in nature than previous approaches, providing a high-level overview of the software
system and how it functions under testing, thus summarizing results and highlighting promising locations in the
program for further exploration. This paper presents a system we have developed, TARANTULA, that applies our techniques to depict a program along with the results of testing
the program.

2. Input Data
Developers and maintainers of large software systems
usually create tests (i.e., test cases) for use in testing the
systems. This testing provides evaluation of qualities such
as correctness and performance. Each test consists of a set
of inputs to the software and a set of expected outputs from
the execution of the software with those inputs. A set of
tests is called a test suite. It is not unusual for software engineers to develop large test suites consisting of unique tests

that number in the hundreds or even in the thousands.
Given a test suite Ì for a software system Ë and a test Ø
in Ì , we gather two types of information about the execution of Ë with Ø: pass/fail results and code coverage. Test
Ø passes if the actual output for an execution of Ë with Ø
is the same as the expected output for Ø; otherwise, Ø fails.
The code coverage for Ø consists of the source-code lines
that are executed when Ë is run with Ø.
The input to our visualization consists of three components: the source code for Ë ; the pass/fail results for executing Ë with each Ø in Ì ; and the code coverage of executing
Ë with each Ø in Ì . Each Ø in Ì (1) is marked as “passed”
or “failed,” and (2) contains the code coverage for the execution of Ë with Ø. A sample input to our visualization
system is shown below. On each line, the first field is the
test number, the second field is the pass/fail (P or F) information about the test, and the trailing integers are the code
coverage for that test.
1 P 1 2 3 12 13 14 15 ...
2 P 1 2 23 24 25 26 27 ...
3 F 1 2 3 4 5 123 124 125 ...
Our challenge is to use this data to help software engineers find faults or at least identify suspicious regions
in code where faults may lie. For large software systems
with large test suites, this resulting data is huge, and is extremely tedious to examine in textual form. A visualization
can summarize the data, letting software engineers quickly
browse the test result representation to find likely problem
regions of the code that may be contributing to failures.

3. TARANTULA
3.1. Design Considerations
In developing TARANTULA, we had several key objectives. One was to provide a high-level, global overview of
the source code upon which the results of the testing could
be presented. We considered a number of alternatives and
decided to use the “line of pixels”-style code view introduced by the SeeSoft system [3]. Each line of code in the
program is represented by a horizontal line of pixels. The
length of the line of pixels corresponds to the length of the
line of code in characters, thus providing a far-away, birdseye view of the code. Other objectives were to let viewers
examine both individual tests and entire test suites, to provide data about individual source-code lines, and to support
flexible, interactive perspectives on the system’s execution.
Our design’s primary focus is on illustrating the involvement of each program line in the execution of the different
tests. We decided to use color to represent which and how
many of the different tests caused execution through each
line. As we explored this idea further, the difficulty of selecting a good visual mapping became evident.

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

Suppose that a test suite contains 100 failed tests and
100 passed tests. Particular lines in the program might be
executed by none of the tests, only by failed tests, only by
passed tests, or by some mixture of passed and failed tests.
Our first approach was to represent each type of line by a
different color (hue). Two different colors could represent
passed and failed tests, and a third color that is a combination of those two could represent mixed execution.
More flexibility was necessary, however. Consider two
lines in the program that are executed only by failed tests.
Suppose that one line is executed by two tests and the other
is executed by 50 tests. In some sense, the second line has
more negative “weight” and could be represented with the
same hue but with its code line darker, brighter, or more
saturated than the first to indicate this attribute to the viewer.
This straightforward idea was sufficient for the pass-only
or fail-only tests, but was insufficient to represent lines executed by both passed and failed tests. One approach was
to vary the hue of the line, mixing combinations of the two
extreme colors, to indicate how many tests of each type executed the line. For example, suppose that a program line
was executed by 10 failed and by 20 passed tests. We could
make its color closer to the color representing passed tests
since it was involved in twice as many of those tests.
Unfortunately, this relatively simple scheme is not sufficient. Suppose that the entire test suite for the example
above contains 15 failed and 200 passed tests. Even though
the line was executed by only half as many failed tests (10
to 20), a much higher relative percentage of the failed tests
encountered the line (10/15 = 67% to 20/200 = 10%), perhaps indicating more “confidence” in that fact. Representing these ratios seemed to be more important than presenting the total quantities of tests executing a line. Thus, the
hue of a line should represent the relative ratios of failed and
passed tests encountered, and the color of this line would be
more strongly the color indicating a failed test.
This notion helped, but further issues arose. Consider
two different source lines. The first is executed by 1 of 100
failed and 1 of 100 passed tests. The two ratios are the same,
thus the line’s hue is a perfect blend of the two. Suppose
that a second line is executed by 95 of 100 failed and 95
of 100 passed tests. The second line is the same hue as the
first, due to the equal ratios, but it seems desirable to render
it differently because of its greater execution by the entire
test suite. We needed to use a different attribute than hue to
encode that fact.
TARANTULA’s visual interface makes concrete the
heuristics hinted at above. We first experimented with a
variety of background and line category colors by running
a series of informal user tests. These studies helped us to
select a color scheme using a black background with green
representing passed tests, red representing failed tests, and
yellow representing an even balance of passed and failed

Figure 1. A screen snapshot of the TARANTULA system in Continuous mode.
tests. In the most advanced display mode, we decided to
use hue to encode the ratio of the percentage (not quantity)
of passed to failed tests through a line, and to use brightness
to represent the larger of the two percentages.

3.2. System Capabilities
Figure 1 shows TARANTULA’s interface acting on an example data set. The middle area is the code-display area
using the code-line representation pioneered in the SeeSoft
system. The top area contains a number of interface controls
for modifying the perspective in the program code display
area. The bottom area shows a detailed textual view of a selected source-code region, statistics of the selected region,
and a color-space map. One of the goals of TARANTULA
is interactivity and flexibility, and different attributes of the
data can be highlighted through different display modes and
by mousing over or selecting different source-code lines.
We next describe the systems’s functionality in detail.
The top area of the display contains a series of buttons,
which are mutually exclusive controls for the display mode.
The first mode, Default, simply shows the lines of code in
gray in the code display area and does not illustrate any testing data. The darkness or lightness of the gray is controlled
through the upper-right slider, which is discussed later.

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

The second mode, Discrete, presents a general summary
of all testing information in a straightforward manner. We
call it “Discrete” because three discrete colors, red, yellow,
and green, are used to color program statements to indicate
how they were executed by the test suite. If no test executed
a line or the line is a comment, header, etc., the line is gray.
If a line was executed only in passed tests, the line is green.
If a line was executed only in failed tests, it is red. Finally,
if a line was executed in both passed and failed tests, then it
is yellow.
The third mode, Continuous (shown in Figure 1), is the
most informative and complex mapping. Unlike the Discrete mode, it renders all executed statements on a spectrum
from red to green and with varying brightnesses. In particular, the hue of a line is determined by the percentage of
the number of failed tests executing statement × to the total
number of failed tests in the test suite Ì and the percentage of the number passed tests executing × to the number
of passed tests in Ì . The brightness is determined by the
greater of the two percentages, assuming brightness is measured on a 0 to 100 scale. Specifically, the color of the line
for a statement × that is executed by at least one test is determined by the following equations.
hue(s)
bright(s)

×× ´×µ
low hue (red) ±Ô ××±Ô´×µ·±
Ð
max(% passed(s),% failed(s))

·

´×µ £ hue range

For example, for a test suite of 100 tests, a statement ×
that is executed by 15 of 20 failed tests and 40 of 80 passed
tests, and a hue range of 0 (red) to 100 (green), the hue and
brightness are 40 and 75, respectively.
The last three display modes (Passes, Fails, and Mixed)
simply focus on showing all the lines in one of the three
components of the Continuous mode. The same coloration
and brightness mapping as in the Continuous case is used,
but only lines that meet one of the three criteria are colored.
For example, in Fails mode, lines executed only in failed
tests are red and all others are gray. This effectively lets the
viewer spotlight only those lines and focus more clearly on
them. In each of these modes, the brightness for each line is
the percentage of tests that execute the respective statement
of the tests for that mode. Lines executed by all failed tests
are bright red, for example, and lines executed only in a
small percentage of the failed tests are dark red.
The long, thin rectangular region located above and to
the right of the code-view area visually encodes the pass/fail
attribute of each test in the suite. A small rectangle is
drawn for each test from left-to-right and is color-coded to
its outcome—green for pass and red for fail. This lets the
viewer, at a glance, see the overall pass/fail trend within the
test suite. Furthermore, the viewer can use the mouse to
select any rectangle in order to display only that particular
test’s code coverage in the code view below. Also, the textentry box in the upper left (labeled “Test:”) lets the viewer
enter the numbers of particular tests and see the code coverage of only those tests reflected in the code-display area.
As mentioned earlier, the slider above the test suite display controls the brightness of the unexecuted statements
shown in gray. This feature lets the viewer gain familiarity
with the code by making comments and other unexecuted
code more visible (brighter gray), and then focus only on
the executed code by making the unexecuted code black.
The bottom area of the display contains a color-space
map and detailed information about selected source code.
The rectangle in the lower right, when in Continuous mode,
is a map of the color space. Statements are represented as
black dots at the position corresponding to their color in
the current color mapping. The viewer is then able to see
the distribution throughout the color space of all statements
in the view. The user also can select particular statements
by “rubber banding” their dots in the map, thus forming
a type of dynamic query that causes the code view to be
redisplayed, coloring only appropriate lines. For example,
the viewer may wish to select all statements that are within
10% of pure red, or all statements that are executed by more
than 90% of the test suite. Finally, moving the cursor over
a code line in the code-display area makes it the focus: the
source code near that line is shown in the bottom left of the
interface, and the line number and test coverage statistics
for that line are shown in the lower center.

Proceedings of the IEEE Symposium on Information Visualization 2001 (INFOVIS’01)
1522-4048/01 $17.00 © 2001 IEEE

To find faults in a system, a software engineer loads the
input data about a system (described in Section 2) and can
then examine the source code under a variety of perspectives. Presently, we are using TARANTULA to examine
large programs under test to gain a better understanding of
how program faults correlate to colored regions in the display. We need to determine whether faults usually fall in
bright red regions of the display that indicate lines executed
only in failed tests and in high percentages of those tests,
or whether faults often lie in yellow regions executed both
by passed and failed tests. Furthermore, we need to determine whether faults sometimes lie “upstream” or “downstream” of these colored regions. If so, we need to include
other program visualization views or supplement TARAN TULA ’s view with information to visually encode other program attributes such as control flow and calling relations.
Along those lines, Ball and Eick created a visualization system that uses the SeeSoft representation to encode program
slices [1]. We will explore the addition of program analysis
information such as slices, into TARANTULA in the future.
We are also investigating possible visualizations for higherlevel abstractions of programs and other techniques to aid
in the scalability of our technique.

4. Conclusion
This article presented an overview of TARANTULA, its
user interface, and its visual encoding methodology for representing program test information. The research makes
three main contributions. First, it introduces the idea of
using a visual encoding of the potentially massive amount
of program test result information to help software engineers locate faults in software systems. Second, it identifies
a visual mapping using color and brightness to reflect each
source line’s influence on the test executions. Finally, it creates an informative and flexible user interface for presenting
a variety of perspectives on the testing information.

References
[1] T. Ball and S. G. Eick. Software visualization in the large.
Computer, 29(4):33–43, Apr. 1996.
[2] J. S. Collofello and S. N. Woodfield. Evaluating the effectiveness of reliability-assurance techniques. Journal of Systems
and Software, 9(3):191–195, 1989.
[3] S. G. Eick, L. Steffen, Joseph, and E. E. Sumner Jr. Seesoft—
A tool for visualizing line oriented software statistics. IEEE
Transactions on Software Engineering, 18(11):957–968, Nov.
1992.
[4] Telcordia Technologies, Inc. xATAC: A tool for improving testing effectiveness. http://xsuds.argreenhouse.com/htmlman/coverpage.html.
[5] I. Vessey. Expertise in debugging computer programs. International Journal of Man-Machine Studies: A process analysis, 23(5):459–494, 1985.


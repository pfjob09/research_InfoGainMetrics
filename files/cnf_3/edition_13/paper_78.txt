ULTIMA RATIO
A Visual Language for Argumentation 
Michael Schroeder1 , Daniela A. Plewe2 , and Andreas Raab3
1

City University, London, UK, msch@soi.city.ac.uk
2 Berlin, Germany, plewe@is.in-berlin.de
3 University of Magdeburg, Germany, raab@isg.cs.uni-magdeburg.de
Abstract

animated visualisation process. The paper contains screenshots of the system as exhibited at Ars Electronica. To see
the screenshots in colour please visit the URL below. 1
Our work is closely related to logic programming and
formal argumentation [8, 10]. Intuitively, argumentation
treats the evaluation of a logic program as an argumentation process, where a goal G holds if all arguments supporting G cannot be attacked anymore. Thus, logic programming is seen as a discourse involving attacking and counterattacking arguments.
Ultima Ratio is a system that relies on a formalism to
represent ambivalence by arguments and to solve them by
argumentation. Arguments are modeled by extended logic
programs which provide two forms of negation, assumptions, integrity constraints, and contradiction removal. Using this expressive language, we implement human decision making and argumentation including features such as:
don’t believe in a statement if there is evidence to the contrary, don’t rely on premises which are defeated, try to find
inconsistencies and remove them by changing relevant assumptions. This methodological canon works on a knowledge base which contains logical representations of various
conflicts occurring in classical literature. For Hamlet, for
example, it is contradictory to have the goal to take revenge
and not to take it. The argument that Claudius killed Hamlet’s father supports Hamlet’s goal. Subsequently, Hamlet
killing Claudius would remove Hamlet’s contradiction, if
there was not another counter-argument: Claudius would
go to heaven (which is too good for him) if killed while
praying. Hamlet is caught in cascades of doubt.
Besides formal argumentation, Ultima Ratio aims at visualizing the process of argumentation in a form understandable by human beings even without basic knowledge
about the foundations of formal logic. To achieve this goal,
we use the construction of argumentation trees as visual
metaphor for the process of argumentation. The tree’s construction is a representation of an argument (the logic) and

In the third act of Shakespeare’s Hamlet, the hero is unsure whether to kill Claudius - the assassin of Hamlet’s father - or not. He argues that if he does kill him, Claudius
who is praying at that very moment goes to heaven and if
he does not kill him Hamlet’s father is not revenged. A contradiction.
Ultima Ratio aims at formalization and visualization of
argumentation for agents. An agent is constituted by a set of
arguments and assumptions. Facing a particular world, the
agent’s believes may be inconsistent triggering a rational
monologue to deal with the situation.
Formally, we define a framework for argumentation
based on extended logic programming under well-founded
semantics. The system serves as decision support and is
capable of detecting and removing contradictions and deriving conclusions of the agent’s arguments.
To demonstrate the structure and dynamics of the agent’s
argumentation, we visualise the process as dynamic construction of proof trees. The paper includes screenshots of
the logical engine and the visualisation unit as exhibited at
the computer arts exhibition Ars Electronica 98.

1. Introduction
The project Ultima Ratio aims at formalisation and visualisation of argumentation for agents. An agent is defined
by a set of arguments and assumptions. Facing a particular
world, the agent’s beliefs may be inconsistent triggering a
rational monologue to deal with the situation. In this paper, we give a theoretical account on how arguments attacking each other are used for conflict resolution and show the
 We’d like to thank Bela Bargeld and Joachim B¨
ottger for helping with
the visualisation, Uwe K¨ussner and Manfred Stede for the audio output and
Dirk Weinreich, Tristan Thunnissen, Jens Eidinger, Martin Dahlhauser, Pik
You Chan, Tilo Meisel of Softimage Operation for the video.

1 www.soi.city.ac.uk/homes/msch/ultima/ars/screenshots.html

1

the execution event (the control flow) in the logic program.
While visualizing the current state of execution of the logic
program can and has been done by tree structures, our approaches mainly differs in the dynamics of the presentation.
Rather than only changing attributes of the visualization
(such as color of an argument) in a more or less static view,
we generate an interactive animation of the whole process.
The goal of this animation is to enable users to navigate
through the argumentation space as well as the argumentation process without losing the overall view.

efficiency reasons, but without loss of generality. We want
to guarantee that the truth value of revisables is independent
of any rules. Thus we can change the truth value of a revisable whenever necessary without considering an expensive
derivation of the default literal’s truth value.
Consider the excerpt of the third scene in the third act of
Shakespeare’s Hamlet below:
1
2

2. Formal Foundations of Argumentation
Argumentation is very useful metaphor to define the semantics of logic programs. Intuitively, argumentation semantics treats the evaluation of a logic program as an argumentation process, where a goal G holds if all arguments
supporting G cannot be attacked anymore. Thus, logic programming is seen as a discourse involving attacking and
counter-attacking arguments.
While argumentation in rhetoric comprises a variety of
figures such as arguments by example, by analogy, by the
consequences, a pari (arguing from similar propositions),
a fortiori (arguing from an accepted conclusion to an even
more evident one), a contrario (arguing from an accepted
conclusion to the rejection of its contrary), and the argument of authority, logic programming can be described in
terms of two figures: rebut and undercut [8]. The former
classifies an argument that leads to a contradiction under the
current believes and arguments, and the latter an argument
that falsifies the premise of one of the current arguments.

2.1. Formalizing Argumentation in Literature

3
4
5
6
7

Hamlet. [approaches the entry to the lobby]
Now might I do it pat, now a’is a-prayingAnd now I’ll do’t, [he draws his sword] and
so a’ goes to heaven,
And so am I revenged. That would be scanned:
A villain kills my father, and for that
I his sole son do this same villain send
To heaven...
Why, this is bait and salary, not revenge.

Hamlet is caught in a conflict. On the one hand he wants
revenge for his father being murdered. On the other he
knows that having revenge by killing Claudius, the murderer, is not possible since Claudius is praying at that very
moment and would go to heaven which contradicts the goal
of having revenge. The text can be formalised as follows:
a
b
c
d
e
f
g
h
i

prayingclaudius:
in heavenX   killsY ; X ;prayingX :
took revenge onX ; Y   killsX ; Y :
killedclaudius; king:
:took revenge onX ; Y   in heavenY :
goal revengeX ; Y   closeX ; Z ;
killedY ; Z ; not justifiedkilledY ; Z :
closehamlet; king:
?  goal revengeX ; Y ; not took revenge onX ; Y :
revisablekillshamlet; claudius; false:

We represent arguments as extended logic programs.
Definition 1 An extended logic program is a (possibly infinite) set of rules of the form L0 
L1 ; : : : ; Ll ; notLl +1 ; : : : ; notLm 0  l  m where each
Li is an objective literal (0  i  m). An objective literal
is either an atom A or its explicit negation :A. Literals
of the form not L are called default literals. A subset R
of default literals which do not occur in the head of a
rule is called revisables. The set of all objective literals is
called the herbrand base H P. A rule with head L0 = ?
is called integrity constraint. The symbol ? stands for
falsity. A program P is inconsistent iff P j= ?, otherwise it
is consistent.
While objective literals have a fixed truth values, default
literals have a default truth value. For revisables this truth
value may be changed. The limitation of revisability to default literals which do not occur as rule heads is adopted for

In line 1, Hamlet realizes that Claudius is praying. This
is represented as a fact (a). In line 2, Hamlet continues
that Claudius would go to heaven if killed while praying.
Formally, this is an instantiation of the general rule (b). In
line 3, Hamlet states that killing Claudius satisfies Hamlet’s
desire for revenge. Or more general (c). In line 4, Hamlet starts another line of thinking by mentioning the fact
that Claudius killed Hamlet’s father, the king (d). In line
7, Hamlet finds that he does not have revenge if he sends
Claudius to heaven (e). Beside this direct translation of
Hamlet’s monologue to logic, we have to add further facts
and rules which are mentioned throughout the scenes before
or which are given implicitly. First of all, we need a rule to
express when someone wants revenge (f). I.e. X wants to
take revenge on Y if Y killed a person Z being close to X,
and the killing is not justified. Left implicitly in the piece
is the fact that Hamlet and his father are close to each other
(g). To specify conflicting goals we use besides facts and

rules integrity constraints. In this scene we state formally
that it is contradictory to want to take revenge and not have
it (h). Finally, we have to specify the assumptions Hamlet is
willing to change to solve conflicts. For this scene, Hamlet
adopts the default assumption of not killing Claudius. I.e.
(i) states that Hamlet killing Claudius is assumed false initially, but may be changed in the course of argumentation.
To formalise human argumentation as shown in the
previous example one has to detect first the assumptions
the protagonist is willing to change. These assumptions
are made revisable and are assigned to a default value.
Secondly, the problem domain has to be modeled in
terms of facts and rules. The two negations (not and
:) are important for this modeling task. For example,
not justifiedkilledX ; Y  expresses that a murder is not
justified as long as there is no explicit proof for the contrary.
In contrast, :took revenge onX ; Y   in heavenY  states
that there is explicit evidence that X did not take revenge
on Y if Y ends up in heaven. Besides the three ingredients
of revisable assumptions, facts, and rules, we have to define
which conclusions are contradictory. Naturally, we say
that, for example, took revenge onX ; Y  and its explicit
negation :took revenge onX ; Y  are contradictory, i.e.
?  took revenge onX ; Y ; :took revenge onX ; Y ,
but for convenience we are at liberty to define further conflicts such as, for example, ? 
goal revengeX ; Y ; not took revenge onX ; Y :
Formally, we define an argument as follows:
Definition 2 Let P be an extended logic program. An argument for a conclusion L is a finite sequence A = rm ; : : : rn
of ground instances of rules ri 2 P such that 1. for every
n  i  m, for every objective literal L j in the antecedent of
ri there is a k i such that L j is the consequent of rk . 2. L
is the consequent of some rule of A; 3. No two distinct rules
in the sequence have the same consequent. A sequence of
a subset of rules in A being an argument is called subargument.
Example 3 An
argument
for
the
conclusion
goal revengehamlet; claudius is the sequence:
goal revengehamlet; claudius 
closehamlet; king;
killedclaudius; king;
not justifiedkilledclaudius; king;
closehamlet; king  true;
killedclaudius; king  true;

2.2. The Process of Argumentation
There are two ways of attacking an argument for a conclusion L. We may prove that the argument for L leads
to a contradiction since there is also proof for :L. Such
a counter-argument is called rebut. The second possibility

is to attack the premises of the argument for L. If L’s argument is based on an assumption not L0 we can attack the
argument with a counter-argument for L0 . Such an attack is
called undercut.
Definition 4 Let A1 and A2 be two arguments, then A1 undercuts A2 iff A1 is an argument for L and A2 is an argument with assumption not L, i.e. there is an r : L0 
L1 ; : : : ; Ll ; not Ll +1 ; : : : ; not Lm 2 A2 and a l + 1  j  m
such that L = L j . A1 rebuts A2 iff A1 is an argument for L
and A2 is an argument for :L. A1 attacks A2 iff A1 undercuts
or rebuts A2 .
Example 5 The
argument
took revenge onhamlet;
claudius  killshamlet; claudius can be attacked by the
rebut
:took revenge onhamlet; claudius 
in heavenclaudius;
in heavenclaudius 
killshamlet; claudius; prayingclaudius;
prayingclaudius  true:
Definition 6 An argument is coherent if it does not contain
subarguments attacking each other. A set Args of arguments
is called conflict-free if no two arguments in Args attack
each other.
Definition 7 Let A1 and A2 be two arguments, then A1 defeats A2 iff A1 is empty and A2 incoherent or A1 undercuts
A2 or A1 rebuts A2 and A2 does not undercut A1 . A1 strictly
defeats A2 iff A1 defeats A2 but not vice versa. A1 is acceptable wrt. a set Args of arguments iff each argument
undercutting A1 is strictly defeated by an argument in Args.
Our notion of acceptability deviates from Prakken and
Sartor’s definition [8] where an argument A1 is accepted if
each defeating argument is accepted. Our notion is more
credulous and leads to more intuitive results.
Example 8 Consider the program P = fa  not b; b 
not a; :ag, then :a and b  not a are acceptable, whereas
a  not b is not. For Prakken and Sartor’s definition of
acceptability there is no acceptable argument which contradicts the intuition of :a being a fact.
Definition 9 Let P be an extended logic program and
S be a subset of arguments of P, then FP S =
fA j A is acceptable wrt. Sg is called characteristic function. A is justified iff A is in the least fixpoint of FP . A is
overruled iff A is attacked by a justified argument. A is defensible iff A is neither justified nor overruled.
Argumentation is closely related to logic programming.
It turns out that the above argumentation framework is eqivalent to WFSX [1], a semantics for extended logic pro-

grams. While the above fixpoint definition of justified, overruled, and defensible arguments is suitable to give a declarative semantics to argumentation, WFSX provides an efficient operational semantics with a top-down derivation procedure. In Ultima Ratio, we use this derivation procedure
and annotate the proof on the fly. Additionally, we compute
revisions, which remove conflicts between arguments by
adapting the involved assumptions appropriately. To compute revisions we use REVISE 2.4 [3]. The derivation procedure and contradiction removal algorithm are extended to
generate proof traces which are then used for visualisation.
Definition 10 The traces are composed of the following
speech-act-like tags:
1. Derivation of default negated literals not L is accompanied with the tags propose notL entering the definition of not L and accept notL if the proof for L fails and
reject notL otherwise.
2. If a revisable Lis encountered during the proof the
tags revisable assumedL and revisable not assumedL
are generated depending on the current truth value of L
3. If a literal L is part of a loop the tag loopL is generated
4. If L is a fact then factL is generated
5. If the proof involves rules for a goal L, then ruleL; Body
indicates the rule used in the proof and no ruleL that there
is no rule. If a rule’s body is proven rule succeedsL; Body
is generated and otherwise rule failsL; Body
6. If a partial revision R is assumed then assumeR
is generated and if R turns out to be a solution
assume solutionR otherwise assume closedR
Having developed the argumentation theory we turn now
to the functionality of the implemented system.

3. Visualizing Extended Logic Programs
Kowalski’s phrase “Algorithm = Logic + Control” has
some interesting implications for visualizing logic programs. Logic, interpreted as formulating premises and
queries can be seen as static since it forms a well-founded
argumentation space in which the actual proof for a given
query is found. Control means the process of deriving a solution and is inherently dynamic since it requires inference,
backtracking etc.
Previous work such as [4], [2] and [6] has primarily focused on visualizing the control flow in an AND/OR tree
by displaying success of failure of rules and the associated
unification process. While these approaches are well suited
for debugging or analyzing the execution of a logic program
they are not very “visually pleasing” and require a good portion of knowledge about the execution of logic programs.
Also, the detection and removal of contradictions, a central
point of extended logic can not be visualised easily by the
techniques used so far.

In contrast, Ultima Ratio aims at visualizing the process
of argumentation in a form understandable by human beings
even without basic knowledge about the foundations of formal logic. To achieve this goal, we use the construction of
proof trees. The construction is a representation of an argument (the logic) and the execution event (the control flow)
in the logic program. While visualizing the current state of
execution of the logic program can and has been done by
tree structures, our approaches mainly differs in the dynamics of the presentation. Rather than only changing attributes
of the visualization (such as color of an argument) in a more
or less static view, we generate an interactive animation of
the whole process. The goal of this animation is to enable
users to navigate through the argumentation space as well
as the argumentation process.

3.1. Argumentation Space
As has been mentioned above, a significant place to start
the visualization with is the argumentation space. It is more
or less the background for the reasoning taking place during
the process of argumentation. This space, although containing sets of pre-defined (i.e. static) facts and rules, may be
used in different contexts and therefore lead to different results. To emphasise this non-absolute behaviour, the visualization of an argumentation space is not static – it provides
a dynamic background on which the actors (the synthetic
agents) perform its “discussion”.
Arguments, seen as sequences of rules, are arranged hierarchically to communicate the dependencies between the
argument and its sub-arguments. For efficient use of screen
real estate its layout is arranged in 3D, allowing to focus
on the argument at hand while still having contextual information of the overall information flow. This type of visualization, also known as implicit distorting views [7], has
been used to visualise complex nested structures by exploiting perspective transformations of 3D objects on 2D screens
[5, 9].

3.2. Argumentation Process
Due to the limited number of execution events in Definition 10, visualising the dynamics of an argumentation
process is done using a forest of trees for the different argumentation processes based on different assumtions and
coloured nodes representing arguments’ conclusions.
The tags in Definition 10 are visualised as follows:
The tag assume indicates the generation of a new argumentation tree.
Once the tree is fully processed assume closed and
assume solution indicate a derivation of a conflict or
not. This event is represented by two rotating, orange

Figure 2. Cascades of Doubt: Should Hamlet
take revenge on Claudius?
Figure 1. Ultima Ratio’s User Interface

ellipses. If a conflict is derived (assume closed) the
ellipses intersect, otherwise they do not.
The structure of the tree is determined by the tags rule
creating internal nodes in the tree and f act creating the
leaves of the argumentation tree. Initially, the tree is
constructed rapidly moving from the root to the leaves.
All nodes are left open and rotate indicating that it is
not yet known whether they are valid or not.
In the next phase the tree is traversed bottom-up and
nodes are filled in yellow if they form a valid conclusion (rule succeds) or blue otherwise (rule f ails,
no rule).
Interestingly, users favoured the visualisation combining
a fast top-down traversal followed by a slow and detailed
bottom-up traversal to pure top-down or bottom-up. This is
very remarkable since this corresponds technically exactly
to the magic-set algorithm used in deductive databases.
This algorithm combines the advantages of top-down and
bottom-up evaluation to improve performance and appears
to capture closely human reasoning.

4. Ultima Ratio’s Functionality
Figure 1 shows Ultima Ratio’s graphical user interface
whose form is derived from a compass. At the rim of the
compass one can select menus which appear as a sphere.
With a joystick the user rotates the sphere until the entry
of choice is in the centre. Via the compass menu the user
selects one of the following functions:
1. Cascades of Doubt - Struggling Agents. The user selects an agent according to the author’s version. Currently
the knowledge base contains Shakespearce’s Hamlet, Ilsa

and Rick in Casablanca, Siegfried, Krimhild, Brunhild, Hagen and Etzel of the German saga Nibelungenlied, Euripides’ Medea, Moli`ere’s Don Juan, the artist Duchamp and
his readymades, Robocop, and Macchiavelli. The arguments for these agents are online.2
Consider Hamlet, for example. The argumentation process which is represented by a proof tree is visualised as
a 3D tree. Premises which are not yet proven are represented by rotating circular rims. If they are successfully
proven an orange disc moves to the rotating rim and fills it
out (see Figure 2). If the proof failed the disc is blue. If
the argumentation finally results in a conflict two rotating
and intersecting ellipses appear at the conflicting nodes. If
the potential conflict did not occur the ellipses do not intersect. The user can navigate in the argumentation space
or switch to auto-pilot. For the auto-pilot, we combined
top-down and bottom-up derivation. Technically, the system performs the proof top-down, but users felt more comfortable with a bottom-up proof starting with the facts and
leading to a conflict in the end. We have combined both by
the camera moving directly from the root of the proof tree
to the leaves and then moving step by step bottom-up from
the facts.
2. Crossovers - Tracing Motifs. Crossovers allow to trace
motifs in the complete argumentation space. In the online knowledge base3 one can see, for example, that the
arguments for revenge occurring in Hamlet are also part
of the Nibelungenlied and of the agent property “revengeful”. Similarly, the topic of offences connects Don Juan
to Medea. Visually, the tree structure of the arguments is
shown and different regions in the 3D space correspond to
different agents. The same argument occurring in different
regions is connected by a bridge of grey cubes (see Figure
3) leading from one agent to another. Besides this 3D visu2 http://www.soi.city.ac.uk/homes/msch/cgi/aec/kbwww/cod.html
3 http://www.soi.city.ac.uk/homes/msch/cgi/aec/kbwww/co.html

Figure 5. Crossovers in 3D

Figure 3. Crossovers: Hamlet and Krimhild
share the revenge motif

5. Conclusion
Ultima Ratio is a system for formal argumentation and
its visualisation. Ultima Ratio allows to specify an agent
and the world it is situated in as an extended logic program.
Using argumentation, it is possible to detect and remove
conflicts the agent is facing. Given the agent’s arguments
and a world it faces, Ultima Ratio unfolds a process of argumentation in which arguments and counter-arguments are
exchanged to detect conflicts and remove them. The visualisation enables users to navigate through the argumentation
space and the argumentation process which is constructed
dynamically as the argumentation process evolves.

References

Figure 4. Crossovers in 2D

alisation, the above online knowledge base provides and an
applet showing the dependencies of arguments
3. War of Convictions - Arguments as Forces. The war
of conviction function focuses on conflicts in general, independent of their instances for particular agents and worlds.
The online knowledge base4 lists all conflicts and arguments together with cross-references showing on which arguments conflicts are based and how arguments support and
attack each other.
4. Reasoning Running Wild. In contrast to the above logical modes, Ultima Ratio also provides a visual metaphor
for reasoning running wild: The proof trees move very fast
so that their structure is not graspable anymore, additionally
the user’s head tracker is switched on leading to a distorted
view depending on the user’s head movements.
4 http://www.soi.city.ac.uk/homes/msch/cgi/aec/kbwww/woc.html

[1] J. J. Alferes and L. M. Pereira. Reasoning with Logic Programming.
(LNAI 1111), Springer-Verlag, 1996.
[2] M. Brayshaw and M. Eisenstadt. A practical graphical tracer for
prolog. Intl. J. of Man-Machine Studies, 35(5):597–631, 1991.
[3] C.V. Dam´asio, L.M. Pereira, and M. Schroeder. REVISE: Logic
programming and diagnosis. In Proc. of LPNMR97. LNAI 1265,
Springer–Verlag, 1997.
[4] A.D. Dewar and J.G. Cleary. Graphical display of complex information within a prolog debugger. Intl. J. of Man-Machine Studies,
25(5):503–521, 1986.
[5] J. D. Mackinlay, G. G. Robertson, and S. K. Card. The perspective
wall: Detail and context smoothly integrated. In Proc. of Conf. on
Human Factors in Computing Systems. ACM, 1991.
[6] E. Neufeld, A. Kusalik, and M. Dobrohoczki. Visual metaphors for
understanding logic program execution. In Proc. of Graphics Interface, pages 114–120, May 1997.
[7] E. G. Noik. A space of presentation emphasis techniques for visualizing graphs. In Proc. of Graphics Interface, pages 225–234, May
1994.
[8] H. Prakken and G. Sartor. Argument-based extended logig programming with defeasible priorities. J. of Applied Non-Classical Logics,
7(1), 1997.
[9] G. G. Robertson, J. D. Mackinlay, and S. K. Card. Cone trees: Animated 3D visualizations of hierarchical information. In Proc. of
Conf. on Human Factors in Computing Systems. ACM, 1991.
[10] M. Schroeder. An efficient argumentation framework for negotiating
autonomous agents. In Proc. of MAAMAW99. Springer-Verlag, 1999.


How to Draw Clustered Weighted Graphs using a Multilevel Force-Directed
Graph Drawing Algorithm
Romain Bourqui, David Auber, Patrick Mary
LaBRI, Universit´e Bordeaux I, France
{romain.bourqui, david.auber, patrick.mary}@labri.fr
Abstract
Visualization of clustered graphs has been a research
area since many years. In this paper, we describe a new
approach that can be used in real application where graph
does not contain only topological information but also extrinsic parameters (i.e. user attributes on edges and nodes).
In the case of force-directed algorithm, management of attributes corresponds to take into account edge weights. We
propose an extension of the GRIP algorithm in order to
manage edge weights. Furthermore, by using Voronoi diagram we constrained that algorithm to draw each cluster in a non overlapping convex region. Using these
two extensions we obtained an algorithm that draw clustered weighted graphs. Experimentation has been done on
data coming from biology where the network is the genesproteins interaction graph and where the attributes are gene
expression values from microarray experiments.

1. Introduction
Visualization of clustered graphs has been a research
area since many years [7, 27, 14, 23, 12, 19]. However, only
few algorithms are able to manage edge weights. The main
interest in managing edge weights is that we can simultaneously visualize a clustering induced by a topological algorithm or given by a taxonomy and still have a correlation
between Euclidian distances in the drawing and weights of
edges in the graph.
In that work, we wanted to visualize genes-proteins interaction network and to be able to see both the relations,
between genes and proteins, and the result of their expression according to the results of experimentation on the level
of expression of each gene/protein on a micro array. The
main difficulty of that problem is first the size of the network and, as we can see in figure 1, its connectivity that produces a mess effect when we draw it with a force directed
algorithm or with a multi dimensional scaling algorithm.
Such a problem is frequent in biological graph, where the

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

number of connections is often really large compare to the
number of nodes and because a lot of these networks are
scale free (i.e. the distribution of degree follows a power
law). To give a useful representation of these data we need
to be able to first decompose the data into groups and if necessary to decompose each group into sub-group and so on.
That process of decomposition leads to a well-known structure called a cluster tree. It exists several ways of building
such a decomposition [20, 22]. Moreover, when one works
with real data, one often has domain specific decomposition
(i.e. taxonomy) that one can use to produce a more meaningful cluster tree.
The challenge of visualization of such networks is thus
to be able to layout the graph according to a cluster tree
and to take into account the strength of the interaction according to experimental results. All the requirements given
above lead to an algorithm that should respect the following
constraints :
1. forbid groups overlap in order to easily identify
groups,
2. preserve groups inclusions in the drawing, to see the
hierarchy produced by the clustering algorithm,
3. have a drawing in which each group can be surrounded
by a convex polygon, and
4. respect weighted graph distances using energy minimization function.
We experiment our technique on genes-proteins interaction network of the fly (see figure 1). In figure 1 (right), one
can see the result obtained using our algorithm. We first
simplify the data by removing vertices of degree 1 and repeating this process until there is no more vertex of degree 1
(that method is called peeling [25]). Removed nodes can be
”easily” added in the drawing at the end of the algorithm.
Then, we decompose the data by constructing “balls” of
similar vertices (i.e. aggregation of connected nodes with
similar values) and repeat this decomposition process into

Figure 1. (left) Force directed layout of a protein-genes interaction graph, scale free nature of the
data gives a messy effect, (middle) clusters obtained using an aggregative method are highlighted
using convex hulls (right) drawing of the same graph using our algorithm.

these “balls”. Finally, we draw the clustered graph using
our drawing algorithm. To improve visibility in the final
drawing, we use edge bundling [13]. Inter-cluster edges
are drawn so that if edges link the same clusters, they are
”merged” in the drawing. This operation enables to solve
the problem of edge cluttering in the final drawing.
This paper is organized as follow. In section 2, we introduce the terminology used in this paper. Then, we present
related approaches to visualize similar graphs in section 3.
In section 4, we give an overview of our method and finally
in section 5, we give details of our algorithm.

In the following, we call height of the clustered graph the
height of the hierarchy tree T .

2. Terminology

In a clustered graph C = (G, T ), to each level i of T can
correspond a quotient graph QG where VG is the partition
represented by nodes of level i of T .
For a weighted graph G = (V, E, w) and one partition (C1 , ..., Ck ), we define the weighted quotient graph
QG = (VG , EG , w ) as follow :

In this section, we present the definition and notion used
in this article.
Let G = (V, E) be a simple graph (without multi-edge and
self-loop), where V is the set of vertices and E the set of
edge, and |V |=n and |E|=m. An edge-weighted graph Gw
is defined as follow : Gw = (V, E, w) where V and E are
respectively the sets of vertices and edges, and w: E → R,
is the weight of an edge. In this paper, we only consider
positive weights. Let S ⊆ V , the subgraph of G induced by
S is G[S] = (S, ES ) where ES = {e = (u, v) ∈ E such
that u ∈ S and v ∈ S}.
Clustered graph:
As defined in [7], a clustered graph C = (G, T ) consists
of a graph G and a rooted tree T such that the leaves of T
are exactly the vertices of G. Each node v of T represents a
cluster of vertices of G that are the leaves of the subtree of
T rooted at v. The root of T represents the whole graph G.

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

Quotient graph:
In [24], R. Brockenauer and S. Cornelsen define the quotient graph QG = (VQ , EQ ) for a partition (C1 , ..., Ck ) of
G = (V, E) as :
• VQ = {C1 , ..., Ck } and
• (Ci , Cj ) ∈ EQ iff i = j and ∃u ∈ Ci and v ∈ Cj such
that (u, v) ∈ E.

• VQ = {C1 , ..., Ck } and
• (Ci , Cj ) ∈ EQ iff i = j and ∃u ∈ Ci and v ∈ Cj such
that (u, v) ∈ E.
• w

: EG → R and ∀e = (Ci , Cj ) ∈ EG :

w (e)=

u∈Ci ,v∈Cj ,(u,v)∈E

w((u,v))

|{u∈Ci ,v∈Cj ,(u,v)∈E}|

In this paper, we call metanode, a node of the quotient graph
that represents a cluster Ci in the original graph.
Weighted graph distances:
In this article, we have to compute graph distances in a
weighted graph G = (V, E, w). Let u and v be two vertices

of G and let p1 , p2 , ..., pl , where pi = (e1 , e2 , ..., er−1 , er )
is a sequence of distinct adjacent edges of G and e1 (resp.
er ) is adjacent to u (resp. v), be all paths between u and
v, then weighted graph distance between u and v in G is :
distG,w (u, v) = min1≤i≤l { e∈pi w(e)} (i.e. the shortest
path between u and v).

collapsing. Each time a cluster is expanded, they draw the
lower level using an optimized version of [2] (which is a
force-directed placement algorithm), time computation of
this algorithm allows an efficient interaction/navigation.

In this article, we use the following notations : G is
the connected edge-weighted graph to draw, C is the corresponding clustered graph, Qi is the quotient graph corresponding to level i of C and T is a tree spanner of G.

In [12, 19], the authors present top-bottom force-directed
algorithms that take into account edges weights to draw
clustered graphs. After drawing a level i (using forcedirected algorithm), they compute a Voronoi diagram of this
level. For a given node v of level i, children of v in the hierarchy tree are drawn in the region (Voronoi cell) of v. This
process is repeated until the whole graph is drawn.
In [12], to force the set S of children of a node v to stay
in v’s cell, the authors first compute the placement of the
subgraph G[S] induced by S and then re-scale positions of
nodes of S in the Voronoi cell of v using a simple geometric transformation. This method leads to good results. The
problem is that the authors do not consider that nodes of
G[S] are forced to stay in the cell of their parent while computing force-directed placement. After several iterations
of the force-directed algorithm, nodes of G[S] could have
”weak” interactions, whereas after re-scaling in the cell,
they should have ”strong” repulsive forces.
In [19], the process is almost the same as in [12]. The main
modification is that, to improve time complexity, the authors
only consider forces applied on a node v (of level i) by v’s
siblings (i.e. nodes represented by the same metanode as cv
in level i − 1). As for a given level of the hierarchy, intercluster edges are not considered to compute forces applied
on a node, this process may conduct to have long edges.

3. Related Works

4. Our approach

In [7], P. Eades and Q.-W. Feng introduce the definition
of clustered graphs and two main ways to represent these
kind of graphs. First, they present plane drawings (i.e.
G is drawn as points and curves in the plane) for which
they give two visualizations : straight-line convex and
orthogonal rectangular drawings. Second, they explain
multilevel drawings : a sequence of plane drawings, one for
each level i in the hierarchy and a 3-dimensional drawing
of the tree hierarchy (i.e. a superposition of planes of each
level and edges of the tree between these planes).
In [27, 14, 23], the authors give force-directed methods
to visualize clustered graphs. In [14, 23], the technique
allows navigation in the resulting drawing, while in [27],
X. Wang and I. Miyamoto integrate a force-directed method
and a constraint solver to improve the layout quality.
In [15], the authors give a way to visualize very large
graph (i.e. graph that cannot be totally loaded into RAMMemory). They propose a visualization similar to the
approach of [23]. They also present several techniques
of interaction and navigation, like cluster expanding or

In this section, we present an overview of our technique.
Our algorithm is based on the method presented in [12].
This is a top-bottom multilevel drawing algorithm. We first
compute the layout of the upper level graph of the hierarchy and then go down to draw lower levels, until the whole
graph has been drawn. The input of our algorithm is a clustered graph with height h. Figure 2.a gives an example of
graph and the figure 2.b gives a possible hierarchy tree of
that graph with h = 3.
First of all, we draw the top level quotient graph Q1 using a force-directed algorithm that takes edges weight into
account. We obtain the layout of the highest level of abstraction of G. Figure 2.c gives the result of this step applied on the clustered graph presented in figures 2.a and b.
In order to guarantee the constraints 1, 2 and 3 (presented
in section 1), we must draw all nodes of G represented by
a unique metanode in Q1 in a convex region. Moreover, we
must ensure that this region do not overlap other regions.
To determine these regions, we compute the Voronoi diagram [26] of the quotient graph Q1 . Figure 3.a shows the

k-spanner:
For a graph G = (V, E) and k ≥ 1, a subgraph H =
(VH , EH ) is a k-spanner of G if :
• VH = V and EH ⊆ E and
• ∀u, v ∈ V : distH (u, v) ≤ k × distG (u, v)
And a tree k-spanner T of G, is a k-spanner of G that is a
tree. For a weighted graph, k-spanner (and tree k-spanner)
is defined using weighted graph distances.
Voronoi diagram:
Let P = {u1 , u2 , ..., un } be a set of n distinct points
in a 2-dimensional Euclidean plane, called the sites. The
Voronoi diagram of P is defined as the subdivision of the
plane into n cells, one for each site in P . We note cell of
ui by V or(ui ). V or(ui ) contains all the points at least as
close to ui as to any other site.

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

Figure 2. (a) Left, an example of graph; (b) Center, an example of tree hierarchy of the graph presented in (a), in this example the height of the clustered graph is 3; (c) Right, drawing of the quotient
graph Q1 corresponding to level 1 of the clustered graph presented in (a) and (b).

computed regions of the graph given in figure 2.c. It allows
us to know the exact convex regions in which we can draw
nodes represented by a metanode of Q1 .
Next, our algorithm draws quotient graphs of each
level i, 1 < i ≤ h using the result of level i−1. To draw Qi ,
we draw each subgraph G of Qi represented by a metanode uG in Qi−1 . The drawing algorithm is the same forcedirected algorithm as for Q1 . Positions of nodes of each
subgraph G are initially set to the position of uG . During
the algorithm, nodes’ positions are forced to stay in the cell
of uG . In figure 3.b, one can see the result of this step on the
metanode 1 of figure 3.a. Thus, our algorithm is a trade-off
between [12] and [23] : we use a similar approach to [12],
but they consider that inter-cluster and intra-cluster edges
have same influence on the layout, whereas we consider that
intra-cluster edges are at least as important as inter-cluster
edges. This is similar to what is done in [23] when the authors add a virtual node in each cluster. Finally, new cells
are computed in order to be able to apply our technique recursively. Figure 3.c shows the drawing of the graph Q2
computed by our method, this layout will then be used to
draw the graph Q3 .

5. Algorithm
In this section, we givre details of the main steps described above. First, we present how to draw first level of
the hierarchy, and then, how to draw all other levels.

5.1. Drawing quotient graph Q1
The algorithm presented in [11] and later improved
in [10] has two main steps: first the algorithm computes
a hierarchy of the graph, then for each level an intelligent

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

placement and a force-directed algorithm are performed.
In these two steps, graph distances must be computed.
Thus, computation time increases when considering edgeweighted graphs. In order to take edges weight into account,
we use a tree spanner T of the graph to ”approximate” graph
distances. Below we give the method used for computing a
tree spanner, then we describe steps of [11, 10] and how to
adapt them to edge-weighted graphs, and finally, we present
the technique used to prevent cluster overlaps.

5.1.1. Tree t-spanner computation
A tree t-spanner is a spanning tree that approximates
graph distances with a factor t (cf. section 2). Many results have been found on tree t-spanner (for an overview
see [4, 3]). For any fixed t > 1, the problem of determining
the existence of a tree t-spanner in a weighted graph is NPcomplete. Due to the NP-completeness of this problem, we
must use an heuristic.
Our heuristic works as follows : we search a spanning tree
such that graph distances between any two nodes are as
short as possible. To compute such a spanning tree, we use
the well known Kruskal’s algorithm [18]. However, minimum spanning tree computed with weight w does not necessary give a good spanner, we have to make a trade-off
between weights and graph topology. To achieve this, we
use strength metric (describe in [1, 5]) on edges. This metric counts the number of cycles of size three or four an edge
belongs to. The intuition we have is that the less cycles
(of size three or four) an edge belongs to, the more it belongs to a shortest path. For instance, an isthmus e (i.e. an
edge such that G = (V, E \ {e}) is not connected) has
a strength equal to zero, and e is in all shortest paths between any two nodes of different connected components of
G = (V, E \ {e}). Our spanner T is obtained by comput-

Figure 3. (a) Left, in green, Voronoi diagram of vertices of the graph Q1 of figure 2.c; (b) Center, result
after drawing subgraph corresponding to the metanode 1 of figure (a); (c) Right, result after drawing
the quotient graph Q2 corresponding to level 2 and computation of its regions.

ing a minimum spanning tree with the metric ms defined as
follow : ∀e ∈ E : ms (e) = w(e) × strength(e).

5.1.2. Maximal Independant Set Filtering
The first step of the algorithm of [11, 10] computes a
of the set
Maximal Independent Set Filtration (MISF)
: V0 ⊃ V1 ⊃ V2 ⊃ ... ⊃ Vk ⊃ ∅
of vertices V of G,
where V0 = V and ∀0 < i ≤ k, Vi is a maximal subset
of Vi−1 such that for all pairs u, v of vertices of Vi the
graph distance between u and v is greater or equal to 2i .
The algorithm then places each node of each filtration set
beginning with the smallest one.

ν

ν

Computing directly this filtering on weighted graph has
no significance. For instance, if we consider a large graph
having very small weights of edges, we could have only one
vertex in V1 (if all graph distances to this node are less than
2). The optimal solution of this problem is to find graph distances (of each level) that optimize the distribution of the
vertices in levels. Finding these distances is not straightforward.
Our method consists of computing the MISF on our tree
spanner T without considering edge weights. In T , “long”
edges of the graph have been removed if a shorter path between its two extremities exists. Thus, two nodes u and v
linked by one of these edges are no more considered as adjacent, whereas they are adjacent in G. In G, u (resp. v)
would represent v (resp. u) in the first filtration set V1 . At
the opposite, in T , u (resp. v) cannot represent v (resp. u)
in V1 since unweighted graph distance between u and v is
greater than 1.

5.1.3. Placement
In the second step of [11, 10], the process first places
nodes of Vk and then each filtration set Vk−1 , Vk−2 , ..., V0 .
For each level, the placement is splited in two phases : an

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

intelligent initial placement (i.e., nodes are placed closed to
theirs final positions), and then a refinement placement that
uses a force directed algorithm (either Kamada-Kawai [17]
or Fruchterman-Reingold [9] algorithm).
Intelligent Placement :
For the smallest set Vk , the authors consider that |Vk | = 3
(if it is not the case, nodes of Vk−1 are included in Vk ). Let
u1 , u2 and u3 be the three nodes of Vk , they are placed on a
triangle such that :

 distR (u1 , u2 )=distG (u1 , u2 )
distR (u1 , u3 )=distG (u1 , u3 )

distR (u2 , u3 )=distG (u2 , u3 )
where distR (u, v) is the Euclidean distance between u and
v.
For each other level i, 0 ≤ i < k, let u be a vertex of Vi , and
v1 , v2 and v3 be the three closest and already placed neighbors of u, the authors lay out u at the barycenter of v1 , v2
and v3 using graph distances between u and v1 , v2 and v3 as
weights.
That method can be directly extended to edge-weighted
graphs by using distG,w instead of distG .
Refinement :
In order to refine placement, the authors use force
directed algorithms.
For each level i, 1 ≤ i < k, they use the well known
Kamada-Kawai algorithm [17]: this algorithm takes into
account graph distances in the computation of the forces.
For the last filtering set V0 , computing all graph distances
would take too much time and/or memory space, so they
use the Fruchtermann and Reingold algorithm [9] that uses
only Euclidean distances. For a vertex v of Vi , the authors
compute forces between v and its avgDeg(G).n
closest
|Vi |
neighbors in Vi (where avgDeg(G) is the average degree

Figure 4. (a) Left, in blue Voronoi diagram of the subgraph is computed; (b) Right, new cells are
computed.

of G). It enables them to improve time computation. The
method used to find this closest neighborhood is to apply a
BFS (Breath-First Search) algorithm.
For an edge-weighted graph, it is not possible to use this
method because closest neighbors are not necessary those
found using a BFS. In the worst case, to find the closest neighborhood of a given vertex, we have to compute
weighted graph distances between it and all other nodes. It
conducts to have a O(mn+n2 log(n)) time complexity and
O(n2 ) space complexity by solving the well-known all-pair
shortest paths problem [6, 21], or a O(nm+n2 log(n)) time
complexity and O(n) space complexity by solving n singlesource shortest paths problem [8, 16]. For an overview on
graph distances computation, reader can refer to [28]).
Our algorithm computes the nearest neighbors using Dijkstra’s algorithm on each node of the tree spanner, so that the
time complexity is O(n2 log(n)) and the space complexity
O(n).

5.1.4. Regions computations
Our algorithm has to force nodes of a cluster to be close
to each other (cf. constraint 1). Last step of the quotient
graph drawing is the computation of its Voronoi diagram.
The cell of each metanode uc is the region in which nodes of
G represented by uc in the quotient graph have to be placed
(for instance, see figure 3.a). Moreover, it ensures that each
cluster can be surrounded by a convex hull (cf constraint 3).
Indeed, even if a Voronoi cell is infinite, one can consider
that this is a convex polygon where a segment has been removed. Thus, the use of a Voronoi diagram ensures that we
are able to compute independent convex hulls for all clusters of a given level.

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

5.2. Drawing quotient graph Qi
The process presented in this section is repeated for each
level of the clustering hierarchy (i.e. until the whole graph
G is drawn). To draw the quotient graph corresponding to
level i, we first place its nodes at the same position than their
father in the hierarchy. And then, we consider subgraphs
Guc represented by metanode uc in level i − 1 individually.

5.2.1. Drawing one subgraph Guc
To draw a subgraph Guc , we use the algorithm presented
in section 5.1. In order to take into account distances between nodes of Guc and nodes of Qi , we modify forcedirected algorithms. When computing forces applied on a
node, we consider a constant number of nodes of Qi that do
not belong to Guc . It enables us to improve the layout by
decreasing the number of abnormally ”long” edges.
During force directed algorithm, we constraint nodes in
their parent’s cell at each iteration of the algorithm. Each
time a node is moved outside its parent’s cell, we force the
node to stay in it. Using this method, we give more importance to intra-cluster than to inter-cluster interactions. This
technique is ”equivalent” to those used by Eades and Huang
in [23] when they add a virtual node and virtual edges in
each cluster to prevent overlap.

5.2.2. Voronoi diagrams computation
As in section 5.1, we then compute the Voronoi diagram
of each subgraph, to ensure that nodes represented by a
metanode in the subgraph are drawn close to the position of
the metanode (see figure 4.a). Finally, to ensure that these
nodes are drawn in the region of all its ancestors, we constraint Voronoi diagram of the subgraph in the cell of the
metanode that represents this subgraph (see figure 4.b).

6. Conclusion and future works
In this paper, we presented an algorithm to lay out clustered weighted graphs. Our method addresses a challenging problem which consists in simultaneously visualizing
groups inclusions avoiding overlap and respecting weighted
graph distances. This leads to pleasant drawings that ease
the identification of groups and of adjacency relations.
Moreover taking into account lengths of edges in the drawing algorithm allows to visually recognize weights of the
edges.
We presented an experimentation of our method on real
data coming from biology. Usually, due to their scale free
property, drawing of such data is messy. We have shown
that using our method can improve significantly the readability of interaction graphs.
In the near future, we plan to improve graph distance
approximation to obtain a drawing in which Euclidean distances are closer to graph distances. This could be done by
computing several tree spanner and considering the shortest
distance as our approximation. Moreover, we are doing experiments on different kind of scale free network in order to
generalize that approach to that class of graphs.

Acknowledgements
The authors would like to thank Christian N´eri who gave
us the data coming from his own researches in biology.

References
[1] D. Auber, Y. Chiricota, F. Jourdan, and G. Melanc¸on. Multiscale visualization of small world networks. In S. C. North
and T. Munzner, editors, IEEE Symposium on Information
Visualization, pages 75–81. IEEE, 2003.
[2] J. Barnes and P. Hut. A hierarchical o(n log n) force calculation algorithm. Nature, 324(4):44–449, 1986.
[3] L. Cai and D. Corneil. Tree spanners. SIAM Journal on
Discrete Mathematics, 8(3):359–387, 1995.
[4] L. Cai and D. G. Corneil. Tree spanners: an overview. In
Proceedings of the Twenty-Third Southeastern Conference
on Combinatorics, Graph Theory and Computing 1992,
Congressus Numerantium, number 88, pages 65–76, 1992.
[5] Y. Chiricota, F. Jourdan, and G. Melanc¸on. Software components capture using graph clustering. In 11th IEEE International Workshop on Program Comprehension, Portland,
Oregon, 2003. IEEE / ACM.
[6] D. K. D.R. Karger and S. Phillips. Finding the hidden path:
time bounds for all-pairs shortest paths. SIAM Journal on
Computing, 22, 1993.
[7] P. Eades and Q.-W. Feng. Multilevel visualization of clustered graphs. In Proc. Graph Drawing, GD, number 1190,
pages 101–112, Berlin, Germany, 18-20 1996. SpringerVerlag.

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007

[8] M. Fredman and R. Tarjan. Fibonacci heaps and their uses in
improved network optimization algorithms. Journal of the
ACM, 34:596–615, 1987.
[9] T. M. J. Fruchterman and E. M. Reingold. Graph Drawing
by Force-directed Placement. In Software-Practice and Experience, volume 21(11), pages 1129–1164. Nov. 1991.
[10] P. Gajer, M. T. Goodrich, and S. G. Kobourov. A multidimensional approach to force-directed layouts of large
graphs. Computational Geometry: Theory and Applications,
29:3–18, 2004.
[11] P. Gajer and S. G. Kobourov. GRIP: Graph dRawing with
Intelligent Placement. In Graph Drawing, pages 222–228,
2000.
[12] M. Granitzer, W. Kienreich, V. Sabol, K. Andrews, and
W. Klieber. Evaluating a system for interactive exploration
of large, hierarchically structured document repositories.
In INFOVIS ’04: Proceedings of the IEEE Symposium on
Information Visualization (INFOVIS’04), pages 127–134,
Washington, DC, USA, 2004. IEEE Computer Society.
[13] D. Holten. Hierachical edge bundles: Visualization of adjacency relations in hierarchical data. IEEE Transactions
on Visualization and Computer Graphics, 12(5):805–812,
2006.
[14] M. Huang and P. Eades. A Fully Animated Interactive System for Clustering and Navigating Huge Graphs. In GD ’98:
Proceedings of the 6th International Symposium on Graph
Drawing, pages 374–383, London, UK, 1998. SpringerVerlag.
[15] F. V. H. J. Abello and N. Krishnan. Ash-graphview : A Large
Graph Visualisation System. IEEE Transactions on Visualization and Computer Graphics, 12(5):669–676, 2006.
[16] R. S. J.R. Driscoll, H.N. Gabow and R. Tarjan. Relaxed
heaps: an alternative to Fibonacci heaps with applications
to parallel computation. Communications of the ACM,
31(11):1343–1354, 1988.
[17] T. Kamada and S. Kawai. An algorithm for drawing general undirected graphs. In Information Processing Letters,
volume 31, pages 7–15, Apr. 1989.
[18] J. B. Kruskal. On the shortest spanning subtree and the traveling salesman problem. In Proceedings of the American
Mathematical Society, number 7, pages 48–50, 1956.
[19] G. Kumar and M. Garland. Visual exploration of complex
time-varying graphs. IEEE Transactions on Visualization
and Computer Graphics, 12(5):805–812, 2006.
[20] S. Mancoridis, B. S. Mitchell, C. Rorres, Y. Chen, and E. R.
Gansner. Using automatic clustering to produce high-level
system organizations of source code. In IEEE Proceedings of the 1998 Int. Workshop on Program Understanding
(IWPC’98), Piscataway, NY, 1998. IEEE Press.
[21] C. McGeoch. All-pairs shortest paths and the essential subgraph. Algorithmica, 13(5):426–441, 1995.
[22] M. E. J. Newman, D. J. Watts, and S. H. Strogatz. Random
graph models of social networks. PNAS, 99(90001):2566–
2572, 2002.
[23] M. H. P. Eades. Navigating Clustered Graph using ForceDirected Methods. Journal of Graph Algorithm and Applications, 4:157–181, 2000.

[24] S. C. R. Brockenauer.
Drawing clusters and hierarchies. In M. Kaufmann and D. Wagner, editors, Drawing
Graphs: Methods and Models, number 2025, pages 193–
227. Springer-Verlag, Berlin, Germany, 2001.
[25] S. B. Seidman. Network structure and minimum degree. Social Networks, 5:269–287, 1983.
[26] G. Voronoi. Nouveles applications des param`etres continus
a` la th´eorie de formas quadratiques. J Reine Angew Math,
134:198–287, 1908.
[27] I. M. X. Wang. Generating customized layouts. In F. J. Brandenburg, editor, Graph Drawing, Passau, Germany, September 20-22, 1995, pages p. 504–515. Springer, 1996.
[28] U. Zwick. Exact and approximate distances in graphsa survey. In AlgorithmsESA01 9th Ann European Symp, Aarhus,
Denmark, pages 33–48. Springer, Berlin, 2001.

11th International Conference Information Visualization (IV'07)
0-7695-2900-3/07 $20.00 © 2007


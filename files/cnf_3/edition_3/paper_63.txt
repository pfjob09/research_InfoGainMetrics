2009 13th International Conference Information Visualisation

Privacy Preserving Sequential Pattern Mining in
Progressive Databases using Noisy Data
Amruta Mhatre

Mridula Verma

Durga Toshniwal

Electronic & Computer Department
Indian Institute of Technology
Roorkee
Uttarakhand, India
aam01pec@iitr.ernet.in

Electronic & Computer Department
Indian Institute of Technology
Roorkee
Uttarakhand, India
mri03pec@iitr.ernet.in

Electronic & Computer Department
Indian Institute of Technology
Roorkee
Uttarakhand, India
durgafec@iitr.ernet.in

The remainder of this paper is organized as follows:
Section 2 gives a formal description of the problem statement
of this paper and discusses some related work pertaining to the
problem. Section 3 sheds light on an algorithm used for
sequential pattern mining in progressive databases on which
the proposed work is applied. In section 4, we present the
proposed module for generating spurious transactions keeping
intact the accuracy of the results. In section 5, compares the
proposed algorithm against certain performance evaluation
parameters. We conclude our work in section 6 and discuss
some areas of developing this idea further.

Abstract—Research in the area of privacy preserving techniques
in databases and subsequently in data mining concepts have
witnessed an explosive growth-spurt in recent years. This work
investigates the problem of privacy-preserving mining of
frequent sequential patterns over progressive databases. We
propose a procedure to protect the privacy of data by adding
noisy items to each transaction. The experimental results indicate
that this method can achieve a rather high level of accuracy. The
method is applied on an existing algorithm PISA for frequent
pattern mining. This algorithm works on both static and
dynamically increasing databases, and thereby takes full
advantage of their applicability of the module.

II.

Keywords- Privacy Preservation, Fake transactions, Sequential
Pattern mining.

I.

A. Problem Statement
A lot of proposals have been made towards solving the
problem of sequential pattern mining. But these efforts are
restricted to only mining of patterns. These proposals overlook
the security aspect of the problem. The existing works in
privacy preserving sequential pattern mining consider a multiparty scenario, and hence a need for privacy preservation while
mining for patterns on shared data. However a privacy breach
may occur due to unauthorized usage of raw data. The
proposed work presents a module which preserves the privacy
of raw data. Privacy preservation in this module is carried out
at pre-processing level, keeping in mind the integrity of the
results. As a result the results of the pattern mining process
remain unaltered and the raw data remains in a perturbed state
and hence regards statistically useless.

INTRODUCTION

Due to the rapid progress in information technology,
companies can nowadays collect and store huge amounts of
data with a view to analyze it. However this large volume of
data, make manual analysis infeasible. Instead, automatic or
semiautomatic tools that employ data mining techniques are
being used for data analysis. Thus, data mining can be
described as the process of discovering patterns or trends in
data.
Of the various techniques of data mining analysis of sequences
of data is recently one of the most active areas of research
works. Sequential pattern mining means extracting patterns that
appear more frequently a certain threshold [1]. Sequential
pattern mining finds its applications in areas such as business,
e-commerce for analyzing the click patterns in a website,
increasing sales and promotions, targeted marketing, etc.

B. Related Work
1) Sequential Pattern Mining
The early works in the field of sequential pattern mining
included algorithms like AprioriAll, AprioriSome[3], Spade[4],
FreeSpan[5], PrefixSpan[6] restricted to mining in static
databases. However it was realized that static databases do not
cater all real world scenarios. Since re-mining all the sequential
patterns each time the database is updated, was not an viable
solution incase of incremental databases algorithms like
IncSpan [7][8], The limitation of this algorithm was its
inability to delete obsolete data. This introduced the concept of
frequent sequential pattern mining over dynamic data, which is

But outsourcing the analysis or mining tasks have led to the
need for privacy of raw data or the mined results. Privacy and
data mining can coexist. The problem with the above scenario
is not the data mining results, but how they are obtained. The
techniques for performing privacy-preserving data mining are
drawn from a wide array of related topics such as data mining,
cryptography and information hiding [2]. Some of these
techniques include secure multiparty computations,
randomization, downgrading application effectiveness, data
hiding etc.

978-0-7695-3733-7/09 $25.00 © 2009 IEEE
DOI 10.1109/IV.2009.67

PRELIMINARIES

462
456

described in [1].The work in this paper is based on this
algorithm. The details of the algorithm are given in section 3.

the pattern with the corresponding sequence number, called the
candidate pattern. If a path already exists the concerned fields
of the nodes are updated with the respective information. The
timestamp for each node of the candidate sequential pattern is
marked according to timestamp of the starting element of the
candidate pattern. An obsolete element (i.e. element which lies
out of the POI) and a node having no sequence numbers in its
sequence list are pruned from the sequence list of the node and
the M-ary tree respectively, ensuring only up to date candidate
patterns in the M-ary tree. Thus, we can ensure that there are
only up-to-date candidate sequential patterns in M-ary tree [1].
After all the candidate sequential patterns are generated, the
algorithm checks for the number of sequence IDs in a sequence
list of all leaf nodes. If the number of sequence IDs in a
particular leaf node is larger than minimum support time’s
number of sequences in the current POI, the path from the root
till that node is considered as a frequent sequential pattern.

Recently, there has been a lot of work addressing privacy
preserving data mining. This wide area of research includes
classification techniques, association rule mining, and
clustering with privacy constraints etc. The early works in
privacy-preserving data mining, were given by Lindell and
Pinkas [9] proposing a solution to privacy-preserving
classification problem using oblivious transfer protocol, a
powerful
tool
developed
by
Secure
Multiparty
Computation(SMC) research. The research area of privacy
preserving sequential pattern mining lies largely unexplored
with very few papers including [10].
These papers majorly deal with secure sequential pattern
mining in multiparty scenarios. The approach proposed in this
paper can be used for privacy preservation in a multiparty
environment or as a pre-processing module in a standalone
scenario.
III.

IV.

PROPOSED WORK

The proposed work is a module which aims at preserving
the privacy of the raw data. This module comes into play at the
pre-processing stage, when the data is made ready to go to the
data miner.

PROGRESSIVE SEQUENTIAL PATTERN MINING

Progressive sequential pattern mining is a generalized
pattern mining methodology that brings out the most recent
frequent sequential patterns. This algorithm works on static as
well as dynamically changing databases and is unaffected by
presence of obsolete data. The patterns are not affected by the
older data. This algorithm uses the idea of sliding window to
progressively update sequences in the database and
accumulates the frequencies of candidate sequential patterns as
time progresses. The sliding window called Period of Interest
(POI) determines the timestamps over which the algorithm is
currently working. The proposed work is modified to suit this
algorithm to increase its scope of applicability. The data
structure and the algorithm are as described below.

A. The Concept
The underlying idea of the proposed module is to
randomize the raw data before it is subjected to pattern mining.
The randomization is realized by addition of fake items to
transactions. However a balance is maintained between the
fake items and original items, so as to keep the results of the
pattern mining algorithm consistent. As a result the miner does
not have access to the actual data, but to the randomized data.
This would curb any other inferences deduced from the
original data.
Consider the following database snapshot. Such a database
is vulnerable to privacy breaches due to its simplistic nature.
The proposed work aims at introducing fake elements in the
sequences of such a database such that they randomize the
input to the pattern mining algorithm.

A. The M-ary tree
The M-ary tree structure forms the basis of the pattern
mining algorithm. The nodes of the M-ary tree can be
distinguished as the root nodes and the common nodes. The
root node contains a list of common nodes as its children. The
common node stores three types of information, node label i.e.
the element of the sequence, a sequence list i.e. a list of
sequence IDs and a timestamp list i.e. list of timestamps
corresponding to each sequence.
B. Mining frequent patterns from the M-ary tree
While mining for patterns, the algorithm keeps track of the
time and newly arriving elements in the database. At each
timestamp the insertion of elements into the M-ary tree at time
t results in an updated tree for time t+1. The algorithm
traverses the tree at time t in post order, deletes obsolete
elements and updates the sequences according to the current
time. That is it inserts new elements into existing candidate
sequence then identifies any new candidate sequences. The
algorithm continues this processing until there is new data in
the progressive database.

Figure 1. Example Database [1]

B. Implementation
The implementation of the data hiding module consists of
two phases 1) Maintaining the element bank and 2) Inserting
fake elements in the input. This module comes into play after
the initial parameters for pattern mining have been finalized by
the data owning party. As a result these parameters can be used

Whenever a series of elements appears in a sequence, path
from the root is created labeled by the respective elements of

457
463

to determine the level of randomization to be induced in the
data.
1) Maintaining the element bank
The element bank as the name suggests is a collection of
elements. The elements in this bank are majorly fake elements
that is, elements that do not actually occur in the original set of
elements. The cardinality of the fake element set is maintained
comparable to that of the original element set.
The module next counts the number of instances of each
original element included in the POI, and also computes their
cumulative sum. The cumulative sum plays a role in deciding
the number of fake elements to be inserted. The maximum
number of fake elements to be inserted is a factor given by eqn
(1). The actual number of fake elements to be inserted is given
by a random factor, such that it is approximately greater than
half the number of fake elements to be inserted. The maximum
number of instances of each fake element is obtained by
dividing the actual number of fake elements to be inserted by
the cardinality of the fake element set as given in eqn (2).
Fmax = Suppmin * NPOI

(1)

Imax = F / |f|

(2)

Where Fmax is the maximum number of fake elements,
Suppmin is the minimum support, NPOI is the number of
elements in the POI, Imax is the maximum instances of each
fake element, F is the actual number of fake elements to be
inserted and f is the fake element.
2) Inserting fake elements into the database
The insertion of elements in the database is carried out
using the same sliding window approach as would the pattern
mining be carried out. This helps to keep a check on the
number of fake elements inserted preventing them to be
frequent. Each time the sliding window shifts the element bank
updates the count of fake elements in the database and also
keeps track of the number of instances of each fake element
present in the current POI. It then computes the total number of
fake elements required to be inserted in the current POI. The
module now searches for sequences in the current POI which
do not contain any data (fake /original) at a particular
timestamp. The module then inserts a fake element at such a
location and updates counters of the fake element inserted. The
element chosen to be inserted is picked from the element bank
in a round robin pattern to ensure uniformity of distribution.
The procedure for insertion of fake elements is carried out in
the decreasing order of timestamps so as to avoid fake elements
being frequent in the preceding POI’s.

Figure 3. Procedure traverse [1]

Figure 4 shows the snapshot of the M-ary tree after time t3
for database from figure 1. Here in time t3, a fake element G is
added to the root. This figure also shows the structure of a node
of M-ary tree, having three types of information about an
element i.e. Label, sequence ID and time stamp.
V.

ANALYSIS AND EVALUATION

This section mainly discusses the execution and
performance issues of the sequential pattern mining algorithm
presented in the previous section, with and without noisy data.
In section A, we introduce our evaluation environment. Section
B discusses the effect of introduction of noisy data on the
database. Comparison between the candidate patterns with and
without noise is given in section C and also certain other
performance issues are being discussed in this section.
A. Evaluation Environment
All the experiments were performed on a 3.2 GHz Pentium
4 PC with 1 GB of main memory, running WINDOWS XP. All
the programs were written in JAVA and compiled with
NetBeans IDE 6.5.
B. Effective change in database
Various experiments were conducted to investigate the
performance of the sequential pattern mining algorithm with
and without noisy data. Test data contained 100 records, spread

Figure 2. The Algorithm Pisa [1]

458
464

Figure 4. M-ary Tree for Example Database

POI becomes longer, algorithm has to examine more
elements of all sequences in the database and PISA has to
examine a bigger sequence tree. Meanwhile, the number of
candidate frequent sequential patterns stored by Pisa
becomes bigger.
1600

Candidate Patterns

effective(%) change in
database

over 9 sequences numbers and 50 timestamps. It is assumed
that the minimum support is 0.5. Here, minimum support is
taken as constant since it is not a significant factor which
impact the generation of fake items. Every time input data is
introduced to the algorithm, some fake elements is also
generated and added to the database. Figure 5 shows the
impact of noisy data over the effective change in the
database.
0.4
0.3
0.2
0.1

1400
1200

without noisy
data

1000
800

with noisy data

600
400
200
0

3

0

3

5

8

5

POI

8

10

10

POI

Figure 6. Comparison of candidate patterns for different POIs for
minimum support 0.5

Figure 5. Effect of noisy data on database for different POIs for minimum
support 0.5

VI.

However observing the effect of noisy data it can be seen
that the memory usage and execution time of the proposed
work exceeds that of the PISA algorithm by a small factor.
This increase in memory usage can be accounted for the
modification in the node structure, in order to suit the
requirements of the problem.

CONCLUSIONS

Privacy preserving data mining is a wide and effective
area of research in recent times. It aims at preserving the
privacy of data or mining results as declared sensitive by the
user. Of the many techniques hiding actual data by
introducing fake transactions or elements is a technique that
protects privacy of the raw data. Various algorithms have
been proposed which use the approach of adding fake
transactions/items to hide knowledge. The proposed work
demonstrates the effect of adding noisy data on sequential
pattern mining algorithm over progressive database. The

Also, the effect on the number of candidate patterns
generated is shown in figure 6. It can be easily observed that
increasing the size of the POI window the number of
candidate patterns increases, since when the length of the

459
465

proposed module unlike the other methods is scalable from a
single node system to a multi-party scenario.
REFERENCES
[1]

J.W Huang, C. Y. Tseng, J.C Ou, and M. S. Chen, “A General Model
for Sequential Pattern Mining with a Progressive Database”, IEEE
Transactions on Knowledge and Data Engineering, Vol. 20, No. 9,
Sept 2008.
[2] C. Aggarwal, Philip S. Yu “Privacy-Preserving Data Mining Models
and Algorithms” ISBN: 0-387-70991-8.
[3] M. J. Zaki, “Sequence Mining in Categorical Domains: Incorporating
Constrains.”, Proc. Int. Conf. on Information and knowledge
management, pp. 422–429. 2000.
[4] J. Han, J. Pei, B. Mortazavi-Asl, Q. Chen, U. Dayal, and M.C. Hsu,
“Freespan: Frequent Pattern-Projected Sequential Pattern Mining,”
Proc. Sixth ACM SIGKDD Int’l Conf. Knowledge Discovery and
Data Mining (KDD ’00), pp. 355-359, 2000.
[5] J. Pei, J. Han, H. Pinto, Q. Chen, U. Dayal, and M.C.
Hsu,“Prefixspan: Mining Sequential Patterns Efficiently by PrefixProjected Pattern Growth,” Proc. 17th Int’l Conf. Data Eng.
(ICDE’01), pp. 215-224, 2001.
[6] H. Cheng, X. Yan, and J. Han, “INCSPAN: Incremental Mining of
Sequential Patterns in Large Database,” Proc. 10th ACM SIGKDD
Int’l Conf. Knowledge Discovery and Data Mining (KDD ’04), pp.
527-532, 2004.
[7] S. Nguyen, X. Sun, and M. Orlowska, “Improvements of INCSPAN:
Incremental Mining of Sequential Patterns in Large Database,” Proc.
Ninth Pacific-Asia Conf. Knowledge Discovery and Data Mining
(PAKDD), 2005.
[8] M.-Y. Lin and S.-Y. Lee, “Incremental Update on Sequential Patterns
in Large Databases by Implicit Merging and Efficient Counting,”
Information System, vol. 29, no. 5, pp. 385-404, July 2004.
[9] Y. Lindell and B. Pinkas. Privacy preserving data mining. Journal of
Cryptology, 15(2), 2002.
[10] 10. J. Zhan, L. Chang, and S. Matwin. Privacy-preserving
collaborative sequential pattern mining. In Workshop on Link
Analysis, Counter-terrorism, and Privacy in conjunction with SIAM
Int. Conf. on Data Mining, pages 61-72, Lake Buena Vista, Florida,
2004.

460
466


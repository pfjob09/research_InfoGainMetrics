Estimating the trafﬁc on weighted cactus networks in linear time
Blaˇz Zmazek
FME, University of Maribor,
Smetanova 17, SI-2000 Maribor, Slovenia
and
IMFM, Jadranska 19, SI-1000 Ljubljana, Slovenia
blaz.zmazek@uni-mb.si
ˇ
Janez Zerovnik
FME, University of Maribor,
Smetanova 17, SI-2000 Maribor, Slovenia
and
IMFM, Jadranska 19, SI-1000 Ljubljana, Slovenia
janez.zerovnik@uni-mb.si

Abstract
A communication network can be modeled by a graph
with weighted vertices and edges corresponding to the
amount of trafﬁc from sources and expected delays at links.
We give a linear algorithm for computing the sum of all
delays on a weighted cactus graphs. Cactus is a graph in
which every edge lies on at most one cycle. The sum of
delays is equivalent to the weighted Wiener number, a well
known graph invariant in mathematical chemistry. Complexity of computing Wiener polynomial on cacti is discussed.

1 Introduction
If a graph is being used to model a computer network,
the weighted distance between vertices represent the time
required for the corresponding processors to communicate
with each other. Weights on vertices correspond to the
amount of trafﬁc from the processor. This concept is useful
when estimating timing statistics associated with distributed
computing.
In this paper we consider vertex and edge weighted
graphs, where the weights are positive real numbers. Cactus is a graph in which every edge lies on at most one cycle.
Practical communication networks may have topology of a
cactus graph. There are several problems, for which the
time complexity is the same for cacti and for trees although
the actual algorithms may become much more involved (see

for example [12] and references there). In this note we show
how the linear algorithm for computing the sum of all distances on a tree [7] can be generalized to work on weighted
cactus graphs.
In mathematical chemisty, molecules are often modelled
by graphs. The sum of all distances is known as the Wiener
number [10]. It is the ﬁrst non-trivial topological index in
chemistry was introduced by H. Wiener in 1947 to study
boiling points of parafﬁns (for historical data see, for instance Ref. [9]). These indices are graph invariants, which
usually reﬂect molecular size and shape.
Since then, the Wiener number (also called the Wiener
index) has been used to explain various chemical and physical properties of molecules and to correlate the structure of molecules to their biological activity[4]. The research interest in Wiener index and related indices is still
considerable[13, 14].
In arbitrary tree, every edge is a bridge, i.e. after deletion of the edge, the graph is no more connected. The contribution to the Wiener number of an edge was taken to be
the product of the numbers of vertices in the two connected
components. This number also equals the number of all
shortest paths in the tree which go through the edge [3].
Therefore the usual generalization of the Wiener number on
arbitrary graphs is deﬁned to be the sum of all distances in
a graph. Recalling and generalizing the original deﬁnition,
edge contributions to the Wiener number were studied in
Refs. [5, 6, 8].
Wiener polynomial of some special networks is studied
in [2] because it is a generating function for the distance

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

distribution. For more motivation, see [2].
The rest of this note is organized as follows. The following two sections recall deﬁnitions, basic observations
on graphs and depth ﬁrst search. Section 4 gives the algorithm with brief correctness arguments. In the concluding section we discuss complexity of computing the Wiener
polynomial.

vertices contributes w(a)w(b)d(a, b) to the Wiener number.
This contribution can be either regarded as a contribution
of the pair a, b or it can be divided to n∗ (a, b) path contributions which can furthermore be regarded as a sum of
edge contribution along the path. Since d(a, b) is the sum
of edge weights along a shortest path, the contribution of
edge e caused by a and b is

2 Deﬁnitions

λ(e)

A weighted graph G = (V, E, w, λ) is a combinatorial
object consisting of an arbitrary set V = V (G) of vertices,
a set E = E(G) of unordered pairs {x, y} = xy of distinct
vertices of G called edges, and two weighting functions,
w and λ. w : V (G) → IR assigns positive real numbers
(weights) to vertices and λ : E(G) → IR assigns positive
real numbers (lengths) to edges.
A simple path from x to y is a ﬁnite sequence of distinct
vertices P = x0 , x1 , . . . , x such that each pair xi−1 , xi
is connected by an edge and x0 = x and x = y. The
length of the path is the sum of lengths of its edges, l(P ) =
i=1 λ(xi−1 xi ). For any pair of vertices x, y we deﬁne
the distance d(x, y) to be the minimum of lengths over all
paths between x and y. If there is no such path, we set
d(x, y) = ∞.
A graph G is connected, if d(x, y) < ∞ for any pair
of vertices x, y. A vertex v is a cut vertex if after removing v and all edges incident to it the resulting graph is not
connected. A graph without a cut vertex is called nonseparable. A block is a maximal nonseparable graph. A cycle is
an induced subgraph which is connected and in which every
vertex is of degree two. A cactus is a graph in which every
block of three or more vertices is a cycle. Alternatively,
a cactus is a connected graph in which two cycles have at
most one vertex in common. For usual graph theoretical
terminology not deﬁned here see, for instance, [1].
The weighted Wiener number of a weighted graph G
studied here is
W (G) =

w(u)w(v)d(u, v).

(1)

u>v

The deﬁnition used here is clearly a generalization of
the usual deﬁnition for (unweighted) Wiener number. More
precisely, if all weights of vertices are 1 and all lengths of
edges are 1, then W (G) is the usual Wiener number.
Lemma 1 For a weighted graph G, W (G)
=
1
∗
λ(e)
×
w(a)w(b),
where
P
∗
∗
a,b
e=uv
Pa,b e n (a,b)
is a shortest path between a and b and n∗ (a, b) is the
number of shortest paths with endpoints a and b.
Proof. To see this it is enough to sum up the contributions
of each edge to W in two different ways. Each pair a, b of

1
w(a)w(b).
n∗ (a, b)

An edge contributes as many times as it appears on various
shortest paths. Here the vertices are weighted, so one has to
take into account the weights of both terminal vertices. Let
us note in passing that the sum of contributions of the edge
e,
1
ω ∗ (e) :=
w(a)w(b).
∗ (a, b)
n
∗
Pa,b e

can be called the shortest path weight distribution, generalizing the ideas of Refs. [5, 6, 8].
Hence one can sum up the lengths of all shortest paths
(as in (1)), or, equivalently, sum up the contributions of all
edges.
Recall that on a tree, there is a unique shortest path between any pair of vertices. Hence n∗ (a, b) = 1 for all a, b.
For a later reference note that on a cactus graph n∗ (a, b) can
only have value 1 or 2. Clearly, n∗ (a, b) = 2 exactly when
a and b are opposite vertices of a cycle (i.e. d(a, b) = d and
a, b are vertices of a cycle of girth 2d).

3 DFS based representation of a cactus
If cycles in a cactus are considered as (super)-vertices,
there is a unique shortest path between any two vertices.
Any cactus G can always be represented as a rooted cactus. This means that a vertex v0 ∈ V (G) is distinguished
and called the root of G. (Any vertex may be chosen for the
root.) All other vertices are indexed as v1 , v2 , . . . , vn−1 in
a DFS (depth ﬁrst search) order. DFS is a standard procedure for searching a graph, see for example Ref. [1]. It can
easily be seen that in each cycle there is exactly one vertex
vj , which is the ﬁrst vertex in the DFS order on the cycle C,
containing the edge vi vj . For this reason we call the vertex
vj the root of the cycle C. Clearly, each cycle in a cactus
has a unique root, determined as a ﬁrst vertex on the cycle in
the DFS order. Moreover, each vertex on a cactus G which
is a successor of a vertex with higher index is the root vertex of one or more cycles. Hence, all cycles in a cactus are
determined with the root and its successor.
The rooted cactus can be represented with two arrays Ti
and Ri , i = 0, 2, . . . , n − 1, where Ti denotes the unique
predecessor of vertex vi in the rooted tree, constructed with

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

the DFS. The element Ri denotes the root vertex of the cycle containing vi . If vi does not lie on a cycle then Ri = vi
and if vi is on a cycle rooted at vj , then Ri = vj = vi . Note
that the array R describes all cycles in the cactus.
It is clear that when traversing the graph with a DFS algorithm, one can also obtain array ind(vi ) := |{j ; vi =
Tj }|. The meaning of ind(vi ) is the number of sons of vi .
Leaves of the tree have no son directing to them. Hence
ind(leave) = 0. This can be done within the time complexity of BFS, O(m).
After a DFS run, each vertex vi can be regarded as a root
of a subcactus, which we will denote by Gi .
From the discussion above we infer that after a DFS run,
one can get a representation of a cactus and, furthermore,
one can decide whether a given graph is a cactus or not.
More formally,
Lemma 2 Let G be a cactus graph. In a DFS run, each
new vertex vi can have at most one neighbor among the
visited vertices and the neighbor can only be on the direct
path from the root v0 to vi .
Proof. If, for some vertex two such neighbors existed, then
there will be edges on two (or more cycles). Contradiction.
A back neighbor which is not on a direct path from the root
v0 to vi was visited already and hence the vertex vi should
have been visited as its son. Contradiction.
Hence, if G is not a cactus graph, this can be observed while
traversing G in the DFS order.
Lemma 3 Cactus graphs can be recognized in linear time.
Proof. DFS algorithm takes O(m) time.

4 The algorithm
We will give the algorithm W for computing the Wiener
number of a rooted subcactus. Recall that by Lemma 1 the
Wiener number can be computed as a sum of contributions
over all edges of a graph.
With each vertex vi of the graph G the value of Vi will
be computed, for which
Vi =

j∈Gi

w(vj )

1. Find a representation of the (rooted) cactus G.
2. Traverse the cactus G in the reversed DFS order and
compute the Vi .
3. Traverse the cactus G in the DFS order and compute
the contributions of edges (cycles) to the invariant.
We now give more details of each step.
Step 1: Cactus recognition
Run a DFS on G. By discussion above, it is clear that we
can compute Ti , Ri and ind(vi ) := |{j ; vi = Tj }| in time
O(m).
Step 2: Computation of Vi
Traverse the DFS tree in the reversed DFS order. Compute
the temporal value Vi for a leave vi and reduce the number
of unvisited sons for its father by one. If the father has no
more unvisited sons, put it in a FIFO (ﬁrst in ﬁrst out) queue.
The computation of temporal Vi is the weight of vi plus the
sum of Vj of its sons:
Vi = w(vi ) +

Tj =vi

Vj .

Lemma 4 After Step 2, for every vertex vi , Vi is the sum of
weights of all vertices of the subcactus rooted at vi . More
formally,
Vi =

vj ∈Gi

w(vj ).

Proof. It follows from the deﬁnition of Vi .
Lemma 5 Step 2 can be computed in O(m) time.
Proof. Clear.
Step 3: Computation of the edge contributions to W (G)
Traverse the DFS tree in the DFS order. Compute the edge
contributions to the W (G).
Observe that V0 is the sum of weights of all vertices of
G.
1. W = 0
2. For each vertex vi (in the DFS order) do

will eventually hold. Vi will thus be the sum of weights of
the subcactus Gi rooted at vi .
The algorithm consist of three steps. First, a representation of the given weighted cactus is found. Then we compute Vi for each vertex. In order to compute the Vi we start
with edges incident to leaves and continue in reversed DFS
order up to root. In the third step we compute the contributions of edges (cycles) to the invariant starting from root to
leaves.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

• For each son vj , for which vi vj is not an edge of
a cycle of G, (i.e., if Rj = vj and Tj = vi ) set
We := Vj (V0 − Vj )λ(e)
W := W + We .
• For each son vj of a root vertex vi (Ri = vi ), for
which vi vj is an edge of a cycle Cj of G, (i.e., if
Rj = vi and Tj = vi ), compute the contributions
of the cycle as follows. Mark the vertices of the
cycle C in the DFS order with u0 , . . . , ue−1 . For

each vertex ui on the cycle compute Li , the sum
of weights of vertices for which the vertex ui is
the nearest vertex on the cycle C, using the val-

Example 2 Compute weighted Wiener number on a cycle

e−1

ues Vj and let |C| =

λ(ui ui+1 ) be the girth
i=9

of the cycle.
– WC := 0; (weighted Wiener number of the
cycle C)
f = l := 0; (loop counters - f is ﬁrst, l is
last vertex - are computed modulo e)
Cont = 0; (contribution of the current
vertices {uf , uf +1 , . . . , ul })
V
:=
0; (sum of weights of
{uf , uf +1 , . . . , ul })
d := 0 (distance from uf to ul )
– Repeat
(compute the contributions of edges on the
cycle which lies on shortest paths that enter
on the cycle throught the vertex vf and continue in a DFS order)
(a) While d + λ(ul ul+1 ) ≤ |C|
2 do begin
∗ l := l + 1;
∗ V := V + Ll ;
∗ d := d + λ(ul−1 ul );
∗ Cont := Cont + Ll d
end(while) (Find the new last vertex ul
on the cycle Cj with a shortest path
from uf in a DFS order.)
(b) WC := WC + Lf Cont;

Example 2.
Let the top vertex of the cycle in ﬁgure be also the root
vertex. All steps of computation of Wiener are written in the
tables bellow (the entries are computed columnwise from
left to right):
Step
(a)

(b), (c)
(d)
(e)
(f )

1
(c) If d = |C|
2 then WC := WC − 2 Lf Ll d;
(d) Cont := Cont − V λ(uf uf +1 );
(e) V := V − Lf +1 ;
(f) d := d − λ(uf uf +1 );
(g) f := f + 1
Until f = 0.
– W := W + WC .

Step
(a)

Example 1 Compute weighted Wiener number of path

Example 1.
Traversing the path we get the following table
i
Ti
λ(vi Ti )
Vi
Vi (V0 − Vi )λ(vi Ti )

0
1
2
3
4
5
−
0
1
2
3
4
0
5
1
1
1
5
24 14 13 12 11 10
0 700 143 144 143 700

Summarizing the last row of the table we get the Wiener
number of the path W = 1830.

(b), (c)
(d)
(e)
(f )

f
l
V
d
Cont
WC
Cont
V
d
f
l
V
d
Cont
WC
Cont
V
d

0
1
2
1
2

2
3
2
4

3
5
3
10

1
2 3
4
5 6
6
4 4
5
5 5
15
10 16
12.5 30.5 38 60
9
5
6 8
4
3
2 3
4
3
3 3

...cont...
4
5
6
...cont...
0
1 2
3
...cont...
4
5 6
6
...cont...
5
4 5
5
...cont... 13 13 18 22
...cont... 70.5
86 120
...cont...
5
12 10
...cont...
3
4
5
...cont...
3
4
3

Summarizing, we read from the tables the values
W (C) = 120.
Lemma 6 We and WC are correctly computed. Each edge
is considered exactly once.
Proof. (sketch) After line (a) in 2. of Step 3, the value of V
is the sum of weights of vertices which are at distance less
or equal to |C|/2 from the vertex uf . Similarly, the value

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

Cont is the weighted sum
f

Cont =

f

l

w(ul )d(uf , ul ) =

w(ul )λ(ui−1 , ui ).
l:=1 i:=1

l:=1

Hence
f

l

w(uf )Cont =

w(uf )w(ul )λ(ui−1 , ui ).
l:=1 i:=1

is the sum of contributions of all paths with the ﬁrst vertex
uf which are oriented coherent with the orientation of the
cycle deﬁned by the labeling u0 , u1 , . . ..
If there are vertices of distance exactly |C|/2 then there
are exactly two shortest paths between them and the contribution has to be divided by 2 (hence step (c)).
Finally observe that in the repeat-until loop each shortest path shorter than |C|/2 is considered exactly once and
that each shortest path of length |C|/2 is considered exactly
twice. We omit the details.
Lemma 7 Step 3 can be computed in O(m) time.
Proof. (idea) Each cycle is considered only once (when its
root is traversed). Furthermore, the computation on the cycle is linear in the length of the cycle, which easily follows
by analysis of the repeat-until loop.
Recalling the complexity of Steps 1 to 3 we conclude
that the algorithm run in linear time.
Theorem 8 The above algorithm computes the weighted
Wiener number on a weighted cactus in O(m) time.

5 Wiener polynomial
Wiener polynomial of some special networks is studied
in [2] because it is a generating function of distance distribution. The Wiener polynomial of a graph G is deﬁned as
W (x) = W (G; x) =

xd(u,v) .

computation will necessarily include an additional factor related to the number of different distances which appear in
the graph. Here we brieﬂy discuss a generalization to trees.
Assume we are given a rooted tree T . For each vertex
v ∈ T let Wv (x) denote the partial Wiener polinomial coresponding to all distances from v to all other vertices in the
subtree, rooted at v. By deﬁntion Wv (x) = 0, if v is a leaf.
Lemma 9 Let v1 , v2 , . . . , vk be sons of a vertex v
in a rooted tree T with partial Wiener polinomial
W1 (x), W2 (x), . . . , Wk (x), respectively. Then partial
Wiener polinomial is
Wv (x) = (W1 (x) + W2 (x) + · · · + Wk (x))x + 1
For each vertex v ∈ T let Wv (x) denote the contribution of vertex v to the Wiener polinomial. This contribution
corresponds to all shortest paths, which meet vertex v.
Lemma 10 Let v1 , v2 , . . . , vk be sons of a vertex v
in a rooted tree T with partial Wiener polinomial
W1 (x), W2 (x), . . . , Wk (x), respectively. Then the contribution of vertex v to the Wiener polinomial is
Wv (x) =

1
2

1 + Wv (x)2 − x2

k

Wi2 (x)

i=1

Proof. The shortest path which meets vertex v consists
of one or two shortest paths from v (paths of the form
v . . . x or x . . . v . . . y). The contribution of vertex v to
the Wiener polinomial is therefore the sum of xWi (x) and
x2 Wi (x)Wj (x). Straightforward calculation gives the result. We omit the details.
Based on this observation, one can design an algorithm
Theorem 11 The Wiener polynomial on a tree T can be
computed in O(D∆2 n) time, where D is the diameter of T
and ∆ is the maximal degree of a vertex in T .

{u,v}⊆V (G)

It is well known that the (unweighted) Wiener number is
the value of the ﬁrst derivative of the Wiener polynomial at
x = 1, W (G) = W (G; 1). As we have fast algorithms
for computing the Wiener number of some special graphs,
it is interesting to ask whether the Wiener polynomial can
be computed faster than in time O(mn), the complexity of
computing all distances in arbitrary graph.
We claim that the algorithm given in the previous section can be generalized to compute the Wiener polynomial.
However, for the polynomial, not only a sum of all distances, but the distance distribution is nedeed. Hence a vector of distances has to be mantained and the complexity of

A detailed proof will be given in the full paper.
Finally, we believe that it is possible to generalize the
approach outlined here to cacti. As the algorithm and the
arguments are likely to be more complicated, we give the
next statement as a conjecture
Conjecture 12 The Wiener polynomial on a cactus G can
be computed in O(D∆2 n) time, where D is the diameter of
G and ∆ is the maximal degree of a vertex in G.
Acknowledgement. Supported in part by the Ministry
of Higher Education, Science and Technology of Slovenia.

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE

References
[1] N.L.Biggs, Discrete Mathematics, Claredon Press,
Oxford 1989.
[2] J. F. Fink and B. Elenbogen, Distance distributions for
graphs modeling computer networks, to appear in Discrete Mathematics.
[3] H.Hosoya, Topological index. A newly proposed
quantity characterizing the topological nature of structural isomers of saturated hydrocarbons, Bul. Chem.
Soc. Japan 44 (1971) 2332-2339.
[4] L.B.Kier and L.H.Hall, Molecular Connectivity in
Chemistry and Drug Research (Academic Press, New
York, 1976).
[5] I. Lukovits, Correlation Between Components of the
Wiener Index and Partition Coefﬁcients of Hydrocarbons, Int. J. Quantum Chem.: Quantum Biol. Symp.
19 (1992) 217-223.
[6] I. Lukovits, The Generalized Wiener Index for
Molecules Containing Double Bonds and the Partition
Coefﬁcients, Rep.Mol.Theory 1 (1990) 127-131.
[7] B.Mohar, T.Pisanski, How to Compute the Wiener Index of a Graph, J. Math. Chem. 2 (1988) 267-277.
ˇ
[8] T.Pisanski and J.Zerovnik,
Weights on Edges
of Chemical Graphs Determined by Paths,
J.Chem.Inf.Comput.Sci. 34 (1994) 395–397.
[9] D.H.Rouvray, Should we have designs on topological
indices?, (in Chemical Applications of Topology and
Graph Theory B.B.King (ed.)), Vol. 28, (Elsevier, Amsterdam, 1984) 159-177.
[10] H.Wiener, Correlation of Heats of Isomerization,
and Diferences in Heats of Vaporization of Isomers,
Among the Parafﬁn Hydrocarbons, J.Amer.Chem.Soc
69 (1947) 2636-2638.
[11] H.Wiener, Structural determination of parafﬁn boiling
points, J. Amer. Chem. Soc. 69 (1947) 17-20.
ˇ
[12] B. Zmazek and J.Zerovnik,
The obnoxious center
problem on weighted cactus graphs, Discrete appl.
math. 136 (2004) 377-386.
[13] Discrete Mathematics 80 (1997). (Special issue on the
Wiener index.)
[14] MATCH 35 (1997). (Special issue on the Wiener index.)

Proceedings of the Ninth International Conference on Information Visualisation (IV’05)
1550-6037/05 $20.00 © 2005 IEEE


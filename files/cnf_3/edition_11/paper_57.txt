A Boundary Representation Technique for Three-dimensional Objects
C. Maple
Department of Computing and Information Systems,
University of Luton, Luton, Beds, LUl 3JU.
carsten.maple @ luton.ac.uk

Abstract
The Marching Cubes algorit,km of Lorensen and Cline,
[4] is a method used frequently in three-dimensional object visualisation. The underlying !conceptof the technique is

to form piecewise planar approximations to surfaces, for
which predetermined normals are used for shading purposes. It should be noted that these approximations are precisely as accurate as the data given, there is no loss in quality
or error introduced. The approach of using these cubes to
represent data can also be used to fully describe the piecewise planar approximation to the surface. Problems arise
however in terms of storage space requiredfor the representation of large objects, and it is this issue that is addressed
here. We present an algorithm that transforms pixelwise
data into a boundary representation that has potential for
large reductions in storage. The algorithm does not involve
any further approximation of the. surface of the object than
that given as input. The algorithin also provides a structure
that makes surface analysis and matching very simple.

1

Figure 1. Pixelwise data is given over aligned
grids on parallel planes.

square from each of the two slices comprise a cube, see
Figure 2.
The marching cubes algorithm forms a piecewise-planar
approximation to the object. The boundary of the object is
assumed to pass exactly half way between a pixel that is
outside the cube and a neighbouring pixel that is not. This
determines the way in which the surface intersects a cube,
if indeed it does. There are 8 vertices to each cube, each
of which can be outside the surface of the object or not.
There are, therefore, 256 different ways in which a cube
can intersect the surface. In order to uniquely identify each
of the 256 ways we assign a weighting value to each vertex
of a cube as shown in Figure 3.
If the pixel at the front bottom-left of the cube is outside the cube it is assigned a value of 0, and a 1 otherwise;
if the pixel at the back top-right of the cube is outside the
cube it is assigned a value of 0, and 64 otherwise, and so
forth. A cube is given the value that is the sum of the value of its vertices. Two examples of cubes, their values and
approximations is given in Figure 4. Once an object is represented in this form, the normals for each of the 256 possible cubes can be found by simply consulting a table. The
Marching Cubes algorithm then uses rendering techniques

Introduction

The Marching Cubes algorithm of Lorensen and
Cline [4], is a surface rendering technique used to produce
3D images given point data from 3-space. The data is given
on orthogonal grids over parallel planes, see Figure 1. The
distance between the planes is the same as the grid mesh
size in each plane. Data is given at each of the vertices of
every square in every slice. This pixel data is transformed
into values of either 0 or 1 ; a 0 corresponding to a vertex
lying outside the surface, a 1 corresponding to all other vertices.
The traditional data structure for this type of information
is a standard three-dimensional airay, where the value of the
pixel, 0 or 1, at position (i, j, I C ) is stored in position [i, j,
IC] of the array. There is a simple mapping from a pixelwise representation to a marching cube representation. Two
consecutive slices, IC and IC - 1say, are used to define a layer
of marching cubes. Four neighbouring pixels that form a

0-7695-1195-3/01 $10.00 0 2001 IEEE

397

Figure 5. A two-dimensional shape. Each x
marks a pixel with value 1.

Figure 2. Two consecutive slices are used to
construct a set of Marching Cubes.

Figure 6. The weightings given to the vertices
of each square.
Figure 3. The weightings given to the vertices
of each cube.

2

Tracking the Boundary of an Object

produce 3D images. In this paper we are not concerned with
the normals to the surface nor the rendering of the surface,
but simply with the way of representing the data in voxels.
Equally, the fact that the Marching Cubes algorithm only
gives an approximation to an object is also not of consequence. Since every unique shape of an object has a unique
approximation and there exists a simple mapping between
a shape and its approximation, storing an approximation is
equivalent to storing the actual shape.
In section two of this paper we describe a twodimensional version of the problem and a boundary representation method for two-dimensional objects. Section
three advances the ideas of section two to produce a graphical representation of the boundary method. An algorithm
and data structure are presented in section four, before the
comments and conclusions of section five.
0
0
0
0
0
0
0
0

Figure 4. Two examples of cubes and their
marching cubes approximations. The left
cube has a value of 6 and the right a value
of 193.

0
0
2
8
2
10
10
8

0
2
11
14
11
15
15
1 2

2
1 1
15
15
15
15
13
4

3
1 5
15
15
15
15
14
8

3 1
1 5 7
15 15
15 15
15 15
15 13
15 5
1 2 4

0
1
7
15
13
4
0
0

0
0
1
5
4

0
0
0
0
0

0 0
0 0
0

0

The correspondence between the pixels in Figure 5 and
the elements of 2D-Object should be obvious. However,

398

-a< 8

we can see that a number of the elements in 2D-Object
correspond to interior points of the object, namely those elements with a value of 15. Sirice the object is completely
defined by its boundary, there is no need to store these interior points, if a suitable (meaningful) method can be used
to store the boundary of the object. Such a method can be
found in [ 11. The boundary squares representation of this
image can be seen to be as follows
2D-Boundary

=

right

(2,3,3,1,7,1,7,1,5,4,13,4,13,
5,4,12: 8,14,13,4,12,8,10,10,
2,11,14,8,2,11,2,11)

To obtain this representation, the first non-zero entry in the

Figure 7. A graphical representation of the
boundary of a two-dimensional object.

2D-Object array is found, in this case at (2,4). This coordinate system is defined using the top-left square as (0,O)
with the first coordinate increasing from top to bottom and
the second from left to right. The boundary is then traced
in a clockwise fashion. This is i i straightforward operation,
again refer to [I]. When the boundary arrives back at (2,4)
the array is closed.
It is immediately obvious that this method of representation requires far less storage. We also note that the representation is now in the form of a single-dimensioned array. As
such all information regarding the coordinates of the cubes
is lost (earlier the entry in 2D-Object[il j ] corresponded to
the pixels in positions i, j, i i1 and j
1.) However,
the placing of the origin is relative to the coordinates used,
and as such, it is only important to keep account of relative coordinates; any surface analysis should be invariant to
translations.
If a similar method could be devised to represent the
surface of a three-dimensional object with finite continuous surface, then this could lead to an appropriate reduction
in the amount of storage space required to define the object.
When considering a two-dimensional object, tracking
the boundary in a clockwise manner is straight forward.
However, due to the increased degree of freedom, tracking
a boundary in three dimensions is non-trivial. A method of
using rotational tracking around each slice of the array (that
is, fixing each k in the 2D-Object array and then travelling
around the surface in a rotationai manner) is not effective as
the correct connections between slices are difficult to maintain.

the array. Thus, though we store the boundary as an array,
it should be thought of as more of a ring. Moreover, if we
consider Figure 5 we see that the boundary of the object
goes from square (2,4) to square (2,5) through the right of
square (2,4). Conversely, the boundary goes from the square
at (2,5) to (2,4) through the left of square (23). Hence the
structure can be represented graphically as in Figure 7.
Considering the structure in this way gives us a natural
progression into higher dimensions. Here the boundary is
represented in a type of surface map. The above representation as a directed graph with edge and vertex labels. Furthermore, any vertex with a label of 2, as in the above figure,
will have two edges, a down edge and a right edge; similarly
any vertex with a label of 1 will also have two edges, a left
edge and a down edge. In much the same way, we can characterise the path of the boundary over a three-dimensional
object. We do this in such a way as to determine the faces
(as opposed to edges in the two-dimensional case) through
which the boundary passes through a particular cube. We
index the six faces through which the boundary can pass as
follows:
Using this direction index, we can describe every direction that the surface passes out of the cube through. Consider the two cube values as shown in Figure 4. We can see
that from the first cube, the surface passes out of the cube
through the left, top, front and bottom faces, indexed by 1,
2 , 4 and 5 respectively, according to Figure 8. Similarly, the
surface from the second cube passes out of the cube through
all the faces 1, . . . , 6.
We can construct a tables that contains information about
the faces through which the surface passes for each of the
254 possible cube values. We ignore cubes with index 0 or
255 as these are trivial in the sense that the boundary of the
object does not pass through such cubes. An excerpt from
such a table is given in Table 1. It can be seen that cubes

+

3

A Graphical Representation of the Boundary

The key to determining a suitable method is to
consider the representation for two-dimensional case. The
boundary of the object is stored in a one-dimensional array.
However it is clear that the tail arid head of the array should,
in fact, be as connected as the second and third elements in

399

Cube Value
1
2

Figure 8. The index of the faces of a cube
through which a surface can pass.

Cube Value
1
2
3
4
5
6
7
8
9
10

,.

3

4
5,7,10,11,13,14
6
8
9
12
15
16
17
18,19,33,49,50

CorresDonding exit faces

20-23,26-30,37,39,40-46,52-63,
65,67,69,7 1,73,75,77,78,8 1-94,
97,99,101,104- 109,113,114,
116,117,120- 122,125,125
24,25,103,110,118,126
3 1,35,47,79,80,95,112
32
34
36,38,66,70,98,100
48
51
64
68
72,76,115,123
96
102
111
127

25 3
254
Table 1. An excerpt of a table listing the sur-

face exit faces for every non-trivial cube value.

with index 1 and 254 have surfaces which pass through exactly the same faces; also cubes with index 2 and 253 have
surfaces which pass through the same faces. In general, surfaces from cubes with values x and 255 - x pass through
the same face due to the dual nature of the two cubes and
so it is only required to store information for cube values
up to and including 127. It can also be seen that the surfaces from cubes with value 5, 7 and 10 pass through the
same faces. To minimise the storage required for the cube
value-face list table, the information can be stored in a twodimensional array as in Table 2. Given the directions that a
surface can exit a cube with a particular cube value, following the boundary of an object is now straightforward. From
a given cube value, we can establish the exit faces by consulting a table such as Table 2, and track the boundary using
a case statement such as that given in (1).
case

Table 2. A complete, alternative list detailing
the exit faces for every non-trivial cube value
from 1-127.

lowest-face of

400

graph, information about each node is stored in an element
of a one-dimensional array. For a graph such as that in Figure 9, it is required that the cube value and the connection
list for each node is stored. For purposes of constructing the
boundary representation, the coordinates of each cube must
be stored. Storing the coordinates of cubes allows a check
to be made as to whether any information about the cube
has already been stored. The graph is complete once every
connection between cubes has been considered. For each node, we introduce a variable, complete, which is set to 1
if all the connections of that cube have been stored (checked
by consulting a table such as Table 2 and 0 otherwise. Once
every element in the boundary list has complete = 1,the
boundary representation is complete. We can write the data
structure to be used in the algorithm as:

,

Boundary -List (I) = (comp1e t e, c o o r d i n a t e s ,
connection-1i s t )
(2)

$(;

Here the connections list is a list of elements
(exit-facepext-cube), where e x i t - f a c e is an
integer in 1,.. . , 6 and next-cube is an integer that
determines which, element of BoundaryList contains
information about the next cube. Using this data structure
we can devise an algorithm to translate pixelwise data into
a boundary method representation, see Figure 10.

1

/ /

5:

\

I

Figure 9. A section of a graph depicting the
boundary of a three-dimensional object.

+
+
+

1 : z ::= z 1
2 : y ::= y 1
3 : z ::= z 1
4 : z :== z - 1
5:y::=y-l
6 : 2 :I= 2 - 1

4

(1)

An Algorithm to Obtain a Boundary Representation

Now we require a data structure that will allow
a three-dimensional pixelwise representation to be transformed into a boundary method representation. The boundary method gives rise to a graphical representation similar
to the two-dimensional version shown in Figure 7. A selection of an example of a graphical representation arising
using the boundary method on a i:hree-dimensional object is
given in Figure 9.
Every cube that is constructed from pixels on the boundary of the object is represented by a node in the graph. It
is typical that, for a computer representation of a standard

401

Figure 10. The Algorithm that transforms a
marching cubes representation of a threedimensional object into a boundary representation

Let I := 0.
Find first non-zero value
of cube

1
I := r + 1.
B L ( I ) { c m p Z e t e }:= 0
Boundary Cubes
representation

t

B L ( I ) {connectiondist}

no

Is there a listj,
such that B L ( j )

1

number of elements in the
appropriate entry of

Compute the lowest face
in the appropiate entry of
cube-f ace list not in
B L ( 1 ){ connection-list}

I:=j
I

I

I
the coordinates of the next
cube to be examined

Is this coordinate in B L ?

Append to

B L ( I ){ c o n n e c t i o d i s t }

402

I

:= Zength(BL)

+1

5

Comments and Conclusions

[4] Lorensen, W.E., Cline, H.E., (1987) Marching Cubes:
A High Resolution 3D Surface Construction Algorithm, Computer Graphics, 21,4, 163-169.

Using the algorithm given in Figure 10 will result

in an array with a structure such as (2). This storage is inefficient since there is, as was argued earlier, no need to store

[5] Nagae, T., Agui, T., Nagahshi, H., (1993) Interpolation of CT Slices for Laser Stereolithography, IEICE
Transactions on Information Systems, 76,8, 905-91 1.

the coordinates of every cube. The relative coordinates are
important and can be determined from the storage structure.
Giving the coordinates of a single cube will allow the absolute coordinates of any other cube to be determined. There
is also no need to store the complete variable since this
was only used for construction purposes. The storage can
also further be reduced by noting that if we pass through
face 1 of cube A into cube B, then this is equivalent to stating that we pass through face 6 of cube B into cube A.
Hence every connection is stored twice, causing redundancy. A simple trimming operation can halve the storage required for the edges.
In this paper we have presented an algorithm that takes
a pixelwise representation of a three-dimensional object as
input and outputs a representalion of the boundary. Storing information about an object with reference to its boundary requires far less storage than storing every pixel. Using the methods presented herein does in no way lead to a
loss of information. We do not approximate the object any
more than the original input, arid as such do not suffer the
short-comings highlighted in [6]. Storing the boundary as a
graph rather than the coordinates of boundary pixels allows
the use of graph-matching algor]thms to determine common
boundary segments in different objects. The storage of the
graph of the boundary is optimal.

6

[6] Rosin, P.L., (1997), Techniques for Assessing Polygonal Approximation to Curves, IEEE Transactions on
Pattern Analysis and Machine Intelligence, 19,6,659666.
171 Zhou, C., Shu, R.B., Kankanhalli, M.S., (1994) Handling Small Features in Isosurface Generation Using
Marching Cubes, Computers & Graphics, 18, 6, 845845.
[8] Zhou, Y,,Chen, W.H., Tang, Z.S., (1995) An Elaborate Ambiguity Detection Method For Constructing
Isosurfaces Within Tetrahedral Meshes Computers &
Graphics, 19, 3, 355-365.

[9] Zhou, C., Shu, R.B., Kankanhalli,M.S., (1995)Adaptive Marching Cubes, Visual Computer, 11, 4, 202217.

Acknowledgements

I would like to acknowledge the help of my PhD
student, Andrea Donafee. Her help in the preparation of
this paper-at a hectic time was invaluable.

References
[I] Donafee, A., Maple, C., (2000) Rotating Squares Journal of Pattern Recognition, submitted.

[2] Heiden, W., Goetze, T., Brickmann, J., (1993) Fast
generation of Molecular-Surfaces from 3D Data Fields with an Enhanced Marching Cube Algorithm, Journal of Computational Chemistry, 14, 2, 246-250.
[3] Levitt, D.G., Banaszak, L.J., (1992) Pocket - A
Computer-Graphics method for Identifying And Displaying Protein Cavities and Their Surrounding
Amino-Acids, Journal of hfolecular Graphics, 10, 4,
229-234.

403


Using Constraint Propagation and Domain Reduction for the Generation Phase
in Declarative Modeling

0. Le Roux, V. Gaildrat and R. Caubet
IRIT, UPS, 1 18 route de Narbonne, 31062 Toulouse Cedex 4,France
{ leroux, gaildrat, caubet} @irit.fr
Abstract

permits presentation, navigation and refinement of valid
models to help the user choose a solution.
In the following we only focus on the generation
phase.
This paper is organized as follows. Part 2 discusses
about the generation phase and related works. It explains
why the search tree approach should be preferred to other
techniques as much as possible. CSP' formalism and
associated techniques are one of the best ways to
implement exhaustive search, so they are presented in
section 2.2. Part 3 introduces a generic constraint solver
as a powerful generation tool. It is based on constraint
propagation and domain reduction. This part also insists
on hotspots to make generation process efficient, like
domain modeling and filtering algorithms. Architecture
(section 3.1) and main algorithms (section 3.2) are given.
Section 3.3 describes how to extend the system at lower
cost by creating more complex constraints from boolean
combination of existing ones. As an application, Part 4
presents a declarative space planning system for virtual
environments.

This paper presents an oriented object constraint
solver based on constraint propagation and domain
reduction f o r the generation phase in declarative
modeling. The solver supports generic constraints and
heterogeneous parameters via ;;eneric domains. This
ensures adaptability and efficiency of the resolution
process in complex cases. As an application, a declarative
system f o r 3D-environments planning is presented.

1. Introduction
Declarative modeling is a recent paradigm (80's) in
the world of computer aided design systems. It allows
designers to build scenes or shapes giving only a set of
properties and constraints to be satisfied, freeing users to
give all the numeric details. 111 opposite to classical
geometric modeling, it does not require a complete
knowledge of objects to build at start time. Moreover, it
can support non-geometric information and maintains
logical links between entities or logical structure of the
scene. It is a design process closer to the user's needs than
classical modeling.
A declarative modeler is the combination of three
parts [4]:
a. The first one is called description module. It defines
the application language and o f f m the user an interface
to describe the properties of scenes or shapes. It also
translates high-level descriptions in an internal language
easier to manipulate and process.
b. The second module can be considered as the system's
kernel. It is the generation module. Its role is to explore
search spaces to produce models ihat meet the description
made by the user even if it is incomplete. One of the key
ideas in declarative modeling is iihe ability of the system
to find several or all solutions.
c. The third part of a declarative modeling system is the
insight module. Many soluticns can be generated
according to the designer's specifications. This module

0-7695-1195-3/01 $10.00 0 2001 IEEIC

2. The generation phase
2.1. Related works
There are mainly four approaches to deal with the
generation phase problem:
- Specific procedural approach: designed for a particular
application; can be very efficient but is not flexible and
generally difficult to extend.
- Deductive approach: it is either a rules-based system or
an expert system based on an inference engine [12, 131.
The difficulties to build rules and their dependencies in
relation to the application are the main drawbacks.
- Stochastic approach: it leans on metaheuristics like
evolutionist algorithms or local search. It is a general

' CSP = Constraint Satisfaction Problem

117

Definition 5: neighborhood of a variable
The neighborhood of VE V is the set of variables denoted
T(v) such that T(v)cV and V w ~ r ( v 3) c ~ CVEV, and

method but it suffers from incompleteness of related
algorithms. However, it is the only viable approach when
the search space is too large. Examples of declarative
applications that use such techniques are [6, 111.
- Search tree approach: probably one of the most flexible,
more and more used in declarative modeling [ 1, 2, 91. It
allows a systematic exploration of search spaces and thus
the generation of all the solutions either at once or in
several times. The user can also control the search process
by giving tree branches to prefer or to prune. One of the
best ways to implement this approach is to use the CSP
model developed about thirty years ago by the AI
community. The generality and expressivity of this
formalism allow the expression of a wide range of
declarative modeling problems.
This is why, when the size of the search space is
reasonable, the search tree approach based on CSP can be
considered as one of the most appropriate to build a
powerful and efficient generic generation tool.

WE

v,.

Definition 6: projection of a constraint
Let c be a n-ary constraint on Vc=(VcI,...Vc,}. The
projection of c on WcVc, that will be denoted CJW,is the
constraint defined on W and equals to the set of
projections on W of the values of c.

.......

...........

kt c be a constraint in
defined by C = AI UA2

Cl(X,Yl=C
C l X = I,,

..... .........

W

UI,?

C3.Y = I,

X

Figure 1: example of 1D projections

2.2. The CSPs

Definition 7: a disjunctive constraint
A constraint c on V,=( Vel,. ..Vcn}is said disjunctive if
and only if 3 i E { l..n) such as cJ.Vc, is non-convex.

This section introduces basic terminology and
fundamental notions about CSPs.

Definition 1: a CSP
A CSP P = <V, D, C> is defined by:
- a finite set of variables V = { v,,...v, }
- a set of domains D = { D , ,...Dn }, where D, is the
domain associated with v,; i.e. the only authorized
assignment of v, are values of D,.
- a set of constraints C = { Cl, ... C, 1; each C E C is a
subset of the Cartesian product
D, where V,cV is

Example: C (fig.1) is disjunctive because of the projection on X

Definition 8: terminology
A CSP P is said to be:
- under-constrained if P has several solutions;
- over-constrained if P has no solution;
- well-constrained if P has one and only one solution.

n,,,

Though tractable algorithms exist in some particular
cases, general constraint satisfaction problems are NPhard. Nevertheless, many techniques exhibit a good
performance in practice in the average case. One of the
best approaches consists in combining systematic search
with constraint propagation (also called consistency
inference). The main difficulty is to find an effective
trade-off between the two ones.
- Systematic search algorithms explore the search space
by testing different possible combinations of variables
assignments until a complete solution is found. The most
common search algorithm is the chronological
backtracking.
- Consistency inference algorithms reason through
equivalent problems (see definition 4):each step consists
in narrowing down domains of the CSP to make it more
explicit. A propagation method embedded in backtracking
algorithm - so-called look-ahead scheme - limits
thrashing by pruning some detected inconsistent branches
of the search tree.
Declarative modeling is an interactive designing task.
Consequently most of the resulting generation problems
are under-constrained or over-constrained. Hard problems

the set of variables of c.
Each constraint can be defined:
- extensionally, for example giving sets of authorized
tuples in the case of finite domains;
- intentionally, giving either a mathematical equation or a
procedural method.
Note that the previous definition does not involve any
restriction neither on constraints arity nor on reference
sets of domains (each domain of D can be finite or
continuous, ordered or not, etc.).

Definition 2: solution to a CSP
A solution is an assignment of a value to each variable
from its domain such that all the constraints are satisfied.
Definition 3: partial assignment locally consistent
A partial assignment is said local/y consistent if it doesn't
break any constraint.
Definition 4: equivalence of two CSPs
Two problems P and P' are equivalent (P = P') if and only
if they have the same set of solutions.

118

more general approach than [ 1, 2, 91 which restrict all the
domains to only one mathematical reference set.
The performance of the resolution process strongly
depends on the domains internal representation. These
representations must take into account the following
considerations:
- Optimization of the ratio $filtering quality / filtering
computation time: the more a domain data structure is
precise and in accordance with its mathematical reference
set the more its memory cost and related filtering
evaluation time are important. In case of continuous
domain, combinatorial explosion due to disjunctive
constraints (see definition 7) and domain splitting should
be avoided by setting a lower bound for domain size.
- Intersection and union operators should be supported to
allow boolean combination of constraints (see section
3.3). When using an exact representation - for example in
the case of finite domains, the complementary operator
should be added.

(transition phase) are very singular. Due to its specificity
the intractability of CSP approac:h must not be considered
as a handicap.
T o learn more about CSP, rcfer to [5,7, 81.

3. A generic constraint sollver
In this part, a generic orientcd object constraint solver
based on CSP is presented. It can be adapted for various
generation problems in declarative modeling.

3.1. Architecture
The adaptability of the solver leans on genericity of
both constraints and domains. Here are the main classes
and the most important associated fields and methods.
The CSP class embeds the problem description:

Class c!;P
Main fields

II

Abstract Class Domain
Main fields
I
I

V: list<Variable>
D: list<Domain>
C: list<Constraint>

V: Variable

I

variable associated with this domain

Main metlhods

Main methods
abstract boolean is€%mpty ( )

finds thefirst solution (see definition 2 ) ifit exists and others by
successive calls (see section 3.2)

returns true iff the domain is empty
abstract List<Value> discretizeo

void removeVariable(in v:Variable)

returns a discrete representation of the domain (a list of values)
solve - see section 3.2)

I

( line 9 -algorithm

Domain createBackup ( )

makes a copy of all domains (line I D - algorithm solve)

Table 1: CSP class description

returns a clone of the Domain object

I

static abstract Domain Inter(in dl, d2:Domain)

computes and returns d , n d2
static abstract Domain Union(in dl, d2:Domain)

computes and returns d , u d ,

The Variable class describes free parameters of the
generation problem:

I

Main fields

abstract void setSingleValue(in va1:Value)

reduce domain to a sinple value
Table 3: Domain class description

I

In the solver, constraints are generic. They can be
defined according to the application.

D: Domain

Table 2: Variable class description

II

Abstract Class Constraint
Main fields

V: list<Variable>

The solver is able to manipulate a heterogeneous set
of variables. That means several types of domains can be
handled simultaneously in the resolution process. This
permits to precisely model a wide range of complex
generation problems (an example is presented on part 4).
Its specificity requires the implementation of a generic
support of domains. Such an idea has already been used;
for example in [3] to design effective algorithms for a 2D
isothetic’ planning application (EAAS). Note it is a much

variables of this constraint
RM

:

list<ReductionMethod>

Main methods

I

abstract boolean
testConsistency(in t: Assignment)

returns true if the constraint is satisfied,false otherwise
Assignment t is a list ofpairs (variable, value)
boolean reduceDomains0

constraint filtering method: applies reduction methods on free
parameters (i.e. not yet instanciated); returns false iff
inconsistency has been detected, (at least one domain is empty)

Table 4: Constraint class description

* isothetic = parallel to reference axes

119

II

A reduction method is an over-estimated projection
function of a constraint on one of its variables (see
definition 6). In the search process reduction methods are
used to tighten domains.

1

r

Abstract Class ReductionMethod
Main fields

boolean solve( in p : CSP;
in/out c : Context

I

I

outVar : Variable

)
Precondition: c i s a v a l i d Context s t r u c t u r e
Postconditions: r e t u r n e i t h e r t r u e i f p h a s a global
s o l u t i o n a c c o r d i n g t o c o r f a l s e i f t h e r e is no more
s o l u t i o n ( t h e e n t i r e s e a r c h s p a c e h a s been e x p l o r e d ) .
c is a new v a l i d c o n t e x t : i t c a n be u s e d t o g e t n e x t
s o l u t i o n . C u r r e n t s o l u t i o n ( p a i r s of ( v a r , v a l ) ! i s
returned in the f i e l d c . S o l .
1 IF Ic.NIVar1 = 0 THEN getNextVar c false

2
3

variable on which the constraint is projected

Main methods

4
5

abstract Domain proj ( )
the projection method of C on outvar

6
7
8

Table 5: ReductionMethod class description

9

Requirements: let CE be a constraint on E = D,x ...xD,.
Let F a set such that F E. We denote CF the restriction
of the constraint CE to F. The method proj - here
written proj(C, outVar) - must satisfy the two following
conditions:

10
11

(2) :

I
I
I I
I I
1

1

15

I
1
I
I
I
1
1
I
I
I
I
I
I

17
18
19

proj(C,,V,)
Vi€ { 1..n} proj(C,,V,) G proj(C,,V,)

I

12
13
14
16

(1): Vie { l..n) CELV,

ELSE getNextVar t true
globalSolutionFound c false
SearchNotFinished c true
WHILE NOT globalSolutionFound
AND SearchNotFinished
I IF getNextVar THEN

I

I

20
21
22
23
24
25
26
27
28 j
29 1
30 1

3.2. Main algorithms
This section presents the main algorithms required by
the solving process.
The search algorithm, called solve, is an improved
non-recursive backtracking algorithm using both
constraint propagation (line 17) and generic dynamic
heuristics (choosevariable on line 8 and choosevalue on
line 15). First call to s o l v e gives the first solution of
the CSP (see definition 2). Successive calls enumerate all
the other solutions of the problem via Context structure.
Locallyconsistent (line 16) checks consistency of
partial assignments (using the method testconsistency
of constraints). This test is necessary because of possible
inexactness of reduction methods.

c.IVar.push(chooseVariable(c.NIVar))

c.DDom.push(c.IVar.top.D.discretize0l
c.Bak.push(p.createBackupDomains0)
getNextVar t false
1ocalSolutionFound t false
W I L E (c.DDom.top01 f 0
AND NOT 1ocalSolutionFound
1 val = chooseValue(c.DDom.top0)
1 IF locallyConsistent(c.va1) AND
I
constraintPropagation(c,vall THEN
I I 1ocalSolutionFound t true
1 I c.Sol.push( (c.IVar.top0, Val) )
1
BREAK
/ / exit while (line 131

I p.restoreDomains(c.Bak.top0)
IF 1ocalSolutionFound
THEN IF Ic.NIVarl=O
THEN globalSolutionFound
ELSE getNextVar = true
ELSE
/ / backtrack
1
1
I
1
I
I

t

true

c.NIVar.push(c.IVar.pop0)

c.DDom.pop0
c.Bak.pop0
c.Sol.pop0
31 I
IF (c.IVARI = 0
32 I
THEN searchNotFinished t false
33 IF globalSolutionFound THEN RETURN true
34

ELSE RETURN false

/ / no m o r e s o l u t i o n

Algorithm 1: solve
Constraint propagation can be either limited to direct
neighborhood (Forward-Checking = FC) or performed on
the complete CSP (Real-Full-Lookahead = RFL) [8].

About iocal consistency: in the general case the useful
arc-consistency3 cannot be achieved in practice. It is
replaced by a weaker local consistency that only depends
on implemented reduction methods.

~~

boolean constraintProgagtion(
in c : Context;
in val : Value )
Precondition: c i s a v a l i d Context s t r u c t u r e
iff
constraints
Postcondi t i o n s :
return
false
p r o p a g a t i o n d e t e c t s i n c o n s i s t e n c y . i . e . one domain a t
l e a s t has been emptied.
P i s an e q u i v a l e n t and s i m p l e r CSP.
1 Variable var = c.IVar.top0

Glossary: Context is a structure containing five stacks:
NIVar = Non Instanciated Variables: stack of Variable
IVar = Instanciated Variables: stack of Variable
S o l = Solution: stack of pairs (Variable, Value)
DDom = Discretized Domains: stack of list of v a l u e
Bak = Backup of domains: stack of list of Domain

2
3
4
5
6
7

8

A constraint CE C is said arc-consistent iff VV,E V,. VdE D,, d is
supported by c. A CSP is arc-consistent iff all its constraints are arcconsistent.

var.D.setSingleValue(va1)
FOR EACH v IN c.NIVar
I IF v E r(var) THEN / / r=neighborhood
I
FOR EACR cn E v . C
IF NOT cn.reduceDomains0
1
RETURN false
1
RETURN true

Algorithm 2: constraintPropagation (FCversion)

120

3.3. Extension: combinations of
constraints using boolean operators

Note: in real applications boolean combinations of
heterogeneous constraints can appear when handling
combination of meta-constraints.

basic

Let’s consider a set of basic constraints defined for a
specific application. An interesting issue is: is it possible
to combine them using boolean operators (AND, O R , NOT)
to create meta-constraints, i.e. more complex constraints?
In the case of homogeneous variables and extensional
constraints the answer is positive and trivial:
let C,= c{”,~” , 1~c E, = D,I x ...x D,”
and CZbe two

4. An application: a declarative planning
system for virtual-environments
4.1. Overview
This part presents a declarative modeler called
DEMZONS-NG4.A functionality of this application is to
place 3D-objects - for example furniture - in a virtual
environment according to a high-level description. Notice
that the goal is neither to create the most efficient space
planning system, nor to propose the most complete one;
but only to design a generative system to illustrate solver
capabilities.

extensional constraints on homogeneous variables: then:
(3):
(4):

c, AND c2 = c1 n CZ
C I ORC2=C1 Ucz

(5) : NOT

C1 = CEIC, (complementary of C I on El)

The only task consists in implementing the three
classical set operators (n,u,C)on considered domains.

Intentionally given Constraints (for example, constraints
defined by a procedural method): unlike the extensional
previous case, classical set operators cannot be directly
applied. However it is possible to preserve filtering by
observing:
( 6 ) : (CIANDCZ)JV~= ( c 1 ~ v , ) ~ ( ( c ~ ~ v , )

( c , OR cz) 1v, = ( ( ~ IVI)
J U (CzJ VI)
where VI is both a variable of C , and Cz
( 7 ):

Hence, ( 1 ) and ( 2 ) (see section 3.1) imply:
( 8 ):
(9) :

proj (CI AND CZ,VI) c proj (C,, VI) n proj(C2, VI)
proj (C, OR CZ,VI) c proj (C,, VI)U proj (Cz, VI)

Therefore, instead of defining reduction methods for
(C, {AND, O R ) Cz), intersection and union operators can
be implemented on concerned domains while generally
preserving a correct filtering.
The NOT operator is more problematic. In fact
proj(NoT C I , VI) c CE, prclj(C,, VI) cannot be used
because when D, has been reduced - i.e. proj(C,, VI) has
been computed - we don’t know yet if its values can be
extended to global solutions or not. In conclusion:
specific reduction methods milst be given to negate an
intentional constraint.

~

Figure 2: synoptic of DEM20NS
As said, the underlying
problem is a
- - generation
space-planning problem. Each 3D-object is identified
with its local coordinate space and defined by three
different kinds of parameters:
- Position variable: location of the local coordinate space
origin in the world coordinate space. A position
variable is made up of three one-dimensional values:
- Orientation variable: an angle in degree. Three
orientation parameters (the three Euler angles) are used
to orientate an object;
- Size variable: a one-dimensional parameter. It
describes a dimension along an axis. Three size
parameters are needed to define the size of a 3D-object.

Heterogeneous constraints: for example if c, and cz are
two unary constraints on two heterogeneous variables v,
and v2, then evaluating proj(C, AND Cz, V I ) and
proj(CI AND CI, Vz) consists in both computing
proj(C1, V I ) and proj(Cz, Vz). Because of independence
between domains D1 and DZ, the constraint (C, OR C,)
cannot be filtered. A new kind of domain - the Cartesian
product of DI and D2 - should be added to perform a
reduction.

DEMWNS-NG = Declarative Multimodal Modeling System Next Generation (initial version, called DEM*ONS, was partly
developed by Kwaiter in [9]).

121

practice each voxel owns a list of pointers towards the
geometrical elements that pass through it.

Consequently to describe an object in the application,
seven Variable objects are required: one for position,
three for orientation and three for size.
For 2D space planning problems, it is proven [3] that
such a representation gives good results. Here, this idea is
extended to 3D. Furthermore one of the most important
differences with [3] is the ability of the system to handle
any orientation, not only isothetic ones. Notice also that
objects can be identified with hierarchical structures of
bounding boxes - i.e. a set of local coordinate spaces - for
a more accurate representation.

I

I

I

I /a

I

I

1

I

I

I

1

I

I

Figure 4: two position domains and the resulting
intersection (2D-orthographic projection)

4.3. About constraints
The application kemel is composed of a set of basic
constraints. Some examples of significant basic
constraints are:
- On position parameters (pas):
Position-fixed (pos, value) (unary)

- On orientation parameters (ort):
Orientation-fixed (ort, value) (unary)

Figure 3: a 3D-object identified with its local
coordinate space

Orientation-same-as (ortl,ortz) (binary)

- On size parameters (Size):
Size-fixed-in (size, min, max) (unary)

4.2. About domains internal representation

Size-equal-to (sizel,size2) (binary)

As parameters are heterogeneous, a different kind of
domain is assigned to each other.

Size-greater-than (sizel,size2, k ) (binary)

- Heterogeneous ones (ob] = {pos, ort, size)) :
Non-overlapping (objl,objz) (arityis 14)

Orientation variable domains: in this application,
consistency tests often require a fixed orientation. So
associated domains are represented by a finite list of
values.

In-fixed-half-space (obj, half-space) (arityis7)

Information: a half-space is defined by a 3D-plane
that splits 3D-world space in two parts.
On-relative-plane (objl.pos, plane<obj2>)

Example: D,, = { 0";15"; 30"; 90" )

It constrains position parameter of obj, to be on a
plane defined from obj2.

Size variable domains: to achieve a correct filtering even
processing disjunctive size constraints, a list of
independent and continuous intervals is used.

Each basic constraint has a set of appropriate
reduction methods to perform domain reduction during
the search phase. They can be combined (see section 3.3)
to get high-level constraints such as:

Example: Ds= [0, 1001; [1.50,15.5];[250;300] )

Position variable domains: as position is a threedimensional parameter, the internal representation must
describe a 3D-space. Various representations, either
continuous or discrete can be used; for example: a list of
polyhedra, a voxel array, an octree, a list of 3D-points, a
set of 3D-isothetic boxes, etc. Actually a good choice is a
trade-off between accuracy of modeling and efficiency of
resulting reducing algorithms. As the system must hold
both equality and inequality constraints, the chosen
modeling is finally a voxel array coupled with a set of
geonierrical elenzetirs (like 3D-point, lines and planes).
Voxels describe volumic space generated by inequality
constraints while geometrical elements are used to tighten
domain in case of equality constraints. The two
complementary models are maintained simultaneously. In

object

target

spatial preposition object

landmark

Examples: objl on objz; objl in-front-of obj2.

5. Experimental results
Some experimental results are presented to illustrate
what can be expected from such a system.

Test scene description: the scene is composed of 30
complex geometric objects (four walls, three tables, two
chairs, a TV, two computers, shelves, books, etc.). The
high-level description contains meta-constraints like
SCREEN, is on TABLE,,dimensions of TABLE,are 2m x

122

0.7mx O.Sm, TABLE, is agairzst the back wall, TABLE, is
t o the right of TABLE2, etc.

various generation problems while preserving correct
performances.

Solver configuration is:

I Voxel size (for position parameter domains) I

20cm
20 cm

Step for position parameters
Step for orientation parameters
Step for size parameters

Future works concern the improvement of existing
generation tools, the design of new ones, and other
aspects of declarative modeling like declarative lighting
and shading.

I

15"

10 cm

References
Translation of the
representation gives:

description

in

Number of variables
Number of basic constraints

the

1

I

internal

[ l ] P-F Bonnefoi, D. Plemenos. Object Oriented Constraint
Satisfaction for Hierarchical Declarative Scene Modeling.
WSCGP9, Plzen, Czech Republic, February 2-12, 1999.

210
245

[2] L. Champciaux. Declarative Modelling : Speeding Up
Generation. Proceedings of CISST'97, p 120-129, Las Vegas,
Nevada, July 1997.

[3] P. Charman. Solving Space Planning Problems Using
Constraint Technology. Technical report CS 57/93, Institute of
Cybernetics - Estonian Academy of Sciences, 1993.
[4] C. Colin, E. Desmontils, J.Y. Martin, J.P. Mounier. Working
Modes with a Declarative Modeler. Compugraphics'97,
Villamoura, Portugal, GRASP, 15- 18 Dec. 1997, pp 1 17-126
[5] R. Dechter, F. Rossi, Constraint Satisfaction, Survey ECS,
March, 2000.

[6] S. Donikian, G. Hegron. The Kemel of a Declarative Method
for 3D Scene Sketch Modeling. GRAPHICON'92, Moscow,
Russia, September 1992.
[7] C. Freuder, R. Dechter, B. Selman, M. Ginsberg, and E.
Tsang, Systematic Versus Stochastic Constraint Satisfaction.
Panel, IJCAI-95, pp. 2027-2032.

Figure 5: four views of a scene generated by the
application that meets the description

[8] V. Kumar. Algorithms for Constraints Satisfaction Problems:
A Survey, The AI Magazine, Vol. 13, Number I , p32-44, 1992.

Time to get the first solution - the first valid scene
according to the given constraints - is approximately 3
seconds. In this example, there are too many solutions to
generate them all. However, some other solutions can be
obtained (required computation time is generally < 1
second).

[9] G. Kwaiter, V. Gaildrat, R. Caubet . DEMZONS: A High
Level Declarative Modeler for 3D Graphics Applications.
CISST'97, p149-154, Las Vegas., Nevada, March 1997.
[IO] G. Kwaiter, V. Gaildrat . Modelling with Constraints : A
Bibliographical Survey. International Conference on
Information Visualisation, IV'98 , London UK. IV'98, July 1998.

Note: the implementation of our application is in Java
(JDK 1.3) / OpenCL and runs under Windows 20000 on
a PI11600 / 256Mb. With a good implementation in C++
and some heuristics adjustments, computation time should
probably be highly restricted.

[ 1 I] S. Likge, G. HCgron. An Incremental Declarative Modeling
Applied to Urban Layout Design. WSCG'97, Plzen, Czech
Republic, Febrary 97.
[ 121 P. and D. Martin. Declarative Generation of a Family of
Polyhedra, GRAPHICON' 93. St Petersbourg, September 1993.

6. Conclusion and futunt works

[ 131 D. Plemenos. Declarative Modeling by Hierarchical
Decomposition. The Actual State of the MultiFormes Project,
GRAPHICON'95, St Petersbourg, Russia, July 1995.

A generic constraint solver based on classical CSP
techniques for the generation phase in declarative
modeling has been presented in this paper. The use of
generic constraints and heterogeneous parameters (via
generic domains) allows the adaptation of this tool to

123


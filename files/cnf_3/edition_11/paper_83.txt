The General Variables Concept:
A Simple Step from Single- to Multi-user Environment
Michal Masa, Jiri Zara
Department of Computer Science and Engineering, Czech Technical University in Prague
{xmasam, zara]@el.cvut. cz
in the same state. These requirements involve distribution
of world changes among the active clients and bringing
later connected users up-to-date on the current state. For
this purpose we enhanced the server to support a generul
variable distribution, joumaling and locking.
Since the concept of general variables is very flexible,
it allows a wide range of applications to utilise the server
for their specific purposes. This led us to an idea of
designing a Java library, which enables turning a singleuser application into a multi-user one with minimum
effort. The library in conjunction with the server provides
a client application with basic capabilities required for
implementation of a typical multi-user system: user
administration, network communication, latecomer
updates, etc.
In section 2 , we explain the concept of general
variables and related mechanisms of variables
distribution, journaling and locking. Section 3 discusses
the concept implementation. The results are presented in
Section 4, where applications currently exploiting the
proposed approach are listed and described. Section 5
concludes the work.

Abstract
When implementing multi-user cooperution systems in
networked virtuul environments, synchronizing locul
representutions of shured virtuul world hus to be
considered. It involves distributing und storing the dutu
that represent users’ uctivity in the virtuul world. In this
puper we propose U concept of generul vuriubles, which
formulizes the tusk of distributing, journuling und locking
the dutu in the client-server model. To verih the
employubility of the concept, we huve implemented U Juvu
bundle comprising U server und U client-side library.
Four multi-user upplicutions ure presented to
demonstrate that with the help of the bundle, U single-user
upplicution cun be turned into multi-user one with
minimum effort.

1. Introduction
Last year we introduced a client-server system, which
utilizes multi-user VR environment for educational
purposes [ I ] . The system sets off one of the users as a
tutor, the rest of them become hidher uudifors. The main
goal of the system was to enable auditors to watch the
virtual world through the tutor’s eyes. The system was
implemented using VRML (Virtual Reality Modeling
Language) [2,3] and Java programming language to
ensure portability to greatest extent possible.
The next development step was to extend the system to
meet multi-user cooperation purposes. In contrast to
previous scenario, it is crucial that any changes performed
in the virtual world by any user are persistent and visible
to every user. Every connected user should see the world

2. The concept of general variables
The primary task of a cooperative multi-user system is
to ensure distribution of users’ activities and world
modifications. The system should also bring latecomers
up-to-date on the current state. As far as a client-server
model is considered, the server is responsible for
distributing and storing the appropriate data representing
user’s interaction with the world. Since the structure and
the meaning of the data are application dependent, we
proposed the concept of general variables.

Table 1. List of supported commands
Command
setValue(va1ue)
setlValue(index, value)
insertvalue (index, value)
delete (index)
clear ( )

Meaning
Sets the variable to a particular value
Sets the index-th value
Inserts a value at the index-th position
Deletes the index-th value from the variable
Clears the variable

584
0-7695-1195-3/01
$10.000 2001 IEEE

variable is up to the application, which has to adapt the
concept to meet its specific needs.

2.1. General variable structure and distribution
General Variable consists of a name for its unique
identification and a list of commands performed on the
variable. The variable can bt: hrther partitioned and
treated as an array. A typical command sets the variable
to an arbitrary value. The flexibility of the concept is
based on the fact that the value can be compounded of
any number of any primitive data types. It can be a simple
value as well as a heterogeneous structure. When a user
attempts to interact with the world, the client application
creates adequate variable and adds a specific command
containing a value representing the user’s action.
Supported commands are listed in Table 1. The variable is
then sent to the server, which is responsible for
broadcasting the variable to other clients. Finally, the
receiving client should decode the meaning of the variable
and replay the original action locally.
Every variable sent to the server has associated
information that controls the distribution of the variable whether it should be broadcast to all active clients
(implicitly except the sender) or sent just to a particular
one(s). If the consistency of the virtual world is critical,
all changes to the world should be performed in the same
order on all clients. Since the server performs ordering of
variables prior to the broadcast, echoing the variable back
to the sender can accomplish the task (echoing is
determined when sending the variable by setting the
ECHO flag). The sender must then postpone the
realization of the changes until all variables preceding the
echoed variable are processed. As this approach reduces
interactivity rate due to longel- response times, another
technique is mutual exclusion on accessing the variables
described in article 2.3.
The similarity between the commands proposed here
and those listed in [ 2 ] is not accidental. Since we assume
VRML representation of the virtual world in most cases,
one of the possible uses of general variables is to imitate
VRML fields. In VRML, user’s interaction and changes
to the world will always result in VRML event(s)
generation. Those events can be easily encapsulated into
setvalue command. More complex operations on
VRML multiple-valued fields will exploit the remaining
commands or even their sequences.
However, this low-level appi-oach is definitely not the
only way of utilizing general variables. Thanks to their
flexibility, they can represent properties of any abstract
structure in the virtual world. The interpretation of the

2.2. General variable journaling
Latecomers to the system (clients connected later)
should find the virtual world in its current state. However,
when considering VRML again, client typically starts by
loading original world, which is unaffected by any
changes made to it later. To solve this problem, the server
maintains a journal of variables. Implicitly, every variable
distributed through the server is stored in the joumal prior
to further broadcasting. The process of storing involves
the following steps.
First, the journal is searched for the existence of a
variable. If it is not present yet, an empty variable with
the same name is added to the joumal. Then the list of
commands contained in the processed variable is
appended to the list contained in the journal variable.
However, in some cases it is not necessary to cumulate all
the commands performed on a variable, it is sufficient to
store only the last command instead (providing it is a
setvalue or setlvalue command). A variable
representing the position of some virtual object is a good
example - only the last position of the object is
significant, prior changes can be safely forgotten. There
are also situations, when the variable should not be stored
in the joumal at all. A variable holding a chat text could
be such an example, unless we want to store the chat
history. To differentiate among particular cases, a storage
Jag is attached to every command. Possible values of the
flag and their meanings are listed in Table 2.
Special methods are being investigated to prevent the
list of commands from having accumulated illimitably.
The idea is that the list of commands can be modified
(shorten), while it still preserves the original information.
For example, when appending clear ( ) command to the
list, all previous commands can be removed, since they
are not relevant any more.

2.3. Hierarchical locking of general variables
A user performing complex modifications of the
virtual world may require exclusive access to affected part
of the world to prevent other users from interfering with
himher. In the general variable concept, this is provided
by a variable locking mechanism. A client can lock the
whole variable or its specific index. Locks are exclusive,

Table 2. List of possible values of the Storage flag
Storage flag value (symbolic constant)
STORE-N EW
STORE-LAST
STORE-NOT

Meaning
Store the command by appending it to the end of the list
Store the command by overwriting last command in the list
Do not store the command

585

variables distribution and joumaling, updates of
latecomers and user management. It is also capable of
serving several different virtual worlds at the same time
by separating general variables of each world.
The client side is designed as a reusable Java library
that mediates between a host application and the server.
The library provides the application with a set of
functions for general variable creation, distribution and
locking. On the other hand, the application may define a
set of callback routines, which the library calls in
response to the messages received from the server.
Callbacks occur whenever a general variable has been
received; variable locking operation has proceeded, either
successfully or unsuccessfully; a user has connected to or
disconnected from the system.
Figure 1 shows the most common architecture of the
client. The host application is implemented as a Java
applet communicating through EA1 [3] with VRML
browser, both running in a WWW browser. The dashed
line between the library and EA1 block denotes an extra
library features, which are a limited implementation of
multi-user extensions to VRML as proposed in [4]
(namely NetworkNode) and a support of trace mode
required by DILEWA. Since these features rely on
VRML scene representation, they can be deactivated on
request.

preventing clients from locking the variables that have
already been locked by other clients. The client is
responsible for unlocking the variable(s), after the user
has finished the world modifications. It is up to the
application to be aware of possible locks and to check the
locks prior to enabling a user to modify the world. Since
we assume the same application running on all clients, it
should not be difficult to implement it.
The nature of a virtual world is essentially hierarchical.
Virtual objects are usually compounded of smaller parts another virtual objects. If a user attempts to modify an
object exclusively, helshe might require preventing the
others from modifying even sub-objects concurrently.
And vice versa. For example a user changing overall size
of a virtual room would interfere with another user trying
to precisely position a table relatively to the room wall. In
order the application would not have to check the locks of
all sub-objects, we proposed a hierarchical locking based
on variable names.
The principle of hierarchical locking is as follows. If a
variable named idA is locked, then variable named idB
cannot be locked as far as one of the following equations
is satisfied for some suffix:
idA = idB+suffix
(11,
idB = idA+suffix
(2).
The suffix represents an arbitrary string (even empty

one) and operator '+' denotes string concatenation.
To illustrate the use of hierarchical locking, consider a
virtual world containing a room with a table and a chair.
Suppose an application chooses variable names according
to Table 3 to express hierarchical organization of the
scene. Consider a situation in which the variable
"Room.Table" is locked. Table 3 shows which variables
can be locked next.
On the other hand, if the second user in the example
above was just changing the color of the table, helshe
would not interfere with the first user at all. The
application should determine how and in which cases the
hierarchical locking can be exploited and investigate
appropriate variable names accordingly.

W W W browser
VRML

b row s e r
I

I

EA1

1

+
................f ...............

.

.

3. The concept implementation

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
_
I

1

connection
to server

To verify the efficiency of the general variable
concept, we have implemented it using Java programming
language. The implementation consists of two parts: the
server and client side. The server side supplies the general

I

Network

I

Figure 1. A common client architecture

Table 3. An example of general variable names expressing hierarchical structure of the scene
Variable name

Can be locked?

Why not? (Satisfied equation(s), suffix)

Room
Room.Table
Room.Chair
Room.Table.Leg

No
No

(I), ".Table"
(I), (21, - empty

Yes
No

(2),

586

'I.

Leg"

Figure 2. A concurrent editing session, where two users are editing the same model.
The Transform tool hias been attached to the rook model, thus enabling the users to change the
positions of vertices by dragging.

Figure 3. Avatars and chat window in Virtual
Agiora

Figure 4. User interface of yacht training
application
employs general variables for representing object
properties that correspond directly to VRML fields in
most cases. The library assures that changes of the scene
are visible to every user, even to the latecomers. The
variable locking mechanism can be exploited to prevent
users from changing the same property of the same object
simultaneously.
The third project has got a working name Virtual
Agora. It involves existence of avatars and chat facility
(in a similar manner to the Blaxxun system [ 5 ] ) . These are
not natively supported by the library but can be easily
implemented by the use of general variables (Figure 3).
The last project is an experimental system for teaching
and testing yacht captains (Figure 4). The project
proposes a scenario, where an instructor can control,
guide and examine hisher student(s) in a shared virtual
world. The implementation comprises of two distinct
client applications to differentiate between specific needs
of the instructor and the student. While the instructor

4. Sample applications
At present, our research group is developing four
multi-user projects based on the library.
The first of them is a successor of the DILEWA
project, which preserves original tutor/auditors idea. The
DILEWA functionality is now fully supported by the
library, including the trace "ode and net-routes, which
were implemented using N e t w o r k N o d e mentioned above.
The next project deals with cooperative editing of
VRML scene. Users can modify scene objects by
attaching special geometries (,fools)to them (Figure 2).
Manipulating the controls of the tool results in changes of
the object properties. There are several different tools
related to particular object properties: the Material tool
and the Transform tool are the basic ones. The tools are
attached dynamically and no preprocessing of VRML file
describing the edited scene is required. The application

587

International Conference on Information Visualisation, 2000,
pp. 563-567.

generates tasks and test situations, the student has to solve
them. Since both are sharing the same world, the
instructor can easily control the student or help himher
when the student is experiencing difficulties.

[2] The Virtual Reality Modeling Language International
Standad ISO/IEC 14772-1:1997
http://www.web3d.org/technicalinfo/specifications/vrl97/inde

5. Conclusion

x.htm

In this paper, we have presented a formalized approach
to the problem of distributing, storing and locking the data
in multi-user networked virtual environment based on the
client-server model. The concept has been implemented
as a Java bundle, consisting of a server and a client side
library. Four multi-user applications, each aimed at
different purpose, have used the library and proved the
efficiency of the concept.

[3] The Virtual Reality Modeling Language External Authoring
Interface Committee Draft ISO/IEC 14772-2
http://www.vrmI.org/WorkingGroups/vrl-eai/Specification/

6. Acknowledgment

[6] G. Reitmayr, “Behind the scenes of a VRML multi-user
architecture”, VRML99 Courses, 1999

This work has been supported by the Ministry of
Education, Youth and Sports of the Czech Republic under
research program No. 1898/3001 - Cooperation in the
virtual reality.

http://www.c-lab.de/vrml99/
http://www.geometrek.com/

[4] Living Worlds,
http://www.mI.org/WorkingGroups/living-worlds/
[5] Blwxun Interactive,
http://www.blaxxun.coml

[7] R. Galli, Y. Luo, “Mu3D: A Causal Consistency Protocol for
a Collaborative VRML Editor”, Proceedings lt’eb3D - b ‘ R M
3000,2000, pp. 53-62.

References

[SI D. Margery, B. Amaldi, and N. Plouzeau. “A General
Framework for Cooperative Manipulation in Virtual
Environments”, Proceedings of the Eurogruphics JP.orbhop in
Vienna, Austria, May 31-June 1, 1999, pp. 169-178.

[ I ] M. MaSa, J. ZAra, “DILEWA: The Distributed Leaming
Environment Without Avatars”, Proceedings of -7000 IEEE

588


Jigsaw-puzzle-like 3D Diagrams to Represent Syntactical Constraints
Noritaka OSAWA
National Institute of Multimedia Education
2-12 Wakaba, Mihama-ku, Chiba, 261-0014 JAPAN

osawa@nime.ac.jp
Abstract
Three-dimensional
diagrams
composed
of
jigsaw-puzzle-like glyphs are proposed for representing
syntactical constraints. The 3D glyphs have convex and
concave shapes that give visual representation to the
constraints. A production rule of grammar is represented
by a stretchable board shape. A syntactical structure is
represented by a nested board shape. A syntactical
constraint is represented by an inclusive match between
the convex shape of one board and the concave shape of
another. A generation method of jigsaw-puzzle-like 3D
glyphs for context-free grammar is proposed and
described.

1.

Introduction

Visual programming languages use diagrammatical
representation and icons. Many of the languages can
represent control flows and data flows using graphs [4][7]
[12]. Icons are useful for roughly representing the
various types of concrete objects; however, I do not think
they represent syntactical constraints very well.
This paper proposes the use of 3D diagrams to
represent the syntactical constraints in a grammar and
describe a method for generating them. They use
jigsaw-puzzle-like 3D glyphs, or shapes, to represent the
syntactical constraints. The inclusion relations of 3D
glyphs represent syntactical constraints. The glyphs have
concave parts and convex parts, and an inclusive match
between a convex part and concave part represents the
satisfaction of a constraint.
Although this constraint representation is similar to
matches between the pieces of a jigsaw puzzle, the phrase
“jigsaw-puzzle-like” does not mean an exact match
between shapes. If a convex shape fits within a concave
shape, they are considered to match and thus satisfy a
constraint. As far as I know, the application of
jigsaw-puzzle-like glyphs to syntactical constraints has
not been fully studied under the condition that exact
matches are not required.
This paper describes the method for generating glyphs,
and considers a context-free grammar. This simplifies the
discussion because the left-hand side of a production rule

has only one symbol in a context-free grammar.
This paper is organized as follows. Related work is
discussed in the next section. Then, 3D diagrams for
syntactical constraints are explained in Section 3. After
that, generation of glyphs for a hierarchy is briefly
described in Section 4. Section 5 then explains generation
of glyphs based on syntax. The duality of glyphs and the
scalability of the proposed diagrams are discussed in
Section 6, and future work is described in Section 7. The
paper is summarized in Section 8.

2.

Related work

Several methods have been proposed for giving visual
representation to graphs representing hierarchical
structures[5]. Nested structures are often used to represent
hierarchical structures where the region of a node
includes the regions of its sub-nodes. Transparent nested
cubes[13] can also be used to represent nested structures
in 3D. Although they are useful for representing a
structure, they are not useful for representing syntactical
constraints or production rules.
I previously proposed the use of 2D glyphs[8][11] to
represent inheritance relationships in object-oriented
programming. The work in this paper is based on that
approach, but it is extended to syntactical constraints and
3D. The inheritance relationships in a single-inheritance
hierarchy have been studied in the previous work. Those
relationships are hierarchical. In contrast, syntactical rules
do not always constitute a simple hierarchy. They can
contain recursive relations.
Bridge[2] used a kind of jigsaw programming, but it
can neither handle practical inheritance hierarchies nor
syntactical constraints.

3.
3.1.

3D diagrams for syntactical constraints
Basic idea

In the proposed method, syntactical constraints are
given visual representation by using jigsaw-puzzle-like
3D glyphs that have convex and concave shapes. A
production rule is represented by a stretchable board

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

shape, as shown in Figure 1.
The left-hand side of a production rule is represented
by a convexo-convex shape as shown in Figure 2. In other
words, a convex shape on a board has the same convex
shape on the reverse side. Given this, we can determine
whether two boards match by simply looking at their
front sides.
The right-hand side of a production rule is represented
by concave shapes or by holes in a board. A match
between the convex shapes of one board and the concave
shapes of another board satisfies a syntactical constraint.
When a convex shape is placed in a concave shape, the
board with the concave shape is stretched, and the size of
the board is adjusted, although the size of the glyphs is
not changed. Nested board shapes have a nested structure,
as shown in Figure 3.
One can understand syntactical constraints, such as
that a variable is an expression and that a block statement
is a statement, if the proposed glyphs are used
appropriately. Figure 4 shows example relationships of
jigsaw-puzzle-like glyphs. The use of jigsaw-puzzle-like
3D glyphs should help programmers.

Fixed size

Stretchable

Fixed size

Fixed size

Left-hand-side
sym bol

Stretchable

R ight-hand-side
sym bols
C onvex

C oncave

Figure 1: Example of a production rule

C onvexo-convex

Figure 2: Backside of convex shape shown in Figure 1

Left-hand-side
convex shape

Parent

Child

Figure 4: Example relationships of jigsaw-puzzle-like 3D
glyphs

3.2.

A simple 3D diagram for a grammar

Let us consider the generation of glyphs based on a
grammar. Grammar G is defined as a quadruple,
G = (V, T, S, P),
where V is a finite set of variables, T is a finite set of
terminal symbols, S is a start symbol, and P is a finite set
of productions.
As stated above, a production rule is represented by a
board shape. A convex shape on the board represents the
left-hand side of the rule. Concave shapes on the board
represent non-terminal symbols on the right-hand side.
A simple unique-glyph method that assigns each
symbol to a unique glyph that is not included in other
glyphs can be used to represent syntactical constraints.
The glyph-generation method that will be described in the
following section can be used to generate many unique
glyphs.
Consider the grammar G = (V, T, E, P) with
V = {E, I },
T = {a, b, +, *, (, ) },
and productions
E→ I

E→
E→
E→
I→
I→

Stretched

Figure 3: Nested boards

Right-hand-side
concave shape

E+E
E*E
(E)
a
b.

These productions can be represented as shown in
Figure 5. In this paper, rotational transformation is not
considered when determining inclusion. The diagrams in

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

Figure 5 represent not only the structure of them but also
the syntactical constraints among them.

E→ I

Although a diagram based on this method shows the
syntactical constraints, each production rule has its own
board, and the relationship between the left-hand side
symbol and the right-hand side symbols is established by
only a board that has glyphs for both sides. This is
indirect and complicates the diagram.
For example, terminal symbols a and b can be derived
from E, but this method needs the boards for I → a and
I → b. Even if we eliminate I by substituting I with E,
boards for the productions from E to the terminal symbols
are required. Including the glyphs for a and b in the glyph
of E is more direct and less complicated.
After explaining the method used to generate 2D
glyphs for hierarchical relationships in the next section,
let us consider my proposed generation method, which
simplifies the diagram and requires fewer boards to
represent syntactical structures.

4.
E→ E+E

E→ E*E

E→ (E)

I→

Here a method used to generate 2D glyphs for
hierarchical relationships (or inheritance relationships) is
explained[8][11] 1 as preparation for describing my
proposed method for generating syntactical constraints.
2D glyphs can be used to represent (inheritance)
hierarchical relationships, not to show a position in a
hierarchy. The 2D glyph of a node in a hierarchy
identifies the node but does not show the precise position
of the node in the hierarchy.
We can represent a node in a hierarchy as a polygonal
glyph. A glyph for a node is generated by replacing the
sides of the glyph for its parent node with other polygons.
Figure 6 shows an example of a hierarchy.
The simple recursive method uses one initiator shape
and one generator shape. For example, a regular
rectangular and a triangular shape can be used as an
initiator and generator shape, respectively. The initiator
shape corresponds to the root node of the hierarchy. The
generator shape is used to replace a side of the glyph.
The relationships in a hierarchy can be represented by
the inclusion relationships of glyphs that have the
following properties (again, for simplicity, rotational
transformation is not considered):
(P-1) Glyphs of children are included in the glyph
of their parent.
(P-2) A node that does not have a hierarchical
ancestor-descendant relationship with another has
a glyph that does not include the glyph of the
other node, and vice versa. This condition will

a

1

I→

b

Figure 5: Example diagrams for grammar G.

Generation of 2D glyphs

The paper[11] containing the details of the generation method can be
accessed at the following URL.
<http://search.ieice.org/2002/files/e000d01.htm#e85-d,1,275>
The paper also discusses the scalability of the generation method.

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

be stated such that the glyphs do not include one
another.
The simple recursive method is applicable when the
number of children of each node and the depth of the
graph is small. It is not applicable if the number of
children is larger than the number of sides. If the graph
has a deep hierarchy, the differences among the glyphs for
nodes at the deeper depths are so small as to be
indistinguishable. My proposed method solves these
problems, and the solution is useful for practical
hierarchies [8][11].
Before explaining my method, let us consider the
position of a node in a hierarchy. The hierarchical
relationships can be represented by a tree. A sequence of
ordinal numbers at each depth of a node can identify the
node. Here I use numbers separated by hyphens to
identify a node in a hierarchy. Since the root node is fixed,
it is given 0, and its direct children are given natural
numbers. Although this is a little irregular, this notation
reduces the length of the sequence needed to identify a
node. Otherwise, all sequences have a prefix of ‘0-‘.
The nodes A, B, and E in Figure 6, for example, can
respectively be represented by 0, 1, and 1-2 because A
is the root, B is the first direct child of A, and E is the
second child of B. This sequence of numbers will be
referred to as the ID sequence (IDS). A single number is
also considered to be a sequence of a single number.

held. Figure 7 shows examples of glyphs in which two
sides at level 0 are replaced. In this paper, a depth and a
level refer to the depth of a hierarchy and the level in a
glyph respectively.
When an initiator shape has n sides, and m of
them are simultaneously replaced with different
nΡm combinations are available.
generators,
Moreover, the i-th replacement position can have

Ki

generators (rewriting rules), where all generators are
unique. The possible number of children, N, is given by
m

N = nΡm ⋅∏ K i .
i =1

For example, N = 400 when n = 5 , m = 2 , K 1

= 5,

and K 2 = 4 . This method using multiple initiators,
generators, and sides increases the number of children
allowed at one level.

Figure 7: Example glyphs in which two sides at level 0 are
replaced.

4.2.

Deep hierarchy

A(0)

B(1)

D(1-1)

E(1-2)

C(2)

F(1-3)

G(2-1)

H(2-1-1)

As explained above, in the simple recursive method,
sides to be replaced are recursively chosen from the sides
of their base levels. Unused sides at a level can be used
for different depths in the hierarchy if different generators
at that level are used for the sides and if the shapes drawn
by the generators do not include one another. In Figure 6,
the base-level sides of H(2-1-1) are replaced for depths
1 and 3. Figure 8 also shows example glyphs whose
base-level sides are replaced for depths 1 and 3.

Figure 6: Example of a hierarchy

4.1.

Many children

As explained, in the simple recursive method, one
initiator and one generator are used, and one side is
chosen to be replaced. However, many initiators,
generators, and sides can be used. The condition (P-1) is
maintained even if more than one side is replaced at the
same time. If the shapes or generators used for
replacement do not include one another, which means that
no shapes include other shapes, condition (P-2) is also

Depth 1 (IDS 1)

Depth 2 (IDS 1-1)

Depth 3 (IDS 1-1-1)

Figure 8: Example glyphs for nodes whose depths are
between 1 and 3.

This method increases the distinguishable depth of a
hierarchy n times, as many times as in simple self-similar

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

shape methods at the maximum, where n is the number of
used sides. By using these replacements, we can assign
unique glyphs to nodes in a practical and large hierarchy.
A prototype glyph generation system[8][11] based on
this approach was able to assign unique glyphs to all 1544
classes in version 1.2 of Java 2 Standard Edition (J2SE).
The number of direct children of the root class Object
was 569, and the maximum depth was 7. This shows that
the proposed glyph-generation method can be used for
practical hierarchies such as the J2SE class hierarchy.
Evaluation experiments 2 showed that inheritance
relationships can be recognized faster when the proposed
glyphs are used than when an ordinary textual
representation is used.

5.

a

Generation of glyphs based on syntax

As explained above, a diagram based on a simple
unique-glyph method can represent syntactical constraints,
although the diagram may be complicated. This section
describes a method that does not require intermediate
boards and is thus less complicated.
Let us consider a mapping of symbols in grammar G to
the IDSs. First, we assign the start symbol to 1. Then, we
assign non-terminal symbols to unique one-element IDSs;
these symbols do not appear as single symbols on the
right-hand sides of productions.
For each production, if the right-hand side of the
production is one symbol, that symbol is mapped to an
IDS, which represents a child of the left-hand side symbol.
If one non-terminal symbol has multiple productions
which have that non-terminal symbol on their left-hand
sides, the glyph of that non-terminal symbol includes all
of the glyphs of the one-element symbols that are on the
right-hand sides of those productions.
An example mapping for G is shown as follows.

Symbol
E
I
a
b

IDS
1
1-1
1-1-1
1-1-2

Figure 9 shows the diagrams generated based on the
mapping. They show that a and b are derived from E and
I. The proposed method can be extended to a larger
grammar.
The example diagrams are given visual representation
by using an interactive 3D toolkit library it3d [10] and the
Java programming language[6].
2

E→ I

The questions used in the experiment can be accessed at
http://www.nime.ac.jp/~osawa/paper/2000EDP7151/

b
Figure 9: Example diagrams based on mapping of
symbols to hierarchical positions.

6.

Discussion

Here the duality of glyphs and the scalability of the
proposed diagrams are discussed.
The proposed diagrams use 3D glyphs. Needless to say,
they can also use 2D glyphs. When I conducted
experiments that measured accuracy and speed to
determine the relationship between two 2D glyphs[11],
some subjects were confused by the duality of their
glyphs. If glyph A includes glyph B, the complementary
area of B (~B) includes the complementary area of A. For
example, the white part of A in Figure 8 can include the
white part of B. Likewise, the colored part of B can
include the colored part of A.
Therefore we need to disambiguate the relationship
caused by this duality. One way to do this is to use 3D
glyphs. 3D glyphs are suitable for an immersive
programming environment like the one that my
co-workers and I have been developing.
If the size of a glyph is fixed, the number of possible
unique glyphs is limited because the number of pixels in a
glyph is finite. This may restrict the scalability of the
proposed diagrams. However, the proposed diagrams
should be practically useful based on the results of
previous 2D experiments, although formal evaluations
should be conducted. This scalability limitation may

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE

apply not only to the proposed diagrams but also to
general visualization methods. Dynamic or interactive
visualization methods would be required to solve this
limitation, which is caused by finite areas.

grammar. The proposed 3D diagrams will help users to
more easily understand grammatical constraints visually.

Acknowledgments
7.

Future work

My co-workers and I have been developing an
immersive programming system called Ougi[9] in an
immersive virtual environment called TEELeX
(Tele-Existence Environment for Learning exploration)[1].
Figure 10 shows a snapshot and screenshot of Ougi. Ougi
has already used glyph representations of inheritance
relationships. We will investigate the integration of glyphs
for semantic constraints, such as inheritance relationships,
and glyphs for syntactical constraints, as proposed in this
paper.
After
we
have
developed
integrated
jigsaw-puzzle-like 3D glyphs for grammatical constraints,
we will apply them to Ougi. We also plan to conduct
usability tests of the proposed glyphs.
We will also investigate application of the proposed
diagrams to UML (Unified Modeling Language)[3][14],
design patterns, XML (eXtensible Markup Language),
and Web visualization. Furthermore, we plan to extend
the proposed diagrams to type 0 grammars.

Figure 10: Snapshot and screenshot of the immersive
programming system Ougi.

8.

Summary

This paper proposed the 3D diagrams composed of
jigsaw-puzzle-like glyphs to represent syntactical
constraints in a grammar. The diagrams use
convexo-convex and concave shapes on board shapes.
From these shapes, one can determine the relationships
between diagrams by simply looking at the front sides of
the shapes, even in 3D. Satisfaction of a syntactical
constraint does not require an exact match between
glyphs, simply an inclusive one. The method proposed for
generating jigsaw-puzzle-like 3D glyphs for a
context-free grammar is also applicable to a practical

This research was partially supported by Grant-in-Aid
for Scientific Research (14380090) in Japan.

References
[1] Kikuo Asai, Noritaka Osawa, and Yuji Y. Sugimoto, "Virtual
Environment System on Distance Education," Proc. of
EUROMEDIA '99, pp. 242-246, 1999.
[2] Bonar, J. and Cunningham, R., “Bridge: Tutoring the
programming process,” In J. Psotka, L. Massey, and S.
Mutter (Eds.), Intelligent tutoring systems: Lessons learned
pp. 409-434, Hillsdale, NJ: Lawrence Erlbaum Associates,
Inc., 1988.
[3] G. Booch, J. Rumbaugh, and I. Jacobson, The Unified
Modeling Language User Guide, Addison-Wesley, 1998.
[4] Margaret M. Burnett, Adele Goldberg, and Ted G. Lewis,
Visual Object-Oriented Programming: Concepts and
Environments, Manning, 1995.
[5] Card, Stuart K., Jock D. Mackinlay, and Ben Shneiderman,
Readings in Information Visualization - Using Vision to
Think, Morgan Kaufmann Publ., 1999.
[6] James Gosling, Bill Joy, and Guy Steele, The JavaTM
Language Specification, Addison-Wesley, 1996.
[7] Brad A. Myers, "Visual Programming, Programming by
Example, and Program Visualization: A Taxonomy," Proc. of
CHI'86 Conference on Human Factors in Computing
Systems and Graphic Interfaces, pp. 59-66, May 1986.
[8] Noritaka Osawa, "Generation and evaluation of glyphs
representing superclass-subclass relationships," IEEE Symp.
on Visual Languages 2000, pp. 81-82, Sept. 2000.
[9] Noritaka Osawa, Kikuo Asai, Yuji Y. Sugimoto, and
Fumihiko Saito, "A Dancing Programmer in an Immersive
Virtual Environment," Symp on Human-Centric Computing
Languages and Environments (HCC2001), pp. 348-349,
2001.
[10] Noritaka Osawa, Kikuo Asai, and Fumihiko Saito, "A
toolkit library for artificial reality applications," Workshop
on Interactive Systems and Software 2001 (WISS'01), 2001,
(in Japanese).
[11]Noritaka Osawa, "Visualization of Inheritance Relationships
By Using Glyphs", IEICE Trans. on Information and
Systems, Vol. E85-D, No. 1, pp. 275-282, 2002.
<http://search.ieice.org/2002/files/e000d01.htm#e85-d,1,275
>.
[12] J. Stasko, J. Domingue, M. H. Brown, and B. A. Price,
Software Visualization, MIT Press, 1998.
[13] Jun Rekimoto and Mark Green, "The Information Cube:
Using Transparency in 3D Information Visualization",
Proceedings of the Third Annual Workshop on Information
Technologies & Systems (WITS'93), pp. 125-132, 1993.
[14] J. Rumbaugh, I. Jacobson, and G. Booch, The Unified
Modeling Language Reference Manual, Addison-Wesley,
1999.

Proceedings of the Sixth International Conference on Information Visualisation (IV’02)
1093-9547/02 $17.00 © 2002 IEEE


A Graph Drawing Algorithm for Spherical Pictures
A. Donafee, C. Maple
Faculty of Creative Arts and Technology
University of Luton
Park Square
Luton
LU1 3DU
Abstract
A spherical picture is a useful way to visualise a
group presentation. Spherical pictures are
essentially planar, possibly non-simple, graphs. In
this paper we present a graph drawing algorithm
that produces spherical pictures. The algorithm
has been encompassed into a software package,
SPICE, and output is presented.
1. Introduction
A convenient way to specify a group is by means
of a presentation. A group presentation is a pair, P =
< x;r >, where x is an alphabet and r is a set of “words”
on x. The elements of x are called the generating
symbols and those of r are called the defining relators.
A group presentation can be depicted geometrically by a
“spherical picture”. These pictures provide a useful way
to obtain information about the group that they
represent. (See, for example, [2], [6] and [8].) An
example of a picture of over a presentation for the
symmetric group of order 3 is given in Figure 1. This
paper will not go into detail concerning the properties of
pictures or their uses, but for more information see the
work of [2], [6] and [8].

based upon the theory of pictures, to compute properties
of the groups they represent (see [6] for more
information). The package also contains an editor that
enables users to manually draw pictures on screen. The
algorithms in SPICE can then be applied to this
drawing, and the properties of the picture can then be
determined.
It would be useful however, if given a representation
of a picture, this picture could be drawn automatically
on screen. Due to the properties of pictures, and the
features of SPICE, existing graph drawing algorithms
cannot be used to produce drawings of spherical
pictures. In this paper, we present an algorithm that uses
the basic idea of current graph drawing techniques and
expands them to visualise pictures. It transpires that the
method presented here does not always produce perfect
picture drawings as edge crossings may still be present.
Nevertheless, in the worse case scenario, it does provide
an initial drawing of a picture. The manual drawing
features of SPICE can then be easily employed such that
the resultant picture can be easily manipulated to
improve readability and look 'aesthetically pleasing'.
Section 2 of this paper reviews existing graph drawing
techniques and in Section 3 we present our graph
drawing algorithm. The results of experiments
performed upon this graph drawing algorithm are given
in Section 4, together with the conclusions that can be
drawn from this work.

2. Existing Graph Drawing Algorithms

Figure 1: A picture over a presentation <a,b; R=a2, S=b2,
T=(ab)3>
As can be seen from Figure 1, pictures are
essentially planar, possibly non-simple, graphs. The
order of edges emanating from each vertex is crucial:
the word obtained by reading the labels on the edges
around a vertex is cyclically equal to a defining relator.
Note that a picture has other features, but these do not
affect the work presented here and are not discussed. A
software package, the SPherical PICture Editor
(SPICE), has been developed that contains algorithms,

Drawing planar graphs is a fundamental graph
drawing problem (see [3] for example) with an NP-hard
complexity. A graph can have infinitely many drawings
associated with it. The aim of graph drawing algorithms
is to produce aesthetically pleasing, readable graphs.
The readability of a graph is the "capability of
conveying the meaning of the diagram quickly and
clearly" [3]. For instance, it is much easier to obtain
information from a planar, straight line graph that one
that contains many bends and edge crossings. The
problem of producing such useful graph drawings has
been examined extensively; this is shown in a
bibliography of graph drawing algorithms [3] which
cites over 300 references. This diversity comes from the
fact that there is a large number of applications where
producing graph drawings automatically is a useful tool.
The first graph drawing algorithm was given in
Knuth's [9] work on visualising flow charts. Since this
time there has been a plethora of work in the area and a
small selection is discussed here for comparison with
the proposed technique. A useful technique to draw a
simple planar graph is given by the visibility approach.

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

This method, which was first introduced in [4] and [5],
involves determining a planar embedding of a graph, G
say, and constructing a visibility representation of G. In
a visibility representation, each vertex of G is
represented by a horizontal line and edges are depicted
by vertical line segments. Once such a representation
has been constructed, the final stage in the visibility
approach is to replace the horizontal lines with vertices
and the vertical segments with polygonal lines.
Visibility representations were introduced by Otten
and van Wijk [11], who also proved that every planar
graph admits such a representation. The method of
Rosentiehl and Tarjan [12] constructs a visibility
representation of G where the resulting drawing gives a
more compact layout for G than that of Otten and van
Wijk. The same method (in essence) was independently
proposed by Tamassia and Tollis [13].
The main problem with the visibility approach, and
indeed the majority of graph drawing algorithms, is that
additional constraints are placed upon the planar,
simple, graph. For example, the algorithm of Rosentiehl
and Tarjan [12] given above requires that G is a
biconnected st-graph (note that spherical pictures are
not necessarily bi-connected graphs). If the graph does
not satisfy these constraints, dummy edges are inserted
until the desired structure for the graph is obtained.
These dummy edges are then removed from the final
drawing. If an aesthetically pleasing graph is produced
based upon having a large number of dummy edges and
these edges are then removed from it, this reduces the
readability of the final drawing of the desired graph.
On the face of it the method of Rosentiehl and
Tarjan [12] would be an appropriate algorithm to use.
The main reason, however, why this technique cannot
be used to construct drawings of pictures is based upon
the fact that a picture, drawn using SPICE, has vertices
of various sizes. As the labels on edges need to be
clearly seen, SPICE uses the convention that the radius
of a vertex is 4 times the degree of that vertex.
Therefore, assume that for a picture P, the visibility
approach computed that the horizontal segment for a
vertex of P was from 0 to 1. The vertex cannot be drawn
in this interval as the radius of a vertex must be at least
8 units (the minimum degree of a vertex in a picture is
2) and so, correspondingly, for P to fit on a sheet the xcoordinate of it's centre must be at least 8.
Moreover, it is not practical to assume that each
interval in the visibility representation corresponds to
the maximum diameter of a vertex in the picture, plus a
small constant to ensure adjacent vertices do not touch.
Take, for example, the picture in Figure 1. This is a
relatively small picture over a group presentation. The
visibility representation of this picture produces a range
of x-coordinates from 0 to 6. The length of the largest
relator in the presentation is 6, (T=abababa) which
gives 48 as the maximum diameter of a vertex in a
picture over the presentation. Hence, employing the idea
that each interval in the visibility representation equals
length 53 (if a value of 5 is chosen for the constant)
means that the width of the sheet that the picture will be
constructed on will have length 53* 6 = 318 units. Now
the picture in Figure 1 has 8 vertices, only two of which
have degree 6. A picture over this presentation could
therefore be drawn on a much smaller sheet. For

presentations with relators that consist of many letters,
or whose pictures contain a number of vertices, this
method would produce large graphic sheets with a great
deal of empty space. For this reason, it is not practical to
use this method to automatically construct spherical
pictures to implement to produce drawings of pictures.
One way to counteract this problem is to try and
remove empty areas in a large visibility representation,
without altering where vertices have been placed.
Alternatively, the visibility representation could be
employed to indicate the area of the plane where a
vertex, v say, lies. Then, by examining the location of
the surrounding vertices in some way, the exact location
of v could be computed. It would be difficult to develop
and implement both of these methods, however, and
they imply that once a visibility representation has been
constructed further techniques are needed to transform it
into a useful representation of a picture. In other words,
constructing a visibility representation of a picture can
only indicate where the vertices should be constructed
on the sheet and not provide any coordinate values for
their location.
A different method is therefore used to produce a
visibility representation for pictures. The Picture
Visibility (PV) representation of the picture drawing
algorithm involves employing a two dimensional
matrix, M, to represent the plane. Each component of
the matrix corresponds to an area of the plane of size (l
+ 5)2, where l is the maximum diameter of all the
vertices in the picture.
The method utilised to determine the arrangement
of vertices involves assigning each vertex to a
component of M. The position of vertices in the plane
can then be obtained by examining the local rotation
scheme of each vertex. The matrix M therefore provides
a type of visibility representation without first needing
to construct a biconnected, st-graph of the picture, it's
dual graph and an st-numbering of both the graph and
it's dual. Moreover, if can be used to produce a
representation of non-simple graphs. Admittedly, this
method would not be as robust for general graphs as the
visibility representation technique because it does not
always place vertices in the most appropriate position.
This is due to the fact that two local rotations could
have conflicting locations for the most appropriate place
to insert the same vertex into M. It is, however, thought
to be a more efficient approach for constructing
pictures. As shown above, the visibility representation
can only suggest where vertices should be placed and
this information can be obtained directly from the
rotation scheme of the picture.
Once the vertices have been drawn on the sheets,
the replacement stage is completed by constructing the
edges of P. The detailed description of the visibility and
representation stages of this picture drawing algorithm
is presented in the following sections.

3 Drawing Pictures
Given a data structure for a picture P with a finite
collection of V vertices and E edges, the aim of this
algorithm is to depict P graphically, with a high level of

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

readability. As the order of edges incident on each
vertex is important, P is represented by means of a
rotation scheme.
Definition 3.1: A rotation scheme, 3 = (3v; v 
V), is such that for each vertex v of a graph we have a
cyclic permutation 3v of edges incident on v which
represents their circular (clockwise) order around v.
Definition 3.2: Let Vi,j) be the edge endpoint
incident on vertex i connected at position j, the edge
number obtained from the local rotation of v. We say
that Vi,j), is a connection point of G.
The planarity and regions of P are determined by
calling the planarity testing algorithm of Donafee and
Maple [7]. The picture drawing algorithm then
comprises the following stages:
1. Construct a picture visibility representation to
calculate a possible location, in the plane, for each
vertex.
2. Construct the edges of P.
3. Once all edges of P have been drawn, examine
any edges with bends. Ensure that bends are placed in a
location that causes a minimum number of edge
crossings in the picture drawing.

3.1 Constructing a PV Representation
Definition 3.3: A region of a planar graph is an
area of the plane that is bounded by edges and contains
neither edges nor vertices.
The matrix, M, that stores the PV representation is
created incrementally. Firstly, the vertices in the
exterior region of P are inserted. For computational
efficiency, the exterior region is selected to be the
region with the largest number of connection points.
The technique in which the vertices of this region are
inserted into M depends on whether it has an odd or
even number of connection points. The aim is to keep
the arrangement of vertices in M as symmetric as
possible. Let the vertices in the exterior region be given
by (v1, v2, ..., vn) . If n is even then k is said to equal to 0,
otherwise k = 1; M is initially a ((n – k)/2 + 1) * 3
matrix. If n is even, v1 is inserted at M[1][2], otherwise
M[1][1] = v1 with v2 being placed at M[1][3].
The remaining vertices of the exterior region are
now inserted in M using the following convention:
x for (2 + k) • i • (n + k)/2, M[i][3] = vi
x for i = (n + k)/2 + 1, M[(n + k)/2 + 1][2] = vi;
x for (n + k)/2 + 2 • i • n, M[n - i + 2][1] = vi.
The remaining vertices of P are now inserted into
M. This is achieved by examining the local rotations,
firstly of vertices in v1, and then those of the remaining
vertices in M, until M contains all vertices of P. By
using this method, M will always contain all the vertices
of P due to the fact that a picture is a connected graph.
Let v be a vertex in M where the local rotation
scheme for v is denoted by 3v. The technique by which
the vertices in 3v are inserted into M depends upon the
positions, in M, of v and any vertices of 3v that are
already in M. Therefore, 3v is examined to find the
number of vertices that have been inserted into M. The
following possibilities arise:
Case (1): All vertices in 3v have been placed into
M.

Case (2): No vertices in 3v have been placed into
M.
Case (3): One of the vertices in 3v has been placed
into M.
Case (4): More than one, but not all, of the vertices
in 3v has been placed into M.
If Case (1) occurs then the algorithm progresses to
examine the rotation scheme of another vertex in M. For
Cases (2), (3) and (4) the appropriate vertices are
inserted into M by employing one of four methods.
These methods, and the selection processes, are
described below.
The Four Methods of Inserting Vertices into M
Let [ be an ordered subset of vertices of 3v that
have not been placed into M. Essentially the vertices of
[ are placed either above and below, or to the left and
right of a certain point, X say, in M. If either Case 2 or
Case 3 arises then X is given by the position of v in M.
When Case 4 occurs, however, there are four situations
where it can be more efficient to choose another
position for X.
Let (vk, [, vl)  3v where vk and vl are vertices that
have been inserted into M. The algorithm calculates
which value to use for X by examining the positions of
vk, vl and v in M. The method for calculating X is given
below. From this point on, for clarity, it is assumed that
the position of X is given by the position of v in M.
The vertices of [ are placed either vertically of
horizontally around X. The way the vertices are placed
around v depends on which of the four types, A, B, C or
D, of methods to insert vertices into M have been
selected. These four methods are described below and
they are illustrated in Figure 2. Here the arrows point to
the location where the vertices of [ would lie. For
instance, if Type A was chosen then the vertices of [
would be placed in the row above v, between vk and vl.

Figure 2: The four methods to insert vertices into M
Types A, B, C and D are now described in detail.
Let [ be a consecutive set of vertices in 3v that have not
been placed into M, where M[i][j] denotes the location
of X. If the number of vertices in 3v is even then N =
|[|/2, if |[| = 1 then N = 1 otherwise N = |[-1|/2.
Furthermore, the kth vertex in [ is denoted by [k (for 1 •
k • |[|). The four methods used to insert vertices into M
are:
Type A: A new row is inserted into M above row
i. If there are not N columns between vk and v then the
appropriate number of columns is added. Similarly,
columns are added if there are not N columns between v
and vl. The vertices of [are added into M as follows:
x For 1 • k • N, the vertex at [k is inserted at

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

M[i - 1][j - N + k - 1].
If |[|  1 and |[| is odd, then M[i - 1][j] = [N+1
and N is incremented by 1.
x For N + 1 • k • n, M[i - 1][j + k - N] = [k .
Type B: A new row is inserted into M below row i.
If they are required, up to N columns are added before
and/or after M[j]. The vertices of [ are added into M as
follows:
x For 1 • k • N, the vertex at [k is inserted at
M[i + 1][j + N - k + 1].
x If |[|  1 and |[| is odd, then M[i + 1][j] = [N+1
and N is incremented by 1.
x For N + 1 • k • n, M[i + 1][j - k + N] = [k .
Type C: A new column is inserted into M at
position j-1. If they are required, up to N rows are added
before and/or after M[i]. The vertices of [ are added into
M as follows:
x For 1 • k • N, the vertex at [k is inserted at
M[i + N – k +1][j - 1].
x If |[|  1 and |[| is odd, then M[i ][j-1] = [N+1
and N is incremented by 1.
x For N + 1 • k • n, M[i + N - k][j - 1] = [k .
Type D: A new column is inserted into M at
position j+1. If they are required, up to N columns are
added before and/or after M[i]. The vertices of [ are
added into M as follows:
x For 1 • k • N, the vertex at [k is inserted at
M[i – N + k - 1][j + 1].
x If |[|  1 and |[| is odd, then M[i ][j + 1] = [N+1
and N is incremented by 1.
x For N + 1 • k • n, M[i – N + k][j + 1] = [k .
x

Selecting which Type to Use to Insert vertices into M
For the local rotations that fall into Case (2), there
is no advantage in selecting one type above the other
three. For consistency, Type B is chosen to insert the
vertices of [ into M. The way in which the relevant type
is chosen for vertices that fall into Case's (3) and (4)
depends upon the positions, in M, of v and the vertices
that bound [. In Case (3) only one vertex, vh say, occurs
in M that also occurs in 3v. Therefore only the positions
of v and vh, in M, need to be considered before the
appropriate method is selected. If vh lies in a row above
v then again, for consistency, Type B is selected;
alternatively, Type A is chosen.
Given that Case (4) arises and [ is bounded by vk
and vl, the positions, in M, of v, vk and vl need to be
considered. It transpires, after the value of X has been
calculated, that there are 16 possibilities to examine for
Case (4). These possibilities, together with the method
for calculating the position of X, are given now.
The positions of v, vk and vl are contained in M and
are located at M[i][j], M[ik][jk] and M[il][jl] respectively.
The first stage is to calculate the position of X. If jl - jk is
even, set N equal to (jl-jk)/2; otherwise let N =
(jl-jk+1)/2.
1. If ik < i and il < i and j < jk < jl then X =
M[i - 1][jk + N]. The discs of [ are inserted into M using
Type A.
2. If ik > i and il > i and j < jl < jk then X =
M[i + 1][jl + N]. The discs of [ are inserted into M using
Type B.

3. If i < ik and i < il and jl < jk < j then X =
M[i + 1][jl + N]. The discs of [ are inserted into M using
Type B.
4. If ik < i and il < i and jk < jl < j then X =
M[i - 1][jk + N]. The discs of [are inserted into M using
Type A.
5. For all other possibilities X = M[i][j]. The
method chosen to insert the discs of [ into M is given by
the following criteria:
a) Type A: Arises if (i • ik and i • il and jk < jl) or
(i • ik and i • il and jk < jl) or (i • ik and i • il and
jk < jl) or (i • ik and i • il and jk < jl).
b) Type B: Arises if (i • ik and i • il and jl < jk) or
(i • ik and i • il and jl < jk) or (i • ik and i • il and
jl < jk) or (i • ik and i • il and jl < jk).
c) Type C: Arises if (j • jk and j • jl and il < ik) or
(j • jk and j • jl and il < ik) or (j • jk and j • jl and
il < ik) or (j • jk and j • jl and il < ik).
d) Type D: Arises if (j • jk and j • jl and ik < il)
or (j • jk and j • jl and ik < il) or (j • jk and j • jl and
ik < il) or (j • jk and j • jl and ik < il).
Employing these methods to insert vertices into M
could alter the position, in M, of the vertices in the
exterior region. Once all vertices have been placed in M,
a procedure then ensures that the vertices in this region,
and only these vertices, lie in the first and last rows and
columns of M. In other words, it is ensured that the
technique used to insert the vertices of the exterior
region into M is adhered to. The picture visibility
representation for P, M, has now been constructed.
Rows and columns are only inserted in M if there
is not enough space in M to insert the vertices of a local
rotation. If |V| denotes the number of vertices in P, and n
the number of vertices in the exterior region, the
maximum number of rows or columns to be inserted
into M at any one time is given by |V|-n. The area bound
for the picture visibility representation is therefore given
by (|V| - ((n-k)/2))2, where k = 1 if n is odd and k = 0
otherwise. This compares favourably with the area
bound of the methods of Rosentiehl and Tarjan, which
is |V| * (2|V|-4) [12], Kant ((3|V|/2)-3)*(|V|-1) [10] and
the orthogonal grid drawing algorithm of Biedl and
Kant, |V|2 [2].
Creating the PV representation of P in such a way
minimises the number of edge crossings. This is
achieved in two ways, firstly, by using the rotation
scheme of P to insert vertices into M. Moreover, the
technique of placing a subset, [, of vertices in 3v, close
to v (i.e. in the preceding or following row or column)
also limits the amount of edge crossings. Edge crossings
do still occur, however, due to the fact that the most
suitable location for a vertex, as dictated by one local
rotation scheme, may not necessary be the same
position as that dictated by another local rotation
scheme.

3.2 Drawing Edges of Pictures
The next stage of the algorithm is to construct the
edges. The edges of the exterior region are drawn first.
These edges are constructed in a different way to the
edges of the interior region of P; the reason for this is to

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

ensure that the area for the interior regions of P is
maximised whilst maintaining readability.
If there are only two vertices in the exterior region, the
corresponding edges are constructed using two vertical
lines between the two smallest and two largest x
coordinates of the circumferences of the two vertices.
For pictures where the number of vertices is greater than
two, the drawing of P adopts a rectangular shape, as
shown in Figure 3.

crossings.

Figure 3: The rectangular shape of P
Drawing the remaining edges of P is more
complex. The SPICE edge drawing function (see [6] for
more information) computes the coordinates of the edge
endpoints incident on a vertex. The PV representation
for P is then examined to determine if any vertices in M
that lie on the route that an edge takes. If this is the case,
a `bend' in the edge is constructed at an appropriate
point.
Assume that e is an edge from vertex v1 to vertex
v2. The position of v1 and v2 is given by M[i1][j1] and
M[i2][j2], respectively. If any of the components of M
from M[i1][j1] to M[i2][j2] contain a vertex of P, then e
must intersect this vertex. This vertex is added to a list,
L say, such that when all components of M between
M[i1][j1] and M[i2][j2] have been examined, L contains
all the vertices that e would intersect.
Let v be a vertex in L with centre point (x;y) and
radius r. If i1  i2 or j1  j2, the coordinate point of the
bend of e needed to avoid this intersection is placed in
one of four possible locations. If i1= i2 or j1 = j2 only two
locations need to be examined. These locations are
shown in Figure 4. On this diagram, x1,2 and y1,2 refer to
the coordinates of the line of e that intersects v. Initially
the bend is always placed at position the B1.
This method is repeated for all vertices in L and,
consequently, the coordinates for the endpoints of the
lines e are now known. If L is not empty, it is placed in
a list, CheckEdges. Once all edges of P have been
constructed, CheckEdges then contains a list of edges
which need to be inspected to ensure that their bends
have been put in the most appropriate place on the
picture sheet.
Let the edge e contain an initial bend near the
boundary of vertex v. The number of edges that are
incident in the section containing B1 of the
circumference of v are counted. If there are no edges
emanating from v in this section the next edge in
CheckArcs is examined. If, however, there are edges
emanating from this section, the point where the bend
lies needs to be moved, as it clearly causes edge

Figure 4: A drawing to illustrate the possible
locations of the bend
The number of edges of v whose connection points
emanate from the remaining sections of v are then
examined in order, beginning from the section that
contains B2. If no connection points of v emanate from a
particular section of v, the point of the bend is
constructed here. If the situation arises that edges are
incident on v in all areas around the vertex then the bend
is deleted and e is redrawn so that it intersects the
vertex. It is true that this option does reduce the
readability of the picture. Nevertheless the resulting
picture drawing is still clearer than if a bend was placed
in the area containing the least edge endpoints.

Figure 5: A drawing to illustrate how arc crossings
can still occur.
Furthermore, as Figure 5 depicts, there is the
possibility that placing the bend in a section with no
edge endpoints could still cause edge crossings. Clearly
there is no easy way to ensure that an edge crossing
does not occur, but it is felt that the method given here
is the most efficient technique to use. In conclusion
therefore, it is believed that this is an efficient method to
ensure there are a minimum number of edge and

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

vertices crossings in the resultant picture.

4. Implementation, Experiments and
Conclusions
The above algorithm was implemented in a
function, DrawPicture, which takes as input a rotation
scheme of a picture. This function was tested on 77
pictures. These pictures had vertices between 3 and 20
and edges between 6 and 100. The resulting picture
drawing fell into one of three categories: drawings that
needed no further user-manipulation, those that required
a small amount of user-manipulation (less than 5
alterations) and, thirdly, picture drawings that needed
more than 5 manipulations. A manipulation is the term
used for one of the following operations:
i) moving a vertex to a different location;
ii) moving an connection point to a different
location on it’s vertex;
iii) creating a bend in an arc.

Figure 6: A spherical picture produced by DrawPicture.
These are procedures that have been implemented in
SPICE and are easy for the user to execute. The results
of this experiment are shown in Table 1, where M
denotes the number of manipulations.
Manipulations Required Number of Pictures
27
M=0
40
1•M•5
10
M>5
Table 1: Results of the picture drawing algorithm
Figure 6 shows a picture produced by this algorithm
that requires no further manipulation. This is a picture
over the presentation <f1, f2;R=f16,S=f24,T=f2-1f1f2f1>.
The algorithm presented above does not always
create perfect pictures; as can be seen from Table 6 it is
not unusual for a few user manipulations to be
performed to produce an aesthetically pleasing picture.
Arc crossing still occur due to the fact that disc could
have been placed in a more appropriate position on the
sheet, or that the coordinates for the endpoints of arcs
could have been placed in a more suitable location.
Chapter 6 in [6] details ways in which, theoretically,
these problems could e overcome.

This graph drawing algorithm produces pictures that
may need some manual manipulation to improve
readability. To improve upon this algorithm so that
manipulations are not required would mean increasing
the computation time and storage space of the algorithm
to an unworkable degree. Given that it is easy to
manually modify a picture, it is felt that this algorithm,
provides a useful way to produce a visualisation of a
spherical picture.
This graph drawing algorithm could also be used to
visualise graphs in areas as genetics, communication
design, VLSI and network optimisation; disciplines
where the order of the edges incident around a vertex
could be important in the representation of a system.

6. References
[1] Booth, K.S., Lueker, G.S., (1976) Testing the Consecutive
Ones Property, Interval Graphs, and Graph Planarity using
PQ-tree Algorithms, Journal Computation Systems, 13, 335379.
[2] Collins, D.J., Huebschmann, J., (1982) Spherical Diagrams
and Identies Among Relations, Annals of Mathematics, 261,
155-183.
[3] Di Battistia, G., Eades, P., Tamassia, R., Tollis, I.G.,
(1994) Algorithms for Drawing Graphs: An Annotated
Bibliography, Computational Geometry: Theory and
Applications, 4, 235-282.
[4] Di Battista, G., Tamassia, R., (1988), Algorithms for Plane
Representations of Acyclic Graphs, Journal of Theoretical
Computer Science, 61, 175-198.
[5] Di Battista, G., Tamassia, R., Tollis, I., (1992),
Constrained Visibility Representations of Graphs, Information
Processing Letters, 41, 1-7.
[6] Donafee, A., (2003), Picture Theory: Algorithms and
Software, PhD Thesis, University of Luton.
[7] Donafee, A., Maple, C., (2003), Planarity Testing of
Graphs Represented by a Rotation Scheme, Submitted to
IV2003.
[8] Fenn, R.A., (1983), Techniques of Geometric Topology,
LMS Lecture Note Series, 57, London: Cambridge University
Press.
[9] Kant, G., (1997), A More Compact Visibilty
Representation, International Journal of Computational
Geometry and Applications, 7, 3, 197-210.
[9] Knuth, D., (1963), Computer Drawn Flowcharts,
Communications of ACM, 6, 9, 555-563.
[10] Otten, R.H.J.M., van Wijk, J.G., (1978), Graph
Representations in Interactive Layout Design, Proceedings of
the IEEE International Symposium on Circuits and Systems,
914-918.
[11] Rosentiehl, P., Tarjan, R.E., (1986), Rectilinear Planar
Layouts and Bipolar Orientations of Planar Graphs, Journal of
Discrete and Computational Geometry, 1, 345-353.
[12] Tamassia, R., Tollis, I.G., (1986) A Unified Approach to
Visibility Representations of Planar Graphs, Journal of
Discrete and Computational Geometry, 1, 321-341.

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE


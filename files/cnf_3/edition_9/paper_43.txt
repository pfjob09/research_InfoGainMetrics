A Generic Visualisation and Editing Tool for Hierarchical and Object-Oriented
Systems

Huan Jin, Carsten Maple
Department of Computing and Information Systems
University of Luton, U.K.
huan.jin@luton.ac.uk , carsten.maple@luton.ac.uk

Abstract
In this paper we present a data retrieval and
information visualisation tool, named the Object-Oriented
Graph Editor (OOGE). The OOGE is designed to
represent information of special kinds of system,
Hierarchical Systems or Object-Oriented Systems. These
systems can be represented by Object-Oriented Graph, in
which nodes have attributes and their connections are
constraint-based.
The editor presented provides a
friendly graphical user interface for users to define any
class of nodes of the OO Systems and to draw the OO
Graph based upon the user-defined node classes. The
validity of proposed system can be checked against the set
of constraints that based on the attributes of the userdefined classes.

systems can be modelled as entities and corresponding
relations between the entities. OO Systems can be
represented by an Object-Oriented Graph (OO Graph), in
which nodes have attributes and connections are
constraint-based. It is possible to use any image
construction tool to construct a graphical representation of
such system. However when using such a drawing
package, the underlying meaning, that is the attributes of
the elements and the information regarding the relations,
is lost. This has lead to the requirement for a generic tool,
which can be used to represent the key information of a
general OO System and provide a means for visualisation
and validation. By creating a generic tool it is possible for
researchers in different areas to share information across a
common platform.

2
1

Existing Techniques

Introduction

A great deal of research effort has been applied to the
area of Information Visualisation in the last ten years.
Information Visualisation is defined as the process of
knowledge internalisation by perception of information, or
by means of elaborating the data [4]. For different
systems, information will be elaborated in different ways.
A graph, an abstract data structure, could be used to
represent any information that can be modelled as objects
and connections between those objects. Therefore, almost
every domain of computer science, other fields of science
and engineering, business management, chemical reaction
and many other applications use graphs in some form to
represent information.
There are some systems and applications have similar
characteristics and can be categorised as a group, which
we term Object-Oriented Systems (OO Systems). These

Before we begin in earnest it is necessary to
introduce some basic concepts of the type of system that
this paper addresses.

2.1 Concepts
Graph: A graph G=(V, E) consists of a finite set of V
of Vertices and a finite multi-set E of edges, that is,
unordered pairs (u, v) of vertices. [3] The vertices of a
graph also known as nodes; edges are sometimes called
links, arcs, or connections.
An Object-Oriented Graph is special graph in which
each node has properties and connections that are
constraint-based. For example, consider a Waster-Water
Treatment Plant (WWTP). Entities in the system may
include a tank and pump. One of the properties of tank is

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

3

Electric In
Pump

Water Out

Water In

Tank

Water Out

Valid Connection

Analysis and Design of OOGE

3.1 Requirements Analysis
We begin by describing the user requirements. The
Use-Case Diagram is used here to describe the typical
scenarios of usage of OOGE. The typical scenarios
include, but are not limited to:

Figure 1. A valid connection in an OO Graph

x

that it has a single input of water and single output of
water. A pump on the other hand has a single input of
electricity and one output of water. The constraint of the
connection in this case is the output of water can only
connect with an input of water, see Figure 1.

x

2.2 Related Works

x

There exist two categories of software for the
representation of OO Systems. Systems exist with very
specific specialised applications in mind, such as LINK
[2] developed for the creation, manipulation and drawing
of graphs and hypergraphs. The Hierarchical Graph
Editor (HGE), is a tool that form part of the WWPT
simulation tools, WEST++ [12]. These packages properly
represent the data in the specific OO Systems. However,
these tools cannot provide communication and data
sharing between the two different OO Systems.
Alternatively, there exist systems providing APIs that
are designed as a general graph drawing and editing tools
such as Graphlet [8] [9]. Using the graphscript language
created by Graphlet we can achieve basic functions such
as checking the validation of a proposed connection. This
kind of package enables software developers to develop
user applications and create a file format for graph
sharing. However such uses are greatly under utilised due
to the fact that a high level of programming ability is
required for the effective use of such systems.
The goal of OOGE is to allow users to define the
application specific components and represent the
relations in the graph format through the use of a useable
user interface. The OOGE is designed to provide a tool
that combines the ease of use of the HGE and the power
and generality of libraries such as Graphlet. It also allows
users to check the possible connections between
components and validation of the connections on the fly,
or at the end of construction.
In section three we will discuss the analysis and
design of the OOGE, and the implementation will
discussed in section four.

x
x

creating a new node type based on data input by
the user
creating a new node type based on a pre-defined
node type in the database
creating a node object based on the pre-defined
node type in the database
drawing a node object on the canvas of the graph
editor; and
checking the valid connection between two node
objects.

Below we describe one of the basic procedures a user
may perform. Figure 2 illustrates the use-case diagram for
the scenario.
Scenario 1: Creation of a new node type.
User creates a user-defined node type via the GUI of
OOGE. The Data Transporting System (DTS) receives
the node type information and saves the information to a
database.
User creates an object of the previous defined node
type, based on the information retrieving from the
database.
User draws the node object on canvas of the Graph
Drawing System (GDS).

Create a new
1
node type

Create an object
of a node type

DTS

Draw the node
object

GDS

DB

User

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

Figure 2. Use Case Diagram for Senario 1.

3.2 Data Structure of User-Defined Types
OOGE focuses on the representation of generic OO
Systems, which means OOGE must provide a flexible and
extendable way to handle the user-defined system
information. Users only need to follow the prompts of the
user interface to create and extract information about the
system without considering the storage and underlying
data structures of the system.
A three-layer data structure is used to handle the
user-defined vertex type T, see Figure 3. Each userdefined node type has a finite set of attributes A={a0,
a1,…, am}. With each attribute ai, there is an associated
finite set of sub-attributes, Ai’={a’i0, a’i1,…, a’ij}, 0<i<m.
There exists a one-to-one mapping between each set of
sub-attributes and a set of to the attribute values.
Vi’={v’i0, v’i1,…, v’ij}. Therefore, the vertex has a data
structure T=(t, (a, (a’, v’))).

3.3 Data Sharing
There are two different types of data-sharing problem
of Information Visualisation. The first is physically
sharing information, by storing the data into a database,
which can be accessed by any application and by any user.
The second is sharing data by means of creating a graph

description language to provide a general interchange
format for graph drawing and visualisation systems.
Although there is a standard way to define graphs by
sets of nodes and edges, there are many different file
formats for graphs. The capabilities of these file formats
range from simple adjacency lists to complex formats
which can store arbitrary data. Much effort has been
devoted to create platform independent and easy to
implement graph description languages.
Examples
include GML[7], WebDot’s DOT [10], and the the
formats used by LEDA[11], GDS[5] and GraphXML[6].
A GML file is a 7-bit ASCII file, which makes it simple to
write files through standard routines. It consists entirely
of hierarchy organised key value pairs. Using the
generality and rich features of XML, GraphXML, an
“application” of XML [6] has been developed.
GraphXML also supports other features such as
hierarchical graphs and dynamic graphs. Application data
can be added to different levels of the graph description
through a series of additional elements defined by
GraphXML.
We use a structure similar to that used in GML. An
example of the data format for Figure 1 is given below.

Attribute Unit 1
Attribute Unit 2
New vertex type name
Attribute Unit m-1
Attribute Unit m

Attribute Item 1

Attribute Value 1

Attribute Item 2

Attribute Value 2

Attribute name
Attribute Item n-1

Attribute Value n-1

Attribute Item n

Attribute Value n
Attribute Unit

Figure 3. Data Structure Layout Diagram

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

graph
[id 0
label "Sample Graph"
node
[id1
label ”Tank”
application attributes
[
Input .WaterInput 1
Output.WaterOutput 1
]
node
[id2
label “Pump”
application attributes
[Input.ElectricInput 1
Output.WaterOutput 1
]
]
edge
[source 1
target 2
label ”Valid Connection”
validation 1
]
]

Descriptions
graph (list)
The tag graph starts a new graph. Common tags
within graph are node and edge.
node (list)
The tag node starts a new node. Common tags within
node are id, label, and application attributes.
edge (list)
The tag edge starts a new edge. Common tags within
edge are source, target, label and validation.

Database Connection System: Data transformed
through DTS will be saved to a more permanent media
such as a hard disk via MySQL DBMS.
Data Retrieval
Interface

GUI
Data Transporting
System

3.4 Rule-based system and Rule-checking
As we mentioned in section 1, there exist many
applications that involve OO System that not only have
elements but relationships which are bound by certain
rules or constraints. In applications such as the circuit
design, checking the validity of the connections between
the components is a vital issue. Therefore, providing a
robust connection validation function is one of the key
features of OOGE.
The OOGE provides both concurrent rule-checking
and post rule-checking. The concurrent rule-checker
points out errors, allows easy correction based on the
constraints retrieved from the Rule (constraints) database.
The post rule checking calculates the possible connections
between the components, which will help the user to see
the possible routine through components. The constraints
of the connection of specific applications are retrieved as a
special kind of attributes of the elements and then store
the constraints into the Rule database.

4

Development of OOGE

4.1 Software Architecture
The system was developed using Java/Swing for
visualisation and using MySQL for the construction of the
database. Figure 4 shows the architecture of OOGE,
comprising three parts: the Graphical User Interface
(GUI); the Data Transporting System (DTS); and the
Database Connection System (DCS).

Graph Editing
Interface

DBMS

DB
DCS

Figure 4. Architecture of OOGE

4.2 Sample Screens
We have created a prototype of OOGE to realise the
basic functionality of OOGE. Sample screenshots are
shown below in Figure 5, 6, 7 and 8.
Figure 5 shows the main menu screenshot. The main
menu contains four submenus: environment, nodetype,
rule-checking and database. For each application, a user
defines an environment. Under the environment, the user
creates the node types. Users can create a new node type
or extend it from an existing node type. Rule-checking
enables the user to be made aware of any invalid
connections in the graph created as a representation of a
system. By selecting the connection menu item of
Database, the system builds a connection to the MySQL
Server.

Graphical User Interface: This consists of two parts:
the Data Retrieval Interface (DRI) and the Graph Editing
Interface (GEI).
OOGE conforms to the interface
standards used by Microsoft Windows.
Data Transporting System: Data retrieved via the
DRI will be handled by DTS and will be formatted as a
three-layer data structure and temporarily stored in the
memory.
Figure 5. Screen Sample 1

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

Figure 6 is a screenshot of the Attributes Editor, by
which users can define the attribute name, sub-attribute
items and attribute values and store them in the database.

For example, T cannot be represented by a node that
has arcs emanating in order (a, a, a, b, b, b) since this
actually represents the element a3b3  (ab)3 in the general
case. The inverses of R, S and T are denoted by -R, -S
and –T, respectively: -R=a-2, -S=b-2 and -T=(ab)–3. The
graphical depiction of -T, for example, would be a node
with arcs (-b, -a, -b, -a, -b, -a). For further information on
Picture Theory the reader is directed to [1].

Figure 6. Screen Sample 2
Figure 7 shows a screenshot in which the connections
have been checked and returned that the connection is
valid. Selecting the Check menu item assesses the
validity of the graph. The system then automatically
checks whether the connections in the graph on the canvas
are valid or not. The example shown is a valid connection
between a Pump and a Tank in a WWTP system.
Figure 8. Screen Sample 4

5

Figure 7. Screen Sample 3
Figure 8 shows an example from Picture Theory, a
branch of group theory concerned with the visualisation of
groups and the manipulation of these visualisation.
First, we need to define the objects illustrated in the
screenshot. There are three types of relators in the system,
R, S and T. The relators are defined by the generators a
and b: R=a2; S=b2 and T=(ab)3. R, S and T can be
represented as nodes with labelled arcs representing the
generators. R has two arcs labelled (a, a); S has two arcs
labelled as (b, b); and T has six arcs, (a, b, a, b, a, b). It is
important that the order of the arcs (modulo cyclic
permutations) emanating from a node is preserved.

Conclusions and further work

In this article, we have presented an Information
Visualisation tool, OOGE, that can be used to visualise
general OO Systems. It allows users to define data types
through a user-friendly GUI, using a three-layer data
structure to handle the data manipulation. The issue of
information sharing is addressed as it has a common file
format for different applications. The OOGE can be used
to aid academic research in diverse areas such as picture
manipulations in group theory, circuit design and
equipment allocation such as network configurations and
WWTP modelling.
The current implementation only features a small set
of graph layout algorithms and this is an area for further
investigation. More algorithms are to be integrated into
the rule-checker, thereby allowing the user a wider range
of constraints to place upon the system.
The GUI of the OOGE is under further development,
to give a more sophisticated selection and editing
management such as multi-selection, multi-copy. A
layered menu will support the easy access and switch
between different system environments created.
It is also desirable to optimise of data structure and to
perform full multi-platform testing.

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE

References
[1] Baik Y.G., Harlander J. and Pride S.J., The geometry of
group extensions, J. Group Theory 1 , p. 395-416, 1998.
[2] Berry J.W., Dean N., Glodberg M.K., Shannon G.E.and
Skiena S., “LINK a system for graph computation”, Software Practice and Experience, 1999, Vol.30, No.11, pp.1285-1302.
[3] Di Battista G., Eades P., Tamassia R., Tollis IG, Graph
Drawing Algorithms for the Visualisation of Graphs, Prentice
Hall, New Jersey, 1994.
[4] Dürsteler J.C., “Information Visualisation, what it is all
about?”, http://www.infovis.net/E-zine/2002/num_100.htm
[5] GDS supported file formats,
http://loki.cs.brown.edu:8081/geomNet/gds/formats.shtml
[6] Herman.I. and Marshall M.S., “GraphXML – a graph
description language”, Proceedings of the Symposium on Graph

Drawing (GD 2000), Springer Verlag, Lecture notes in computer
science, 2000, Vol.1984, pp. 52-62.
[7] Himsolt M., “GML - Graph Modelling Language”, 1997.
http://infosun.fmi.unipassau.de/Graphlet/GML/
[8] Himsolt M., “Graphlet: design and implementation of a graph
editor”, Software - Practice and Experience, 2000, Vol 30,
No.11, pp.1303-1324.
[9] Himsolt M., “The Graphlet system (system demonstration)”,
Lecture notes in computer science, 1997, Vol.1190, pp.233-240.
[10] North S.C., “DOT abstract graph description format”,
http://www.research.att.com/~north/cgibin/webdot.cgi/dot.txt
[11] Thiel S., LEDA graph input/output format, 1999.
http://www.mpisb.mpg.de/LEDA/information/graph_io_format/
graph_io_format.html
[12] West++: http://biomath.rug.ac.be/~westpp/

Proceedings of the Seventh International Conference on Information Visualization (IV’03)
1093-9547/03 $17.00 © 2003 IEEE


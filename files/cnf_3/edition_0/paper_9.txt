2012 16th International Conference on Information Visualisation

AIVA vs UML: Comparison of Component Application Visualizations in a
Case-Study
ˇ
Jaroslav Snajberk,
Lukas Holy and Premek Brada
Department of Computer Science and Engineering, Faculty of Applied Sciences,
University of West Bohemia, Pilsen, Czech Republic
{snajberk, lholy, brada}@kiv.zcu.cz

There are tools able to visualize the structure of these
components in a general way, however they all use either
UML [7] or plain “boxes-and-arrows” notation, which is
not able to visualize more than the simple structure. UML
on the other hand is able to extend itself with proﬁles
to offer more information related to the component model
and since version 2.0 offers more options for visualization
of components – the component diagram. UML is a well
acknowledged software engineering approach recognized for
its advantages through all domains of software development
and is the current state of the art in general visualization of
components.
Sadly even with this massive commercial support there
are no tools able to reverse engineer component-based applications for visualization purposes. IBM Rational Software
Architect3 should be able to reverse engineer EJB 3 beans;
however we could not verify this feature due to unexpected
failures of the RSA.

Abstract—UML is the state of the art in visualization of
software. However, it does not satisfy the needs of modeling in
the domain of component applications and complex software
architectures. UML has to be extended with proﬁles so as to be
able to model the speciﬁcs of a particular component model;
its diagrams are not scalable, therefore one has to balance the
amount of information and readability; and it presents all the
information at once so visual data mining is harder. These
were the reasons for developing a completely new approach
called AIVA (Advanced Interactive Visualization Approach)
that focuses solely on the component domain and addresses the
problems of scalability and readability by adopting interactive
techniques like information hiding and details on demand. In
this paper we analyse how this new approach stands compared
with UML by modelling a nontrivial component application.
Keywords-software visualization; component; UML; reverseengineering;

I. I NTRODUCTION
The domain of component-based software development
is very diverse as there are dozens of component models
in Java only from both commercial and research areas –
OSGi [1], EJB [2], SOFA 2 [3], CoSi [4] and others. Any
component model can introduce its own unique features like
behavior protocols [5] or hierarchical decomposition (SOFA
2), making it even more difﬁcult to reverse-engineer and
visualize the structure of component-based applications in a
general way.
In the matter of fact there is no current software visualization approach that would be able to satisfy both these
goals – a) reverse-engineer the structure of application for
further visualization; b) work in general way without strong
ties to one component model only.

B. Goal and structure of this paper
The goal of this paper is to evaluate our new visualization
approach called AIVA [8]. It will be thoroughly compared
with UML component diagram extended with proﬁle, which
is currently the state of the art in visualization of componentbased software. These two approaches are going to be
compared on a case-study of two applications: ﬁrst is a
very simple application called ParkingLot and second is a
complex one called CoCoME [9], which is a recognized
component modeling example.
Evaluation of a new approach by comparing with an
existing one is recognized as a valid evaluation method
classiﬁed in [10] and emphasized in [11]. We would like to
note, that this is only a ﬁrst step in our evaluation process.
This paper is structured as follows. Section II provides
a basic overview of both visualization approaches UML
and AIVA. The technological background for the case-study
is explained in Section IV. The case-study is described
in Section IV and the results of this case-study are then
discussed in Section V. Finally these results are generalized
in Section VI and conclusions close this paper.

A. State of the Art Overview
There are of course tools that are able to reconstruct
the structure of component-based software, but they are
closely bound to speciﬁc component models in both the
reverse-engineering and visualization abilities. For example;
SOftware MOdel eXtractor (SoMoX)1 visualizes Palladio
component model [6] and Plug-in Dependency Visualization2 visualizes Eclipse plug-ins (OSGi).
1 www.palladio-simulator.com/tools/add

ons/somox/

2 www.eclipse.org/pde/incubator/dependency/visualization/

1550-6037/12 $26.00 © 2012 IEEE
DOI 10.1109/IV.2012.20

3 http://www.ibm.com/developerworks/rational/products/rsa/

54

hiding and details-on-demand features. For example, additional information about component elements is provided
as tool tips or all relations between two components are
represented as only one line and additional details are
provided on demand. These features particularly help to
decrease the overall complexity of the ﬁnal diagram.
The importance of interactivity on information visualization was earlier discussed by Yi et al. [14] whose work we
thoroughly studied while designing AIVA. The principles of
this approach are described in detail in [15] and AIVA is
an implementation of these principles. Brief list of several
adopted interactive techniques follows:
Grouping and ﬁltering of elements of the component
is possible thanks to the ENT meta-model [12], which has
a feature called CategorySet based on the ENT’s faceted
classiﬁcation used on elements. CategorySet can deﬁne
several categories as sets of rules that have to be satisﬁed in
order to include an element in the given category. The bodies
of components are ﬁltered using the selected CategorySet.
Conditional formatting is another powerful feature possible due the ENT meta-model. AIVA is able to create conditional formatting based on the name of component or its elements, but what is more important, it
can work with any other detail about component or its
elements hold by the ENT meta-model like full name,
version, required environment, etc. For example: In OSGi
all event handling must go through provided service called
org.osgi.service.event.EventHandler, events
are then routed by setting the event topic inside the service
ﬁlter. AIVA can take into account the value of this ﬁlter and
visually highlight only those elements or whole components
that listen on certain topic.
Navigation/explore interactive techniques are represented
by scrolling, zooming, panning, outline view and quick
search (move the view on component in diagram, when
selected in project overview). These techniques should provide quick navigation through the diagram for either looking
up some component or plain browsing of relations. The
zoom function has a special meaning in AIVA, because it
does not only provide the simple zoom in and out but also
hides component details irrelevant to current zoom level, to
provide cleaner overview of the whole structure.
Selecting is more important in AIVA, because it helps
reveal and eye track more information. By selecting a
component, element or connection line, one can get more
information about the item. Selection stays active even after
reconﬁguration (e.g layout changes). Selected connection
line also highlights connected components even in diagram
outline, so it is easier to ﬁnd them and their related components.
Reconﬁguration – change of representation of components, connection lines or layout of a diagram is useful when
a different point of view on a complex software system
is needed. AIVA supports several layouts which can be

II. OVERVIEW OF UML AND AIVA
This Section will provide an overview of our new approach called AIVA. As UML is a well known approach,
only its shortcomings which lead to development of AIVA
will be discussed.
A. UML Component Diagram
UML uses a component diagram to visualize components,
which can be represented as black-boxes – without any
details, or white-boxes – with details. Component diagram
has all features like other UML diagrams it is general, is
supported by dozens UML tools, provides the same information in computer and on paper, is easily understandable
and can be extended via proﬁles. UML tools have to support
UML 2.0 or higher, which is the version where component
diagram was introduced.
Component diagram has several shortcomings in
component-based development that makes it harder to use
on some component models and bigger applications.
First problem is caused by its generality. Because proﬁles
are an extension mechanism usable by any UML diagram,
they are unable to precisely model all the aspects of components in different component models. The origin of this
problem is in the UML meta-model itself as we discussed
in our previous publication [12].
Secondly, UML does not contain mechanisms when simplify visualized structure. This is a major problem when
visualizing dozens of components with hundreds of relations
– the structure is just too complex. Compared with class
diagrams the structure of components is more complicated,
because component models can introduce several different
types of relations and features on component interface. Thus
several connection lines can be present between two components, leading to complete confusion in bigger diagrams.
Third, UML is static and does not support different views
– when one needs to visualize the same application but
with different levels of details he has to create two different
diagrams. There are already nonstandard ﬁxes in the form
of layers, suggesting that this is a recognized problem with
UML. These layers are described by Dumoulin in [13] while
already implemented and in use in IBM RSA.
B. AIVA
AIVA uses oriented graph to visualize components and
their relations. Its notation is similar to the UML component
diagram, but unlike complete UML it is focused only on
component-based software to provide more precise information. Moreover, it adopts interactive techniques to improve
the process of software comprehension.
Its easy to understand visual notation is uniﬁed for all
component models – any component will look the same, it
will only vary in the inner elements of the component. To
simplify the visual representation it uses a lot of information

55

switched on the ﬂy. However it is also able to change the
representation of displayed components – while someone
might ﬁnd useful the default tree representation of elements,
others might prefer classic UML representation. AIVA offers
three completely different visual representations right now.
AIVA is built as part of an extend-able tool, called
ComAV, that enables reverse-engineering of applications
from different component models. ComAV is based on
the Rich Client Platform (RCP) [16] that is used to build
powerful applications such as Eclipse4 IDE. OSGi, EJB
and SOFA 2 component models are already implemented as
ComAV plug-ins and more can be easily added this way.
Thus it is possible to support any component model for
future visualization. AIVA itself uses JgraphX5 diagramming
solution for basic graph operations, the library has been
extended to open new possibilities required by AIVA.
III. T ECHNOLOGICAL BACKGROUND FOR THE
C OMPARISON
The comparison of UML and AIVA was performed on two
case applications. Both are implemented in OSGi which is
a standard industry component model used for example to
build Eclipse IDE. In this section we will brieﬂy describe
both the OSGi component model and the structure of these
applications.

Figure 1.

UML proﬁle of OSGi component model

speciﬁcation captured in a form which would an supplier
get from a business company. It was mainly developed for
the purposes of comparing different approaches to a component based software development. It has been ofﬁcially
implemented by 13 modeling approaches; we implemented
it in OSGi component model.
The described system serves as an information system
for supermarket chains. It consist from three main parts.
First is Cashdesk part, which contains the cash desk as it
can be seen in supermarkets, including bar code scanners,
credit card readers etc. Second part is store infrastructure
consisting from store server and store client. Finally there is
an enterprise server, which consist from an enterprise server
and client applications. CoCoME is assembled from 37
components and 12 interfaces, thus representing a mediumsize application.

A. OSGi Component Model
OSGi is a multi-platform Java component solution focused on dynamic deployment and assembly of components.
OSGi components are black-boxes their nature and ties are
described in a manifest ﬁle. The communication between
components is limited to services which are implementations
of interfaces, thus keeping their black-box nature.
Apart from services these components can depend on Imported packages and other components – Required bundles.
This means that there are three types of relations in OSGi
environment. Complex analysis of OSGi component model
and its key features is described in [17], where the author
also suggested a proﬁle for the ENT meta-model, which is
used by AIVA.
After a thorough study of this proﬁle we developed a
similar one for UML, so it can model the same information
as the ENT meta-model. It is suitable to note that UML
meta-model is unable to describe the character of these
information, thus it loses information already. However this
characteristics is not vital for the visualization itself. This
UML proﬁle of OSGi component model is presented in
Figure 1.

C. ParkingLot
ParkingLot is a simple example application, developed
to demonstrate the features of CoSi component model6 . It
is assembled from 5 components with 4 interfaces. In an
OSGi implementation an EventAdmin component had to be
added to enable event handling, thus the whole application
was extended on 6 components and 6 interfaces.
ParkingLot was chosen as a case example because it is
small enough to be compared thoroughly in reasonable time.

B. CoCoME

IV.

CoCoME stands for Common Component Modeling Example [18]. It is an example description of requirements

CASE - STUDY

A PPROACH

This Section describes how this case-study was performed, presents all the gathered data, discusses them and

4 http://eclipse.org
5 http://jgraph.com/

6 http://www.assembla.com/spaces/cosi/wiki/Tutorial

56

examples

Figure 2.

Figure 3.

ParkingLot in UML

ParkingLot in AIVA, with one connection (Gate – Conﬁguration) selected

57

the same structure and data. There are a few components,
that are not complete in UML as they contain dozens of
elements that are not related to the application itself as they
are imported by OSGi framework. Hierarchic algorithm was
used on CoCoME diagram without any manual modiﬁcation.
The diagrams of CoCoME are too big to be a part of this
paper in readable resolution so we created a preview of these
diagrams to illustrate our statement. Full size images can be
viewed on project homepage7 together with all resources
needed to recreate our experiment.

proposes conclusions.
A. Goals of the case-study
The research into comparison of AIVA and UML in the
domain of component-oriented applications was inspired
by a formal deﬁnition of software visualization by von
Mayrhauser [19]:
Software visualization is a discipline that makes
use of various forms of imagery to provide insight
and understanding and to reduce the complexity of
the existing software system under consideration.
The reduction of complexity is understandable as it provides better readability and understandability of the diagram.
This is caused by limitations of human brain; these limitations were studied in context of software visualization by Ric
Holt in [20], where he deﬁned several laws for minimizing
the amount of visualized information.
The research questions asked in the study therefore were:
1) Which approach provides more logical data representation.
2) Which approach provides less complex diagram.
3) Which approach provides better readable structure/hierarchy.

V. R ESULTS OF THE CASE - STUDY
The case-study data were gathered by visualizing the two
applications in both visualization approaches and comparing
the ﬁnal qualities of the diagrams.
To answer the ﬁrst research question about quality of
data representation, it is better to use the case example of
ParkingLot, which is representant of small applications. All
criteria concerned with this question will be answered in one
paragraph in following subsections. ParkingLot is visualized
in Figures 2 and 3.

B. Evaluation Criteria

A. UML

To correctly answer on all research questions we deﬁned
several evaluation criteria, as follows.
To decide which approach provides better data representation we used these criteria: 1) How are these data
organized logically; 2) What can be learned on ﬁrst look;
3) How accessible are secondary information (attributes of
stereotype described in Figure 1). All these criteria are
focused on how easy it is to get and classify an information.
The complexity of diagram can be quantiﬁed, because
diagram with less graphical elements is less complex. There
are two major types of graphical elements, that crate diagram
more complex: 1) Number of nodes; 2) Number of lines.
The readability of structure/hierarchy of diagram is individual and depends on the structure of visualized graph.
The criteria to answer this question are: 1) How well is
hierarchy readable from spatial organization of nodes; 2)
How logically are nodes arranged.

UML does not provide any logical organization of its provided/required elements. Both types of packages are mixed
together on the edges of component as ports and user has
to study which stereotype was applied on the port to decide
which type it is. UML tools can change the appearance of
components – to show/hide the list of elements in the body
of component like interfaces in Figure 2. This feature makes
it easier to get an overview of component, but UML supports
only the most basic grouping and shows only some types of
features in these lists.
In small diagram one can see almost any information
on the ﬁrst look. The packages are nicely showed as
ports so it is possible to recognize the type of relation –
service/package/bundle. The UML is basically supposed to
provide all information on the ﬁrst look. It comes handy that
one can get the same experience from printed diagram and
by using a big format/resolution printer to get even better
context of the whole application. However, more complex
diagrams make it harder to read any of these information.
Concerning the information which is not directly visualized but can be accessed manually, their availability depends
on UML tool used. RSA needs four steps to get to these
information: 1) select Properties view, 2) choose Stereotypes
tab, 3) ﬁnd Stereotype properties list, 4) locate relevant
properties (RSA shows all inherited and empty properties).
Other UML tools do not provide much better experience.

C. Preparation of data
AIVA is built on ComAV which is able to reverseengineer OSGi applications and thus both applications were
automatically analyzed by it. AIVA then used this data to
create oriented graph and applied its hierarchical layout on
it.
The RSA was chosen as a UML tool, because of its
importance and richness of features. Both UML diagrams
were created manually, because there is no OSGi to UML
reverse engineering tool. These diagrams are based on
information from AIVA diagrams to ensure that it present

7 http://www.assembla.com/spaces/comav/wiki/Comparison

58

of AIVA

Figure 4.

Complete CoCoME visualized with UML
Figure 5.

Complete CoCoME visualized with AIVA

B. AIVA
information which UML provides directly.
This information is not directly visualized and interaction
is required. A tool-tip with the list of nonempty properties
appears after hovering over the element, when no tool-tip
shows after interaction it means that this element does not
offer any additional information.

AIVA provides grouping of elements based on their characteristics and lists them all on one place. The tree hierarchy
is used in Figure 3 to emphasize where every element
belongs. One can though easily classify each element. It
is possible to change the grouping of elements on the ﬂy –
like when one needs to study what elements are functional
and which are only the data. It is also possible to change
representation of components, AIVA provides three completely different representations that are focused on logical
arrangement of its elements and use easily comprehensible
lists in its body.
It is possible to see all elements of a component in
one place as well as relations between components. AIVA
collapses all lines between two components into one line to
lower the complexity of diagram and emphasize components
themselves. It does not provide any textual hint that would
tell more about these relations – interaction is required.
AIVA also uses only one visual style for connection line
(same for service, package, bundle) and does not use any
other graphical indicators like ports. AIVA is therefore
cleaner and its readability is better in more complex diagrams, but requires more user interaction to get the same

C. Quantitative evaluation
One can look on Figures 2 and 3, which are both well
readable, and count the connection lines in the diagrams.
AIVA uses 6 nodes and 11 lines, while UML has to use
12 nodes (6 components and 6 interfaces) and 20 lines to
express the same. The hierarchy of ParkingLot is better
distinguishable from AIVA diagram, but this statement is
arguable on application of this size. ParkingLot diagrams
can’t answer this question, but they create a good basis for
the next example.
CoCoME is visualized in Figures 4 and 5. AIVA uses
37 nodes and 125 lines, while UML has to use 49 nodes
and 244 lines. Both diagrams contain the same amount of
information, however UML needs two times more graphical
elements to express the same. The structure of CoCoME is
well readable from AIVA, one can immediately study the

59

VII. C ONCLUSIONS

hierarchy and ﬁnd the key components of the application,
however UML diagram is ﬂat – no spatial information can
be observed from the diagram and the positioning does not
seem to have any logical reason.

This paper described a case-study that compared UML
and AIVA in the domain of visualization of structure of
component-based applications. The research questions were
chosen to ﬁnd out which one of these approaches generates
better diagrams in terms of understanding, better structure
and lower complexity. As case examples that presented
features of these approaches on differently complex applications were used a simple application with 6 components
and CoCoME for complex application with 37 components.
The results suggest that AIVA is better almost in all
relevant criteria because it generates better understandable,
more clearly structured and less complex diagrams than
UML does.
It is still needed to test other aspects of this new visualization approach. Currently we are working on user study aimed
to measure the time required to answer simple questions
related to the diagram.

D. Summary of ﬁndings
AIVA is better in two criteria of the ﬁrst research
question – it provides better logical organization of data
and secondary information is better accessible. However
it provides less information on the ﬁrst look and requires
interaction. In small application, like ParkingLot, UML is
better because it provides all the information immediately.
In bigger applications, like CoCoME, AIVA is better because
high number of connection lines in UML diagrams makes it
harder to 1) read types and names of ports and 2) visually
trace the relationships.
The number of nodes and lines suggests that AIVA is
less complex and thus better readable, as it contains a half
of graphical elements of UML diagram.
The spatial composition of these nodes is also better
in AIVA, where the hierarchy of the application is easily
readable, while RSA (UML) offers only vague idea of the
structure.
These ﬁndings should be further supported with a detailed
user study. The main reason is that the better structure was
acquired by hiding a lot of information and it is important
to test if this approach does not slow down users when
analyzing application architecture. Such study (out of scope
for this paper) is currently under preparation.

ACKNOWLEDGEMENTS
The work was supported by the UWB grant SGS-2010028 Advanced Computer and Information Systems.
R EFERENCES
[1] OSGi Alliance, OSGi Servise Platform Core Speciﬁcation,
OSGi Alliance Std., 2009.
[2] Sun Microsystems, Inc., Enterprise JavaBeans(TM) Speciﬁcation, Sun Microsystems, Inc. Std., 2001.

VI. G ENERALIZATION

[3] T. Bures, P. Hnetynka, and F. Plasil, “SOFA 2.0: Balancing
Advanced Features in a Hierarchical Component Model,” in
SERA. IEEE Computer Society, 2006, pp. 40–48.

This case-study can be generalized for all component
models and any UML tool as discussed below. As mentioned
in the introduction, any component model can have several
features that require extension of UML through proﬁles to
enable modeling of its advanced features. Our OSGi proﬁle
is still one of the simplest ones. We used only one type
of interface and ports meant for either provided or required
packages thus one did not have to pay much attention what
type of port or interface it is.
In reality, proﬁles might be much more complicated based
on the complexity of the particular component model. For
example an ofﬁcial proﬁle for CORBA Component Model
[21] deﬁnes seven different types of ports. This suggests
that if AIVA managed to get better results against the
simple OSGi proﬁle, it should provide better results for more
complex component models as well.
RSA is an advanced commercial tool that contains a lot
of rich features to get the information about relationships of
elements as soon as possible and supports easy development
of both UML proﬁles and component diagrams. Given that
AIVA provides better results against this state of the art
UML tool we conjecture that it provides better results against
any other tool.

[4] P. Brada, “The CoSi Component Model: Reviving the Blackbox Nature of Components,” in Proceedings of the 11th
International Symposium on Component-Based Software Engineering, ser. CBSE ’08.
Berlin, Heidelberg: SpringerVerlag, 2008, pp. 318–333.
[5] F. Plasil and S. Visnovsky, “Behavior Protocols for Software
Components,” IEEE Trans. Software Eng, vol. 28, no. 11, pp.
1056–1076, 2002.
[6] S. Becker, H. Koziolek, and R. Reussner, “The palladio
component model for model-driven performance prediction,”
Journal of Systems and Software, vol. 82, no. 1, pp. 3 – 22,
2009, special Issue: Software Performance - Modeling and
Analysis.
[7] Object Management Group, UML Superstructure Speciﬁcation, Object Management Group OMG speciﬁcation
formal/2009-02-02, Rev. 2.2, 2009.
[8] J. Snajberk and P. Brada, “COMAV - A Component Application Visualisation Tool,” in Proceedings of International
Conference on Information Visualization Theory and Applications. SciTePress, 2012.

60

[9] S. Herold, H. Klus, Y. Welsch, C. Deiters, A. Rausch,
R. Reussner, K. Krogmann, H. Koziolek, R. Mirandola,
B. Hummel, M. Meisinger, and C. Pfaller, “The common
component modeling example,” A. Rausch, R. Reussner,
R. Mirandola, and F. Pl´asˇil, Eds.
Berlin, Heidelberg:
Springer-Verlag, 2008, ch. CoCoME - The Common Component Modeling Example, pp. 16–53.
[10] R. K. Christopher, C. G. Healey, V. Interrante, D. H. Laidlaw,
and C. Ware, “Thoughts on user studies: Why, how, and
when,” IEEE Computer Graphics and Applications, vol. 23,
p. 2003, 2003.
[11] C. Forsell, “A guide to scientiﬁc evaluation in information
visualization,” in Information Visualisation (IV), 2010 14th
International Conference, july 2010, pp. 162 –169.
[12] J. Snajberk and P. Brada, “ENT: A Generic Meta-Model
for the Description of Component-Based Applications,” Electronic Notes in Theoretical Computer Science, vol. 279, no. 2,
pp. 59 – 73, 2011, proceedings of the 8th International
Workshop on Formal Engineering approaches to Software
Components and Architectures (FESCA).
[13] C. Dumoulin and S. Gerard, “Have Multiple Views with
one Single Diagram! A Layer Based Approach of UML
Diagrams,” Institut National de Recherche en Informatique
et en Automatique, Universite des Sciences et Technologies
de Lille, Research report INRIA-00527850, October 2010.
[14] J. S. Yi, Y. ah Kang, J. T. Stasko, and J. A. Jacko, “Toward a
deeper understanding of the role of interaction in information
visualization,” IEEE Trans. Vis. Comput. Graph, vol. 13,
no. 6, pp. 1224–1231, 2007.
[15] J. Snajberk and P. Brada, “Interactive Component Visualization,” in Proceedings of International Conference on
Evaluation of Novel Approaches to Software Engineering.
SciTePress, 2011, pp. 218–225.
[16] J. McAffer, J.-M. Lemieux, and C. Aniszczyk, Eclipse Rich
Client Platform : Designing, Coding, and Packaging Java
Applications, 2nd ed. Addison-Wesley Professional, April
2010.
[17] L. Valenta and P. Brada, “OSGi Component Substitutability
Using Enhanced ENT Metamodel Implementation,” Department of Computer Science and Engineering, University of
West Bohemia, Tech. Rep. DCSE/TR-2006-05, 2006.
[18] A. Rausch, R. Reussner, R. Mirandola, and F. Plasil, The
Common Component Modeling Example: Comparing Software Component Models, 1st ed.
Springer Publishing
Company, Incorporated, 2008.
[19] A. von Mayrhauser and A. M. Vans, “Program comprehension during software maintenance and evolution,” Computer,
vol. 28, pp. 44–55, August 1995.
[20] R. Holt, “Software Architecture as a Shared Mental Model,”
in Proceedings of International Workshop on Program Comprehension, 2002.
[21] Object Management Group, UML Proﬁle for CORBA
and CORBA Components Speciﬁcation, Object management
Group OMG Speciﬁcation formal/2008-04-07, Rev. 1.0, 2007.

61


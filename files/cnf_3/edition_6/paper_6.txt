xAnVi – An Extensible Visualization and Analysis Framework
Jan Griebsch, Oliver Arafat, Wolfram Koska
Technical University of Munich, D-85748 Garching, Germany
{griebsch@in.tum.de, lewder@web.de, koskaw@in.tum.de}

Abstract
xAnVi is an extensible framework for the analysis and
visualization of graphs. The framework consists of a small
core to manage resources, plugins and extension points
and an arbitrarily expandable set of plugins to provide the
actual application functionality. This paper describes the
design approach to create a modular bioinformatics
toolkit/framework for:
x Research involving the dynamic and interactive
visualization of graphs and networks.
x Biological networks analyses.
In addition, two plugins for the interactive exploration of
hierarchical networks are presented. The toolkit is
available through the toolkit homepage [1].

1. Introduction
xAnVi's design was motivated by the goal to develop a
flexible and extensible network visualization and analysis
tool for metabolic and other biological networks. Networks
appear in many contexts in molecular biology nowadays.
Prominent examples include metabolic, protein interaction
and regulatory networks. A plethora of (internet) databases
offer data from which networks can be extracted or
extended upon. Unfortunately, the data formats are almost
as diverse as the data itself, and data conversion becomes
an ever recurring task: convert data to import it into an
analysis tool, convert it again to run one's own analysis
algorithms, convert it yet again to visualize the network or
the results of the analysis. This problem tends to become
worse as researchers of the post-genomics age increasingly
link diverse data into their analyses. The usual approaches
to this problem include:
x Defining a common meta format... This approach does
help improve the situation, but does not entirely solve
the problem. Unfortunately, it is seldom for a proposed
format to become widely used and accepted.
x Writing a tool to transform the custom data format into
a format known to the AV tool. This is certainly a
straightforward solution, but it also offers the least
flexibility: What if the custom data contains attributes,
relationships or data types that cannot be modeled

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

satisfactorily by the native data formats of the AV
tool? What if the analysis or visualization has to be
tweaked in a way that the authors of the tool did not
foresee and hence are not offered through GUI or
command line parameters?
x If
the
tool's
source code
is available,
adjustments/additions can be made. This offers the
most flexibility, but can be very cumbersome.
Changing somebody else's code is considered a very
difficult and error-prone task - even with a proficient
developer and good documentation at hand.
Furthermore, the tool may depend on a number of
other libraries that need to be installed in order to do a
complete rebuild.
Another perspective to the problem is that the existing
analysis and visualization tools are too monolithic and not
extensible enough. If an analysis is conducted in a certain
program with insufficient visualization capabilities, one
cannot simply extend the program with one’s own
visualization routines. In order to test one's own network
analysis algorithms, one first needs to write custom
import/conversion routines, even though the problem of
accessing that particular data source has probably been
solved by others many times before. This research
proposes a concept for a network visualization and analysis
platform in which the program is not monolithic, but
consists of a set of pluggable modules (plugins), similar to
Eclipse [2]. Except for a small generic core module, all
functionality is located in plugins. Plugins may be
developed and delivered separately and are loaded at runtime.
Consequently, it is possible to add custom I/O,
analysis and visualization routines, extend the GUI, or
replace existing components without having to rebuild
parts provided by others.
Biological networks are often large, as are many real
life networks, e.g. the internet AS graph [3]. Protein
interaction networks typically have tens of thousands of
nodes and metabolic networks range from a few dozen to
several thousand nodes. Drawing such networks as a whole
on the screen is usually not a feasible option (Fig. 1).
Zooming in on details, as offered by most tools, is not an
adequate help. This only makes it more difficult to retain
an understanding of the relationship between the zoomed

2. Related work
2.1. Plugin architectures

Figure 1
A drawing
interaction network.

of

a

protein-protein

area and the network as a whole – the so-called mental map
[4]. One solution to this dilemma is to only draw
placeholder nodes (meta nodes) for each subnetwork. The
meta nodes inherit connections between subnetworks from
their children. On demand, the meta nodes can be
expanded by replacing them with the nodes of the
respective subnetwork. Alternatively, a subnetwork may be
collapsed into a meta node. The expand step may be
repeated until the most detailed view is reached, thus
providing a discrete zooming step that may allow the user
to keep his/her mental map. The collapse step may be
repeated until the complete network has been collapsed
into a single (root) node, thus forming a tree-like hierarchy.
To support such operations efficiently, special data
structures such as so-called hierarchical graphs and
suitable graph drawing algorithms are needed. In this
context, the currently visible set of (meta) nodes and
(induced) edges is called a view.

In the past years, developers have increasingly moved
away from monolithic designs and have offered plugin
interfaces to extend their programs’’ functionality. Popular
examples include the Firefox web browser or the
Thunderbird e-mail client. With the exception of the
Eclipse framework, all of these applications are one-level
plugin architectures, i.e. plugins extend a static interface of
the main application, but cannot extend other plugins,
because mechanisms that enable plugins to publish their
named extensions, resources and signals to other plugins
are missing.
The well-known Eclipse framework was designed to
provide such abilities. In comparison to the xAnVi plugin
framework it offers a powerful and more mature API,
extended extension point semantics and tools to support
plugin development. While the initial set of plugins
provided little more than an extensible text editor, today
hundreds of plugins are available for a wide range of
applications. In comparison to the C++ based xAnVi
framework, Eclipse also profits from the cross-platform
compatibility and ease of library handling of Java.
However, for work related to graph/network analysis and
visualization,, Java has two major drawbacks: (1) The
available graph libraries are not (yet) as mature or powerful
as their C++ counterparts. (2) Similar arguments apply for
the 2D drawing libraries. The authors of this paper are
unaware of a C++ framework with a similarly flexible
plugin concept.

2.2. Hierarchical Graphs
Concepts for hierarchical graphs as well as various
trade-offs between the time necessary for navigation
(collapse and expand) and edit operations, and the space
requirements for the hierarchy data structure are described
here [5,6,7]. A demo implementation for a hierarchical
graph with limited editing possibilities is available here
[6]. The authors are also aware of an unpublished thesis
work on this topic that includes a Java/Jung [8]
implementation.

3. Plugin Platform
Figure 2 A graph (light blue background) with a
tree-like hierarchy. The nodes that are currently
visible (the view) have an orange coloring.

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

The core of the framework is a management
component that loads plugins at runtime, resolves
dependencies among plugins, and implements generic

functionality such as error handling, logging and base GUI
elements.
The central service of the framework core is provided
by the object broker. Through the object broker, each
plugin can register and publish well defined, uniquely
named extension points i.e
resources/potential
interconnections it wants to make available to other
plugins. Through these extension points, plugins may
extend other plugins, possibly defining points of extension
themselves.
An example for an extension point provided by the
core component is the menu bar, to which plugins can add
their own entries and sub menus. Another example from
figure 3 is the graph extension point provided by the
hierarchical graph plugin. Through this extension point the
I/O plugin extends a graph data structure with the ability to
load graphs from a file. Signals [10] can also be extension
points and can be used to introduce a loose coupling
between plugins. For example, the visualization plugin
could subscribe to a signal “graphChanged” in order to be
notified of changes to the depicted graph, or the I/O plugin
to a GUI signal “MenuEntryLoadGraphClicked” in order
to show a file open dialog. In this manner, the framework
could be extended to implement virtually any functionality
by adding plugins with the missing functionality to the set
of available plugins.

GUI

Layout
Geometry

ButtonBar
ToolView

Profile Manager

LogWidget
MenuBar

Plugin Manager

Graph
Hierarchy

Object Broker

Visual
Attributes

3.1. Implementation
The framework was implemented in C++, which was
chosen over Java for the availability of mature graph
libraries and for the ease of integration into the MOSES
chemical simulation library [9]. The graphical user
interface is implemented with Qt [10], which also provides
the build system and cross-platform abstractions of file and
library operations. The project has a single code base,
which is developed and tested under Microsoft Windows
XP and Linux (Suse 9.3). The xAnVi framework core is
available as a precompiled and debug or release package
from the project website, or as source code from the
subversion repository.

Spring
Spring
Layout
Layout

Layout
Layout
Plugin
Plugin

Graph Drawing
Window Plugin

View
Node Centrality

Extension Points

Property Facility
Analysis Plugin

GUI.ButtonBar
GUI.ToolView
…
Plugin.Graph
Plugin.Graph.Hierarchy
Plugin.Graph.PropertyFacility

Visualization Plugin

Graph Plugin
Biopath DB

I/O Plugin

Core Module

Figure 4 Screenshot of the GUI of the core
component. A few menu entries, and the tabbed
window at the bottom have been added by the
loaded plugins.

Visualization Plugin

Figure 3 The core framework and a few plugins
with their inter-plugin dependencies. Extension
points are depicted as blue dots on the box
frame. Implemented extensions are depicted by
grey edges.

The graph plugin and the graph drawing window plugin
contain
the
main
functionality
for
exploring
hierarchical/interactive visualization approaches. The
following section briefly describes these two plugins.

4. Example plugins
Although the above description is seemingly
straightforward, it does not scale well. Loading dozens or
even hundreds of plugins would delay start-up and
significantly increase memory consumption. The Eclipse
framework handles this by lazy loading of plugins on
demand. For simplicity, we have chosen to let the user
define subsets of plugins (called profiles) a priori, thus
enabling him/her to choose the role the framework takes up
at start-up time.

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

4.1. The Hierarchical Graph Plugin
The plugin consists of widgets that extend the core
component’s GUI to show instantiated graphs, hierarchies
and views and of the actual graph library. The classes for
the base graph are implemented on the boost graph
template library [11], which is a mature, cross-platform
open source graph library. A property facility enables the

association of arbitrary key/value pairs (i.e. properties) to
nodes and edges. Similar to [6], subject-observer design
patterns allow an arbitrary number of hierarchies to be
attached to a graph. The pattern also facilitates the
notification of the attached hierarchies of changes in the
base graph. Similarly multiple views can be attached to a
single hierarchy, enabling concurrent views of the same
graph, with different level of detail. Through the same
mechanism, multiple visualizations of a single view are
kept synchronous, thus enabling multiple visual
representations of a given view.

ObservableGraph
• new_node(NodeID)
• new_edge(EdgeID)
• del_node(Node)
• del_edge(Edge)
• del_edge(Node,Node)

Hierarchy
1

n

• update()
• step(children)
1
• unstep(Node)
• connect(Node, Node)
• set_graph(ObservableGraph)

View
n

Visualization

• update()
• exand(Node)
• collapse(Node)
• set_hierarchy(..)

1

n

• update()
• draw()
• set_view(..)

Graph
• new_node(NodeID)
• new_edge(EdgeID)
• del_node(Node)
• del_edge(Edge)
• del_edge(Node,Node)

Figure 6 Expanding a node (see mouse arrow in
the upper left frame).

EditableGraph
ConstGraph
• node_exists(NodeID)
• node(NodeID)
• node_id(Node)
• edge …
• source(Edge)
• target(Edge)
• node_it()
• edge_it()
• properties()

PropertyFacility
• add_node(Node)
• add_edge(Edge)
• del_node(Node)
• del_edge(Node)
• get(Node,string)
• set(Node, string, ptype)

Observer

Subject
• attach(Observer *)
• detach(Observer *)
• notify(Message)

1

n

Figure 5 Inheritance relationships among the
main classes of the graph plugin. Only
characteristic methods and classes are shown.
Methods
are
shown
where
they
are
(re)implemented.

4.2. The visualization plugin
The 2D visualization window plugin provides methods
to draw nodes, edges and properties. The plugin also
manages visual attributes (such as colour, shape)
associated with the graph objects and handles user
interaction such as clicking on a node to expand/collapse it.
By design the hard work of calculating an aesthetic layout
for a given view is outsourced to layout plugins (Fig. 3).
Currently we are developing a spring embedder based
layout algorithm that is optimized for the inter-active
exploration of large networks with hierarchies.

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE

5. Conclusions

• update()

This paper described xAnVi , an extensible testbed for
visualization approaches based on hierarchical data
structures. xAnVi is also a software design approach for
creating modular bioinformatics toolkits and frameworks
for network visualization and analysis. Our experiences
with the xAnVi framework show that it is indeed feasible
to implement such a highly flexible plugin design with
C++. Despite the relatively large overhead involved in
designing and programming such a configurable system,
the implementation is justified by numerous advantages.
The modular design makes it easy to supplement an
application with custom functionality, which is particularly
useful when development occurs at separate groups of
developers. Our experiences with the xAnVi framework as
a testbed for visualization approaches show that it is indeed
feasible to implement such an ultra flexible plugin design
with C++.

6. Acknowledgements
The development of xAnVi was supported by the BMBF
within the BFAM research project (Bioinformatics for the
Functional Analysis of Mammalian Genomes).

7. References
[1]

J. Griebsch. The xAnVi plugin framework homepage.
http://www14.in.tum.de/personen/griebsch/xanvi
[2] Eclipse
Platform
Technical
Overview.
http://www.Eclipse.org/whitepapers/Eclipseoverview.pdf
[3] Wikipedia.
Autonomous
system
(Internet).
http://en.wikipedia.org/wiki/Autonomous_System_Number
[4] P. Eades, W. Lai, K. Misue, and K. Sugiyama. Preserving
the mental map of a diagram. In Proceedings of
Compugraphics 91, pages 24–33, 1991
[5] Adam L. Buchsbaum and Je_rey R. Westbrook.
Maintaining
hierarchical
graph
views.
In 11th ACM-SIAM Symposium on Discrete Algorithms,
2000.
[6] Marcus Raitner. HGV: A library for hierarchies, graphs,
and views. In M. T.Goodrich and S. G. Kobourov,
editors,Proc. Graph Drawing, volume 1528of LNCS, pages
236–243, 2002.
[7] A. L. Buchsbaum, M. T. Goodrich, and J. R. Westbrook.
Range searching overtree cross products. ESA , 2000.
[8] Java Universal Network/Graph Framework (JUNG)
Homepage. http://jung.sourceforge.net
[9] A. Herwig, T. Kleinöder, J. Marusczyk, J. Gasteiger.
MOSES - a comprehensive framework for knowledge-based
systems handling chemical structures and reactions.
Computer-Chemie-Centrum,
http://www2.chemie.unierlangen.de, 2003
[10] To Trolltech AS. Qt, c++ toolkit for application
development. http://www.trolltech.com/products/qt/.
[11] J. Siek, L.-Q. Lee, A. Lumsdaine. BGL – the Boost Graph
Library,
http://www.boost.org/libs/graph/doc/table_of_contents.htm
l, 2000.

Proceedings of the Information Visualization (IV’06)
0-7695-2602-0/06 $20.00 © 2006

IEEE


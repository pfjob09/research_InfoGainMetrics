MPLS Multicasting Using Caterpillars and a Graceful Labelling Scheme
Ayhan Basak
European University of Lefke
Basak@lefke.edu.tr
Abstract. In this paper we describe MPLS (Multi Protocol Label Switching) multicasting
under a specific graph (graceful) labeling with the use of the specific multicast tree
topology called caterpillar. The use of a caterpillar as the multicast tree is analyzed and
compared with the other tree topologies under a multicast network metric. The labeling
algorithm proposed uniquely assigns link labels based on the node numbering which in turn
enables to give a sharp estimate to the time-to-live parameter and assists in choosing
optimal selection of rendezvous points. The graceful code for the caterpillar has revealed an
efficient method (G-trace) of the reconstruction of multicast tree topology which in turn to
be used for maintainability and for the other purposes in the management site.
1. INTRODUCTION
IP multicasting has attracted considerable interest
from industry due to the vast number of
applications that require distributing information
through the internet in a one-to-many or many-tomany fashion. There exist many outstanding
complexity (scalability) and maintainability issues
of the multicast tree in the IP multicasting. The
situation is not clear at all in the Quality if Service
(QoS) assured MPLS (Multi Protocol Label
Switching) multicasting routing except a few
propositions and results, see for example [7], [14],
and [19]. The evolution of the multicast techniques
has been given in [2].
In this paper we describe MPLS multicasting
under specific graph (graceful) labeling with the
use of the caterpillar multicast tree topology. A
caterpillar is the next highest topological structure
from a path, the central concept in IP unicast
routing. The use of a caterpillar as the multicast tree
is analyzed and compared with the other tree
topologies under the multicast network metric
given in [5]. We have applied graceful label
distributions to the links of the spanning caterpillars
associated to the autonomous sub-networks (AN)
that involved in the multicasting. The labeling
algorithm proposed uniquely assigns link labels
based on the node numbering which in turn enables
to give a sharp estimate to the time-to-live
parameter. It also aids in selection of optimal
rendezvous points in the caterpillar topology to
nodes in the ANs by transmitting ‘graceful codes’
in the form of a sequence of (n-2) node numbers.
In Section 2 of the paper we give an overview
of multicasting on spanning trees and related
protocols followed by the graceful label numbering
of the spanning caterpillars with special reference
to the TTL (Time-To-Live) values and RP
(Rendezvous Points). We have also discuss the
application of the numbering algorithm for the
network consisted of several subnetworks together

with the application of the graceful codes to inform the
topology of the spanning caterpillars among the
backbone path. The graceful code for the caterpillar
has revealed an efficient method (G-trace) of the reconstruction of multicast tree topology which in turn to
be used for maintainability and for the other purposes
in the management site.
2. BACKGROUND
For efficient transmission, designated routers usually
construct a spanning tree that connects all members of
an IP Multicast group.
A spanning tree has just
enough connectivity so that there is only one path
between every pair of routers, and it is loop-free. If
each router knows which of its lines belong to the
spanning tree, it can copy an incoming multicast
datagram onto all of its outgoing branches, generating
only the minimum needed number of copies. Finding a
specific spanning tree (such as Steiner tree [13])
satisfying one or several network metrics on its nodes
or links efficiently is a major problem from the point
of scalability, see [6], [7] or [19], for example.
Messages are replicated only when the tree branches,
thus minimizing the number of copies of the messages
that are transmitted through the network. Since
multicast groups are dynamic, with members joining or
leaving a group at any time, the spanning tree must be
dynamically updated. Branches in which no listeners
exist must be discarded (pruned). A router selects a
spanning tree based on the network layer source
address of a multicast packet, and prunes that spanning
tree based on the network layer destination address.
The spanning algorithm used and how multicast
routers interact depends on the objectives of the
routing protocol. Several IP Multicast routing
algorithms and protocols have been designed with
different objectives and features.
2.1 Approaches to IP Multicast Routing
IP Multicast routing algorithms and protocols
generally follow one of two basic approaches,

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

depending on the distribution of multicast group
members throughout the network. The first
approach, dense-mode, is based on the assumption
that the multicast group members are densely
distributed throughout the network and bandwidth
is plentiful. Such routing protocols rely on periodic
flooding of the network with multicast traffic to set
up and maintain the spanning tree. Dense-mode
routing protocols include Distance Vector Multicast
Routing Protocol (DVMRP), Multicast Open
Shortest Path First (MOSPF), and ProtocolIndependent Multicast - Dense Mode (PIM-DM).
The second approach to multicast routing is
based on the assumption that the multicast group
members are sparsely distributed throughout the
network and bandwidth is not necessarily widely
available, for example across many regions of the
Internet. It is important to note that sparse-mode
does not imply that the group has a few members,
just that they are widely dispersed. In this case,
flooding would unnecessarily waste network
bandwidth and hence could cause serious
performance problems. Hence, sparse-mode
multicast routing protocols must rely on more
selective techniques to set up and maintain
multicast trees. Sparse-mode routing protocols
include Core Based Trees (CBT) and ProtocolIndependent Multicast - Sparse Mode (PIM-SM).
There are a number of novel protocols
presently being developed by the Internet
community, IETF working groups and industry
vendors to support new applications of IP
Multicast. Only a brief introduction is possible
here. RTP, the Real-Time Transport Protocol,
provides end-to-end network transport functions
suitable for applications transmitting real-time data,
such as audio, video or simulation data, over
multicast or unicast network services. RSVP, the
ReSerVation Protocol, enhances the current
Internet architecture with support requests for a
specific quality of service from the network for
particular data streams or flows. RTSP, the RealTime Streaming Protocol is an application-level
protocol for control over the delivery of data with
real-time properties to enable controlled, ondemand delivery of real-time data, such as audio
and video.
3. A METRIC FOR MULTICAST TREES
In general the primary benefit of using multicast is
its scalability in terms of required resources per
receiver. However, defining a quantifiable metric
for the benefits of multicast over unicast was
largely overlooked until the work of Chalmers and
Almeroth in 2000, [5]. They define a simple metric
as a function of the ratio of multicast hops (links) to
unicast hops:

' 1

multicast hops
unicast hops

The multicast metric will be a fraction in the
range 0d'<1 . When ' = 0, there is no benefit of

multicast over unicast. As the value approaches one
however, the benefit of using multicast increases. As
our multicast tree is always a caterpillar tree that
consists of a backbone path and links attached to the
backbone nodes, for a given AN with n nodes the
length of the backbone path of the multicast caterpillar
would be dominate on the value of the metric. In case
where ' = 0, the topology of the multicast tree looks
like a Hamiltonian path, a path which traverses all the
nodes in the AN only once. This unicast-like covering
all nodes may be desirable in cases where the
subnetwork comprises optical nodes, since this reduces
complexity of the internal structure of the nodes. On
the other hand the benefits of the short backbone path
of the multicast spanning caterpillar is apparent from
the point of small average link delay.
3.1 The Role of Time-To-Live (TTL)
Each IP Multicast packet uses the time-to-live (TTL)
field of the IP header as a scope-limiting parameter.
The TTL field controls the number of hops that a IP
Multicast packet is allowed to propagate. Each time a
router forwards a packet, its TTL is decremented. A
multicast packet whose TTL has expired (is 0) is
dropped, without an error notification to the sender.
This mechanism prevents messages from needless
transmission to regions of the Internet that lie beyond
the subnets containing the multicast group members.
A local network multicast reaches all
immediately-neighboring members of the destination
host group (the IP TTL is 1 by default). If a multicast
datagram has a TTL greater than 1, the multicast
router(s) attached to the local network take
responsibility for internetwork forwarding. The
datagram is forwarded to other networks that have
members of the destination group. On those other
member networks that are reachable within the IP
time-to-live, an attached multicast router completes
delivery by transmitting the datagram as a local
multicast. TTL thresholds in multicast routers prevent
datagrams with less than a certain TTL from traversing
certain subnets. This can provide a convenient
mechanism for confining multicast traffic to within
campus or enterprise networks. Several standard
settings for TTL are specified for the MBONE: 1 for
local net, 15 for site, 63 for region and 127 for world.
Since we know the size of each AN and by
establishing the spanning caterpillar covering all the
nodes of the AN we can exactly find the value of the
TTL, TTL= |the length of the backbone path of the
spanning caterpillar| +1.
4. GRACEFUL LABELING ALGORITHM
We define a caterpillar to be a tree T that contains a
dominating (backbone) path P such that T-V(P)
contains no links. A spanning caterpillar is a
caterpillar, denoted by TS, if it contains all n nodes of
the network N. Construction of a spanning caterpillar
which will carry multicast packets from the source
node S will be based on a selected single network
metric for its backbone path P of Ts. It is well known
that path computation algorithms (e.g., OSPF) with a

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

single metric such as delay and hop-count are
widely used in most current IP networks. For
purposes herein (with local selection with respect to
the links connected to a node), the network metric
is chosen as the minimum delay į for each
backbone link of the spanning caterpillar. Note that
the selection of minimum delay į at the current
node in the MPLS graceful numbering is a concave
network function at the node nk,

Let V(T)={v1, v2, …, vn} be the set of nodes of
caterpillar tree T. Let Li stand for the nodes of hoplevel, 1d i d j < n and N = {1, 2, …, n}. Further let
vp(i) denote the node labeled by i  N, and N(Li)
the subset of integers formed by deleting all
integers from N which have been used in labeling
the nodes of level Li. We can now present the
algorithm for graceful numbering of a caterpillar.
Step 1. Label the source node S, which is the first
node of the backbone path of the caterpillar, by the
integer 1. Remove the integer 1 from the set N and
call it N(L1).
Step 2. Consider ~L2~ nodes of the hop-level L2.
Take up the largest ~L2~ integers from N(L1).
Number the node v2~L2~ (the node on the backbone
path) with the minimum of these integers. Next
number the remaining nodes of L2 arbitrarily with
the other integers. Remove the integers used from
N(L1) and call the resulting set N(L1  L2).
Step 3. Consider the ~L3~ nodes of the hop-level
L3. Take up the ~L3~ smallest integers from N(L1 
L2). Number the node v3~L3~ (the node on the
backbone path) with the maximum of these
integers. The remaining nodes of L3 are then
arbitrarily numbered by the other integers.
Step 4. Repeat the similar process of numbering the
nodes in other levels, alternating, first like Step 2
and then like Step 3.
Step 5. If all nodes of the caterpillar T have been
numbered, then terminate the algorithm.
In the above algorithm the induced link labels
are taken as the absolute node numbers differences
among the adjacent nodes which are distinct
integers from the set N = {1, 2, …, n-1} [4]
however the algorithm can equally be applied to m,
m<n nodes to cover a caterpillar for multicasting on
a subset of nodes of the network. While in [4], it is
proved that any caterpillar topology can be
gracefully numbered, it is an open problem to
determine a caterpillar, if exists, on a given m
(multicast) nodes. These labels then, are to be
generated by the initiating node and assigned to the
links in the multicasting caterpillar such that if the
link corresponds to the hair edge, i.e., the link of
the caterpillar which has degree one node at the one
end, then no computation is needed for minimum
delay assignment. If the link corresponds to the

backbone path P then that link is to be selected as the
minimum link delay among the links connected to the
current node. Clearly, the above algorithm with these
properties can generate a spanning multicast caterpillar
of the network. An interesting point in the above
labeling is that, once the current node is numbered, the
labels of links connected to the node can be assigned
by that node, where the other neighbour node number
assignments are automatically and uniquely generated
(see Fig. 1). In Fig. 1 nodes numbered with 16, 3, 12,
5, 9 are the backbone nodes of the spanning caterpillar
which its links can be chosen with respect to the local
minimum link delays. Similarly nodes numbered with
{1,2}{13,14,15}{4}{10,11}{6,7,8} are the leaf
nodes of the spanning caterpillar. Link labels which are
generated uniquely as an outcome of node numbering
and distributed by the backbone nodes in the direction
arrows point in the figure.

Fig. 1: Multi-casting in MPLS over a spanning
caterpillar by using graceful numbering.
In the above algorithm, the labeled spanning
caterpillar is created based with the longest backbone
path, which may not always be desirable in
multicasting. Hence, the algorithm can be modified in
such a way that in the first phase a minimum length
path is found and in the second phase the uncovered
nodes are reached through the nodes of the shortest
path. However in this case, in order to assure that the
resulting multicast spanning tree is a caterpillar, the
neighborhood of every backbone node along the path
has to be searched locally.
4.2 Link Labeling and Placement of the RPs
Let us assume that the network N consists of k
autonomous sub-networks AN1, AN2, ..., ANk
respectively with n1, n2,..., nk nodes. Consider the node
S in AN1 which is multicasting to the other nodes in N.
The network N = AN1AN2...ANk alone, may not
have single spanning caterpillar in which S is a leaf
node. In this case, although there exists a graceful
labeling we cannot guarantee that the source node label
would be the smallest label, 1. In this case we label
the nodes of N as follows:
• For each i, 1 d i d k, label the nodes of ANi gracefully
by using the labels {1, 2, ..., ni} for i = 1, 2, ..., k.
• In order to distinguish the induced link labels in the
whole network N, put the sub-network index ‘i’ as the
most significant digit (MSD) to the link labels of each
sub-networks ANi. This ensures the uniqueness of link

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

labels in the network N. That is if f(x,y) is the link
label of ANi then f(x,y)= {i j}, where j = |f(x) - f(y)|.
An example of such labeling is illustrated in
the network shown in Figure 2.

Fig 2. Gracefully labeled spanning caterpillars
in the subnetwork.
Another important issue is the concept of the
RP (Rendezvous Point) in the PIM-SM protocol.
PIM-SM requires at least one RP per domain (subnetwork) to function. Initially, receivers do not
need to know the location of a source to function as
the address of the RP is distributed throughout the
domain. When a receiver wants to join a group G
(AN) it sends a IGMP member report to its first
router (node), which sends a (*,G) join to the RP.
Similarly, when a source wants to begin
transmitting to group, its DR (Designated Router)
encapsulates and unicasts the multicast data to the
RP, which strips off the encapsulation and multicast
it to the group members (if any). It can easily be
seen that in our model of multicast tree all these
functions take place on the backbone path of the
spanning path. Therefore the selection or placement
of the RP points for each AN and spanning
caterpillar is important. The problem, in general,
under various other criteria of reliability,
connectivity etc., is a difficult combinatorial graph
optimization problem [11]. However since the
topology of the multicast tree is a caterpillar we can
easily select a central node of the backbone path of
caterpillar as the RP. For example in the Fig. 1 the
node labeled by 12 is selected as a RP which is
located in the middle of the backbone path
{16,3,12,5,9}. In this way average distance of the
data flows dictated by the protocol above (PIMSM) would be minimized.
We now address the problem of how to inform
an RP in one domain that there are sources in other
domains. There is no mechanism to connect the
various intra-domin multicast trees together. This
problem can be resolved by the use of graceful
labeling in each domains and extended the labeling
by the use the domain index (AN number), to the
other nodes of the other domains. Furthermore we

can transmit the G-code of one domain to another
domain (and vice versa) to inform the detailed tree
topology and the location of a RP points. For example
in Fig. 2 for subnetwork AN1, node labeled by 8 is RP1
and node labeled by 6 is MBGR (Multicast-Capable
Border Router). Similarly nodes labeled by 1 and 6 are
the MBGRs of AN2. Again node labeled by 1 in AN3 is
another MBGR. RPs of AN2, and AN3 are the nodes
labeled by 3 and 4 respectively. G-codes for each
multicast caterpillar can be exchanged among the
domains.
4.3 Joining and Leaving Multicast Groups
A computer joins a multicast group by sending an
Internet Group Management Protocol (IGMP)
membership report message. IGMP is common to all
multicast router protocols - it isolates end users from
the routing protocol in use. IGMP packets are always
sent with a TTL of 1, and are not supposed to be
forwarded. Join latencies are typically very short, a
few seconds at most. The latest IGMP version allows
specific (S, G) joins and leaves, through addition of
source specific include reports, so that it will be
possible to join a specific source of a specific group
directly [3].
In this subsection we describe a simple renumbering algorithm for the nodes of a given multicast
caterpillar tree when a new node wishes to join to the
multicast group (MG). Let us first classify the node
labels in a graceful numbering of a caterpillar tree as:
Small Label {SL} = {f(v)N ~ 1df(v) d n/2}
Big Label {BL} = {f(v)N ~ n/2 + 1df(v) d n}
Where n is the number of the nodes in the
caterpillar tree Cn. Assume that a new node vn+1 wishes
to join a multicast group which is represented by the
labelled multicast caterpillar Cn, that is an addition of
the link (vn+1, vb). Hence the multicast tree becomes
Cn+1 = Cn  (vn+1, vb), and we relabel the nodes as:
Case (a): f(vb){BL}
• Label the NEW node vn+1 as f(vn+1) = max {f(vi)} + 1
such that (vi, vb) is a network link.
• Re-label the existing nodes of Cn by
(1) Add 1 to all of the labels of the up-stream
nodes of vb.
(2) Add 1 to all big labels of the down-stream
nodes of vb.
(3) All other node labels remain unchanged.
Case (b): f(vb){SL}
• Label the NEW node vn+1 as f(vn+1) = max {f(vi)}
such that (vi, vb) is a network link.
• Re-label the existing nodes of Cn by
(1) Add 1 to all of the labels of the down-stream
nodes of vb.
(2) All other node labels remain unchanged.
It can be seen that in the above re-labeling, the new
multicast tree has been gracefully labeled and the new
node vn+1 joined to the multicast group. The leave

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

operation can be performed in a similar manner, by
just subtracting 1 from the appropriate node labels
as in the two cases above. The advantage of using
this simple re-labeling in these operations is that,
there is no need to use rather complicate timers as
in IGMPv3 protocol which controlling suggest to
forward traffic from source in the group FilterMode INCLUDE and EXCLUDE [3].
4.4 Graceful Codes for Topology Discovery
In the literature, for a simplified model there are a
few tools to effectively determine the multicast tree
and subsequently the multicast and unicast hops.
For example Mtrace [10] has been used to perform
traces from each receiver back to a given source
and from this data a graphical representation of the
multicast tree is constructed and consequently the
hop counts can be computed. A topology discovery
approach for a multicast tree named ‘Tracetree’ has
been given by Saraç and Almeroth in [17].
One of the important issues in multicasting is
that the structure of the multicast tree formed at the
RPs in each AN must be known by the source and
the other RPs. In this section we will use again the
property of the graceful labeling of the spanning
caterpillar and give a very efficient code of n-2
integers which describes uniquely the topology
discovery of each spanning multicast caterpillar.
Graceful codes for general trees are based upon the
Prufer-like code presented in [8]. It relies on the
property that a tree is an acyclic connected graph.
Moreover graceful code takes advantage of the fact
that edge-labels of a gracefully-labeled tree on n
nodes are 1, ..., n-1. Also note that any gracefullylabeled tree must contain an edge (1,n), as this is
the only edge that has label n-1.

Definition: The graceful code for an n-node tree T,
GC(T), is an (n-2)-tuple of node labels. The kth label in
the code, denoted by GC(T)k, is min(u,v), where
(u,v)E(T), |f(u)-f(v)|=k, and 1 d k d n-2.
Thus, for the links with labels 1 to n-2 of the
gracefully labeled spanning caterpillar, Ci  ANi, the
end-node with the smaller label is recorded. The link
with label (n-1) is implied as described above. For
general trees it is not the case that a graceful code
uniquely identifies a tree, but for the caterpillar tree
uniqueness is guaranteed. Hence once the spanning
caterpillar has been labeled the corresponding graceful
code constructed and be sent to the step-by-step from
the last node in the backbone path of the caterpillars to
the other nodes for re-construction and maintainability
purposes.
In Table 1 graceful codes for spanning
caterpillars Ci of sub-network ANi, i = 1,2,3 have been
given. In Fig. 3 we have shown graphically the use of
graceful code (G-trace or G-code) in the course of treetopology (caterpillar) discovery together with the some
of the other known tree trace methods [18].
Link
label
Label
deleted
GC(C1)

11 12 13 14 15 16 17 18 19 110 111
6

7

8

8

8

9

10 11 12 12

12

5

5

5

4

3

3

3

1

3

3

2

Link
21 22 23 24 25 26 27 28 29 210 211 212 213
label
Label 7 8 8 8 9 9 10 11 12 13 14 14 14
deleted
GC(C2) 6 6 5 4 4 3 3 3 3 3
3
2
1
Link
label
Label
deleted
GC(C3)

31 32 33 34 35 36 37 38 39 310
7

8

8

8

9 10 11 11 11 11

6

6

5

4

4 4

4

3

2 1

Table 1: Graceful codes for ANs of Fig.3

Fig. 3. Topology discovery techniques

The metric used in [18] for comparsions were the
processing overhead put on the routers (nodes), the
messaging overhead on the management site and the
topology discovery time i.e., the time needed to
discover the topology. Fig. 3, except (d), shows the
generic operation of each techniques and the amount of
router overhead (in terms of number of visits to
routers) and the amount of messaging overhead on the
management site. The numbers with the nodes
(Fig.3(a)-(c)) show the number of visits to the routers
and the numbers associated with links show when
more than one message is sent to the management site.
However the proposed G-trace works on this example
as follows:
• Querier sends [1,5] the interval for node labels for the
caterpillar tree, where the label 1 is the smallest and 5
is the size of the caterpillar.
• Downward arrows show the propagation of the node
labels towards the leaf nodes.

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

• Upward arrows (shown by dotted line in the
figure) show accumulation of partial graceful codes
which results in the G-code [3,2,1].
• The multicast caterpillar topology is extracted
very easily from the G-code [3,2,1] as {(3,4=3+1),
(2,4=2+2), (1,4=1+3), (1,5)}, where the underlined
numbers indicate the induced link labels in the
graceful labeling. As before since the label 5 is the
maximum node label in the numbering there is no
need to use the link label 4 in the computation Gcode. By considering rather complicated other tree
trace tools as described in [18], the advantages of
using multicast caterpillars and G-code outlined
here would be apparent. The router overhead is
only sending a single digit to its neighbors and
receiving sequence of no more than n digits
(indicating the partial or complete G-code). In the
management site (the source in the caterpillar tree)
the complexity of re-constructing the tree topology
is O(n-2) which can be performed in parallel.
5. CONCLUSIONS AND FURTHER WORK
The use of caterpillar as the multicast tree has been
analyzed and compared with the other tree
topologies. We have applied graceful label
distributions to the autonomous sub-networks (AN)
that involved in the multicasting. The labeling
algorithm proposed uniquely assigns link labels
enabling a sharp estimate to the time-to-live
parameter and the optimal selection of RP
(rendezvous points) by transmitting a ‘graceful
code’ in the form of sequence of (n-2) node
numbers. Although the multicast technique given in
this work is based on the special label switching
and is topology constrained (and driven) future
work can include the simulation of this technique
on large networks, a more detailed analysis of
multi-domain networks.
6. REFERENCES
[1] A. Acharya, F. Griffoul, F. Ansari,’IP Multicast
Support in MPLS Networks’, draft-acharyaipsofacto-mpls-00.txt, February 1999.
[2] K.C. Almeroth, ‘The Evolution of Multicast:
From the Mbone to Inter-Domain Multicast to
Internet2 Deployment’, IEEE Network, Jan./Feb.
2000.
[3] B. Cain, S. Deering, B. Fenner, J. Kouvelas, A.
Thyagarajan, ‘Internet Group Management
Protocol, Version 3’, <draft-ietf-idmr-igmp-v309.txt>, 2002
[4] I. Cahit and R. Cahit, ‘On the Graceful
Numbering of Spanning Trees’, Information
Processing Letters, 3(4), March 1975, pp. 115-118.
[5] R.C. Chalmers and K.C. Almeroth, “Developing
a multicast metric”,Proc. of IEEE, Globecom2000,
San Fransisco, Calif., December 2000.
[6] S. Chen and J. Crowcroft, ’Building Shared
Trees Using a One-to-Many Joining Mechanism’,
Computer Communication Review, 1997.

[7] S. Chen, K. Nahrstedt and Y. Shavitt, ‘A QoSAware Multicast Routing Protocol’, INFOCOM 2000.
[8] N. Deo, P. Micikevicius, ‘Prüfer-Like Tree Codes:
Their Properties and Parallel Computation’, Invited
Talk, FH80 Conference, Illinois Institute of
Technology, Illinois, November 2, 2001.
[9] H. Eriksson, ‘The Multicast Backbone’,
Communications of the ACM, vol.8, 1994.
[10] W. Fenner and S. Casner, ‘A “traceroute” Facility
for IP Multicast’, IETF, <draft-ietf-idmr-tracerouteipm-*.txt>, Work in Progress.
[11] M.R. Garey and D.S. Johnson, ‘Computers and
Intractability, A Guide to the Theory of NPCompleteness’, Freeman, San Francisco, 1979.
[12] C. Huitema, ‘Routing in the Internet’, Prentice
Hall 2000.
[13] F.K. Hwang, D.S. Richards, P. Winter,’The
Steiner Tree Problem’, North-Holland, 1985.
[14] F. Kuipers, P. Van Mieghem,’MAMCRA: A
Constrained-Based Multicast Routing Algorithm’,
Computer Communications, vol. 25, no. 8, 2001.
[15] D. Ooms, W. Livens, B. Sales, M. Ramahlo,
‘Framework for IP Multicast in MPLS’, draft-oomsmpls-multicast-01.txt, February 1999.
[16] E. Rosen, A. Viswanathan, A. Callon,
‘Multiprotocol Label Switching Architecture’, draftietf-mpls-arch-05.txt, April 1999.
[17] K. Saraç and K.C. Almeroth, ‘Tracetree: A
Scalable Mechanism to Discover Multicast Tree
Topologies in the Network’, submitted to ACM/IEEE
Transactions on Networking.
[18] K. Saraç and K.C. Almeroth, ‘Scalable
Techniques for Discovering Multicast Tree Topology’,
International Workshop on Network and Operating
System Support for Digital Audio and Video
(NOSSDAV), 2001.
[19] P. Van Mieghem, G. Hooghiemstra, R. Van der
Hofstad, ‘On the Efficiency of Multicast”, IEEE/ACM
Transactions on Networking, vol. 9, No. 6, 2001.
[20] D. Waitzman, C. Partridge, ‘Distance Vector
Multicast Routing Protocol’, RFC 1075, November
1988.

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE


Human Hand Model based on Rigid Body
Dynamics
ˇ
Roman Durikoviˇ
c
and Katsuhiro Numata
Software Department, The University of Aizu
Tsuruga, Ikki-machi, Aizu-Wakamatsu City, 965-8580 Japan
Email: roman@u-aizu.ac.jp

Abstract— In this paper, a method for dynamics simulation of
articulated multi rigid body system is presented. We simulate
a model of a hand, using constraints to express joints, motors
and contacts between the bodies. The basic ideas of rigid body
simulation and constraints are explained. Using contacts as a
signal for motors, we create a physically valid motion of the
hand model.

I. I NTRODUCTION
The physically based dynamics simulation can synthesize
very realistic motions. For this reason, it plays important
role in computer graphics area, such as computer animation,
virtual reality and computer aided design. Though rigid-body
dynamics is a foundational technique of physically based
simulation, there are not many applications. One reason for
its small popularization is its computational expensiveness, the
other reason is that there are scattering paradigms for dynamics
simulation.
Roughly, current simulation methods for rigid multibody systems with frictional contacts are classified into
several groups, penalty-based method [1], constraint-based
method [1], impulse-based method [2] and so on. Each method
has strengths and limitations. The method we propose is based
on constraints. A constraint is a restriction on the way the
bodies are permitted to move. Generally, a constraint works as
a joint between two bodies. In this approach, it also describes
a contact between two bodies. Specifically, we use velocity
based constraint which allows us to treat joints, collisions
and resting contacts uniformly. Constraint equations are transformed to the Linear Complementarity Problem (LPC) which
is a standard problem of quadratic programming summarized
in a book by Coutinho [3].
Applying this method, we create the motions of an articulated hand with frictional contacts. The human hand has an
articulated structure with many degrees of freedom. It becomes
a slightly-difficult task to make the motion, only for grasping
something. We use bodies’ contacts as signals for “motors”
attached to joints to generate motions semi-automatically. It is
also physically accurate, therefore it is applicable not only for
animation but also virtual reality and robotics.
II. DYNAMICS OF R IGID B ODIES
We consider a rigid body, a body which has fixed shape
and density. The behavior of the rigid body is described by

first order ordinary differential equation (ODE) [1]. To obtain
its numerical solutions, we use Euler’s method, the simplest
method to solve ODEs. In this method, if we know the state
of the body and its time derivative, at any instance, t, we can
derive the system’s state after a short period of time, t + ∆t.
A. Rigid Body Equations of Motion
A state of a rigid body can be defined by position of its
center of mass x (t), orientation matrix R (t), linear momentum
P (t) and angular momentum L (t). Therefore we can describe
a state of a body by a vector X (t),


x (t)
 R (t) 

X (t) = 
 P (t)  .
L (t)
At any instant, we can compute the auxiliary quantities,
inertia tensor I , angular velocity ω and linear velocity v as
I (t) = R (t)II 0R T (t),
L(t),
ω (t) = I −1 (t)L
v = P (t)/M,
where I 0 is body-space inertia tensor and M is the mass of
the body.
Then the time derivative of X (t) is defined by


v (t)
 ω (t)∗R (t) 
d
,
X (t) = 


F (t)
dt
τ (t)
where F and τ are total force and torque acting on the body,
respectively. Given the 3-vector, ω = (ωx , ωy , ωz )T we define
the dual of the vector to be the antisymmetric matrix ω ∗ ,


0
−ωz ωy
0
−ωx  .
(1)
ω ∗ =  ωz
−ωy ωx
0
B. Second Form
Though the above equations are in the most standard form,
d
we can directly write dt
v (t) = FM(t) on linear components.
Because linear velocity is conserved in nature, i.e. it does not
change without applied external forces. On the other hand,

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

angular velocity is not conserved, it can change sequentially
while angular momentum is constant. The time derivative of
ω (t) is
d
ω (t)×ω
ω (t) + τ (t)).
ω (t) = I −1 (t)(II (t)ω
dt
Therefore, if we define a body’s state as


x (t)
 R (t) 

S (t) = 
 v (t)  ,
ω (t)
its time derivative is


d
S (t) = 

dt



v (t)

ω (t)∗R (t)
.

F (t)/M
ω (t)×ω
ω (t) + τ (t))
I −1 (t)(II (t)ω

Our method is based on this form of state vector. For impleω (t)×ω
ω (t) to the total torque,
mentation, we need adding I (t)ω
τ (t).
From the above equations, if we know the total force and
torque acting on a body, they yield the derivative of the state
vector. Sequentially, we can calculate the next state of the
body.
C. Global Equations
In the multi-body case, we would like to consider the
system globally, rather than considering each body in the
system. Therefore, the multi body system state looks like a
point in high-dimensional space. We concatenate positions and
rotations of all bodies into a single vector p , similarly linear
and angular velocity into a vector q , forces and torques acting
on the bodies into a vector Q ,
p (t)

x1 (t), R 1 (t), x 2 (t), R 2 (t), . . .)T ,
= (x

q (t)

=

T
(vv 1 (t), ω 1 (t), v 2 (t), ω 2 (t), . . .) .

Q (t)

=

F 1 (t), τ 1 (t), F 2 (t), τ 2 (t), . . .)T ,
(F

where a subscript i corresponds to the ith body’s state. And,
we need to deal with the masses and inertias of all bodies, we
define the inverse of global mass matrix as W ,


0
0
0
M1−1
−1
 0
I 1 (t)
0
0
... 


−1

 0
0
0
M2


−1
W (t) =  0
.
0
0
I 2 (t)



 0
0
0
0


..
..
.
.
Now, we can calculate the linear and angular acceleration of
all bodies in the global form,
d
q (t) = W (t)Q
Q(t).
dt
Finally, q (qq ) is defined to calculate the time derivative of p (t),
d
p (t) = q (qq (t))
dt
R 1 (t), v 2 (t), ω 2 (t)∗R 2 (t), . . .)T .
= (vv 1 (t), ω ∗1 (t)R

D. Numerical Method
For numerical simulations, p (t) is evaluated at each discrete
time steps and p (t + ∆t) is calculated by some approximation
methods. In Euler method, the p (t) changes linearly in the
direction of its time derivative,
d
p (t)∆t
dt
= p (t) + q (qq (t))∆t,
d
q (t + ∆t) = q (t) + q (t)∆t
dt
Q(t)∆t.
= q (t) + W (t)Q

p (t + ∆t)

= p (t) +

(2)
(3)
(4)
(5)

If ∆t is small enough, we can use q (t+∆t) instead of q (t). In
the simulation step, a new linear and angular velocity, q (t+∆t)
is calculated, then a new position and orientation, p (t + ∆t) is
calculated from the new velocities, q (t + ∆t). In this way, if a
force is applied to a body, the body starts to move immediately,
not at the next time step.
The typical steps of the simulation are:
1. Calculate total forces and torques acting on all bodies, Q .
ω i for each torque component of Q .
2. Add I iω i ×ω
3. Update the system’s velocity, q .
4. Update the system’s position, p .
III. C ONSTRAINT
A constraint allows us to restrict a body’s motion. If a rod
is hooked on a nail, it can be simulated by a constraint. The
constraint will connect a point on a rod with a point in a space.
Such a constraint usually works as a joint between two bodies.
Generally, a constraint applies force and torque to the bodies
to make the bodies fit the constraint. They are called constraint
force and torque in distinction from external force and torque.
Constraint force and torque have to be calculated after external
force and torque are supplied to the system because the
constraint have to cancel the un-permitted motions of the body
which will be caused by the external force and torque.
A. Lagrange Multiplier Velocity Based Scheme
Let us consider constraint between two bodies for simplicity.
In our method, all constraints are expressed in terms of the
velocity, i.e. first derivative of the state vector. It allows
constraints to achieve desired velocities directly, rather than
indirectly using the accelerations. Further, this scheme makes
constraint equations simpler to derive, and makes simulation
more stable for a time stepping scheme. Every constraint is
expressed by following equations,
J 1v 1 + Ω 1ω 1 + J 2v 2 + Ω 2ω 2
λl
λl

= c l + C lλ l ,
≥ ll,
≤ hl,

where the first equation has m rows. v 1 , ω 1 , v 2 and ω 2 are
3 × 1 linear and angular velocities of two constrained bodies,
respectively. J 1 , Ω 1 , J 2 and Ω 2 are m×3 Jacobian matrices,
the differentiations of constraint deviation with respect to the
body’s velocities. c l is an m×1 ”right hand side vector” and

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

C l is an m×m diagonal matrix called the ”Constraint Force
Mixing” (CFM). λ l is unknown m×1 vector which determines
the strength of the constraint force and torque. Having solved
for λ l , the constraint force and torque on each body are J T1 λ l ,
Ω T1 λ l , J T2 λ l , Ω T2 λ l , respectively.
The significant features of these equations are that the first
equation has the units of velocity, and the unknown λ l has
lower and upper bounds. Exploiting these features straightforwardly, a constraint can have a “motor”. We can specify,
for example, angular or linear relative velocity between two
bodies by c l , and we can set maximum force or torque by h l
and l l , respectively.
B. Constraint Examples
We use several simple constraints in this research. They are
point constraint, hinge constraint, slider constraint, fixed constraint, and contact constraint. A simple mechanical demonstration of some constraints is shown in Fig. 1.

a 2 are the vectors from the each body’s center of mass to
the connected point, see Fig. 2. Therefore, we can derive the
constraint equation as follows,
a1
v 1 + ω 1 ×a
∗
v 1 + ω 1a 1
v 1 − a∗1 ω 1

a2 ,
= v 2 + ω 2 ×a
∗
= v 2 + ω 2a 2 ,
= v 2 − a∗2 ω 2 .

Finally,
1v 1 − a ∗1ω 1 − 1v 2 + a ∗2ω 2

= 0.

a ∗1 , ω ∗1 , a ∗2 and ω ∗2 are defined in Eq. 1. So simply we have
a∗1 , J 2 = −11 and Ω 2 = a ∗2 . Since there are no
J 1 = 1 , Ω 1 = −a
limits on the constraint force, and the constraint’s condition
∞,
is independent to the constraint force, we have l l = −∞
h l = ∞ and C l = 0 . Finally, we make c l proportional to the
positional error between two connected points,
cl =

((pp2 + a 2 ) − (pp1 + a 1 ))
,
s

where s is time step and is a constant within a range of 0
to 1. Definition of c l in this way will reduce the joint error
caused by numerical drifts. When the two connected points
come away, it sets their velocities so that they move closer to
each other. The damping constant controls how quickly the
joint error is reduced.
D. Global Constraint Equations
Constraints between two bodies within the system can be
collected into a global constraint equation with the form,
Fig. 1.

Jq
λ
λ

Example of Constraints

C. Point Constraint

= c + C λ,
≥ l,
≤ h.

(6)
(7)
(8)

The global Jacobian matrix J is composed of block matrices
given by two-body constraints related to linear and angular
velocities. Each row of the first equation removes one degree
of freedom from the system. The components of λ are known
as Lagrange multipliers. And, global constraint force is given
by J T λ . We can think of each row of J as the system’s
constrained direction and J T λ as their linear combination
controlling the velocities in those directions.
E. Solving Constraint Equations

Fig. 2.

Point Constraint

For example, a point constraint makes each point on two
bodies connected. In other words, this constraint makes velocities of two points identical. The velocities of two points
a1 and v˜2 = v 2 + ω 2 ×a
a2 , where a 1 and
are v˜1 = v 1 + ω 1 ×a

Our objective is to obtain a solution for constraint equations
at the end of each time step. That is, the constraint equations
are evaluated with the system’s velocity at the next time step,
q (t + ∆t). The force acting on the system is separated into
external force and constraint force. We write external force as
˜ , therefore we can write Q = Q
˜ + J T λ . Substituting Eq. 5
Q
into global constraint equation, Eq. 6 gives,

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

˜ + J T λ )∆t) = c + C λ
J (qq + W (Q
(9)
C
c
q
˜ ).(10)
JW J T −
λ =
(J
)λ
−J(
+WQ
∆t
∆t
∆t

To solve the Eq. 10 for unknown λ that satisfies Eq. 7 and
Eq. 8, we can rewrite them in the form,
Aλ = b + γ ,

(11)

where,
C
JW J T −
A = (J
),
∆t
q
c
˜ ),
−J(
+WQ
b=
∆t
∆t
and unknown γ represents residuals. Each element of λ and
γ satisfies one of three possible cases:
λi = hi , γi ≤ 0
λi = li , γi ≥ 0
li ≤ λi ≤ hi , γi = 0

(12)
(13)
(14)

The Eq. 11 with two unknowns λ and γ can be solved by
Dantzig’s algorithm [3]. The algorithm divides the rows of
Eq. 11 into three groups, those with γi < 0, γi = 0 and
γi > 0. Then the intermediate solutions for the problem are
computed incrementally.
IV. I MPLEMENTATION
We simulated a model of a hand’s motion to pick up a ball
on a plane. The simulator was built on the Open Dynamics
Engine [4], and displays the model with OpenGL functions.

Hinge constraints connect parts of fingers. A slider constraint and a fixed constraint fix the hand and the plane in
the space. If bodies are contacted, the contact constraint is
created at contacted point when needed. As described above,
all constraint works by controlling the body’s angular and
linear velocity.
A sensor is a pseudo object that is associated with some
bodies and constraints. At each time step, the sensor checks
whether the bodies are in contact. Based on the sensor signals,
hand model switches the desired velocities of the constraints.
B. Response to Contacts
A body was assumed to contact with other objects at point
contacts. However, if bodies contact at a face, the contact face
is approximated by a few points from that face.
When a body touches another body, we check whether the
bodies are connected by a constraint. If there is no constraint
defined between them, the contact constraints are made at the
contacting points. The contact constraint controls the normal,
tangent and binormal components of relative velocity by the
coefficients of restitution and friction.
V. C ONCLUSION
We have described the modeling method of multi rigid body
system with velocity-based constraints. This scheme is fast
and stable for real time simulations. Using this method, we
simulated the motion of a model hand, demonstrated in Fig.
4. The motion and interaction between bodies are simulated
based on physical laws.
In cases where more accuracy is needed, we may need
another integration method rather than Euler method. The
frictional force is approximated by independent forces in two
directions, and there is no distinction between dynamic and
static frictions. These may be the first things that should be
improved for more accurate simulations.
R EFERENCES
[1] A. Witkin and D. Baraff, Physically Based Modelling. ACM SIGGRAPH
2001 Course Notes, 2001.
[2] D. Stewart and J. Trinkle, “An implicit time-stepping scheme for rigid
body dynamics with coulomb friction,” in IEEE Int’l Conf. on Robotics
and Automation, vol. 37, no. 1, 2000, pp. 162–169.
[3] M. G. Coutinho, Dynamics Simulations of Multibody Systems. New
York: Springer-Verlag, 2001, ch. The Linear-Complementarity Problem,
pp. 337–364.
[4] R. Smith. (2003) Open Dynamics Engine. [Online]. Available:
http://opende.sourceforge.net/

Fig. 3.

Model of Hand

A. Model of Hand
The model was created with primitive rigid bodies, such
as boxes and spheres. Each body has the properties needed
for dynamics calculation, position, rotation, linear and angular
velocities, mass and rotational inertia. Also, a geometric shape
was associated with each body. Then, constraints connect or
fix them. Several constraints work as not only joints, but also
motors between two bodies.

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE

Fig. 4.

A simulation of articulated hand’s model

Proceedings of the Eighth International Conference on Information Visualisation (IV’04)
1093-9547/04 $ 20.00 IEEE


12th International Conference Information Visualisation

RDF Query Generator∗
Jiˇr´ı Dokulil
Faculty of Mathematics and Physics,
Charles University, Prague, Czech Republic
dokulil@ksi.mff.cuni.cz

Jana Katreniakov´a
Faculty of Mathematics, Physics and Informatics,
Comenius University, Bratislava, Slovakia
katreniakova@dcs.fmph.uniba.sk

Abstract

handle querying of the data. The following text describes
what we have already done in that matter and what direction may further development take.

There have been many attempts to create software that
would allow the users to design SQL queries visually, even
though it is not very natural to handle relations and relational algebra (the theoretical background of SQL) this
way. But the RDF data format is based on directed labeled graphs, whose visual representation is very natural.
We have created an RDF visualizer and tried to extend it to
support query construction. It turned out that the nature of
current RDF query languages only allows some basic support but prevents creation of a more sophisticated system.
This articles describes our query generator and discusses
the limiting factors.

1

2

A common approach to RDF querying is to base it on
some kind of subgraph matching (for an example see the
SPARQL standard [5]). The idea is that the user provides a
pattern and the query engine tries to match a subset of the
queried data to the pattern.
Let us look a bit at the patterns. A pattern is usually an RDF graph (a labeled directed graph), except that
some of the nodes are replaced by variables. Then a match
is a mapping of the variables that transforms the pattern
into a subgraph of the queried data. This simple idea can
get more complicated as e.g. inferencing is added to the
process. That may change the problem of finding a subgraph into a more complicated task of finding a graph entailed by the data (for detail of entailment in RDF data
see [1]). But the more complex entailment rules (like
RDFS or OWL-DL entailment) are not reflected in the
query. They only affect what data is returned. An example
may be a query that states (in a SPARQL-like syntax) ?x
rdf:type ex:mammal. The basic version would return
all resources that are of the type ex:mammal. With RDFS
entailment, the result would contain all resources that have
type ex:mammal or a subclass of ex:mammal.
After the pattern is formed, it is combined using other
operations provided by the query language, like (in the case
of SPARQL) optional matches, unions, filters etc. If we use
SQL queries as an analogy, forming a graph pattern is like
selecting what tables and which of their columns should be
used in the query and how are the tables joined. To do this,
one needs a good knowledge of the database schema (or
RDFS / OWL ontology in the case of RDF data). When developing an application using SQL, it is usual to have some
kind of schema explorer and also some application (often
the same one) to browse the data. Because in practice, it
is usually not sufficient to only look at the schema. The

Introduction

To get data from a database, you need some query system. This usually takes the form of some query language.
Then the software developers write queries in that language.
But to write a query, you need to know several things. One
of them is the exact syntax and semantics of the query language. The other is (in most cases) the exact structure of
the data you are querying.
In the case of relational databases and SQL, many tools
have been created to help user with this task. They range
from syntax highlighting editors with code completion features and automatic formatters to graphical drag & drop editors. None of the graphical editors became really successful, probably due to the fact that it is quite unnatural way
to handle SQL queries, since SQL is based on relational algebra, which does not mix well with placing rectangles and
connecting them with lines.
But the RDF data format – the basic low-level data format of the Semantic Web – is by its very nature a graph [1].
This gives us some hope that there is some way to visually
∗ This research was supported by the Czech Science Foundation under
the contract no. 201/05/H014 and VEGA 1/3106/06

1550-6037/08 $25.00 © 2008 IEEE
DOI 10.1109/IV.2008.13

Query pattern generation

191

(a) Original RDF data

(b) Graph pattern

Figure 1. Example of query pattern generation
names (or even comments – if there happen to be any) in
the schema may not accurately describe the actual data. Or
the data may be incomplete, encoded or simply wrong.
There are several visualization tools (our visualizer being one of them [2, 3]) for RDF data. In their own way,
they allow the user to explore the data, which may be very
helpful aid in development of RDF-based applications. But
we believe we can go one step further. What we want to do
is help the user construct graph patterns. One idea is that
the user may not remember the exact names of all available
predicates (labels of the edges in the RDF graph are called
predicates). This can (to a certain degree – as mentioned
in the previous paragraph) be solved by working with the
RDFS or OWL (or even some other ontology language).
But still writing of graph patterns is somewhat unnatural.
The problem is that even though the pattern is a graph, it is
written as triples (one triple represents source, edge label
and destination of the edge). If the same value or variable
is found in two triples, then it both edges are incident to the
same node. But as the value (or variable) can be a member
of several triples and one graph pattern may contain tens
of triples, it may not be easy to find all edges incident to a
node. Displaying the pattern as a graph may help the user
understand the query.
The query evaluation process replaces variables in a
query by values. Construction of the query may in many
cases be seen as an inverse process. Starting from a piece of
the data, the user replaces some nodes with variables. For
example seeing data that look like this:

1. Finding the relevant data
2. Elimination of unnecessary nodes
3. Transforming nodes to variables and different values
After these steps are performed, the query is generated
in either SPARQL language or in Trisolda query API [4].
Finding the relevant data. The visualizer gives the user
possibility to navigate the data. The user explores the data
using the supported operations until he or she finds the relevant portion of the graph.
Elimination of unnecessary nodes. In our example, the
user may not need to find the last names of the people. Then
the query would be just
?x ex:first_name "John"
The visualizer supports the view reduction operation that
allows the user to remove unneeded nodes from the view.
Transforming nodes to variables and different values.
As we have already mentioned, some nodes in the displayed
graph should be transformed to variables. The user is given
the option (using a context menu) to do this and select the
name for the variable – this is necessary as the final query
can contain more than one graph pattern but variable names
are global to the query so if they were always named e.g.
x1, x2, . . . the names would collide.
The other operation is changing a value of a node. In our
example, “John” was replaced by “Jack”. This is necessary,
otherwise the user would have to explore the data until he
finds a person named Jack which is something not easily
done with the visualizer alone.

ex:john ex:first_name "John"
ex:john ex:last_name "Doe"
the user creates the query
?x ex:first_name "John" .
?x ex:last_name ?y

3

The query finds all people (and their last names) whose first
name is John. Or replace ”John” with ”Jack” in the query
to get all Jacks.
And this is exactly the process we want to make easy
with our visualizer. The process of query construction can
be divided into three steps.

Example

The Figure 1 shows an actual example. The first image shows the data. For clarity and readability the data
have been reduced to the necessary minimum. Note, that
the nodes of the RDF graph are shown as merged nodes.

192

The node merging technique is a method we have developed to help the users quickly see neighbors of a node.
The node shows not only label of the node itself, but
also a list of incoming and outgoing edges. So the node
data:846993817175361413 has two neighbors. An
edge labeled ex:first name leads to a literal node
Jiˇ
r´
ı and an edge labeled ex:last name leads to a literal node Dokulil. The first edge is also listed in the
graphical representation of the node Jiˇ
r´
ı as an incoming
edge and the same goes for the second edge and the literal
node Dokulil.
In the second picture, data:846993817175361413
was replaced by ?x and Dokulil by ?y. Note, that the
user only works with labels of the nodes, but the changes are
also reflected in all relevant records in the lists of incoming
and outgoing edges.

SPARQL supports a CONSTRUCT query that does produce
an RDF graph. The problem is that it only “patches” the
output of the query from table to RDF graph. But inside
the query, it still works with tables (note that they are not
exactly the relations as defined in the relational algebra, the
semantics is a lot different – but the basic idea is the same).
To sum it up, the current query generation feature of the
visualizer is very limited. To further extend it, we need a
closed RDF query language. We need every elemental operation to transform an RDF graph into another RDF graph.
We have already spent some time exploring the idea and so
far it seem feasible. But creating a new query language –
especially one quite different from the existing ones – is not
an easy process.

4

There is one definite conclusion. Generation of the basic
graph patterns is doable and provides a simple, yet useful
tool for the developers.
And there is the big question. Does it end here or can we
go much farther? From the visualization point of view, there
are several interesting challenges but they all seem to be
well within current capabilities of visualization techniques
and computer hardware. We just need the right query language. From the formal and technical point of view, it is
most likely possible to create one. The question is whether
the users (in our case software developers) would accept
such language. Current popular RDF query languages are
mostly SQL-like in terms of syntax and semantics. For instance, in the case of SPARQL the likeness of semantics is
not obvious from the first look because there are no “tables”
in the standard, but the solution sequence concept maps to
tables quite well.

5

Limitations

This system has many limitations. One of them is that
because the visualizer only displays connected subgraphs
of the data, the generated graph pattern also has to be connected. This is not a big problem, as unconnected patterns
(roughly equivalent to SQL-like cross join of the connected
subgraphs) are not as common and can be created in several
steps, where in each step a connected part of the pattern is
generated.
One obvious limitation is that it is not possible to create
a query that is “not in the data”. That is, if we want to find a
person with two first names, then we have to first find such
person with the visualizer and only than we can make the
query.
These two issues could quite easily be resolved by altering the behavior of the visualizer. But there is one fundamental limitation that cannot be solved like this. Let us get
back to the analogy with SQL queries. A SQL query construction may be an iterative process. The user starts with
a simple query, executes it and looks at the results. Then
he or she may further refine the query to see an interesting
portion of the results. Or the query can be used as a part of
a bigger, more sophisticated query.
Our visualizer cannot achieve this. One reason is that being a graph visualizer it is not able to execute the query and
display the table with the results. Second reason is that it
is unable to extend and combine the queries to create more
complex queries. There is a common reason for these seemingly unrelated issues. Current RDF query languages are
not closed. They take an RDF graph as input and produce a
table as their output.
Of course, we could display the table, thus solving the
first problem. But there is nothing more the visualizer can
do with such data. It cannot navigate tables. As for the
second problem, there is a “solution” as well. For instance,

Conclusion and future work

References
[1] J. J. Carroll and G. Klyne. Resource description framework:
Concepts and abstract syntax. W3C Recommendation, 2004.
[2] J. Dokulil and J. Katreniakov´a. Visualization of large schemaless RDF data. In International Conference on Mobile Ubiquitous Computing, Systems, Services and Technologies (UBICOMM 2007), includes: SEMAPRO 2007, WSNEXT 2007,
MUTL 2007, VVSSearch 2007, pages 243–248. Los Alamitos: IEEE Computer Society, 2007.
[3] J. Dokulil and J. Katreniakov´a. Visual exploration of rdf data.
In SOFSEM 2008: Theory and Practice of Computer Science,
pages 672–683. Springer-Verlag Berlin Heidelberg, 2008.
[4] J. Dokulil, J. Tykal, J. Yaghob, and F. Zavoral. Semantic web
infrastructure. In First IEEE International Conference on Semantic Computing, pages 209–215. IEEE Computer Society,
Los Alamitos, California, 2007.
[5] E. Prud’hommeaux and A. Seaborne. SPARQL query language for RDF. W3C Working Draft, 2005.

193


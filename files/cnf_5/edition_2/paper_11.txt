2009 Sixth International Conference on Computer Graphics, Imaging and Visualization

Photon Mapping Parallel Based On Shared Memory System
1

2

3

4

He Huaiqing , Wang Tianbao , Xu Qing , Xing Yaoyu
1,2,4

3

College of Computer Science and Technology,
Civil Aviation University of China, Tianjin 300300,China

School of Computer Science and Technology, Tianjin University, Tianjin, China
{huaiqinghe@yahoo.com.cn, violin_wang@yahoo.cn, qingxu@tju.edu.cn, yaoyuxing@163.com}
mapping under multi-core environment and the matter
faced in performance optimization.

Abstract
By searching the basic tasks when photons are
launched by photon mapping algorithm, this paper
focuses on the implementation of photon mapping in
parallel at low-end graphics workstation. It designs and
implements multithreading of photon mapping under the
shared memory even gets obvious acceleration ratio
through a combination of OpenMP and Win32 threads
library. Meanwhile, it further optimizes the parallel
performance and, to some extent, improves the speed of
rendering of photon mapping.

2. Jobs related
Photon Mapping is a kind of global illumination
technique which is officially presented and developed by
Henrik Wann Jensen in 1996[2], it has obvious
advantages compared with the other two methods of
rendering: ray tracing and radiosity. While it can not deal
with the effect simulation such as caustics and indirect
reflection, the ray tracing can only handle the reflection,
refraction based on the direct light and ideal specular
layer [3]. Although the identity of slow circulating speed
exists in all the three global illumination algorithms
compared here, the extrusive shortcomings of radiosity
algorithm rest with disposing the perfect point light
source and glossy surface negatively.
The global illumination based on Photon Mapping is
an algorithm with two-pass method. The first step is to
set up a photon map that is to shoot photons to the scene
through the light source. These photons which hit the
non-specular surfaces will be stored in a data structure
called photon map. Step two: the stage of playing up. It
is to extract information on the rendering point like
incident flux and reflected radiance from photon map
with statistical principle through the classic method of
ray tracing when it shoots rays at this rendering point
from a viewpoint. Photon map exists independently
from the scene geometry, which is the main feature of
photon mapping. This feature enables it to simulate the
overall illumination for complicated scenes that include
hundreds of millions of triangle films, a lot of geometric
objects and the objects implemented by a large number
of procedures.
Parallel rendering studies have been much touched;
you can find the literature [4] which rises up the parallel
rendering with radiosity algorithm implemented in the
GPU while literature [5] is referring a new parallel
photon mapping method based on non-shared memory
system compared with the disadvantage of large
computation, taking amount of memory space. And also

Keywords---photon mapping multithread parallel
rendering shared memory

1. Introduction
In recent years, multi-core processors which have
been widely used in PC, servers, laptop and so on have
become the mainstream of CPU with a rapid
development of multi-core technology. A wide upgrade
of hardware’s performance presents new challenges to
traditional software, namely how to make the serial
software or algorithm on the traditional sense adapt to
the mainstream of "multi-core" style better. It has been
an issue worthy of concern that how we can proof the
serial program or algorithm developed on a single
processor to parallel and make full use of the parallel
character[1] supported by multi-core processors to
enhance the performance of traditional serial program
and related arithmetic.
It will take a great deal of time to act the rendering
of realistic image, and the issue on how to improve the
efficiency of rendering have already got great discussion
on dissertations. The parallel specialty of rendering
algorithm is becoming a hot spot. This paper aims to
discuss the methods of parallel rendering at photon

978-0-7695-3789-4/09 $25.00 © 2009 IEEE
DOI 10.1109/CGIV.2009.41

69

Literature [6] proposes a kind of parallel rendering with
ray tracing under the mixed-mode, a new method on
parallel with ray tracing. Besides, Literature [7]
introduces a novel photon mapping framework, it is the
final integration phase to accelerate photon mapping
through a parallel between single instruction stream and
multiple data stream (SIMD).

the first phase. It divides the whole mission of photon
memory into basic mission units which can be parallel
performed with relatively less relation in accordance
with the way of “mission separation”.

3. Basic ideology on algorithm

4.1. Basic mission unit

This paper focuses on the parallel photon mapping
algorithm which is based on the algorithm of literature
[2]. By comparing the real-time ray tracing and photon
mapping, it is found that the same core operation exists
in both of them, that is, the former light intersection test
and rendering operations of the latter light point and
photon mapping are both special database --- KD tree.
Through the commonness and difference compared
between the photon mapping algorithm and ray-tracing
algorithm, this paper absorbs and improves the idea of
parallel ray tracing algorithm to introduce a new
algorithm of photon mapping for parallel rendering.
The parallel discussed and implemented in this
article is to make use of basic unit - thread scheduled and
dispatched independently in the computer system to
handle parallel affairs. Through the method of creating
multiple threads, it will make suitable decomposition for
rendering algorithm to realize independent existence
between threads or less relation between data. This
environment of shared storage system decreases the
trouble of partitioning the data and reduces the effect of
bandwidth for data communication, but it also brings
problem such as thread synchronization, data
competition when the shared resources are accessed.
Further, if the utilization of cache memory is under
consideration, we have to solve the existence of "pseudoshare". The above-mentioned phenomena all need further
performance optimization.
In accordance with the two-stage feature of photon
mapping algorithm, you can find the inherent parallelism
in algorithm itself that is a kind of mission
decomposition from the design space [8] model of
"search and distribute". Parallelization can be achieved
mainly in two aspects:(1) during the first phase of setting
up the photon map, it is sampling photon light source
parallel in order to launch parallel photon, each mission
unit will be in charge of tracking one or more photons in
the scene and recording their various activities. All the
photons’ activities will be recorded to a shared static data
photon map eventually. (2) It is the parallelization at the
time of rendering: By using classical ray tracing
algorithm from the point of view to rendering, this
process is to get the sampling points intersected by rays
and the scene. Therefore it is so similar between parallel
during this stage and the parallel ray tracing that they can
parallel each following pixel or divide the rendering
pictures into blocks to achieve parallelization by data
decomposition. Due to much discussion on ray tracing
parallelization can be found in literature, we will focus
on the parallelism of photon storage phase described in

The mission of each basic processing unit includes
mainly the following components: (1), it selects light
source in scene in accordance with the rules of random
selection sampler, if the light source is not a point light,
it will determine the location on which the point light
source is launched through a random seed; (2), it shoots
photon, determines the energy and direction of the
photon; (3), it determines the intersection point and
accesses a variety of information on the intersection
point such as position, normal direction, BSDF
(Bidirectional scattering distribution function); (4),
photon classification, according to the information of
intersection point and recursive depth, it estimates
whether the photon information and photon type should
be recorded; (5), It selects new shooting direction and
determines whether the photon travel should be
terminated, if it is selected to continue to travel, then it
follows step 3 and continues until the termination of
travel. Of course, it is necessary to deal with some initial
things such as initialization files, determining the total
number of photons launched and setting up three types of
data structure of photon map before each basic
processing unit is in the implementation. The pseudocode is as follows.
sample_light();
shoot_photon();
while(1) {
if(intersect()) {
bsdf();
…….
accumulate_photon_block { …….}
choose_new_direction();
if (judge_stop_state())
break;
} else break;
}

4. Design, implementation of algorithm and
result of experiment

4.2. Scheduling of basic processing unit
We have put the work to aim at scheduling a
separate mission, known as the scheduling module, and
its framework can be described as: The overall mission
of first phase of photon mapping is divided into N basic
processing units which are organized into the form of a
queue to show. Then a set of threads (thread pool) with
N (number) elements is created to deal with the basic
mission. Then you can distribute a basic mission for each
thread which can go into the queue to reach another basic
mission to continue when the current mission is finished
until all the basic tasks to be completed with empty
70

mission queue. Threads in thread queue are executed in
parallel, so that it can be assured that a number of basic

tasks can be completed in parallel. As figure 1 shown:

Thread pool

B-N
U-2
…….

U-n

B-NMission queue

U-1

Complete

Complete

．．
B-2

Complete

B-1

Basic mission pop

Schedule thread

Figure 1 Framework for Scheduling module. U-i expresses thread, B-i shows the basic mission, if the
basic mission currently dealed with by U-i has been completed, the transferred mission goes out of the
queue to obtain another basic mission.

4.3. Results and Analysis from experiment

multi-thread [10] programming Win32, it respectively
launches 10000,20000,50,000 photons and uses 75
photons to estimate optical brightness at 1, 2,3 thread,
the acceleration ratio is such as Figure 2.

acceleration ratio

Realization of the algorithm in this paper is based on
the PBRT rendering platform. PBRT is a classic
rendering system completed by MattPharr, GregHum
Phreys and so on. PBRT provides all kinds of parts that
are physical units and physical concepts needed by
image rendering in the form of class and plug-ins. PBRT
can support 12 types of plug-ins such as the type of
camera, of material, of light source and so on, and what
we need to improve is the surface of the part (Surface
Integrator) and Photon Integrator under classification. So
we can improve the modules interested by us easier to
complete the requirements of our experiment while other
parts of the system do not have to do large-scale changes.
The types provided in the form of plug-ins are relatively
independent, but they transfer and interdependent on
each other during their work which makes the system
very complicated and will encounter unknown
difficulties when it is improved.
The PBRT version we use is version 1.02 that is
supported by the Windows XP operating system, and its
hardware environment is dual-CPU structure while each
CPU has a core. From the theoretical analysis and
experimental results, we conclude that for this large and
complex PBRT rendering systems, the parallel of photon
mapping would be often involved in the changes of the
main program and other plug-ins interface, so that the
performance of the entire rendering system can be
factually improved rather than just to parallel the part of
the photon mapping which will be able to truly improve
the algorithm efficiency. Under the above-mentioned
conditions of software and hardware with the
combination of programming language OpenMP [9] and

2
1.8
1.6
1.4
1.2
1
0.8
0.6
0.4
0.2
0

10,000
20,000
50,000

1

2

3

number of threads

Figure 2 Acceleration ratio of implementation
with multi-thread process
We can find that the acceleration ratio is increasing
as the number of threads is growing, but the rate of
increase is different. Obviously, the white block firing
more photons is with larger growth rate than others,
which shows that the calculation with the amount of data
is more suitable for multi-threaded parallelism rather
than when the amount of data is not very large, the
computing time is relatively smaller to the whole running
time, the increased time of system overhead results in
lower performance. In addition, from the previous figure
71

we also can find when the number of thread reaches 3,
the accelerated growth rate significantly becomes lower,
the main reason is that our hardware threads number is
two, when the three threads run, the non-one mapping
situation that three mapping software map two hardware
threads is formed, so the operating system can only use
time slice rotation strategy to make effective scheduling,
while a large number of CPU time is taken on the system
scheduling which results in degradation of performance.

between basic tasks to some extent compared with the
situation without any Optimization.
(3) Overhead synchronization. Variables’ sharing is
a kind of communication means between parallel threads,
but it also creates a situation: a thread has to wait for
another thread to implement. If the process has many
sharing variables existing, you must add a lot of
synchronization mechanisms (such as locks) to
coordinate between threads to run. Synchronization
mechanism itself is a kind of overhead, too many such
applications will take up lots of system resources, and
meanwhile it will introduce neutral behavior of hanging
to the thread, and reduce the efficiency of the
implementation of the procedures. Our solution is to
change some global variables into thread privatization,
each thread has its own local variables, and the results of
the thread can be added to the global variables only when
these threads are finished.

5. Performance optimize and experiment
result
5.1. Analysis and solution of issues affecting
performance
After several rounds of tests, it shows that the
parallel performance is not necessarily more positive
than serial performance. According to Amdahl's law, we
should strive to improve the ratio that parallel code is
used in the application process, which is a common way
to improve the efficiency. From above information, you
can find that the parallel part is the one with biggest
computation, often said hot-part. In addition there are
other constraining factors.
(1) Size of thread-queue. The number of threads has
a direct impact on the performance of parallel. If the
thread number is too small, it cannot take full advantage
of the physical hardware resources to avoid wastage. Or
if too many threads work, it may lead to take substantial
CPU running cycle on maintenance (starting, termination,
etc.), also to result too large overhead for the
maintenance of shared resources. Our solution is the
number of thread can adapt dynamically hardware
conditions. The so-called dynamic situation is to ensure
the portability of the realization program, while the socalled “to adapt hardware” says the thread number does
not exceed the number of hardware threads.
(2)Load balancing. In accordance with the
characteristics of Photon mapping algorithm itself, in
tracking the path of photons, the travel time said
recursion degree of each photon within the scene is
different, then there are the basic mission sizes.
Unbalanced load is caused by different running times of
the mission assigned to the various threads. According to
the physical property of photon, after the repeated
collision with the object surface at scene, its energy will
be reduced, so that the estimation contribution to
brightness during rendering from recorded information
of the photon is very small or can be omitted. Therefore,
we can set an appropriate number “W”of recursive
degree, if the actual number of photon travel is over “W”,
its travel will be forced to stop; if the actual number of
photon travel is less than “W”, its travel will not be
affected by any action. So this will not cause new errors
and keeps the hardware threads on load leveling. We can
not achieve absolute balance, after all, there may be large
number of photons whose recursive degree are less than
“W”, but for the photos whose recursive degree are more
than “W”, their travel are limited to reduce the size gap

5.2. Analysis and result of experiment

acceleration ratio

After following the multi-threaded parallel, although
the algorithms acceleration ratio is improved, the parallel
performance is not good which is far from the ideal
parallel acceleration ratio making use of analysis of
Amdahl’s Law [11]? After the performance optimization
(load balancing and synchronization overhead), the
algorithm efficiency is further enhanced as shown in
Figure 3, the acceleration ratio after optimization is
improved to some extent than the former one and the
speed-up ratio showed in cylindrical Fig with three
colors is basically the same during all stages of
increasing thread, the load is well balanced, the impact
from the amount of photon emission is weakened a lot to
the performance of program.

2
1.8
1.6
1.4
1.2
1
0.8
0.6
0.4
0.2
0

10,000
20,000
50,000

1

2

3

number of threads
Figure 3 Acceleration ratios after optimized
performance
Although the performance after Optimization is
improved to a certain degree, it is not perfect for
performance increase on the whole. The predicted
possibilities of the problem are as follows: (1) the
72

difference between hardware: there is great distinction
during the realization through multi-CPU systems and
through multi-core system; it is mainly reflected in the
communication issue between the threads. (2) PBRT
rendering platform itself is with a large system and a
complex internal structure which leads to inefficiency in
parallel. These two issues will be the focus of the followup study. We will further transplant the system to a quadcore SMP machine to research in the next stage.
During the process of performance optimization, the
load nearly goes to balance by forcing the travel of some
photon to stop, but it does not loss too much image detail.
The below 2 pictures are both formed by rendering
brightness with 50 optical photon from 50,000 photons
fired. We almost can’t observe any diversification of
quality for image with the naked eye through the
compare between images implemented by serial
algorithm (Figure 4) and rendering ones by parallel
optimized (Figure 5).

photon travel and variables privatization based on the
nature of Photon mapping algorithm itself. But it refers
no further discussion on multi-threaded performance
such as pseudo-sharing. More contents need our further
discussion on how the second phase of photon mapping
can be parallel rendering and how to divide the photon
map with global variables to reduce the correlation
between the threads.

Acknowledgements
This work has been supported by the National
Natural Science Foundation of China grant 60572169,
Scientific Research Foundation for the Returned
Overseas Chinese Scholars, State Education Ministry
grant D4200407, Tianjin Natural Science Foundation
grant 06YFJMJC00400, and Tianjin Natural Science
Foundation grant 05YFJMJC09200. The authors are
grateful to the anonymous reviewers for their helpful
suggestions and comments.

References
[1]

MJ Quinn. Parallel computing: theory and practice.
McGraw-Hill, Inc. New York, NY, USA. 1994.
[2] Henrik Wann Jensen. Global Illumination Using Photon
Maps. Proceedings of the Eurographics workshop on
Rendering techniques. 1996. 21-30.
[3] Urner Whitted. An Improved Illumination Model for
Shaded Display[J]. Communications of the ACM, 1980,
23 (6) : 3432349.
[4] Wang Jing, Wang Lili, Li Shuai. An Algorithm of the
Expected Radiometric Transmission with All-frequency
Shadow Based on GPU[J]. Computer Research and
Development, 2006, 43 (9) .1505-1510.
[5] M.Tamura, H.Takizawa, and H. Kobayashi(Japan), A
Parallel Image Generation Algorithm Based on Photon
Map Partitioning, Proceeding(600) computer Graphics
and Imaging 2008.
[6] Erik Reinhard, Alan Chalmers, Frederik W.Jansen.
Hybrid Scheduling for Parallel Rendering Using
Coherent Ray Tasks. Proceedings of the 1999 IEEE
symposium
on
Parallel
visualization
and
graphics,1999.21-28.
[7] Shawn Singh, Petros Faloutsos. SIMD Packet
Techniques for Photon Mapping. IEEE/EG Symposium
on Interactive Ray Tracing 2007, pp. 87-94.
[8] Timothy G. Mattson, Beverly A. Sanders and Berna L.
Massingill, Patterns for Parallel Programming.
[9] OpenMP Architecture Review Board. OpenMP.
http://www.openmp.org
[10] Thornley, KM Chandy, H Ishii. A System for Structured
High-Performance Multithreaded Programming in
Windows
NT
2nd
USENIX
Windows
NT
Symoposium.1998
[11] Hennessy J L, Patterson D A. Computer Architecture: A
Quantitative Approach.Third Edition. Beijing: China
MachinePress,2002

Figure 4 Image Rendering and Implemented
by Serial Algorithm

Figure 5 Image Rendering by Optimized
Parallel Performance

6. Summary and outlook
This thesis focuses on making photon mapping
algorithm to be multi-threaded and getting better
performance by using OpenMP and Win32 Thread
Library through the shared memory system, which
maximizes the utilization of computation resources. It
improves the performance by compulsory stopping of
73


2009 Sixth International Conference on Computer Graphics, Imaging and Visualization

Real-time rendering system of large-scale terrain in flight simulation: design and
implementation

HE Huai-qing, XING Yao-yu, and WANG Tian-bao
College of Computer Science and Technology, Civil Aviation University of China
huaiqinghe@yahoo.com.cn
yaoyuxing@163.com.cn
violin_wang@yahoo.cn
Using the original sample data directly when
rendering large-scale terrain is far beyond the processing
limitation of an ordinary PC. In order to better balance the
rendering effectiveness and efficiency, LOD [1] is used to
organize terrain. In this paper, the key technologies of two
modules, terrain pre-processing and real-time rendering are
described.

Abstract
In flight simulation, scenes are rich in content with
the characteristic of large-scale. In this paper, a largescale terrain rendering procedure suitable for flight
simulation is given and a terrain data pre-scheduling
criteria is established. A linked queue based quadtree
partitioning algorithm is proposed, so that triangulation
and elimination of cracks can be performed
simultaneously during the process of quadtree
partitioning. Finally an experimental system is designed
and implemented to perform large-scale terrain real-time
rendering. Based on this system, we studied the key
technologies of real-time rendering large-scale terrain.
Experimental results show that the system is suitable for
real-time rendering large-scale terrain.

2. System design
To make the terrain data suitable for real-time
rendering, off-line pre-processing needs to be performed
on the raw data, which is firstly divided into blocks. All
blocks in the whole terrain form a block matrix. A block is
saved as a unique file named ij, where i is the row index
and j is the column index of the block in the matrix, so that
blocks can be easily retrieved. The system predicts the
visible region according to the information user inputted
and then up-dates the terrain data in memory. After
reading the terrain data of current frame into memory, a
quadtree is used to partition the data in a top-down
approach, and a view frustum culling is used to remove
invisible nodes simultaneously. Nodes that have reached
the dividing criteria are real-timely triangulated and then
sent to render pipeline. System structure is shown in Fig.
1.

Keywords: Large-scale terrain; real-time rendering;
LOD; quadtree

1. Introduction
Flying vision system provides a realistic out cabin
scene in the process of pilot training. But due to the
limitations of hardware and software, only scenes around
airports are used currently, and the training concentrates
on take-off and landing stage, ignoring the affection of
large-scale terrain during cruise phase. In order to build a
complete flying vision system, it is necessary to set up an
experimental system to study the key technologies of realtime rendering large-scale terrain.

978-0-7695-3789-4/09 $25.00 © 2009 IEEE
DOI 10.1109/CGIV.2009.47

3. Terrain pre-processing
3.1 DEM structure of the terrain
There are two kinds of data structures in terrain DEM
data, regular grid structure and non-regular grid structure,
also called square grid structure and triangular grid
180

Fig. 2. System structure
named with the code and saved as a unique file on the hard
structure. These two structures have their own advantages
disk drive.
in some aspects such as storage simplification. DEM files
of the regular grid structure record the coordinate of
3.3 Scheduling strategy
starting point and sampling interval as well as elevation
values of all sample points. The topological structure
Typical scheduling methods usually schedule data
between each square grid and its vertex, as well as the
once
in each frame, that is, there is always only one frame
topological structure between the square grid and its
in
memory.
adjacent grids are included in the array. Therefore such a
Scheduling data once before rendering each frame
simple structure needs less storage space, and is easy to
leads
to frequent I/O operations during rendering. Besides,
organize. These characteristics make it suitable for largeMA
Zhao-ting,
et al. proposed a method that keeps 9 data
scale terrain rendering. Our system uses a regular grid
blocks
in
memory,
that is, set the view projection on the
structure. After transferred into memory, original terrain
ground
as
the
centre,
make sure that the 8 surrounding data
data with highest resolution are stored in a twoblocks
are
transferred
into memory before each rendering.
dimensional array.
This method restricts the size of the visible region and
when the size of the visible region is small, a great number
3.2 Splitting method
of useless data are left in memory. Here, according to the
characteristics of the flight roaming, we proposed a
The sizes of blocks have direct effects on the
scheduling strategy. That is, predicting the data needed and
efficiency of rendering. If the size is less than a certain
scheduling data once every period of time t .
threshold, the frequency of I/O operations will increase
In the initialization, visible terrain data is firstly
during the rendering procedure, as a result, the system uses
transferred into memory. According to the characteristics
more resources. Meanwhile, if the size is too large, it may
of the flight simulation, there are only three directions,
exceed the computer's processing capacity and cause overfrequent scheduling of the invisible data in memory,
forward, left and right. As is shown in Fig .2, OD is current
therefore increase the burden of the real-time rendering
view vector, the limitations of the three directions in the
system and decline the overall frame rate. So the threshold
next period are OC , OA and OB respectively. These three
of block partitioning becomes a factor of the system
situations correspond to trapezoids A, B and C, as shown
performance. Normally, according to Intel [2], the size of
in Fig. 3 respectively. Thus in the next period, the view
memory page is 4K, thus the size of blocks should be
direction varies within ∠AOB . Suppose the horizontal
integer multiples of 4K. This can further improve the
acceleration is a1 , deflection acceleration is a2 , maximum
speed of data reading.
vertical incremental is L = (V + a1 ∗ t ) ∗ t , deflection angle is
For N × N original terrain sampling data, we split
n
n
a = (W + a2 ∗ t ) ∗ t , therefore, the flank maximum
the terrain into blocks of size (2 + 1) ∗ (2 + 1) to be
convenient for the organization of a quadtree. In our paper,
incremental is D = L ∗ gl (a ) , d is terrain sampling
we set n = 6 , i.e., the size of each block is 65*65. After
interval, then in current view direction, L / (64 ∗ d ) + 1 row
block partitioning, blocks are coded according to the
data blocks need to be transferred, while on the left and
coordinate they occur in the original data. Each block is
right sides, a / (64 ∗ d ) + 1 column data blocks need to be

181

transferred. Fine-mesh part in Fig. 3 is the pre-scheduling
data. This ensures the data that needs to be rendered in
next period are transferred in memory.

Fig. 2. View variance

huge amount of stack operations. The number of these
operations increases exponentially [11].
When quadtree grows to certain depth, stack overflow
may happen. For these reasons, we employ a linked queue
to implement a quadtree. Here we define the tree node as
follow:
Class QuadTreeNode
{
int x；//line number of node in terrain array
int y；//column number of node in terrain array
int Size；//half size of node in terrain array
QuadTreeNode *next；
}

Fig. 3. Pre-scheduling

4. Real-time rendering terrain
4.1 The LOD organizing of quadtree
Main methods for organizing terrain data are binarytree [5], quadtree [6] and octree [7] etc. Binary tree method
is suitable for interior roaming. Octree structure is suitable
for rendering scenes with large vertical heights, but the
cutting and occlusion culling are poor in efficiency.
Quadtree structure is suitable for regular terrain. It
considers the whole terrain as root of a quadtree, and
divides the whole terrain into 4 equal-size sub-terrains.
These 4 sub-terrains are considered as first level children
nodes. Further similar division is carried out recursively.
Traditional quadtree structure is described as follow [6, 8]:
Class QuadTreeNode
{
int index;
int depth;
int width;
Position3D position;
QuadTreeNode *father;
QuadTreeNode *children [4];
Mesh mesh[n];
}
Traditional quadtree partitioning process [9, 10] is:
Function (n)
{
//Other operations
Function (n - 1)
}
Traditional quadtree based terrain management needs
to build a complete quadtree which has many leaf nodes.
And all children pointers in these leaf nodes are null. This
causes a great amount of memory waste. Besides,
traditional quadtree generation process is recursive which
makes the algorithm simple. But for large-scale terrain, the
procedure of recursively generating quadtree can lead to a

Fig. 4. Node topology
According to the quadtree structure definition above,
when rendering the needed patches using quadtree, for
every quadtree node, by calling node.x, node.y, node. Size
etc. we can locate its children nodes and adjacent nodes.
As shown in Fig. 4, node B is the up-left child node of A,
B.Size=A.Size>>1 ，B.x=A.x-B.Size, B.y=A.y-B.Size; node
C is an adjacent node of A, then, C.x=A.x+ (A.Size<<2),
C.y=A.y, C. Size=A.Size. Therefore, the topological
relations of quadtree are implicit in a two-dimensional
table, eliminating the storage of more tree nodes during
further division.
To mark the status of nodes, a two-dimensional
character array index, which has the same scale with the
terrain data in memory, is generated and initialized with its
all elements to A that means inactivated. When generating
detail terrains, we can record the real-time status of nodes
by modifying certain elements in array index. When the
node is completely visible, the corresponding value in
array index is C; when it is partly visible, the value is S;
the corresponding values of the 4 children nodes are set to
P when certain breakdown criterion is reached.

4.2 View frustum culling
Determination methods for visibility of a node have
been well studied and are now really sophisticated.
Traditionally view frustum culling can be used, that is, the
intersection of the terrain patches contained in the node
and every one of the six view frustums, respectively [12].
In our system, we employed a simplified method. We first

182

that are involved in the whole partitioning procedure and.
We first insert the root node (center of terrain) of the
quadtree into ListQueue, and then traverse ListQueue. We
subdivide each node in ListQueue according to the
subdivision criterion, and insert new visible subnodes
(including partly visible and completely visible) at the end
of ListQueue.
Algorithm description:
Step 1. Insert the terrain center into ListQueue as the
root node of quadtree and set the corresponding value in
index to S.
Step 2. Traverse ListQueue and evaluate each node
according to subdivision criterion. If the current node
reaches the criterion, go to Step 4, else go to step 3 until
the traverse is over.
Step 3. For those nodes that did not reach the
criterion, generate 4 sub nodes according to quadtree
partitioning method. Check the mark in index, if the node
is completely visible, then insert all 4 sub nodes at the end
of ListQueue, and set the corresponding value in index to
C; for partly visible nodes, cull the field of view of all 4
sub nodes, then insert completely visible and partly visible
nodes at the end of ListQueue, and set the corresponding
value in index to C, S respectively. Release the invisible
nodes directly. Keep the corresponding value in index
inactivated.
Step 4. For those nodes that have reached the
subdivision criterion, set the values in index to P, perform
triangulation and then send to rendering pipeline.

find the rectangular projection of a view frustum on
horizontal surface, and then determine whether the four
corner of the contained region of the node is within the
projection rectangular. If so, the node is marked
completely visible; or if no corner is in the rectangular, it
is marked completely invisible; if the corners are partly
within the rectangular, it is marked partly visible.
Completely invisible nodes are removed. And elements in
array index corresponding to completely visible nodes are
marked C. These nodes are no longer further divided.
Elements corresponding to partly visible nodes are marked
S. Only these nodes are used in further view frustum
culling.

4.3 Breakdown criterion
4.3.1 Vision criteria
In order to describe terrain using minimum number of
nodes to increase rendering efficiency, node evaluation
criteria is introduced while organizing quadtree [13]. This
criterion determines the maximum resolution of each node.
This criterion should meet the characteristics of human
vision, that is, observation of distant objects with less
detail, and near objects with more details. Besides, to
ensure of the reality degree, complex terrain is described
with more details, plain terrain is described with less
details. Therefore the node evaluation formula can
be f = L /(d ∗ C ∗ R) . If f < 1 , keep subdividing; else stop.
Where L is the Euclidean distance from a node to view, d
is the length of the region covered by the node, R is the
roughness of the region, C is total terrain resolution
control factor (constant given). Terrain with higher C is
one with higher resolution.
4.3.2 Criteria for engineering practice
After subdivision if the resolution between some
terrain grids is more than 1, lots of redundant triangles will
be generated, which will cause real-time rendering system
burden and impact the smoothness of terrain. Therefore,
grid subdivision should be controlled to make sure
resolutions between adjacent grids are less than 1 during
subdivision. Before evaluating each node with vision
criterion, we should check the adjacent nodes above,
below, left and right (ignore directions in which there are
no adjacent nodes). If there is a node in status P, then its
parent node has reached subdivision criterion. Thus the
resolution between the current node and this adjacent node
is 1. This is the time to stop partitioning.

4.5 Triangulation
Since adjacent grids may have different resolutions,
there might be cracks on the boundary of two square
terrain blocks during texture mapping. There are many
methods for crack elimination. Typically, there is recursive
elimination, that is, dividing nodes with lower resolution.
But recursive way may cause bad rendering efficiency.
Additionally, there are two other simplified ways to
eliminate cracks: one way is to forcedly split triangles with
low resolutions by adding edges. This method works well
in spite of differences between resolutions of adjacent
triangles. One drawback is that it generates redundant
triangles. The other way is to eliminate cracks by delete
the smallest edge that causes cracks. This way is used only
when difference of resolutions are less than 1. This method
is simple enough but may lead to bad rendering quality.
Our terrain subdivision algorithm perform real-time
triangulation on those squares covered by nodes that
reached the subdivision criterion during subdivision
process, thus it eliminate cracks at the same time. Here we
make full use of the functions of OpenGL for rendering
triangle fan to perform triangulation and render the terrain.
For every node that meets the subdivision criterion as
point O shown in Fig. 5a, it contains 4 edge points {A, C ,

4.4 Terrain subdivision algorithm description
We use the quadtree partitioning method to perform
subdivision. In our algorithm, we do not really build a
quadtree, but using a linked queue called ListQueue whose
nodes are of QuadTreeNode type to record quadtree nodes

183

between the view and the center of region covered by node
to the size of this node and the roughness of a node in our
system. Considering the impact on vision when flying near
the ground, a more scientific node evaluation criterion
should be given in order to increase the ability of real-time
data processing. Those are two problems that need further
research.

E, H}, 4 corners {B, D, F, I} and a center {O}. We
consider O as original point of triangular fan, all edge
points as vertexes. For each edge point, we first check its
all adjacent points in every edge point directions, if some
adjacent point is not activated, and then this node’s parent
node has reached the subdivision criterion. At last,
according to the occurrence order in series OABCDEFHI,
all the originals, edge points and corners contained in the
terrain triangular fan covered by the current node are
rendered between globulin() and glEnd(). According to
this rule, the triangular fan of the terrain block covered by
node O consists of original O and vertexes ABCDFI. The
triangulation result is shown in Fig. 5b.

Fig. 6. Mesh simplified

a

b

Fig. 5. Terrain block triangulation
representation
Fig. 7. texture mapping

5. Experimental results
Employing the method described above, making use
of the OpenGL library, we developed a large-scale terrain
experimental system. In our experiments, we get the
terrain model with a scale of 16385 × 16385 , the experiment
is carried out on legend PC, which with the operating
system of Windows XP and Pentium 4 1.8GHZ CPU,
512M internal memory, GeForce MX 400 video card.
Above 20fps frame rate in the whole rendering process.
Fig. 6 shows a mesh simplified frame; Fig. 7 shows the
frame after texture mapping. Experimental results show
that the efficiency of our system can meet the requirements
of large-scale terrain rendering.

Acknowledgements

6. Conclusions

References

This work has been supported by the National Natural
Science Foundation of China grant 60572169, Scientific
Research Foundation for the Returned Overseas Chinese
Scholars, State Education Ministry grant D4200407,
Tianjin
Natural
Science
Foundation
grant
06YFJMJC00400, and Tianjin Natural Science Foundation
grant 05YFJMJC09200. The authors are grateful to the
anonymous reviewers for their helpful suggestions and
comments.

[1]

In this paper, a large-scale terrain rendering system
was designed and implemented. The system uses such
technologies as terrain partitioning, pre-scheduling, LOD,
fast Visibility Culling, and multi-threaded. Experimental
results showed that the system is quite efficient, suitable
for ordinary PC. Due to large amount of texture data
during large-scale rendering, the texture data should be
compressed stored. Then during real-time rendering,
texture mapping performs after decompression.
Additionally, for the design of node evaluation module, we
considered only two factors, the ratio of the distance

[2]
[3]
[4]

184

J Clark. Hierarchical Geometric Models for Visible
Surface Algorithms [J].Communications of the ACM,
1976, 19(10):547-554.
Jeffrey R, Christophe N. Programming Applications for
Microsoft Windows [M] (5th Edition) 2008 360-361.
DeCoro C. Pajarola R Chris. "XFastMesh: Fast viewdependent
meshing
from
external
memory",
Visualization’02, 2002, 363-370.
MA Zhao-ting, PAN Mao. A Fast Walkthrough Method for
Massive Terrain Based on Data Block Partition Acta
Scicentiarum
Naturalum
Universitis
Pekinesis
[M],2004,20(4): 619-625

[5]

[6]

[7]
[8]
[9]

[10]

[11]

[12]

[13]

[14]

Kumar A , Kwatra V , Singh B, et al. Dynamic Binary
Space Partitioning for Hidden Surface Removal [C ]. In:
Proceedings of the Indian Conference on Computer Vision,
Graphics, and Images Processing (ICVGIP’98). New Deli,
1998.x
PAJAROLA R. Overview of quadtree-based terrain
triangulation and visualization [EB /OL]. [2007 -03 - 10].
Http://www.ifi.uzh.ch/vmml/admin/upload/UCI2ICS20220
1. pdf.
Joshua Shagam, Joseph Pfeiffer, Jr. Dynamic Irregular
Octrees [R]. New Mexico State University, 2003.
PAJAROLA R. Object-Space Point Blending and Splatting
[J]. IEEE Transactions on Visualization and Computer
Graphics, 2004, 10 (5): 598 - 608.
Gross MH, Staadt OG, Gatti R. Efficient triangular surface
approximations using wavelets and quadtree data structures
[J]. IEEE Transactions on Visualization and Computer
Graphics, 1996, 2 (2): 130 – 144.
CHAN Yuan-kuan, CHANG Chin-chen. An efficient data
structure for storing similar binary images [C] Proceedings
of the Fifth International Conference on Foundations of
Data Organization (FODO p98). Kobe,Japan: [s. n.], 1998:
268 - 275.
WAN Wang-gen, ZHOU Jun-wei, et al. Real-time
rendering of 3D large-scale scene based on improved
quadtree algorithm. Journal of Computer Applications
2007,27(9):2095-2113
Naga KG, Avneesh S, Yoon SE, Dinesh M. Interactive
visibility culling for complex environments
using
occlusion-switches[C] Proceedings of the 2003
Symposium on Interactive 3D Graphics. Monterey: [s. n.],
2003: 103 – 112.
Rottger, S., Heidrich, W, Slusallek, P and Seidel, H. S.
Real-Time Generation of Continuous Levels of Detail for
Height Fields, Proc. Sixth Int'l Conf. Central Europe
Computer Graphics and Visualization, Feb. 1998. 315-322.
HUANG Chao-chao, LING Yong-shun, et al. Research on
Dynamic Terrain Render with ROAM.
Computer
Simulation, 2005,22(01) : 216-219

185


Real-Time Predefined Shape Cutaway with Parametric Boundaries
R H Liang1,2, G J Clapworthy2, M Krokos2, R Mayoral2
1

College of Information Engineering, Zhejiang University of Technology, Hangzhou, P R China
2
Department of Computing & Information Systems, University of Luton, UK
ronghua.liang@luton.ac.uk, gordon.clapworthy@luton.ac.uk
Abstract

Cutting away part of a 3D outer surface to show some
interior objects hidden beneath it can play an important
role in visualization and technical illustration. Previous
work includes cutaway using rules and Alpha blending
employed to achieve an appearance of cutaway drawings.
These methods have mainly aimed at showing the
presence of the interior objects, and the shape of the hole
has been considerably less important than the visibility of
the interior objects. However, in some applications, it
may be important for the shape of the hole to have
particular properties. Our example comes from
orthopaedic surgery and the shape of the aperture should
represent the shape of the incision made by the surgeon
when retractors are applied to it to give access to the
tissue beneath. In this paper, we propose a novel
approach to cutting a hole of a specific shape in a surface
consisting of a 3D polygonal mesh. The user first defines
the required shape on the surface; the algorithm then
superimposes the shape on the surface and implements
the cutaway. Jittering problems associated with the
boundary generated by the above steps are resolved and
experimental results demonstrate the efficiency of the
algorithm.
Keywords: OBBTree, predefined-shape cutaway, BSP
tree, outer surface, jittering

1. Introduction
Cutaways in technical illustrations allow the user to view
the interior of a solid opaque object by removing parts of
the external surface. One well-known technique for
achieving this is α blending [1]. However, α blending
causes rather a smearing out than a cutting out or slicing.
Other work has used transparency, rather than cutaway, to
show inner-space relationships in the context of nonphotorealistic rendering (NPR) [2,3,4].
Diestraten et al. [5] discuss a number of different
approaches to generating cutaway illustrations by defining
some rules. These rules propose an efficient approach to
the computer-based rendering of cutaway illustrations that
is not limited to a specific rendering style, but can

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE

successfully be combined with a great variety of wellknown artistic or technical illustration techniques.
However, the cutaway (or breakaway) shape used by
Diestraten is regular polygon. Our application concerns
orthopaedic surgery planning and we wish to create an
incision that, firstly, reflects the shape expected by the
surgeon when retracting the skin from the incision and,
secondly, has some parametric control so that the
resulting shape can be tuned to reflect the different
stretching properties of the skin of individual patients,
depending upon their physical characteristics. Clearly, in
this situation, it is inappropriate to use straight edges to
represent the hole.
In this paper, we propose a novel approach to cutting a
specific shape on a surface which is represented by a 3D
polygonal mesh. The shape is firstly defined in a 2D
plane, and OBBTree analysis for the surface is used to
project this user-defined shape on to the surface in 3D
space. A cutaway on the surface is generated to show the
cut according to the projection of the user-defined shape
on the surface. The problem of jittering of the boundary
of the cutaway generated by the above steps is also
resolved.
This remainder of the paper is organised as follows:
the detailed algorithm is outlined in Section 2, which
includes the initial assumptions, an overview of the
algorithm, and the detailed steps of the cutaway;
experiments are described in Section 3, and conclusions
are presented in Section 4.

2. Algorithm Description
2.1 Assumptions and definitions
Some assumptions are made which do not affect the
generality of the approach. Interior objects are not sliced
by the cut-out geometry – cutting is applied to the exterior
surface only. The exterior object is formed of a 3D
polygonal mesh – we shall assume that it is defined as a
triangular mesh and that there is no self-intersection. The
shape used to define the cut in the surface can be a curve,
a polygon, etc., but it has the properties that consists of

lines and points and it does not self intersect. In summary
the assumptions are:
(S1) interior and exterior objects have to be distinguished
from each other
(S2) the exterior object consists of a 3D triangular mesh,
denoted IS
(S3) the exterior object does not self-intersect
(S4) the shape used to cut the surface consists of coplanar
lines and points, and is denoted as US
(S5) the shape does not self-intersect

2.2 Overview of the algorithm
OBBTree
Generation
for IS

Calculation of
approximate
shape of US

Ö

Ö

Cutaway
generation
on IS

Ö

Jittering
boundary
smoothing

Figure 1. Overview of the algorithm

The algorithm consists of the four steps illustrated in
Figure 1. Although other forms of tree exist (e.g. AAAB,
Sphere) to represent 3D objects, the OBB Tree encloses
the object more tightly. In addition, we can add useful
data to the node of the tree for our purposes. To generate
the approximation with the required shape on the surface,
the BSP tree is employed to speed the search for the
closest points in US and obtain the projective points on
the outer surface IS, and then we use a clipping algorithm
to generate a cutaway that is very similar to that of
Diepstraten et al. [3]. To resolve the jittering of the
boundary, we need adaptively to subdivide two points
into more points and project them on to the IS.

where n is the number of triangles, pi = pi − µ ,
q i = q i − µ and ri = ri − µ . These last terms
represent the vector from a vertex to the centroid.
The approach uses a statistical technique, principal
components analysis, that finds the best fit for 3 primary
axes (the principal components) to minimise the square of
the distance of each vertex from its centroid.
As C is symmetric, its eigenvectors will be mutually
orthogonal. Two of the three eigenvectors of the
covariance matrix are the axes of maximum and of
minimum variance. The normalised eigenvectors are used
as a basis as they will tend to align the box with the
geometry of a tube or a flat surface patch.. We find the
extremal vertices along each axis of the basis, and size the
bounding box, oriented with the basis vectors, to bound
those extremal vertices.
In fact, OBB analysis goes further and works with the
convex hull, but in our case the convex hull and the
surface of interest are the same as there are not large
numbers of interior elements in IS.

2.3 OBBTree Analysis of the Outer Surface
Although an Axis Aligned Bounding Box (AABB) is easy
to construct to represent the object, an Oriented Bounding
Box (OBB) [6] provides a better object approximation.
An OBB is a bounding box that does not necessarily line
up along the coordinate axes. The difference between an
AABB and an OBB is depicted in Figure 2, where it is
clear that the OBB more tightly encloses the object.
OBB generation requires the following:
− the centroid of triangle i, mi = (pi + qi + ri)/3, where
pi , qi and ri are the vertices of triangle i
− the centroid, µ, for the whole IS

µ=
−

1 n
¦ ( pi + qi + ri ) ,
3n i =1

where n is the number of triangles of IS
the 3×3 covariance matrix C, given by:

C

j ,k

=

1
3n

¦ [p i j p ik
n

i =1

+ q i j q ik + ri j ri k

]

(1)

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE

Figure 2. Comparison of (a) AAAB and (b) OBB

The OBBTree is a tree structure of such bounding
boxes, where deeper levels of OBB confine smaller
regions of space. OBBTree has proved to be a tight-fitting
hierarchical structure and an efficient overlap-testing
algorithm for interference detection amongst complex
models undergoing rigid motion.
To build the OBBTree, a recursive, top-down process
is used. First, the root OBB is constructed, as above. To
create two child OBBs, a split plane is found that
(approximately) divides the number cells in half. This
process then continues until the threshold limits the
recursion, or no split plane can be found.
To perform this, we find the maximum and minimum
extents of the original triangle set along each axis, then
split the longest axis of the OBB with a plane orthogonal
to one of its axes, partitioning the polygons according to
which side of the plane their centre point lies on. The
subdivision coordinate along that axis is chosen to be that
of the mean point of the vertices.

Traditionally the OBBTree is used for collision
detection. We extend the tree by, additionally, saving
th
every centroid mi in the i node ni; we aim at organising
the data and find our closest points for US generation
afterwards. Therefore, the OBBTree for the IS can be
denoted as:

ISOBB = { n1 , n2 ,… nm }

(2)

where node ni = {OBBi, mi }, OBBi is the normal
OBBTree node and m is the number of OBBtree nodes.

2.4 Generation of Approximate Shape on Surface
When we compute the approximate shape IS represented
by OBBtree, we need to consider techniques that enable
us to access the geometrical database for the centroid of
all nodes on OBBtree quickly. Figure 3 depicts the
concept of "binary space partitioning" in 2D space.

Figure 3. Divide space with BSP. The middle
picture is Y-X axis order partition, and the right
is X-Y axis order partition
Using Binary Space Partitioning (BSP), we can divide
the space into smaller regions. Since each region is
associated with an object or a group of objects, we can
eliminate some unnecessary checks as we march along the
branches of the binary search tree from top to bottom.
Partitioning of space can be achieved using the minimum
and maximum coordinates of the objects – as an
illustration, see the middle picture in Figure 3: minimum
and maximum y coordinates of the objects are projected
to the Y-axis to sort the objects and to partition the space
along the Y axis, and followed X-axis to sort the objects.
We construct the BSP according to all centroids mi of
the leaf nodes in ISOBB along different the X,Y,Z axes
order, respectively, the BSP tree can be represented as
three different directions e.g., X-Y-Z order,Y-X-Z order,
ISBSP ={ BSP1 , BSP2 , BSP3 }
(3)
Assumption S4 indicates that US consists of points
(where the profile is curved), together with straight line
segments. The BSP tree is employed to accelerate
matching the elements in US to the closest points on the
surface IS.
We can find the closest node i in BSPk (k=1,2,3) e.g.
node BSPki to point P on US. If BSP1i, BSP2j, BSP3k is the
closest BSP node to P, and i, j, k do not need to be the
same, the minimum distance from P to BSP1i will be the
approximate projective point of P on IS. Let vector xi,xj,xk

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE

denote the coordinates of BSP1i, BSP2j, BSP3k
respectively. the approximation projection point Pƍ of P
on surface IS can be represented as:
3

min x
i =1

i

−P

(4)

The whole process for calculation projects can be written
in pseudocode as below.
// project the approximate shape of US on to 3D outer
// surface, IS
// V is the set formed by projecting US on to IS
V = {};
for each point P in the 2D user-defined shape US do
{
find the closest node on OBBTree
generate its projected point Pƍ
V = V ∪ { Pƍ }
}
After the projected set is computed, the crucial point
of the algorithm is clipping the area inside the projective
region of US. Let US’ represent the shape of US projected
on to IS, then US’ acts as a clipping window – the area
within US’ will be clipped away. The algorithm has been
integrated in VTK [7], and it can implement clipping
away automatically.

2.5 Eliminating Jittering
If the distance between two adjoining projection points
covers more than two triangles, jittering of the boundary
may occur.

Jitter
Position

(a) Existence of Jittering

(b) Elimination of Jittering

Figure 4. Elimination of jittering on the boundary

In Fig. 4, the dark area represents the cut shape. Fig.
4(a) shows the presence of jittering, and (b) shows the
boundary after it has been eliminated.
Some additional “projection” points on IS between the
two points are calculated to eliminate jittering on the

boundary. Figure 5 shows an example of generating a new
projected point – currently, the additional projected points
used to eliminate jittering are calculated by subdividing
the adjacent two points into more points.

Figure 5. Generating more projected points to
eliminate jittering

The black spheres in Fig.5 are the projected points and
the white sphere is a newly generated point. In our
algorithm, if the length between two adjacent projected
points is above a threshold, new points will be generated
between them. The procedure can be described as follows.
for each point Pi in V do
{
find its two adjacent points and place in the set Vpi
for each point Pj in Vpi do
if ||PjPi|| > LEN
// LEN is the threshold value
{
n = int ( ||PjPi|| / LEN )
divide PjPi into n equal sections Pj1, Pj2, … Pjn
project Pj1, Pj2,…,Pjn into Pj1ƍ, Pj2ƍ,…, Pjnƍ by the
closest node on OBBTree
V = V ∪ {Pj1ƍ, Pj2ƍ, Pj3ƍ ,…, Pjnƍ}
}
}

3. Experiments
The algorithm has been implemented in C++ using
OpenGL and VTK [7]. The application for which it is
being used is a surgical planner for the Total Hip
Replacement operation, which is a demonstrator
application for the Multisense project [8].
In this project, a multisensory environment, including
haptics, motion tracking, stereoscopic visualisation and
voice control are provided to allow the surgeon to plan the
operation and test whether any of the intended actions are
likely to cause damage to the patient, both during the
operation and in terms of post-operative capability.
The skin incision is the first step taken in the
operation. We aim to create an accurate shape of the skin
incision under the action of retractors positioned by the
user, according to the likely properties of the patient’s

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE

skin when stretched. The shape defined contains
parameters that enable the behaviour of the incision to be
adjusted as a result of user feedback.
Figure 6 illustrates the specific shape used in the THR
application; it consists of two straight lines and four
adjustable spline curves. The straight lines represent the
positions of the metal retractors that are pulled to open the
incision to allow the surgery to take place. The cusps
represent the ends of the incision made by the surgeon.
Figure 7 compares our approach to that of Diepstraten
et al. [5], in which the breakaway (another style of
cutaway) consists simply of six straight lines, which is
clearly inappropriate for our particular application.
Table 1 indicates the computational time in test cases.
The additional time required for our calculation is easily
justified by the greater complexity of the shape the hasd
to be made in the external surface.
Table 1. Computational speed
No. of
triangles
4532
23800
3000

No. of
vertices
8521
35263
6421

Time Consumed
Diepstraten et al. Liang et al.
0.12ms
0.21ms
0.67ms
1.10ms
0.07ms
0.15ms

Algorithmic analysis
To compute the OBBTree, the computational complexity
2
is O(n log n), where n is the number of input triangular
meshes. If m is the number of points in US, the
computational complexity for generation of shape on the
surface is O(mlogn).

4. Conclusions
In this paper, we have proposed a novel approach for
performing a real-time cutaway of a predefined shape on
the exterior surface of an object. The advantage of our
algorithm is that the shape of the cut in the surface is
much more versatile than the regular, polygonal shapes
used in previous algorithms.
We adopted and extended the OBBTree to
approximate the outer surface and the BSP tree to
generate the predefined shape on the surface. Jittering
problems associated with the boundary generated were
resolved. Experiments have shown that our approach
works in real-time on an ordinary PC. It is being applied
to a surgical planner in the Multisense project.

Acknowledgements
This work was supported by the Multisense (IST-200134121) project, funded under the Information Society
Technology Programme of the European Commission and
Key project from Zhejiang Provincial Natural Science
Foundation under Grant No.Z603262.

References
[1] D Blythe, “SIGGRAPH 1999 Course: Advanced Graphics
Programming Techniques Using OpenGL”, 1999.
[2] D Dooley and M F Cohen, ”Automatic Illustration of 3D
Geometric Models: Surfaces”,.IEEE Computer Graphics
and Applications, 13(2):307–314, 1990.
[3] J Diepstraten, D Weiskopf and T Ertl, “Transparency in
Technical Illustrations”, Computer Graphics Forum,
21(3):317–325, 2002.
[4] J Hamel, S Schlechtweg and T Strothotte, “An Approach to
Visualizing Transparency in Computer-Generated Line

(a) Exterior Surface with Transparency

[5]

[6]

[7]
[8]

Drawings”, Proc. IEEE Information Visualization 1998, pp.
151–156, 1998.
J Diepstraten, D Weiskopf and T Ertl, “Interactive Cutaway
Illustrations”, Computer Graphics Forum, 22(3):523-532,
2003.
S Gottschalk, M Lin and D Manocha, “OBB-Tree: A
Hierarchical Structure for Rapid Interference Detection”,
Proc. SIGGRAPH 1996, pp.171-180, 1996.
http://public.kitware.com/VTK/index.php
http://www.cineca.it/B3C/multisense/

(b) Surface with Cutaway

Figure 6. Illustration of the cutaway in THR

(a) Cutaway using current approach

(b) Breakaway using method of Diepstraten et al.

Figure 7. Comparison of profiles

Proceedings of the Computer Graphics, Imaging and Vision: New Trends (CGIV’05)
0-7695-2392-7/05 $20.00 © 2005 IEEE


2011 Eighth International Conference Computer Graphics, Imaging and Visualization

Highly Parallel Surface Crack Simulation
Shuji Hao, Mingqu Zhou, Zhongke Wu, Pengfei Xu, Hongming Zhang
College of Information Science and Technology, Beijing Normal University
Beijing, China
{hao.shuji@gmail.com, mqzhou@bnu.edu.cn, zhongkewu@gmail.com,
pengfeixu@gmail.com, zhm_hd@126.com }

Abstract—We show a parallel surface crack
generation algorithm based on physical method that
runs mostly on the GPU. According to existing
physically correct surface crack generation, our
algorithm firstly proposes a new data structure from
the given set of points and triangles, and then
computes where the crack should show up, and
finally defines how the mesh’s stress tensor updates
to generate surface cracks. A key insight of our
algorithm is constructing a novel data structure on
the GPU, which makes it faster to obtain the
neighborhood information of each vertex and
triangle. Moreover, a novel method that updates the
stress tensor and computes Separation Tensor in
real-time on the GPU has been presented. And we
got that our algorithm runs almost two orders of
magnitude faster than previous CPU algorithms via
a large number of testing. In order to support this,
images of crack teapot and apple generated from our
algorithm were shown.

structure consists of the node array and the triangle
array, which provides the neighborhood
information between nodes and triangles. And we
build the nodes’ neighbor triangles in real-time on
the GPU.
The other and obviously the most important
feature of our algorithm is updating the stress
tensor of the model and computing the separation
tensor entirely on the GPU. Based on the data
structure developed above, the algorithm firstly
performs parallel operation to update the stress
tensor of triangles, and then computes the nodes’
separation on the GPU. It is clear that our
algorithm fully utilizes the parallelism by
assigning a new thread for every vertex to
compute [2].
Based on the technology mentioned above, our
algorithm could generate surface crack in a short
time, which opens up new possibilities, for
example, it is possible to view the surface crack in
time.

Keywords: GPU, Crack generation, physically based
simulation, cracking, finite element method

I.

Introduction

Surface crack simulation has been an attractive
field for diverse applications such as cartoons,
computer games and so on. There are a number of
algorithms which could produce believable crack
images, however, all of these algorithms need
several hours to compute.
In this article, we show a highly parallel
algorithm to simulate surface crack based on
physical method [1] that runs mostly on the GPU.
We first proposal a new data structure from the
given set of vertexes and triangles, then compute
where crack should begin, and how to extend.
Different from the prior systems running on CPU,
our method executes most computation on the
GPU.
The basis of our algorithm is a novel data
structure constructing on the GPU. This data
978-0-7695-4484-7/11 $26.00 © 2011 IEEE
DOI 10.1109/CGIV.2011.17

Figure 1 Example of a crackle glaze apple.

In the figure 1, the image is generated from
21500 structured triangles. The crackle glaze apple

82

cost 1.65 hours computation using the CPU
algorithm, 0.41 hours on our GPU algorithm.
II.

Related Work

•

Surface crack simulation based on physics has
attracted researchers’ interest for a long time. Here
we present references most related to this paper.
A.T.Skjeltorp and P. Meakin [3] generated
crack patterns using the mass-spring system in
microsphere monolayers. And two-layered massspring system was presented by Hirota and
colleagues [4] to define stress and strain on the
surface, and laterly they produced cracks inside a
3D volume using the tetrahedral configuration [5].
James F. O’Brien and Jessica K. Hodgins [6] used
the stress tensors to compute over a finite element
model to determine where the cracks initiate and
how they propagate. Kimiya Aoki and colleagues
[7] described an approach to synthesize cracking
patterns in a 3D freeform object by its
approximate quantized shape and the mesh
relation of its original shape, than they use this
method to simulate the external cracks and internal
cracks.
Yun-Ta Tsai and colleagues [8] used cubes as
the internal volume and applied FEM to simulate
fracture on an interactive environment. Based on
FEM, Hayley Nicole Iben [1] uses heuristic
methods to define as stress field and generates
cracks pattern on a variety of materials, including
glass, mud, rock, and ceramic glaze .Our approach
of simulate crack pattern is based on the work
presented in [1].
III.

n.tensileForce, and the array of tensile force
each of the neighborhood element exerts on
the node, n.tensileForceEach.
The separation tensor computed from the
above information, n.separationTensor, the
max
eigenvalue
and
corresponding
eigenvector of the separation tensor,
n.maxEigenValue and n.maxEigenVector.

ElementArray and maxEigenvalueArray are
relatively simple. ElementArray contains three
vertex of the triangle: e.nodeIndex,which points
the index of the NodeArray; the stress of the
element e.stress; barycentric matrix [6] used for
converting a point from local triangle coordinates
to the barycentric coordinates, e.barycentric.
MaxEigenvalueArray contains the max
eigenvalue and the corresponding index of each
node, which is used to find biggest eigenvalue of
all the max eigenvalues by carrying out parallel
reduction operations [9].
B. GPU Data Structure Implementation
We firstly read each node’s position and
element’s three vertex index in the node array, and
then, initiate the other information of the data
structure on the GPU.
Listing 1 Initiate the NodeArray, ElementArray,
MaxEigenvalueArray
1: //Step 1: read data file
2: Initiate each node's xyz position and each element'
3: index by reading the data file

GPU Data structure Construction

3: //Step 2: Compute other parameters in the node and
4: element arrays.
5: for each element i=0 in ElementArray In Parallel
6: ElementArray[i].stress=m_stress
7: compute barycentricMatrix for each element
8: ElementArray[i].barycentric=barycentricMatrix
9: for each j=0 to 3
10:
tmpIndex=ElementArray[i].nodeIndex[j]
11:
NodeArray[tmpIndex].neighborElement.add(i)
12: //Compute comressive force,cforce, and tensile
13: //force, tforce
14:
NodeArray[tmpIndex].compressiveForce
15:
+=cForce
16:
NodeArray[tmpIndex].compressiveForceEach.
17:
add(cForce)
18： NodeArray[tmpIndex].tensileForce+=tForce
19： NodeArray[tmpIndex].tensileForceEach.
20:
add(tForce)

In this section, we firstly describe the design of
our data structure suitable for crack simulation.
Secondly, we present how to implement the key
procedure of the structure on the GPU.
A. Data Structure Description
Our data structure consists three arrays:
NodeArray, ElementArray, MaxEigenvalueArray.
In the NodeArray, each node n records the
following information:
• The xyz position of the node, n.pos, reading
from the model.
• The neighborhood element array of node,
n.neighborElement.
• The sum of compressive force [1]
neighborhood elements exert on the node,
n.compressiveForce, and the array of
compressive force each of the neighborhood
elements exerts on the node,
n.compressiveForceEach.
• The sum of the tensile force [1]
neighborhood elements exert on the node,

21: //Step 3: compute each node's separation tensor and
22: //the max eigenvalue, initiate the MaxEigenvalue
23: //Array
24: for each node i in NodeArray
In Parallel
25: compute separation tensor and the max eigenvalue
26: mEigenvalue of the separation

83

27:

the mesh. Consequently, the time complexity will
become bigger as long as the growth of numbers
to crack the mesh, especially when using a mesh
consisting of a large number of vertexes and
triangles. With the assistance of modern GPU
architecture [2], we allocate a thread for each node
or element in order to update the arrays in parallel
by making heavy use of the neighborhood
information constructed in section III.
We focus on the step 1 and step 3 in this
section to accelerate the algorithm on the GPU,
crack two nodes at a time until users want to stop
or no max eigenvalue exceeds the material
toughness threshold.

MaxEigenvalueArray[i].mEigenvalue

Listing 1 presents the pseudo code for
initiating the three arrays mentioned above. In the
first step, we read the node’s position and the
element’ index to initiate n.pos and e.nodeIndex.
In the second step, we firstly initiate the
element’s stress using the data user defined,
calculate the barycentric matrix, then initiate the
nodes’ information e.nodeIndex points, including
the node’s neighborhood element array,
compressive force and tensile force. All of these
procedures are implemented on the GPU. We also
adopt the similar procedures to update the
information when every crack happens.
In the third step, we compute every node’s
separation tensor according to the compressive and
tensile force, and then get the max eigenvalue of
the separation. At last we update the
maxEigenvalueArray so as to decide which node
should crack and the direction of the crack.
IV.

Listing 2 Crack Generation
1: //Step 1: find the biggest eigenvalue of the
2: // MaxEigenvalueArray
3: find the biggest eigenvalue in MaxEigenvalueArray
4: array using the Reduce primitive.
5: //Step 2: Crack mesh at the node found above.
4: crack mesh at the node using algorithm in [1]

GPU Surface Crack Generation

5: //Step 3: Update the ElementArray
6: for each I in ElementArray In Parallel
7: compute ElementArray[i].barycentric
8: shrink ElementArray[i].stress
9: for each j in ElementArray[i].nodeIndex[3]
10:
compute:NodeArray[j].compressiveForce,
11:
NodeArray[j].compressiveForceEach,
12:
NodeArray[j].tensileForceEach,
13:
NodeArray[j].neighborElement

In this section, we present the steps of
algorithm [1], and describe the way to accelerate
the algorithm on the GPU.
A. The algorithm
The algorithm mainly consists of three steps
after the initialization mentioned above:
a)

Find the node that the model begins to crack
from;
b) Crack the mesh at the node we find in the
step a);
c) Update the arrays we describe in the section
III, and back to step a).

14: //Step 4: Update the NodeArray and
15: // MaxEigenvalueArray
16: for each I in NodeArray In Parallel
17: compute: NodeArray[i].separationTensor,
18: NodeArray[i].EigenValue,
19: NodeArray[i].EigenVector,
20: MaxEigenvalueArray[i].eigenvalue

Firstly, we compute the biggest eigenvalue in
maxEigenvalueArray by implementing parallel
reduction operations [9] on the eigenvalues of all
nodes.
Secondly, we crack the mesh at the node along
the eigenvector corresponding to the eigenvalue
found in the first step, we adopt the strategy
described in [1]. And update the nodes’ and
element’s information influenced by the crack.
Thirdly, after cracking the mesh, we compute
the barycentric matrix of the elements whose
nodes’ positions changed, and then shrink the
tensile of the element by using uniform strategy.
At last, we calculate the compressive force and
tensile force for each node of the element, and
update the neighborhood element of the nodes.
Finally, we calculate the separation tensor of
each node by heavily using the forces computed

In the first step, we find the node where crack
begins by the max eigenvalue of the separation
tensor in the maxEigenvalueArray, and determines
the direction of crack according to the eigenvector
corresponding to the max eigenvalue. In the
second step, we calculate the intersection point
between the crack line and the edges of the
element, and update the local topology of the
model. At last, we update the tensile of each
element, and then calculate the force of each node.
If users want to continue crack and we could find
the crack node satisfying the criteria user defined,
the algorithm goes back to step a).
B. GPU Implementation
Based on statement above, we should find the
biggest eigenvalue in the maxEigenvalueArray,
update all of the elements’ tensile, and compute
the whole nodes’ forces every time when cracking
84

from the last step, meanwhile, update the
maxEigenvalueArray for the next crack.
We find that most of the time is used to locate
where to crack and update the arrays. Meanwhile,
the process to update the arrays could be done in
parallel with the aid of data structure constructed
in section 3 and the GPU architecture.
V.

Results and Discussion

We have implemented our crack simulation
algorithm on an Intel Xeon E5506 @ 2.13GHz
Duo with a Nividia Quadro FX580 (512MB)
graphics Card.
We tested our algorithm on a variety of models.
As shown in Figure 1, our GPU algorithm is
capable of generating highly similar cracks. On the
part of performance, our GPU algorithm is nearly
two orders of magnitude faster than the CPU
algorithm. For example, the CPU algorithm takes
1.42 hours for a crack image of the teapot model,
however, it only cost 0.35 hours to generate the
same crack image using our GPU algorithm.

Figure 3: Example of a crackle glaze teapot 2

VI.

Conclusion and Future Work

We have presented a parallel crack simulation
algorithm that runs mostly on the GPU. For largesized model data, our GPU algorithm generates
highly similar crack surfaces, which is nearly two
orders of magnitude faster than CPU algorithms.
Our GPU algorithm also opens up new possibility
of interactive simulation.
There are several ways in which we could
improve and extend:
• Improve the algorithm to enable the
interactive way to simulate the crack.
• Extend the approach to incorporate the
algorithm in the game.
• Extend the algorithm to allow fracture
simulation.

REFERENCE
[1] Iben H. N.: Generating Surface Crack Patterns,
PhD Thesis. 2007.
[2] NVIDIA, 2011, CUDA Toolkit 3.2.
http://developer.nvidia.com/cuda-toolkit-32downloads
[3] Skjeltorp A. T. and Meakin P.: Fracture in
microsphere monolayers studied by experiment and
computer simulation. Nature, (Sept. 1988),
335:424–426.
[4] Hirota K., Tanoue Y., and Kaneko T.: Generation
of crack patterns with a physical model. The Visual
Computer, (1998), 14(3):126–137.
[5] Hirota K., Tanoue Y., and Kaneko T.: Simulation
of three dimensional cracks. The Visual Computer,
(Nov. 2000), 16:371–378.
[6] O’Brien J. F., Hodgins J. K.: Graphical Modeling
and Animation of Brittle Fracture. Computer
Graphics Proceedings, Annual Conference Series.
(1999)
[7] Aoki K., Dong N. H., Kaneko T., and Kuriyama S.:
Physically based Simulation of Cracks on Drying
3D Solid. Proceedings of the 10th Pacific
Conference
on
Computer
Graphics
and
Applications, (2002).

Figure 2: Example of a crackle glaze teapot 1

Because we are using the structured triangle
models generated from Autodesk 3ds Max 8, one
limitation of our GPU algorithm is that it brought
unnatural regularity in the cracks.
In the figure 3, the image cost 3.58 hours
computation using the CPU algorithm, 1.23 hours
on our GPU algorithm. Both of the crackle images
were generated from 10744 structured triangle
meshes.

85

[8] Tsai Y.T., Chang J. S., Lin C. Y.: Practical Realtime Fracture Simulation for Games. http://wwwscf.usc.edu/~yuntatsa/.( 2005).
[9] Popov S., Günther J., Seidel H. –P., and Slusallek
P.: Stackless kd-tree traversal for high performance
GPU
ray
tracing.
In
Proceedings
of
Eurographics’07, (2007), 415–424.

86


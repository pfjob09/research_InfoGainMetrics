A Method Used To Dynamic Scene Management Based On Octree
Huaiqing He, Yu Zhang, and Haohan Liu
College of Computer Science and Technology, Civil Aviation University of China
huaiqinghe@yahoo.com.cn, zyzy101@hotmail.com

Abstract
At present the most important things on scene
rendering in computer graphics are fidelity and
efficiency. In order to achieve these goals, a
considerable number of applications require a data
structure like a tree to manage the entire scene.
Searching the scene means to traversal the tree and
moving objects in the scene means to recreate the tree,
which are very costly but unavoidable process. In this
paper, we establish an octree for managing the whole
scene and encode the nodes in the tree. Through a
simple process of calculation from one node’s code, we
can get this node’s adjacent nodes’ code. With the
orderly structure of the octree, we have obtained the
target that is searching the nodes in the octree and
recreating part of the octree efficiently.
Key Words: Dynamic scene management, Octree,
Encoding

1. Introduction
In the highly realistic scene rendering, it is useful to
use a tree structure to mange the data of the scene, such
as the BSP tree, the kd tree and the octree etc [1] [2].On
this way, we partition the scene, store the data into the
leaf node of the tree. But it is possible to traversal the
tree to find a node that we want. In dynamic scene, the
tree’s structure will change when the objects are
moving, so we still need to concern on the re-creating
of the tree’s structure. Comparing to the BSP tree and
kd tree, the octree is easy to control and be watched,
and can be partitioned with different requirement. As a
widely used tree’s structure in computer graphics,
octree has lots of applications in different field. Just as
the ray tracing, lots of work have been done on it [3] [4]
[5] [6]
, and the kd-tree also is a useful structure to do it [5]
[6]
. With the dynamic scene, the dynamic irregular
octree had been proposed [7]. In fact, the process of
traversal the octree is the process of finding a series of

Computer Graphics, Imaging and Visualisation (CGIV 2007)
0-7695-2928-3/07 $25.00 © 2007

nodes needed. Several algorithms for octree traversing
have been proposed. They can be classified into two
groups. One is bottom-up methods in which traversing
starts at the first terminal node intersected by the ray. A
process called neighbor finding is used to obtain the
next terminal node from the current one [8] [9] [10].The
other is top-down methods: These methods start from
the root node (that is, from the one covering all
others).Then a recursive procedure is used. From the
current node, its direct descendants hit by the ray are
obtained, and the process is (recursively) repeated for
each of them, until terminal nodes are reached [11] [12] [13]
[14] [15]
. But all of them are lack of discussion on how to
change a tree when some objects have moved. This
paper present a method for managing dynamic scene
based on octree. The following is structured as follows:
Section 2: method of encoding. We introduce
briefly the way we encoding the octree.
Section 3: Introduce the data structure and method
that we use to manage the dynamic scene.
Section 4: Though experiment, we get conclusions
from the results and set the goals for future work..

2. The way of encoding the octree
We encode every node in the octree, to a giving
node, searching its neighbor nodes by code and the
structure of the octree [16]. As Fig.1 shows, the basic
system of linearity octree’s encoding is listed as
follows:
North Set: N8 = {0, 1, 4, 5};
South Set: S8 = {2, 3, 6, 7};
West Set W8 = {0, 2, 4, 6};
East Set E8 = {1, 3, 5, 7};
Up Set U8 = {0, 1, 2, 3};
Down Set D8 = {4, 5, 6, 7}.
If the node that encoding with 0 need to partition,
then its eight son nodes’ code with the same order
shows in Fig.1 are as follows: 00, 01, 02, 03, 04, 05,
06, 07. And the other is the same. To one node’s code
A = q1q2…qi…qn, we judge whether it is border node

0

1

y
2

3

4
6

5
7

z

x

Fig.1.The basis system of linearity octree’s encoding
first. To one node’s code A = q1q2…qi…qn, we judge
whether it is border node first, then its eastern neighbor
or southern neighbor or western neighbor or northern
neighbor or up neighbor or down neighbor doesn’t
exist, which has a commonalty surface with the given
node.
Then we can compute its neighbors’ code by its
own code, but attention that, the computation here will
adopt octal means. The up neighbor's and down
neighbor’s code is computed like this: if qn belongs to
the up set, we can get its down neighbors’ code is A +
4, but its up neighbor’s code must be computed as
follows: scanning the code from the right to the left and
start from the end of the code qn, until find the first bit
qi that doesn’t belong to the up set (1≤i≤n- 1, i is the
number of the bits from the left to the right).
Obviously, the n – i bits in the right are all belong to
the up set, then add them value by 4, minus qi’ value by
4, and the left bits q1q2…qi-1’ value don’t change. Then
the new code is the up neighbor’s (if we can’t find a bit
that doesn’t belong to the up set, means this node is the
up border node, its up neighbor doesn’t exist, below
similar). If qn belong to the down set, we can get its up
neighbor’s code is A - 4, but its down neighbor’s code
must be computed as follows: scan the code from the
right to the left and start from the end of the code qn,
until find the first bit qi that doesn’t belong to the down
set (1≤i≤n- 1, i is the number of the bits from the left
to the right). Obviously, the n – i bits in the right are all
belong to the down set, then minus them value by 4,
add qi’ value by 4, and the left bits q1q2…qi-1’ value
don’t change. Then the new code is the down
neighbor’s.

Computer Graphics, Imaging and Visualisation (CGIV 2007)
0-7695-2928-3/07 $25.00 © 2007

To the given node’s eastern, southern, western and
northern neighbors’ code, the method that we compute
them is the same when the last bit qn is 0 or 4, 1or 5, 2
or 6, 3 or 7.
When the last bit qn is 0 or 4, its eastern
neighbor’s code is A +1, southern neighbor’s code is A
+2. To its eastern neighbor, we scan the code from the
right to the left and start from the last bit qn, until find
the first bit qi (1≤i≤n – 1）that doesn’t belong to the
eastern set. Obviously, the bits on the right side of qi
are all belong to the eastern set, we add them’s value
by 1, minus qi’s value by 1, and the left bits q1q2…qi-1’
value don’t change. Then the new code is the eastern
neighbor’s. To the northern neighbor, searching the bit
qi that doesn’t belong to the northern set, minus its
value by 2, add the value of the bits in the right side of
qi by 2 , and the value of the bits in the left side of qi
don’t change. As shown in Tab.1, a node’s neighbors’
code is given by its last bit qn. In this way, we can get
one node’s neighbors’ code from this given node’s
code. This method will be used in our management for
dynamic scene. And the situation that a node’s
neighbor’s lever isn’t as the same as the given node’s
lever will be discussed in the next section. The method
we have discussed is used to compute the neighbor that
has the same size with the given node.

3. The method for management
Octree has been chosen for organizing the whole
scene, it can partition the space of the scene. The
standard of division is that the largest number of
objects in a single node of the octree. Before
discussion, two assumptions have been raised in order
to facilitate operation. First, assuming the whole scene
space occupied is much larger than the space occupied
by the all objects in the scene. Secondly, assuming the
octree has been established, the space occupied by the
largest objects in the scene will not exceed the smallest
node scope in the octree. In other words, there will be
no object in the octree occupied more than one node’s
space when the octree just been established, and that
situation will not happened when the structure of octree
has changed. The main problem that considered is how
the structure of octree changes when the objects in the
scene have moved or changed. In this process, it is not
real to recreate the entire tree, which will spent more
time and impact efficiency of the method. It is
impossible that the structure of the octree do not
Table 1. Details of encoding

0
or
4

1
or
5

2
or
6

eastern
A+1

add qi by
1, minus
right of it
by
1,
others
don’t
change
A+1

southern
A+2

A+2

western
Minus qi
by 1, add
right of it
by
1,
others
don’t
change
A-1

northern
Minus qi
by 2, add
right of it
by
2,
others
don’t
change
Minus qi
by 2, add
right of it
by
2,
others
don’t
change
A-2

add qi by Minus qi
2, minus by 1, add
right of it right of it
by
2, by
1,
others
others
don’t
don’t
change
change
3
add qi by add qi by A-1
A-2
or 1, minus 2, minus
right of it right of it
7
by
1, by
2,
others
others
don’t
don’t
change
change
change in this process, for it is difficult to show the
changes. It is a better choice to recreate the part of
octree whose objects have changed. Accordingly, we
separate the data of objects in the scene and the data of
octree, it is not related to the specific data of objects in
the tree, only store the pointers of object. In this way, it
is only needs moving the pointer of an object than
moving the whole data of an object when objects have
changed. For example, now an object M is in node A
(A is one of the leaf nodes, the same below), M will
move forward to the A’s right neighbor B, as shown in
Fig.2. We need only to restore the pointer of M from A
to B, and delete the pointer in A.

3.1. Creating the octree.
The process of establishing the octree as follows:
Step 1, generate a root node and put all the objects
in the scene to this node;
Step2, judge whether this node meet the
requirements of division (for example, there is the
largest number of objects can exist in a single node). If
meet the requirements, then we get the position that

Computer Graphics, Imaging and Visualisation (CGIV 2007)
0-7695-2928-3/07 $25.00 © 2007

M

M

Fig.2. A sample of object’s movement
the objects is placed in the node, and generate a new
node where the objects placed. Put the pointer of the
objects to the new nodes from their parent node, then
delete them from the parent node.
Step 3, repeat step2 to each of the child node untill
there is no leaf node can be divided. Finally only the
leaf nodes have the objects. Therefore, assumption that
after the initialization of the scene, the tree structure is
shown as followed (the nodes that don’t have object are
not shown):
The root node

Level 0

Level 1

Level 2
...
A

B

Level n

Fig.3. A sample of octree structure
Reference to Fig.2, node A and node B are the
adjacent nodes; the object M move from A to B, in
accordance with the above description, the pointer of
M will be put in node B. To avoid traversal the entire
tree to determine the location of B, while the tree
established, we adopt a structure (such as MAP) to
store the leaf nodes that have objects inside and their
code, shown as in Tab.2:
…
…

Table 2. A sample of MAP structure
The code of …
The code of …
A
B
The pointer …
The pointer …
of A
of B

3.2. Management of dynamic scene
3.2.1. The application of code. Then we can calculate
the right neighbor B’s code of A, and search the
structure mentioned above in order to get the pointer of
B. As the method for calculating codes is considered as
the same level of nodes, so there is a situation that we
can’t find B, which means node A and node B is not at
the same level, irregular treatment will be adopted.
Based on the assumption 1, the number of leaf nodes
that have objects inside is far less than the number of
all leaf nodes, so the MAP structure will not use too
many additional storage spaces. Therefore, searching
node B like this is far efficient than traversal the tree to
get B’s position. In fact, in the general space scenes,
such an assumption is always established, so the
method is feasible. The whole process of judgment is
shown as follows:
while（objects are moving）
If（will cross the node right now）
If （the node is border node）
Stop moving, End
Else
Calculate the code though movement
If（can search the code in the MAP）
Do with the pointers of objects
Else
Do with the nodes with different levels
Do with the pointers of objects
Re-create part of the tree, End
3.2.2. The method to deal with the adjacent nodes
which are not at the same level. In practical tests,
such situation always happened. So this is the main part
of our method that results in efficiency. In the
following discussion, in order to facilitate the
operation, we use the two-dimensional quadtree to
replace the three-dimensional octree. However, the
method is the same. There are two situations: objects
move from a lower level node (whose size is larger) to
a higher level node (whose size is smaller) or vice
versa.
As shown in Fig.5.a and 5.b, when the object M
moves from a low level node to a high level node, in
fact the code we calculate from the method that
mentioned above is the node B’s code q1q2…qi…qn, so
we can’t find B in the current MAP. The code we need
is the node B2’s. Obviously, the codes in the MAP
whose bits number less than n are not meet
requirement. Searching the code as the principle that
the two codes matched perfectly from left to right in
the remaining codes, we will get the code like
q1q2…qi…qn …q n + m. If we can’t get such a code, the

Computer Graphics, Imaging and Visualisation (CGIV 2007)
0-7695-2928-3/07 $25.00 © 2007

situation is shown as Fig.5.c and 5.d. Then we chose
the code q1q2…qi…qn …q n + m with less number of bits,
find its parent node, until the parent node’s code is
q1q2…qi…qn, and this node is the current node B. Get
the intersection P that between A and B that M move
to, calculate the intersection’s position in node B. If B
has an existed node in the same position, then add M to
this node and judge whether it should be divided, as
shown in Fig.5.a. If B has not an existed leaf node in
the position, then generate a new node whose parent is
B, and add it into the octree, as shown in Fig.5.b. If B
has an existed non-leaf node, then repeat the process
until get the exact position of the target node.
As shown in Fig.5.c and 5.d, when the object M
move from a high level node to a low level node, the
node whose code we calculate from the method that
mentioned above is the a part of node B. So we remove
the last bit, the code become to q1q2…qi…q n – 1, then
search the new code in MAP as the principle that the
two codes matched perfectly from left to right, if we
can get the correct one (there is q1q2…qi…q n – 1 in the
MAP), this situation is shown in Fig.5.c. Then put the
pointer of M into this node and judge whether need
partition. If there is no correct one in the MAP, but we
can find some code as q1q2…qi…q n – 1 …q n – 1 + m, then
choose one with less bits, find its parent node, until its
parent’s code is q1q2…qi…q n – 1, it is node B as shown
in Fig.6.d. Get the intersection P that between A and B
that M move to, calculate the intersection’s position in
node B. And at this position (P), there isn’t existed a
leaf node with objects. If there is not existed leaf node
at that position, then generate a new node whose parent
is B and add it to the octree. The object M belongs to
the new node now. If there is a existed non-leaf node,
then the situation has become as shown by Fig.5.a and
5.b. If it still can’t get a result, then remove the last bit
again, the code become to q1q2…qi…q n – 2. Do the
same thing mentioned above to the new code. If the
code is 1 bit now and still can’t get the result, then
generate a new code as child of the root node at the
position and add it into the octree.
In the example that we discussed, node A is always
exist as a leaf node with objects inside, after the object
M leave node A. If there is still other objects exist in
the node, then the octree structure don’t change. If
there is no object in node A now, we first delete node
A from the octree structure and the MAP, after that,

A

B
P

a. M moves from a high level node A to
a low level node B2, which is an existed
leaf node with objects
A

B

b. M moves from a high level node A to
a low level node B2, which is an existed
leaf node without objects
A

B

c. M moves from a low level node A3 to
a high level node B, which is an existed
leaf node with objects
A

B

d. M moves from a low level node A3 to a
high level node B, which is an existed leaf
node without objects
Fig.5 The movement across nodes have different levels
considering A’s parent node still meet the requirement
of division. If it still meet the requirement, then the
structure of octree don’t need other change, if it don’t
meet the requirement now, then we delete the node’s
other children and put the pointer of the objects in other
children into their parent node, add this node into the
MAP. To the node that M is move to, after things
mentioned above done, delete the leaf node that aren’t
existed in the tree from the MAP, and add the new leaf
node with objects.

Computer Graphics, Imaging and Visualisation (CGIV 2007)
0-7695-2928-3/07 $25.00 © 2007

When we couldn’t find the calculated code
q1q2…qi…qn , then the first thing we must face is to
choose the object moving from high level node to the
low level node or the object moving from low level
node to the high level node. In fact, there is only one
possibility, so we should avoid unnecessary judgement
and calculation. Assumption that, the deepest level in
the tree is based on our definition, one node’s level is
lager at the numerical value, which is a low level. If
node A’s level n < a /2, so we first consider this
movement is to the lower level. In other words, to a
object M move from node A to node B, adopting the
method deal with movement from low level node to the
high level, if we can’t get the result after that, then
adopting the method dealing with movement from the
high level to the low level. If node A’s level n >= a /2,
dealing with the opposite way above.
3.2.3. view-frustum culling. Though the nodes in the
octree are all cubes, it is simple to carry on viewfrustum culling. Comparing the view-frustum with the
6 faces of the leaf nodes, it is easy to determine which
nodes are in the view-frustum totally, which are partly
in it or which are not in it. Thus we finish the culling
on the whole scene.

4. Experiment results and conclusions
The scene for testing is combined with 12 objects,
each of them has a great deal of data, and can move
freely in the scene. Before they start to move, the scene
and octree is shown in Fig.6. After a few second of
movement, the structure of octree of the scene is shown
in Fig.7. In the process, the octree changed with the
movement of the objects all the time with no halt. In
our example, the yellow lines is the nodes’ range, the
blue lines is the AABB boxes of the objects [17], which
can be used to collision detection. Contrast to the
dynamic irregular octree [7], our method is easy to
control, and facilitates the applications such as ray
tracing. It works very well as we thought, so it is a
useful method to manage the dynamic scene.

5. Prospect of future work
For lacking of enough time to test our method with
numerical number of objects, so this is the first thing
we should do next. After that, considering the
requirement of division, besides the largest number of
objects in one node, it always works if we adopt the
largest number of polygons of the objects in one node,
in this way, we can do some works with objects
simplifications to improve the rendering efficiency.

Reference:

Fig.6 The scene and octree before movement

Fig.7 The scene and octree after a few seconds of
movement

ACKNOWLEDGMENTS
This work has been supported by National Natural
Science Foundation of China grant 60572169 ， the
Scientific Research Foundation for the Returned
Overseas Chinese Scholars, State Education Ministry
grant D4200407, Tianjin Natural Science Foundation
grant 06YFJMJC00400, and Tianjin Natural Science
Foundation grant 05YFJMJC09200.

Computer Graphics, Imaging and Visualisation (CGIV 2007)
0-7695-2928-3/07 $25.00 © 2007

[1] GLASSNER A, An Introduction to Ray Tracing. Morgan
Kaufmann, 1989.
[2] HAVRAN V, “Heuristic Ray Shooting Algorithms” [Ph.
D. Thesis], Faculty of Electrical Engineering, Czech
Technical University in Prague, 2001.
[3] Aaron Knoll, Ingo Wald, Steven G Parker, and Charles D
Hansen, “Interactive Isosurface Ray Tracing of Large Octree
Volumes” proceedings of the 2006 IEEE Symposium on
Interactive Ray Tracing, 2006, pages 115-124
[4] Herve Bronnimann, Marc Glisse, “Cost-optimal trees for
ray shooting”, In Proceedings of the Latin American
Symposium on Theoretical Informatics, 2004.
[5] Alexander Reshetov, Alexei Soupikov, and Jim Hurley.
“Multi-Level Ray Tracing Algorithm”. ACM Transaction of
Graphics, 24(3):1176–1185, 2005.
[6] Ingo Wald, Philipp Slusallek, Carsten Benthin, and
Markus Wagner, “Interactive Rendering with Coherent Ray
Tracing”. Computer Graphics Forum, 20(3):153–164, 2001.
[7] Joshua Shagam, Joseph Pfeiffer, Jr., “Dynamic Irregular
Octrees”, Technical Reports, New Mexico State University,
2003
[8] A. S. Glassner, “Space Subdivision for Fast Ray Tracing”
IEEE Computer Graphics & Applications Vol. 4(10), pp. 1522 October 1984.
[9] H. Samet, “Implementing Ray Tracing with Octrees and
Neighbor Finding” Computer & Graphics Vol. 13(4), pp.
445-460, 1989.
[10] H. Samet, Applications of Spatial Data Structures:
Computer Graphics, Image Processing, and GIS. AddisonWesley 1990.
[11] M. Agate, R.L. Grimsdale and P.F. Lister, “The HERO
Algorithm for Ray Tracing Octrees” Advances in Computer
Graphics Hardware IV R.L. Grimsdale, W. Strasser (eds)
Springer-Verlag, New York, 1991.
[12] D. Cohen, A. Shaked, “Photo-Realistic Imaging of
Digital Terrains” Computer Graphics Forum Vol. 12(3), pp
363-376, 1993.
[13] R. Endl, M. Sommer, “Classification of Ray-Generators
in Uniform Subdivisions an Octrees for Ray Tracing”
Computer Graphics Forum Vol. 13(1),1994.
[14] F.W. Jansen, “Data Structures for Ray-tracing” Data
Structures for Raster Graphics L. Kessner, F.Peters, M. van
Lierop (eds). Springer-Verlag, 1985, pp. 57-73.
[15] I. Gargantini, H.H. Atkinson, “Ray Tracing an Octree:
Numerical Evaluation of the First Intersection” Computer
Graphics Forum Vol. 12(4), 1993.
[16] Xiao Lebin, Gong Jianhua and Xie Chuanjie, “A New
Algorithm For Searching Neighbors In The Linear Quadtree
And Octree”, Acta Geodaetica et Cartographica Sinica. Vol.
27, No.3, 1998.
[17] Gottschalk S, “Collision Dctection Using Oriented
Bounding Boxes” [Ph. D. Thesis]. Dept. Comput. Sci., UNC
Chapel Hill, 2000.


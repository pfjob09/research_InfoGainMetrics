An Improved Approach on Visualization of Large-Scale Terrain Surface
Huaiqing He, Chong Wang, and Haohan Liu
College of Computer Science and Technology, Civil Aviation University of China
huaiqinghe@yahoo.com.cn
Wangchong_cauc@yahoo.com.cn
Abstract
We propose an improved approach on visualization
of large-scale terrain surface based on ROAM
algorithm, within this approach, we study the issue in
two aspects: one is view-dependent LOD(Level of
Detail) control, the other is out-of-core data paging.
An efficient data structure is introduced into the aspect
of LOD control, on which coding method and none Tconjunction simplification algorithm is proposed.
Meanwhile, the corresponding data conjunction
method between different terrain blocks is given in the
aspect of out-of-core data paging. The purpose of
employing such a data structure is to improve the
efficient use of internal memory. The experiment
results show that our approach achieves real-time
LOD rendering for sufficient large-scale terrain and
saves much internal memory compared with traditional
ROAM algorithm.
Key words: ROAM algorithm, An efficient data
structure, coding, out-of-core, data conjunction

1. Introduction
Real-time rendering for large-scale terrain surface is
playing a key role in the virtual reality technology, and
it has a wide variety of application in many fields such
as geographic information system, flight or ground
driving simulating or 3D games.
There are two main categories in rendering
continuous LOD terrain model: One category is
irregular grid(TIN), another is regular grid(DEM).
Irregular grid for the same terrain in the same errors
requires less triangles, but regular grid has a merit that
the mesh it constructs is simple, rapid and the data can
be well read.
For the study of large-scale DEM terrain rending,
there are mainly two aspects: one is LOD control,
another is out-of-core data paging.
In the aspect of LOD control, Lindstrom, etc[1]
against DEM first proposed a dynamic multi-resolution

Computer Graphics, Imaging and Visualisation (CGIV 2007)
0-7695-2928-3/07 $25.00 © 2007

terrain rending algorithm, which lays the foundation
for multi-resolution
LOD terrain rendering.
Duchaineauy[2] proposed ROAM(real-time optimal
adaptive meshes) algorithm, which uses a binary tree
over the set of triangles and two queues are maintained
for splitting and merging operations, the algorithm
becomes the most widely used algorithm at present.
Yanqing Lu[3] propose an efficient framework for
large-scale terrain real-time visualization, however,
the data structure he uses contains a large number of
pointers which waste internal memory. Reference [4][5]
construct its LOD model with quadtree data structure,
but the basic idea of using quadtree is complex
compared with using binary tree.
In the aspect of out-of-core data paging, reference
[6][7]
proposed out-of-core visualization of large-scale
terrain relies on an approach of view-dependent
simplification, which makes use of consistency of
internal memory to organize terrain data from external
memory during the process of top-down refinement.
Leng Zhiguang, etc[8] proposed an algorithm to solve
the problem that LOD level on the adjacent terrain
borders does not match, however, the algorithm is
based on quadtree, and it is not applicable in our binary
tree data structure.
This paper is based on ROAM algorithm but
improves it in some aspects compared with YanQing
Lu[3], the algorithm in reference [3] uses lots of pointers
which wastes much internal memory space during
mesh simplification and refinement. In this paper, we
solve the problem by introducing an efficient data
structure, and accordingly propose the coding method
and none T-conjunction simplified algorithm,
meanwhile, an approach on data conjunction during
out-of-core data paging is also described.

2. Mesh Simplification
The basic thinking of mesh simplification in this
paper is to construct a data structure which is suitable
for the simplification in internal memory, and efficient

operations on the data structure is defined so as to
simplify the triangles in internal memory as soon as
possible and improve the utilization of memory space. .

2.1 Subdivision in Terrain Model
In our terrain visualization, data acquisition is a
group of equally sampled elevation data. To be
converted into simplified triangle mesh, we will
sample every one of the least square with its diagonal
subdivision into two triangles. Mesh segmentation
from rectangular to triangular process shown in Fig.1.

BinTriangle *leftChild; //left child
BinTriangle *rigntChild; //right child
Vertex *leftVertex;
//left vertex
Vertex *rightVertex;
//right vertex
Vertex *ApexVertex;
//apex vertex
Vertex *midVertex;
//mid vertex in hypotenuse
}BT;
To establish the data structure this way, we can
eliminate pointers that a node points to its left
neighbor, right neighbor and base neighbor as the
method used in reference [5], our approach only
increases an encoding attribute. On the coding method
we will introduce in 2.3. This data structure improves
the utilization of internal memory space, and it is
conductive to large-scale terrain mesh simplification.

2.3 Coding
Fig.1. the process of segmentation from rectangular
to triangular

2.2 An Efficient Data Structure
Terrain mesh subdivided from rough triangles to
refined triangles, we refer to as the top-down
refinement, when the grid from the bottom simplified
to rough triangles until error metrics meet the threshold
of this process, we refer to as bottom-up simplification.
To establish LOD terrain model, we can use not only
top-down
refinement
but
also
bottom-up
simplification. Bottom-up method needs to build
upward to a binary tree with original triangles as the
leaf nodes, which wastes lots of internal memory
during the simplification. In this paper, we use the topdown method, which treats the original triangle mesh
terrain as the crude model, and each triangle as the root
of a binary tree, also, we link all the roots in a linked
list structure. Then for each binary tree which takes
original triangle as its root, we can refine the mesh
downwards gradually to get the refined terrain model.
This method saves more internal memory space
compared with bottom-up simplification, and can
achieve the same effect. The data structure is shown in
Fig. 2.

Fig.2. data structure sketch map
Among them, each node of data is structured as
follows:
Typedef struct BinTriangle
{
Int Code;
//coding of the triangle

Computer Graphics, Imaging and Visualisation (CGIV 2007)
0-7695-2928-3/07 $25.00 © 2007

2.3.1 Coding Method in Original Mesh. In our
coding method, we needs to make sure each one of
n
n
terrain block with ( 2 + 1) × ( 2 + 1) size, this size may
construct a fully binary tree for original triangle mesh
model. We encode from the root of the tree, and the
number of nodes followed according to the order of
level traversal, the process is shown in Fig.3.

Fig.3. encoding process
If we change this for binary coding we may get the
rule as follows:
Rule 1: The binary coding of a triangle’s left child
equals the binary coding of its parent moves one bit
left then adds 0 to its tail, and the binary coding of a
triangle’s right child equals the binary coding of its
parent moves one bit left then adds 1 to its tail.
In this way we can easily get the binary coding of a
child from the binary coding of its parent. The same
principle, we can get the following rule:
Rule 2: We can get the binary coding of a parent by
removing the last bit of its child’s binary coding then
moves the remaining binary coding one bit right.
If we use code (P ) to denote the binary coding of
node P , LChild ( P ) to denote the binary coding of

node P ’s left child, RChild ( P ) to denote the binary
coding of node P ’s right child, << to denote moving
one bit left, >> to denote moving one bit right, then the
rules can be described as follows:
LChild ( P ) = code ( P ) << 1 + 0
RChild ( P ) = code ( P ) << 1 + 1
code ( P ) = LChild ( P ) >> 1 = RChild ( P ) >> 1

In the relationship between a node and its
neighbors, we can get the rule as follows:
Rule 3: If a node is the left child of its parent, then
its left neighbor is the right child of its parent, right
neighbor is the right child of its parent’s base neighbor,
base neighbor is the right child of its parent’s left
neighbor.
If we use LNei ( P ) to denote the binary coding of
P ’s left neighbor, RNei(P) to denote the binary coding
of P ’s right neighbor, BNei ( P ) to denote the binary
coding of P ’s base neighbor, in the condition that P
is left child of its parent, then the rule can be described
as follows:
LNei ( P ) = code ( P ) + 1
RNei ( P ) = BNei ( code ( P ) >> 1 ) << 1 + 1
BNei ( P ) = LNei ( code ( P ) >> 1 ) << 1 + 1

For the node that is the right child of its parent, we
have the similarly process.
2.3.2 Coding method in the Process of
Simplification. However, In the process of triangle
mesh simplification, to build our model for continuous
LOD triangular structure, we need to avoid Tconjunction. T-conjunction is one triangle or more
triangles share a part of the triangle edge, so in the
process of simplification that avoids T-conjunction, the
above mesh model may changes dynamic and the rule
above needs further adjustment.
In none T-conjunction algorithm we have rules as
follows:
Rule 4: If a triangle with its left neighbor or right
neighbor is not in the same level, it must be in the
more rough level; if a triangle with its base neighbor is
not in the same level, it must be in the more refined
level.
According to the above rule, the coding method in
none T-conjunction simplification needs to be adjusted
as follows:
Rule 5: If left neighbor that calculated in
accordance with Rule 3 has children, the binary coding
of its right child takes place of the binary coding of the
left neighbor. For the same reason, if right neighbor
that calculated in accordance with Rule 3 has children,
the binary coding of its left child takes place of the
binary coding of the right neighbor. If base neighbor
that calculated in accordance with Rule 3 does not

Computer Graphics, Imaging and Visualisation (CGIV 2007)
0-7695-2928-3/07 $25.00 © 2007

exist, the binary coding of its parent takes place of the
binary coding of the base neighbor.
Through adjustment of the above rules, we can
easily use coding method for none T-conjunction
algorithm during the process of refinement and
simplification
In summary, we can easily know from one node to
his father’s, left neighbor’s, right neighbor’s or base
neighbor’s coding, according to the binary coding we
get, we may easily find the corresponding node in
internal memory. This coding method eliminates the
pointers used in reference [5], effectively improves the
utilization of internal memory space.

2.4 Simplification Algorithm
Against the data structure in 2.2 and the coding in
2.3, we propose the refinement and simplification
algorithm as follows to avoid T-conjunction.
Refinement algorithm(for a triangle T that has no
children):
Step1: Calculate the binary coding of T’s base
neighbor, if T’s base neighbor is not in the same level
with T, split T’s base neighbor recursively.
Step2: Create two child nodes for triangle T.
Simplification algorithm(for a triangle T that has
children):
Step1: Calculate the binary coding of its left
neighbor, right neighbor and left neighbor to the left
neighbor, if they are not in the same level, merge the
triangles that are not in the same level recursively.
Step2: Merge triangle T, its left neighbor, right
neighbor and left neighbor to the left neighbor, then
free the memory spaces they occupy.
Step3: Make the node of T’s parent to a NULL
pointer.

3. Out-of-core Data Paging
In out-of-core data paging, this paper mainly deals
with the previous data structure to propose the
corresponding data conjunction method between
different blocks of terrain data.

3.1 Multi-resolution Terrain Organization
For large-scale, high-detailed terrain rending, if the
scale of data far exceeds the capacity of internal
memory, it will page the data frequently between
internal memory and external memory if we still use
this form of data. To solve this problem, we divide the
terrain into several blocks, each piece of terrain
composed of four of its corner points becomes the
coarse-resolution terrain mesh, and terrain of each

block for high-resolution mesh. The process is shown
in Fig. 4.

Or i gi nal t er r ai n
s ur f ace

Bl oc k i n a s pl i t gr i d

Fig.4. multi-resolution terrain organization

3.2 Data Conjunction
In accordance with the simplified algorithm in 2.4,
we can get none T-conjunction triangular mesh within
a terrain block, however, according to the above data
paging method, the junction between terrain blocks is
still not considered. This method is for each terrain
block that has just paged into internal memory, view in
the memory to see whether the terrain block has its
adjacent block, if any, subdivide each triangle on the
border recursively until the triangle with the
corresponding neighbor triangle in adjacent terrain
block is at the same level. The process is shown in Fig.
5, which dotted line refers to subdivision of the new
terrain block recursively.

Fig. 5. subdivision new terrain block recursively
According to the out-of-core data paging model
shown above, the coding method in 2.3 need to
adjusted as follows:
Rule 6: If the neighbor of a triangle does not exist,
then the triangle is certainly on the border, we need to
calculate the binary coding of corresponding neighbor
triangle on adjacent terrain block to take place of the
binary coding of its neighbor.

4. Experiment Results
Based on Windows platform using Visual C++ and
OpenGL, we implement a program using the terrain
model of Washington state area with size of
16385 × 16385 and the block size of 32 × 32 to test on
lenovo PC, the operating system is windows 2003, the
PC is Pentium 4 1.8GHZ CPU, memory to 256M,

Computer Graphics, Imaging and Visualisation (CGIV 2007)
0-7695-2928-3/07 $25.00 © 2007

GeForce MX 400 video card, window displays a
resolution of 1024 × 768.
Table 1 shows the average frame rate under
different block size and different number of triangle
faces with the unit of fps(frame/sec). Fig.6 shows the
grid graph when wandering on the terrain surface.

size

Table 1 The average frame rate
5000
10000

faces

20000

128 × 128

140

110

60

64 × 64

145

111

63

32 × 32

145

115

65

(a)

(b)
Fig.6. the grid graph when wandering on the
terrain surface

5. Conclusion and Future Work
This paper uses an efficient data structure for the
terrain accelerated rending, in accordance with the data
structure, we propose coding method and none Tconjunction algorithm, our method saves lots of
internal memory space compared with the more
traditional methods such as reference [5] use. At the
same time, we also propose a method on data
conjunction for out-of-core data paging. Experiment
shows the algorithm we use is effective for rending
large-scale terrain. In future, we can further explore the
use of more efficient data structure and corresponding
methods to make it both in memory cost and time cost
greatly improved.

ACKNOWLEDGMENTS

This work has been supported by National Natural
Science Foundation of China grant 60572169 ， the
Scientific Research Foundation for the Returned
Overseas Chinese Scholars, State Education Ministry
grant D4200407, Tianjin Natural Science Foundation
grant 06YFJMJC00400, and Tianjin Natural Science
Foundation grant 05YFJMJC09200.

References:
[1] Lindstrom P, KollerD, RibarskyW et al. “Real-time,
continuous level of detail rendering of height fields”. In: P
roc SIG2GRAPH’96, New Orleans, Louisana, 1996. 109118
[2] DuchaineauM , WolinskyM , SigetiDE et al. “ROAMing
terrain: Real-time optimally adapting meshes”. In: P roc
IEEEV isualization’97, Phoenix, A Z, 1997. 81- 88

Computer Graphics, Imaging and Visualisation (CGIV 2007)
0-7695-2928-3/07 $25.00 © 2007

[3] YanQing Lu, “Study of the Real-Time Rendering for
Large-Scale Terrain Dataset”, Ph.D. Department of
Mathematics Zhejiang University, 2003.
[4] Zheng Haiou, Li Peng, Wang Dong “Technique of threedimensional battle terrain’s real-time rending based on LOD”,
In Journal of System Simulation. November 2006 188-191.
[5] Jing Tao “An efficient algorithm of LOD for 3D terrain
simulation based on quadtrees”, In Journal of System
Simulation November 2005 123-126.
[6] Lindstrom P, PascucciV. “Visualization of large terrains
made easy”. In: P roc IEEE Visualization’2001, San Diego,
California, 2001. 363- 370
[7] Lindstrom P, PascucciV “Terrain Simplification
Simplified: A General Framework for View-Dependent Outof-Core Visualization” IEEE Transaction on Visualization
and Computer Graphics, 2002.

[8] Leng Zhiguang, Tang xiaoan et. “Study on
dynamic rapid rending technique of large scale terrain”.
In Journal of System Simulation, October 2006.


A Uniﬁed Framework for User-Controlled
Simpliﬁcation
Muhammad Hussain1> 2 , Yoshihiro Okada1> 2 , and Koichi Niijima1
1
Graduate School of Information Science and Electrical Engineering, Kyushu University,
6-1, Kasuga Koen, Kasuga, Fukuoka 816-8580, Japan.
{mhussain, okada, niijima}@i.kyushu-u.ac.jp
2
Intelligent Cooperation and Control, PRESTO, JST

Abstract
Polygonal Models are ubiquitous in every application of
Computer Graphics but their real time manipulation and
rendering in such interactive application environments as
are sensitive to their sizes and complexity have become a
threat. A whole family of automatic algorithms emerged
during the last decade to help out this problem, but they
reduce the complexity of the models uniformly without caring about semantic importance of localized parts of a mesh.
Only a few algorithms deal with adaptive simpliﬁcation of
polygonal models. We propose a new uniﬁed framework for
user-driven simpliﬁcation exploiting the simpliﬁcation hierarchy and hypertriangulation model [1], which lends a user
the most of the functionalities of existing adaptive simpliﬁcation algorithms in one place. The proposed new underlying data structures are compact and support real time navigation across continuous LODs of a model. Comparison
with related work shows that the proposed framework provides combined environment at reduced overhead of memory space usage and faster running times.

1 Introduction
Various applications of CG rely on polygonal models
where a data set is typically speciﬁed with triangle-based
surface mesh. The quest for realism on one hand and the
enhanced ability to acquire polygonal models with arbitrary
accuracy on the other hand have lead to highly complex and
huge polygonal meshes, which are hard to store, manipulate
and visualize in real time; real time rendering of such models especially in interactive applications is a challenging
problem in CG. One approach to alleviate this problem was
the proposal of LOD and multiresolution paradigms where
an object is stored at k different (discrete/continuous) levels of detail; a higher resolution version is employed when

the object is close to the viewer and coarser version is substituted as the object recedes [2]. This approach necessitated the need of polygonal simpliﬁcation algorithms and
throughout the last decade, a whole family of automatic
polygonal simpliﬁcation algorithms came into existence,
for through survey of these methods an interested reader
is referred to [4, 7]. While they produce very appealing results in many cases, they perform poorly at extremely low
levels of detail because they are blind to semantic or high
level meanings of a model and simplify it uniformly without caring about whether its some localized area visually
more important that others. To overcome the shortcomings
of uniform automatic simpliﬁcation, methods for adaptive
simpliﬁcation [6, 8, 13] were developed but here the focus
is on the exploitation of view space constraints and so their
scope is limited to applications where viewing space impact
is important. In many applications it is very important that
a model conveys overall, not only with respect to a certain
view space, an optimized knowledge about an object even
at extremely low levels of detail, and it can not be accomplished without user interaction. For example, in case of human body, face is visually important and face features must
be preserved even at low levels of detail and other parts of
the body such as torso or legs can be reduced drastically. In
this situation some kind of user interaction is essential.
Algorithms proposed in [1, 5, 12, 14] address the problem from user-interaction point of view. [5, 12, 14] rely on
simpliﬁcation hierarchy whereas Zeta [1] rely on hypertriangulation model; the algorithms in [12, 14] provide high
level control whereas Semisimp [5] and Zeta [1] provide
low level control to a user. Zeta [1] provides relatively
better control to a user but it is limited because it takes
pre-computed multiresolution representation of a polygonal
model as input and then builds a hypertriangulation model
for resolution modeling. In this paper we propose a uniﬁed
framework employing simpliﬁcation hierarchy and hypertriangulation model that provides low level as well as high

1
Proceedings of the International Conference on Computer Graphics, Imaging
and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

Figure 1. Half-edge collapse transformation
hvw (yv > yw ) 7$ yw .

level control to a user. The proposed new underlying data
structures are compact and support the construction of simpliﬁcation hierarchy simultaneous with hypertriangulation
model creation in one pass thereby extending the functionality of Zeta [1] to that of methods based on simpliﬁcation
hierarchy, with reduced overhead of memory space occupancy and faster running time; these data structures support
real time navigation across continuous LODs of a polygonal model, extraction of any desirable ﬁxed LOD and selectively reﬁning and selectively coarsening it.
The overall organization of the paper is as follows. Section 2 describes in detail a new uniﬁed framework for adaptive simpliﬁcation, and the construction algorithm has been
detailed in Section 3. Results have been discussed in Section 4 and Section 5 concludes the paper.

2 Adaptive Simpliﬁcation Model
In this section, by the synthesis of simpliﬁcation hierarchy and hypertriangulation model [1], we propose a uniﬁed
framework for the construction of sophisticated multiresolution mesh representation of orientable , 2-manifold polygonal models in <3 > which allows real time navigation across
continuous LODs, and efﬁcient implementation of selective
simpliﬁcation and selective reﬁnement, and provides low
level as well as high level control to the user; hereafter we
call it adaptive simpliﬁcation model (ADSIMP).

Figure 2. ecol and vsplit transformations (top
row), corresponding nodes of vertex hierarchy (right bottom row) and glue operation
(middle bottom row). A half-edge and its adjacencies (left bottom row).

2.1 Simpliﬁcation Hierarchy
Automatic simpliﬁcation algorithms based on edgecollapse have become attractive because of their elegant features. Edge collapse (ecol) and vertex split (vsplit) transformations build naturally a vertex hierarchy; Figure 2 shows
ecol and vsplit transformations and the associated nodes
of the vertex hierarchy. ADSIMP exploits half-edge collapse transformation for simpliﬁcation because it behaves
like both edge-collapse and vertex decimation but does not
create new vertices like half-edge collapse and needs not
any optimization algorithm like vertex decimation to ﬁll the
hole, and the resulting vertex hierarchy can be encoded with
as many nodes as there are vertices in the input mesh P .
The sequence of half-edge collapse transformations is
driven by a memory-efﬁcient and feature preserving error
metric proposed in [11]; according to this the cost of the
half-edge collapse transformation hvw (yv > yw ) 7$ yw (see
Figure 1) is
Cost(hvw ) =

X

Tw =

where Tw = ow · w with ow = 12 (D1 + D2 )> D1 = area of
triangle w (y1 > y2 > yv ), D2 =area of triangle w0 (y1 > y2 > yw )>
and w is the angle described by the normal of the triangle w
when edge hvw is collapsed, and summation is taken over all
triangles incident on yv . For the detailed account, consult
[11].

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

next adjacent half-edges. Pasting is carried out by storing
a new next adjacency in this list, setting it active and setting current next adjacency inactive. Notice that in case of
half-edge collapse transformation, pasting follows a speciﬁed pattern and is quite simple to implement.

2.3 Multiresolution Data Structures

Figure 3. Half-edge collapse transformation
hvw (yv > yw ) 7$ yw removes the patch Wx of triangles incident on x shown in shaded re0
gion, and adds new patch Wx of triangles also
shown in shaded region with solid line segments.

2.2 Hypertriangulation Model
Hypertriangulation model proposed by Cignoni et al. [1]
is of particular relevance for us because our system also
exploits this model. The concept of hypertriangulation is
based on the idea of gluing. At i-th iteration of an automatic simpliﬁcation algorithm, a patch of triangles Wx is
removed from Pl1 > an intermediate mesh obtained after
0
l  1 iterations, and new triangulation Wx replaces it in Pl .
0
The idea of gluing is to past the new set of triangles Wx over
the old triangles Wx , see Figure 2.
Half-edge collapse transformation employed by ADSIMP naturally and elegantly builds hypertriangulation
model simultaneous with vertex hierarchy creation; this
transformation removes triangles from a small localized region and introduces new triangles to ﬁll the hole following
a speciﬁc automatic pattern, so gluing operation can trivially be accomplished by updating just a few adjacencies,
but in case of vertex decimation it is not that easy because
introduction of new triangles does not follow some speciﬁc
pattern but is driven by some optimization approach.
Consider Figure 3, half-edge collapse transformation hxy
(x> y) 7$ y replaces current patch Wx of triangles incident
0
0
on vertex x with a new patch Wx ; patch Wx is glued over Wx
by modifying the next adjacent relations of the half-edges
hy0 > h01 > h12 > h23 > h34 > h45 along the boundary of each patch
e.g. after gluing, next adjacent half-edge h4x of the boundary half-edge h34 will become inactive and h4y will become
active. Observe that when gluing is accomplished, there are
two half-edges next to each of the half-edges along the com0
mon boundary of patches Wx and Wx ; a list of variable size
is associated with each half-edge to store reference to these

Vertex hierarchy and hypertriangulation model described
in the previous subsections is encoded by two entities of
data structures: Vertex and PackedEdge; Vertex encodes
geometrical and topological information about a vertex, and
PackedEdge encodes a half-edge and its adjacencies in ADSIMP; hereafter, we will use PackedEdge and half-edge interchangeably. Their representation in C/C++ format is as
follows.
struct Vertex {
ﬂoat
position[3];
PackedEdge*
pe;
int*
children;
ﬂoat
cost;
int
heapspot;
unsigned short ch_indx;
int
parent ;
bool
mark;
Vertex *
next ;
Vertex *
prev;
};
Here position ﬁeld holds three coordinates representing
the geometric position of the corresponding vertex, and pe
is a pointer to the associated PackedEdge that makes possible the traversal of all vertices in 1-ring neighborhood of
this vertex and its adjacencies, it is representative of the
half-edge whose collapse will remove this vertex, we term
this as optimal half-edge because its collapse causes minimum geometric deviation; children and parent ﬁelds encode simpliﬁcation hierarchy, children is a variable length
array that holds the pointers to those vertices which will collapse to this vertex in the order of their simpliﬁcation and
parent holds the pointer to the vertex to which this vertex
will be collapsed; mark ﬁeld is used to hold the information
whether this vertex is active or not in an LOD, if vertex is
chosen for display it is active otherwise inactive; next and
prev hold pointers to chain through the vertices in the order they are removed during simpliﬁcation process. The
remaining two ﬁelds cost and heapspot hold the cost of collapse of the half-edge pe and the position of the vertex in the
priority queue respectively; each half-edge collapse transformation removes one vertex, so the cost of a half-edge can
also be regarded as cost of the vertex which will be simpliﬁed, that is why we store the cost in vertex data structure.
We can get rid of heapspot ﬁeld if we employ probabilistic optimization framework instead of greedy framework for

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

simpliﬁcation process.
struct PackedEdge {
int
origin;
PackedEdge*
twin;
PackedEdge**
next;
unsigned short idx_next;
bool
mark;
};
Here origin stores the index of the starting vertex (origin)
of the corresponding half-edge, twin is its mate that shares
the common edge with it (see Figure 2), next is a variable
length array that holds in order the pointers to those halfedges which are next to this half-edge in ADSIMP across
different resolution levels (see Figure 3), its size depends
on the number of half-edge collapse transformations which
have this half-edge on the boundary of the simpliﬁcation
region, one of these half-edges would be active at a time
and idx_next holds the index of this active half-edge; mark
ﬁeld is used to mark and unmark the PackedEdge.
Note that there is no need of data structure to explicitly
specify facets, they are implicitly deﬁned by the adjacencies
which are encoded in PackedEdge data structure.

3 Construction Algorithm
The construction algorithm for ADSIMP described in
Section 2 takes original fully detailed polygonal mesh P
as input and performs the following steps:
1. Initialize ADSIMP by creating PackedEdge record for
each half-edge h and Vertex record for each vertex x
of the original input mesh P .
2. For each vertex x 5 P> determine optimal half-edge
hxy >where x is origin and y is head of hxy (see Figure 2); this is the one among out-going half-edges of x
whose collapse removes x and causes minimum geometric deviation (Section 2.1). Cost of the corresponding optimal half-edge will be the cost of a vertex.
3. Put each vertex in the priority queue taking cost of the
vertex as priority value.
4. Remove minimum cost vertex x from the queue, collapse hxy by putting reference of x in children ﬁeld of
y and putting reference of y in parent ﬁeld of x> and
0
weld the new patch Wx onto the current patch Wx (Section 2.2)
5. Re-evaluate the cost of each vertex in 1-ring neighborhood of x> and update the priority queue.
6. Repeat steps 4 and 5 until no vertex can be removed.

Vertices: 34,834

o
i
o
i

Faces: 69451

PackedEdges:371,041

1

2

3

4

5

138,902

142,523

65,879

19,031

3,436

6

7

8

9

10

1094

126

36

10

2

Table 1. PackedEdge history for bunny model. l
stands for the length of next ﬁeld and f is its
frequency. Average length is 1.9.

Note that not all edges are considered legal for collapse;
for a detailed discussion on the legality of edge collapses,
refer to [9].
Two key methods to traverse ADSIMP for continuous
LODs of a mesh are reﬁne_vertex() and simplify_vertex();
these methods perform ecol and vsplit operations just by
modifying a few next adjacent half-edge references. These
methods allow navigation across continuous LODs of a
mesh and extraction of any desirable ﬁxed LOD. Further
these methods can implement selective reﬁnement and selective simpliﬁcation by adding/removing detail from a localized region.

4 Discussion
We implemented ADSIMP using C++, MFC classes, and
OpenGL on a system with PentiumIV 2.9GHz and main
memory 512MB. Figures 4 and 5 show snapshots of our
system with original bunny and horse models and their approximations at ﬁxed levels of detail. We can efﬁciently
navigate through different levels of detail at run time using
the slider, can extract any ﬁxed LOD and can further ﬁne
tune it. In the following, we discuss space and time complexity of our model.

4.1 Space Complexity
Let n be the total number of vertices and m the total number of half-edges (PackedEdges) in ADSIMP. In each Vertex record, children is a variable length ﬁeld which holds
the number of vertices that will be collapsed to the corresponding vertex; since each vertex is removed once, so the
total size of all children ﬁelds will not exceed n l=h. average
length of each ﬁeld does not exceed 1. As such, list of Vertex
records will occupy 63q bytes of memory. Each half-edge
collapse transformation will add 2(u-3) half-edges, where
u is the valence of the vertex to be collapsed and the total
number of legal edge collapse transformations can not exceed q. So, assuming the average valance to be 6, the number of half-edges introduced by half-edge collapse transformations will not exceed 6q. Also, since in a manifold mesh,

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

number of half-edges is about 6q, therefore, the total number of half-edges does not exceed 12q i.e. p  12q. We
found empirically that for bunny model p  10q, see table
1. In PackedEdge record, next is a variable length ﬁeld and
its average length is found empirically to be 1.9 for bunny
model; note that legality of edge collapses allows the simpliﬁcation of bunny model to 15 vertices. Thus, the memory
size occupied by PackedEdges is about 180q bytes, and the
overall memory size occupied by ADSIMP is at the maximum 291q bytes. But in case of Zeta, this size is 390q. It
means that our proposed model consumes 25% less memory
with enhanced functionality. Although, the authors of the
methods proposed in [5, 12, 14] have not reported memory
space occupancy, the method of Youngihn et al. associates
two quadric error metrics with each vertex and this requires
160q bytes only for error metrics in addition to other entities.

4.2 Time Complexity
Construction of ADSIMP takes constant time to compute cost for each optimal half-edge and the time complexity of the priority queue is O(qlogq). Thus theoretically
the time complexity the preprocessing phase is O(qlogq).
During interactive session, the only time consuming methods may be reﬁne_vertex() and simplify_vertex() but each
involves traversal of the half-edges around a vertex x and
modiﬁcation of next adjacent half-edge references of the
half-edges along the boundary of Wx , so each takes constant
time. Therefore, the complexity of reﬁning/simplifying v
vertices exploiting simpliﬁcation hierarchy is O(v); but in
case of Zeta, it is O(vlogv) because they maintain a priority
queue.

5 Conclusion and Future Work
We proposed a new multiresolution model ADSIMP for
user-controlled simpliﬁcation of polygonal meshes that exploits simpliﬁcation hierarchy as well as hypertriangulation
model and consequently provides the functionality of both
low-level and high level user-driven methods for adaptive
simpliﬁcation of polygonal meshes in a uniﬁed environment
with reduced overhead of memory consumption and faster
execution time. This paper presents the details about the
construction method, underlying data structures and the key
methods for the traversal of continuos LODs of a mesh. Employing this model one can efﬁciently navigate through continuos levels of detail of a mesh, and can extract mesh at a
constant desirable resolution that can further be locally simpliﬁed or reﬁned. The details about the user interface for
selective reﬁnement and selective simpliﬁcation are yet to
be decided, and are considerations for future work; it would
be the topic of a companion paper.

References
[1] Cignoni, P., Montani, C., Rocchini, C., and Scopigno,
R. Zeta: A resolution modeling system. GMIP: Graphical Models and Image Processing 60(5):305-329,
1998.
[2] Clark, J. Hierarchical geometric models for visible
surface algorithms. Communications of the ACM 19,
10, pp:547-554, 1976.
[3] Garland, M., and Heckbert, P., S. Surface simpliﬁcation using quadric error metric. In Proc. SIGGRAPH’97, pages 209-216, August 1997
[4] Garland, M. Multiresolution modeling: survey & future opportunities. Eurographics’99- State of the Art
Report, 111-131.
[5] Li, G., and Watson, B. Semiautomatic simpliﬁcation.
In ACM symposium on Interactive 3D Graphics 2001,
43-48.
[6] Luebke, D., and Erikson, C. View-Dependent Simpliﬁcation of Arbitrary Polygonal Environments. In
Proc. SIGGRAPH ’97, pp: 199–208, 1997.
[7] Kuebke, D. A Developer’s survey of Polygonal simpliﬁcation Algorithms. IEEE Computer Graphics & Applications, 24-35, May 2001.
[8] Hoppe, H. View-dependent reﬁnement of progressive
meshes. In Proc. SIGGRAPH ’97, pp: 189–198, 1997.
[9] Hoppe, H., DeRose, T., Duchamp, T., McDonald, J.,
and Stuetzle, W. Mesh optimization. In Proc. SIGGRAPH ’93, pp: 19–26, 1993.
[10] Hussain, M., Okada, Y. and Niijima, K. Fast, simple, feature-preserving and memory efﬁcient simpliﬁcation of triangle meshes. International Journal of Image and Graphics, 3(4):1-18, 2003.
[11] Hussain, M., Okada, Y. and Niijima, K. Efﬁcient
and Feature-Preserving Triangular Mesh Decimation.
Journal of WSCG, 12(1):167-174, February 2004.
[12] Pojar, E., and Schmalsteig, D. User-controlled creation of multiresolution meshes. In ACM symposium
on Interactive 3D Graphics 2003, pp: 127-130, 243.
[13] Xia, J., C., and Varshney, A. Dynamic view-dependent
simpliﬁcation for polygonal models. In Proc. Visualizaion’96, pages 327-334, Oct. 1996.
[14] Kho, Y., Garland, M. User-guided simpliﬁcation. In
ACM symposium on Interactive 3D Graphics 2003,
pp: 123-126, 242.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

Figure 4: Original bunny model (small window) consisting of 34834 vertices and 69451 faces.
One ﬁxed LOD containing 1351 vertices and 2537 faces.

Figure 5: Original horse model (small window) consisting of 48485 vertices and 96966 faces.
One ﬁxed LOD consisting of 1281 vertices and 2556 faces.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE


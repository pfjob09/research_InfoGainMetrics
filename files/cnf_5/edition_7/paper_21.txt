Precomputed Radiance Transfer with Spatially-Varying Lighting Effects
Masahiro Fujita
Keio University SFC
Graduate School of Media and Governance
syoyo@sfc.keio.ac.jp
Abstract
We propose a new method to render physicallybased globally illuminated scenes at interactive speed.
Our method is based on Precomputed Radiance Transfer (PRT) [10]. Although the shape of model does not
change and its position is ﬁxed, we can move any light
source with arbitrary shape dynamically during rendering process. This enables a spatially-varying lighting
effect which has not been considered in the previous approach [10]. We also describe the details of rendering the
scene with dynamic lights using cube mapping. Our implementation demonstrates that our method is suited for
interactive applications such as 3D games and lighting simulations.
Keywords: interactive graphics, global illumination,
PRT, spherical harmonics

1. Introduction
In this paper, we propose a new interactive rendering
technique based on Precomputed Radiance Transfer [10].
Our major contribution in this paper is to handle more general scenes with PRT, especially for indoor scenes which has
middle scale lighting variation. Our implementation demonstrates that our method is suited for interactive applications
such as 3D games and lighting simulations.

1.1. Precomputed Radiance Transfer
Precomputed Radiance Transfer (PRT) was ﬁrst proposed by Sloan et al. in [10]. In PRT, spherical harmonic
function is employed for the decomposition of incident
lighting and geometric scattering. In [10], the light source
is placed at inﬁnity. A rendering equation is expanded using spherical harmonic functions. It replaces the integral
of the rendering equation by a simple set of dot products
using orthogonality of spherical harmonics. This enables

Takashi Kanai
Keio University SFC
Faculty of Environmental Information
kanai@sfc.keio.ac.jp
dynamic movements of lights, using environment mapping
and a rigid object, at an interactive speed.

1.2. Related Work
An application of spherical harmonic functions to computer graphics as the deviation of isotropic BRDF was ﬁrst
introduced by Cabral et al. [1]. They represented a light integral on a hemisphere as several dot products of its coefﬁcient vector and then reduced its computational cost. Westin
et al. [14] extended their approach to the case of anisotropic
BRDF. Sillion et al. [8] used spherical harmonic functions
for approximating the formulation of a radiance launched
from a point in the radiosity method.
Ramamoorthi et al. [7] represented a light integral of diffuse reﬂectance as several dot products of spherical harmonic coefﬁcients in the scene of environment mapping.
Kautz et al [4] proposed a method to combine Sloan’s original PRT to an arbitrary BRDF. Lehtinen et al. [5] generalized their combined formulations in a matrix form, and improved the rendering speed by compression of the matrices
using principal component analysis (PCA).
Sloan et al. [11] decomposed the original PRT into a
macro-scale PRT with the accuracy of ordinary surface level
and a meso-scale PRT with the accuracy of surface texture level. They were used in combination with bidirectional
texture functions to establish more sophisticated rendering results with high accuracy. They also improved rendering speed by compressing the matrix of spherical harmonic
coefﬁcients using clustered principal component analysis
(CPCA) in [9].

1.3. Our Contribution
Our contributions presented in this paper are as follows:
Spatially-varying lighting effect. In the previous approach
by Sloan et al. [10], light sources are placed at inﬁnity. This
assumption causes constant color shading. For example,
when applying the light to a plane, any point of the plane
will be shaded with a constant color (spatially-invariant

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

(a)

(b)

Figure 1. (a) Spatially-invariant lighting effect in [10]. Note that the ground plane is ﬂat-shaded. (b)
Our spatially-varying lighting effect. Note that the ground plane is now shaded gradually.

lighting effect). PRT is by nature suitable for rendering outdoor scenes. But it is difﬁcult to render indoor scenes in
which the scale of variation in lighting is small with this approach.
In Sloan et al. [10], vector quantization is used to represent local lighting effects. They propose an approach for
sampling points in a part of a model. Then lighting environments are re-sampled from these points. Our approach considers the attenuation term by the distance from a light position to a point of an object. It enables a spatially-varying
lighting effect even when applied to a plane.
Figure 1 illustrates the comparison between spatiallyconstant (left) and spatially-varying (right) lighting effects.
It can be seen that in our approach the ground plane is
shaded gradually compared to the previous one which is
ﬂat-shaded. PRT can be used in more general scenes including indoor scenes thanks to our spatially-varying lighting effects.
Application to the dynamic lighting environments. In the
previous approach, lighting environments are given by environment mapping, dynamic variation of lighting is done
by rigid rotations thanks to rotation-invariant properties of
spherical harmonics. Thus the environment of lighting is
ﬁxed. In our approach, We use a cube mapping to render the
scene with moving lights or its background scene. The usage of cube mapping has already been pointed out by Sloan
et al. [10]. However, we show here the details of its implementation, and demonstrate its use for more general lighting environments.

2. Interactive Global Illumination Using PRT
2.1. Pseudo Code
We show in this subsection a pseudo code of our approach. Our approach is divided into two steps. One is the
simulation of irradiance transformation as pre-processing,
and the other is an interactive rendering process. First,
the transfer simulation of radiance is described as follows:
Generate sampling points using [12];
For each vertex x
Compute coefﬁcients for shadow pass Mx0 ;
For b = 1, 2, . . .
Compute coefﬁcients for
interreﬂection pass Mxb ;
end
Mx = Mx0 + Mx1 + . . .;
end
We store M calculated by transfer simulation. In the interactive rendering step, the following procedure is executed by using M .
Compute lighting coefﬁcients L by cube map
rendering;
For each vertex x;
compute matrix-vector multiplication of
Mx and L;
end

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

A binary ﬂag is set to 1 for a sampling direction with an
interruption. It is used to reduce the computational cost of
ray tracing in the following inter-reﬂection pass.

q1

q1
q2

Mqb1

q2
Mqb2

q3

Mqb3

q3

(Mx )bi = ρπx

x

x

(a)

(b)

Figure 2. (a) Shadow pass. Rays are shot towards the hemisphere and a ﬂag (bit) is set
where a ray hits the hemisphere. (b) Interreﬂection pass. Transfer coefﬁcients Mqbi are
computed from each qi to point x.

2.2. Transfer simulation
In the pre-process, transfer simulation is done by the similar procedure as radiosity method. Each transferred radiance is expanded by using a set of spherical harmonic functions, and transfer coefﬁcients are computed for each vertex of an object. This process can be done by the following
two steps.
We use here a quasi-Monte Carlo method [12] for generating sampling rays on a hemisphere. The low-discrepancy
sequence we have choosen is the Hammersley point sets.
In the ﬁrst shadow pass, a shadow of a ray directly
entering each vertex is computed. In the following interreﬂection pass, inter-reﬂective effects are computed. We use
transfer coefﬁcients computed by the shadow pass. This
computation is repeated until the whole energy integral is
less than a threshold.
Diffuse reﬂection The transfer simulation of diffuse reﬂection (Lambert BRDF) is processed as follows:
Shadow pass. The following integral is computed for each
vertex (See Figure 2(a)).
(Mx )0i

ρx
=
π

Ω

Inter-reﬂection pass. The following integral is computed
based on the transfer vector (Mx )0 calculated in the previous pass (See Figure 2(b)).

V (x, ω ) max(cos θx , 0)yi (ω )dω ,

where (Mx )0 denotes the transfer vector in the shadow pass
for a vertex x. A subscript i is deﬁned as i = l(l + 1) +
m + 1 where l, m denote parameters of spherical harmonic
functions. ρx (0 ≤ ρx ≤ 1) denotes the diffuse reﬂectance
at a point x. V represents a two-valued visibility function
which is equal to 1 if no interruption exists between x and
ω , otherwise it is equal to 0. This equation is computed for
each RGB value.

Ω

(1−V (x,ω )) max(cos θx ,0)(Mq(ω ) )b−1
dω ,
i

where b (≥ 1) denotes the number of inter-reﬂection
pass. This integral is computed only for sampling directions
which have a binary ﬂag. q(ω ) is a point hit at ﬁrst on a direction of ω .
The computation of transfer simulation is done for each
vertex. Then it is rare that q(ω ) is exactly on a vertex. Thus,
Mq is computed by linear interpolation of M between vertices neighbor to q.
We record the whole transfer energy for each interreﬂection pass. We stop the computation if it is less than
a threshold. In practice, only three or four iterations are sufﬁcient due to the rapid decrease of the energy.
A transfer vector at a point x is represented by the sum of
those computed in shadow pass and in inter-reﬂection pass:
(Mx )i = (Mx )0i + (Mx )1i + (Mx )2i + · · · =

N

(Mx )ki ,
k=0

where N is the number of passes.
Figure 3 demonstrates the results of three different settings (without interruption of diffuse reﬂectance transfer,
shadow pass only, and shadow pass + inter-reﬂection pass).
The case without interruption (Figure 3(a)) is just the same
as the irradiance environment mapping described in [7]. It
is brighter than the other two settings, because the plane below the model does not stop the light from illuminating the
model. The difference between a shadow pass (Figure 3(b))
and both a shadow pass and an inter-reﬂection pass (Figure
3(c)) can not be easily distinguished. However, in the latter case, the shadowed regions are slightly brighter due to
inter-reﬂective effects.
Glossy reﬂection Glossy BRDF can also be represented
by PRT. This has an obtuse reﬂectance property in between
Lambert BRDF and ideal specular reﬂectance BRDF. Here
we treat only an isotropic case described in [10]. It should
be noted that the transfer coefﬁcient in glossy BRDF is represented by a matrix and not by a vector [10].
Shadow pass. A transfer coefﬁcient (Mx )0ij computed in
the shadow pass is as follows:
(Mx )0ij =

Ω

V (x, ω )yi (ω )yj (ω )dω .

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

(a)

(b)

(c)

Figure 3. (a): No occlusion. (b): After shadow pass. (c): After shadow pass + inter-reﬂection pass.
scene is surrounded with a virtual sphere. The lighting environments projected by cube mapping (described later) correspond to such a virtual sphere. We also assume that the
light source is outside the sphere. In the ﬁrst incidence of
a light, we use the formulation which is measured by their
surface, that is, the area A(x) for a point x on a surface is integrated by dA(x) as intervals of the whole surface A ∈ R2 .
The rendering equation re-formulated by its surface measure is as follows:
(a)

(b)

Figure 4. Different BRDF models. (a): Using
diffuse reﬂection. (b): Using glossy reﬂection.
Inter-reﬂection pass. A transfer coefﬁcient (Mx )bij computed in the following inter-reﬂection pass is as follows:
(Mx )bij

=

(1 − V (x, ω )) ×

Ω
n

αk (G∗xq(ω ) )k (Mq(ω ) )b−1
kj ×

L(x, x )

= Le (x, x )
+

L(x, x )f (x , x )V (x, x ) ×

A

cos θx cos θx
2
x−x

dA(x ),

(1)

Since a point in the lighting environment can be projected
to that on a surface of a sphere by cube mapping, we get
the following transfer coefﬁcients by treating an interval of
a scene surface A as that of a sphere with radius r:
(Mx )0i =

ρx
π

S

V (x, x )G(x, x )yi (x )dx ,

cos θ

where α is a constant and G∗x is a coefﬁcient of projected
isotropic glossy BRDF at a point x by spherical harmonic
functions.

where G = |r(x−xx)|2 . A term of cos θx in Equation (1)
can be omitted because it is included in cube mapping. In
the second inter-reﬂection pass or later, we use an original formulation based on a solid angle. Consequently, we
can represent a PRT including the attenuation by the distance from a light source.

3. PRT with Spatially-varying and Dynamic
Lights

3.2. Generation of the distribution of lights by
cube map rendering

3.1. Spatially-varying formulation of rendering
equation

We get a distribution of lights incident to a point by using cube mapping. This can be done using a cube map constructed by rendering each face of a cube with a camera put
on its origin. We set fov of the camera to 45◦ . The camera direction and the up vector for each face are set as de-

k=0

yk R(−ω , Nq(ω ) )

yi (ω )dω ,

Here we describe our novel spatially-varying formulation. In spatially-varying lighting, we assume the whole

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

Face direction
+x
−x
+y
−y
+z
−z

view direction
+x
−x
+y
−y
+z
−z

up vector
−y
−y
+z
−z
−y
−y

Table 1. Coordinates of each face in cube
map rendering.

els for six faces of a cube. We can also compute the correction W (ω(1, y, z)) = √ 2 1 2 ∆A for other four side
y +z +1

faces. Finally, a spherical harmonic function for each pixel
is computed by
SHk (s, t)i,j = yi,j (ω(k, s, t))W (ω(k, s, t)),
where k denotes a face id, (s, t) denotes the uv-coordinate
of a texture, and ω(k, s, t) denotes the unique direction
clearly deﬁned by (k, s, t).

3.3. Interactive rendering
Using transfer coefﬁcients as pre-computation and lighting coefﬁcients by dynamic cube map rendering, we can
render the scene with dynamically moving lights by GPU.
It is easy to implement the computation of this stage by using the vertex program on GPU.

Z
x

y

Diffuse reﬂection In the case of diffuse reﬂection, radiance
Lx for each vertex can be computed simply by the following sum of dot products:

θ

1

N

Lx =

Y
X

Figure 5. The derivation of pixel weight.
scribed in Table 1 (which are based on a coordinate system
used in OpenGL).
By this, we can get a lighting environment of a light with
arbitrary shape. For each pixel of textures from cube map
rendering, we can quickly compute an expansion of spherical harmonic functions by multiplying spherical harmonic
functions which are computed in advance.
Correction for a pixel Distortion arises at the corner of a
cube by projection. This happens because different pixels in
each face of a cube map have no longer the same solid angle. To solve this issue, a correction is applied for a pixel as
in [2].
In Figure 5, a weight correction W of (x, y) for upper
and lower faces is as follows:
r

=

cos θ

=

W (ω(x, y, 1)) =

(Mx )i Li ,

(2)

i=1

x2 + y 2 + 1
1
x2 + y 2 + 1
1
x2 + y 2 + 1

∆A

where ∆A = 4π/N . N denotes the total number of pix-

where N denotes the number of coefﬁcients of spherical
harmonic functions, and L denotes the lighting coefﬁcients
computed by dynamic cube map rendering.
Glossy reﬂection In the case of glossy reﬂection, the multiplication of a matrix and a vector is needed.
N

Lx =

αi G∗i ((Mx )ij Li ) yi (R),

(3)

i=1

where R denotes an inverse direction of a viewing vector. α
and G∗ can be computed the same fashion as described in
Section 2.2.

4. Results and Discussion
All of our programs are implemented in C language. We
also use OpenGL for rendering and Cg [6] for the vertex
program functionality on GPU. We use a software renderer
lucille [3] to pre-compute transfer coefﬁcients. For the expansion of spherical harmonic functions, we set l = 4, e.g.
coefﬁcients of N = 25. This is because it is the maximum
value that can be processed with a current CPU and GPU.
In our experiments, the case of N = 25 presents a good approximation for the light distribution of low frequency. If
we treat only the ideal diffuse reﬂection and the complexity
of occlusion is adequately small, N = 9 also gives a good
approximation [7]. In the case of diffuse reﬂection, Equation (2) can be processed by a simple combination of the

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

stage
Scene rendering
Cube map rendering
glReadPixels ×6
Lighting coefﬁcients computation
Glossy coefﬁcient matrix manipulation
Others
Total
Frame rate

Mobility Radeon 9600
diffuse
glossy
seconds (%)
seconds (%)
0.1500 (83%) 0.0400 (6%)
0.0012 (0.7%) 0.0010 (0.1%)
0.0028 (1.5%) 0.0028 (0.4%)
0.0180 (10%) 0.0180 (3%)
0.6000 (90%)
0.0080 (4%)
0.0030 (4%)
0.18 sec.
0.66 sec.
5.6 FPS
1.5 FPS

GeForce FX 5900 Ultra
diffuse
glossy
seconds (%)
seconds (%)
0.0260 (70%) 0.0260 (10%)
0.0015 (4%)
0.0015 (0.6%)
0.0061 (16%) 0.0061 (2.4%)
0.0032 (9%)
0.0032 (1%)
0.2100 (84%)
0.0002 (1%)
0.0032 (1%)
0.037 sec.
0.25 sec.
27 FPS
4 FPS

Table 2. Computation time for each frame.
summation and multiplication, and then a vertex program
on GPU can be used. In the case of glossy reﬂection, coefﬁcients of glossy transfer is a 25 × 25 matrix when N = 25.
In the matrix computation, however, the number of elements
is much more than the number of instructions which a vertex program can be processed at a time. We use CPU computation only for this case.
Table 2 shows the detail of computation time in each
frame. These timings are measured on two machines (PowerPC G4 1.25 GHz / ATI Mobility Radeon 9600 / Mac OS
X, and Pentium 4 3.2 GHz / NVIDIA GeForce FX 5900 Ultra / Windows XP).
The scene used for measuring computation time is Stanford dragon scene (Figure 4) consisting of about 50k polygons. “Dragon diffuse” is shown in Figure 4(a) and “Dragon
glossy” in Figure 4(b). Scene rendering is the rendering time of polygons using vertex program on GPU in
ﬁnal rendering stage. Cube map rendering is the rendering time based on cube map rendering in the scene
with dynamic lights. glReadPixels counts the time consumed by transferring cube map pixel memory on VRAM
to CPU memory. lighting coefﬁcients computation calculates lighting coefﬁcients convolving read-backed cube map
pixel values and pre-computed spherical harmonic functions.
Coefﬁcients for the diffuse surface expanded by spherical harmonics and lighting coefﬁcients are multiplied in vertex program. For the glossy surface, we calculate shading
for each vertex on CPU (this is listed in Table 2 as Glossy
coefﬁcient matrix manipulation) because the data associated to each vertex can not ﬁt into the hardware limit of vertex program.
Interactively rendered images using our method are
shown in Figure 6. We used area light sources to illuminate these scenes. The number of lights can be freely chosen and no performance drops occurs even if hundreds of
lights are placed in the scene. Each of these scenes consists
of 20-50 k polygons which can be rendered interactively.

5. Conclusion and Future Work
We proposed a new interactive rendering method by an
extended PRT method. It can be implemented on GPU almost entirely if the scene consists of diffuse surface. Our
method is suited for scenes with middle scale lighting variation such as indoor environment, which is difﬁcult to represent in the previous work.
Our future work includes the support for more general
BDRFs, data compression and animated objects.

Acknowledgements
The “dragon” and “Buddha” models are courtesy of
Stanford University, Computer Graphics Laboratory, other
models we used is from 3D cafe. We would like to thank
Mr. Alexandre Gouaillard for proofreading this paper. We
would also like to thank Prof. Yoshinori Dobashi, Hokkaido
University for useful discussions and Prof. Tomoshi Miyamura, Nihon University for granting us the usage of 16×
CPU parallel PC cluster.

A. Spherical Harmonic
A.1. Real Spherical Harmonic
Spherical harmonic is a complex function, but in computer graphics we need only real part of it. So we use real
spherical harmonic. There is a correspondence between
spherical harmonic Yl,m and real spherical harmonic yl,m .

yl,m =





√1 (Yl,m + Yl,−m )
2
1
√
(Yl,m − Yl,−m )
i 2

Yl,m

m>0
m<0
m=0

Rewriting it in terms of associated Legendre polynomial
Pl,m , we get

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

(a)

(b)

(c)

(d)

Figure 6. Interactively rendered images using our method.

yl,m

 √
m>0
 √2Kl,m cos(mφ)Pl,m (cos θ)
=
2Kl,m sin(−mφ)Pl,−m (cos θ) m < 0

m = 0,
Kl,m Pl,m (cos θ)

where Kl,m =

2l+1 (l−m)!
4 (l+m)! .

A.2. Spherical Harmonics in Cartesian Coordinates
Solid harmonic rl Yl,m (θ, φ) in spherical coordinates
(r, θ, φ) can also be described in Cartesian coordinates [13].

rl Yl,m (θ, φ)

=

2l + 1
(l + m)!(l − m)! ×
4π
x + iy p x − iy q s
1
(−
) (
) z
p!q!s!
2
2
p,q,s

p, q, s are positive integer numbers. Summation is taken
over all combination of p, q, r that fulﬁlls p + q + s =
l, p − q = m. If we think a unit sphere(r = 1), real spherical harmonic in Cartesian coordinates is represented by simple polynomial up to order l. Table 3 lists real spherical harmonic in Cartesian coordinates up to l = 4.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE

l=0,1,2
=

1
4π

y1,−1
y1,0
y1,1

=
=
=

3
y
4π
3
z
4π
3
x
4π

y2,−2
y2,−1
y2,0
y2,1
y2,2

=
=
=
=
=

15
xy
4π
15
yz
4π
5
(3z 2 − 1)
16π
15
xz
4π
15 2
x − y2
16π

y0,0

l=3

y3,−3
y3,−2
y3,−1
y3,0
y3,1
y3,2
y3,3

=
=
=
=
=
=
=

l=4

35
(3x2 y − y 3 )
32π
105
xyz
4π
21
y(5z 2 − 1)
32π
7
(5z 3 − 3z)
16π
21
x(5z 2 − 1)
32π
105
z(x2 − y 2 )
16π
35
(x3 − 3xy 2 )
32π

y4,−4
y4,−3
y4,−2
y4,−1
y4,0
y4,1
y4,2
y4,3
y4,4

=
=
=
=
=
=
=
=
=

315
(x3 y − xy 3 )
16π
315
z(3x2 y − y 3 )
32π
45
xy(7z 2 − 1)
16π
45
(7yz 3 − 3yz)
32π
9
(35z 4 − 30z 2 + 3)
256π
45
(7xz 3 − 3xz)
32π
45
(x2 − y 2 )(7z 2 − 1)
64π
315
z(x3 − 3xy 2 )
32π
315
(x4 − 6x2 y 2 + y 4 )
256π

Table 3. Real spherical harmonics up to l ≤ 4 with normalized vector (x, y, z) representation in Cartesian coordinates.

References
[1] B. Cabral, N. Max, and R. Springmeyer. Bidirectional reﬂection functions from surface bump maps. In Proceedings of
ACM SIGGRAPH 1987, pages 273–281, 1987.
[2] M. F. Cohen and D. P. Greenberg. The hemi-cube: A radiosity solution for complex environments. Proceedings of ACM
SIGGRAPH 1985, 19(3):31–40, 1985.
[3] M. Fujita and T. Kanai. lucille: Open source global illumination renderer. In The 7th IASTED International Conference
on Computer Graphics and Imaging (CGIM 2004), 2004. to
appear, http://lucille.sourceforge.net/.
[4] J. Kautz, P.-P. Sloan, and J. Snyder. Fast, arbitrary BRDF
shading for low-frequency lighting using spherical harmonics. In Proceedings of Thirteenth Eurographics Workshop on
Rendering, pages 291–296, 2002.
[5] J. Lehtinen and J. Kautz. Matrix radiance transfer. In Proceedings of the 2003 symposium on Interative 3D graphics,
pages 59–64, 2003.
[6] W. R. Mark, R. S. Glanville, K. Akeley, and M. J. Kilgard.
Cg: a system for programming graphics hardware in a c-like
language. ACM Transactions on Graphics (Proceedings of
ACM SIGGRAPH 2003), 22(3):896–907, 2003.
[7] R. Ramamoorthi and P. Hanrahan. An efﬁcient representation for irradiance environment maps. In Proceedings of
ACM SIGGRAPH 2001, pages 497–500, 2001.
[8] F. X. Sillion, J. R. Arvo, S. H. Westin, and D. P. Greenberg.
A global illumination solution for general reﬂectance distributions. In Proceedings of ACM SIGGRAPH 1991, pages
187–196, 1991.
[9] P.-P. Sloan, J. Hall, J. Hart, and J. Snyder. Clustered principal components for precomputed radiance transfer. ACM
Transactions on Graphics (Proceedings of ACM SIGGRAPH
2003), 22(3):382–391, 2003.
[10] P.-P. Sloan, J. Kautz, and J. Snyder. Precomputed radiance
transfer for real-time rendering in dynamic, low-frequency
lighting environments. ACM Transactions on Graphics (Proceedings of ACM SIGGRAPH 2002), 21(3):527–536, 2002.

[11] P.-P. Sloan, X. Liu, H.-Y. Shum, and J. Snyder. Bi-scale radiance transfer. ACM Transactions on Graphics (Proceedings
of ACM SIGGRAPH 2003), 22(3):370–375, 2003.
[12] W.-S. L. Tien-Tsin Wong and P.-A. Heng. Sampling with
hammersley and halton points. Journal of Graphics Tools,
2(2):9–24, 1997.
[13] D. A. Varshalovich, A. N. Moksalev, and V. K. Khersonskii.
Quantum Theory of Angular Momentum. World Scientiﬁc
Publishing Co., Singapore, 1988.
[14] S. H. Westin, J. R. Arvo, and K. E. Torrance. Predicting reﬂectance functions from complex surfaces. In Proceedings
of ACM SIGGRAPH 1992, pages 255–264, 1992.

Proceedings of the International Conference on Computer Graphics, Imaging and Visualization (CGIV’04)
0-7695-2178-9/04 $20.00 © 2004 IEEE


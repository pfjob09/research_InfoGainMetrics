2012 Ninth International Conference on Computer Graphics, Imaging and Visualization

GPU Ray Tracing Based on Reduced Bounding Volume Hierarchies
Sai-Keung Wong

Yu-Chun Cheng

Shing-Yeu Lii

Department of Computer Science
National Chiao Tung University
Hsinchu, 300 Taiwan
cswingo@cs.nctu.edu.tw

Department of Computer Science
National Chiao Tung University
Hsinchu, 300 Taiwan
qcycp1007@gmail.com

Department of Computer Science
National Chiao Tung University
Hsinchu, 300 Taiwan
HenryLii@hotmail.com

Abstract

of the objects. The algorithm [13] is based on Morton
code so that the locality of the triangles of the objects is
encapsulated in the BVH structure.
The assumption of our method is that the objects are
closed. At the runtime phase, the objects are divided into
view-sets with respect to the view targets which include
the camera and light sources. The triangles of each viewset are then used for constructing a reduced bounding
volume hierarchy (RBVH). Our key contributions include:
(1) We present a GPU-based approach to construct a
RBVH for each view target. The ray traversal for the
primary and shadow rays is substantially faster by using
the RBVHs. Our approach is suitable for supersampling;
and (2) We propose to group the nearby light sources and
treat them as a single view target. So that we build one
RBVH instead of multiple RBVHs for the nearby light
sources.

We present a bounding volume hierarchy construction
based on a culling technique for performing ray tracing
on manycore GPUs. The objects are divided into view-sets
of triangles with respect to a set of view targets (including
the camera and the light sources). A bounding volume
hierarchy, namely reduced bounding volume hierarchy
(RBVH), is then constructed for each view-set. Each
RBVH contains a portion of the triangles of the objects.
The ray traversal is improved for primary and shadow
rays, leading to a net improvement of ray tracing. We
also handle multiple lights that are close to each other.
Our method has been implemented on manycore GPUs
and evaluated for dynamics scenes. Experimental results
show that our method improves ray tracing for primary
and shadow rays.
Keywords— ray tracing, bounding volume hierarchy,
manycore GPUs, culling technique

II. Related Work
The ﬁrst GPU-based ray tracer was Ray Engine [2]
but GPU was employed only for computing ray-triangle
intersection. There was a lot of data transmission between
the CPU main memory and GPU memory, resulting in
poor performance. Later on, Purcell et al. [17] employed
GPUs for performing primary ray generation, traversal,
ray-triangle intersection, shading, and secondary ray generation on separated streaming kernels.
Most ray tracing techniques focus on improving the
process of ray traversal. A uniform grid acceleration structure was proposed in [17] for performing ray traversal.
Ernst et al. [4] proposed a recursive algorithm by using a
stack on GPUs with texture and fragment shaders. Their
method was based on kd-tree traversal. Foley et al. [5]
proposed a stackless kd-tree algorithm, called kd-restart
and kd-backtrack. Horn et al. [10] used a short stack
structure to reduce the number of traversal steps of kdrestart, and they achieved interactive performance. Popov
et al. [16] presented a stackless packet traversal algorithm
to implement ray tracing using kd-trees.
Using BVH acceleration structures for ray tracing on
GPUs was received much attention [1][7][3], particularly

I. Introduction
Ray tracing is one of the most important rendering
techniques in computer graphics. It is widely used in
rendering realistic scenes. With the rapid development
of graphics processing units (GPUs), there are more and
more ray tracing techniques developed on GPUs.
The acceleration structures, such as kd-tree and bounding volume hierarchy (BVH), can be used for efﬁcient
ray traversal. The construction cost of such acceleration
structures should be considered for rendering dynamics
scenes. Therefore, we adopt BVH as its construction
cost is less than kd-tree. Most approaches build the
acceleration structures for all the triangles of the objects.
However, it is not necessary to do so in some cases.
For example, we can use back-face culling to remove
the triangles that are not visible from the camera when
primary rays are concerned. Similarly, we can collect all
the triangles facing to the light sources and then handle
shadow rays for these triangles. In other words, we can
collect the required triangles and then employ an efﬁcient
GPU-based algorithm, such as [13], to construct the BVHs
978-0-7695-4778-7/12 $26.00 © 2012 IEEE
DOI 10.1109/CGIV.2012.12

1

Fig. 1. The snapshots of the four models. From left to right: wood doll, toasters, AEK 24 cell, and armadillo. The effects include shadow and
reﬂection.

S + (V, U ) and S − (V, U ) with respect to a view target
V. Hence, S − (V, U ) = U \ S + (V, U ). S + (V, U ) and
S − (V, U ) are given by

for handling dynamics scenes. G¨unther et al. [7] presented
a BVH-based parallel packet traversal algorithm based on
a shared stack. Hybrid methods were proposed on GPUs
[15][6] by increasing the degree of parallelism.
Different kinds of spatial partitioning schemes are
exploited. For example, Zhou et al. [18] proposed a real
time algorithm based on the breadth ﬁrst search order
to construct kd-trees on GPUs. Lauterbach et al. [13]
developed a hybrid algorithm based on Morton code to
construct the SAH-based BVHs on GPUs. A real time
technique of constructing uniform grids was introduced
in [8]. In this paper, we adopt [13] for constructing the
BVHs of the objects as its performance is fast for handling
dynamics scenes.
The culling technique can reduce the number of triangles because the invisible triangles are removed. Hunt et
al. [12][11] proposed the method using the perspective
volume of the view targets to create the acceleration
structure. In this paper, we adopt a similar idea but our
approach is implemented entirely on manycore GPUs.
Furthermore, we build only one RBVH for nearby light
sources.

S + (V, U ) = {ti | − r(ti ) · n(ti ) > 0, ti ∈ U }

(1)

and
S − (V, U ) = {ti | − r(ti ) · n(ti ) ≤ 0, ti ∈ U },

(2)

where r(ti ) = p(ti ) − p(V) is the direction from the
position p(V) of the view target V to a vertex p(ti ) of
the triangle ti . If the view target is a directional light
source, then r(ti ) is the direction of the light source.
Denote the camera as C and the light source as L.
Then we have C + = S + (C, U ), C − = S − (C, U ), L+ =
S + (L, U ) and L− = S − (L, U ).
To compute the intersection points between the primary
rays and the triangles of U , what we need is the triangles
of the view-set C + . This is because the ﬁrst intersection
point between a primary ray and the triangles of U is
the intersection point between the primary ray and the
triangles of C + . However, if a mesh is unclosed, the claim
is not true as a primary ray may be shot at the backside
of a triangle of the mesh and the triangle is negatively
oriented with respect to the camera (see Fig. 2).

III. Reduced BVHs (RBVHs)
Our method is based on the back-face culling technique
to remove the triangles that are invisible from the given
view targets before the BVHs are constructed. The view
targets include the camera and the light sources.

A. Model Decomposition and Computation of
View-Sets
A view target is either a camera or a light source. The
normal vectors of the triangles of each object point to the
exterior region of the object. Suppose that the unit normal
vector of a triangle t is n(t) and the direction of the
incident ray from the camera to t is r(t). If −r(t)·n(t) >
0, then the triangle is positively oriented with respect to
the camera and it is negatively oriented otherwise.
Let U be the set of all the triangles of the triangle
meshes. Then, we split U into two disjoint view-sets

Fig. 2. An incident ray hits at a point (red) of the backside of a triangle.
The positively and negatively oriented triangles are marked in orange
color and blue color, respectively.

We build the RBVH of C + and employ the RBVH
for performing primary ray traversal. Fig. 3 shows the

2

(a)

(b)

(c)

Fig. 3. The triangles of the view-set C + for an armadillo model from
different viewing positions. (a): from camera; (b) and (c): from other
viewing positions.

Fig. 4. Index assignment for a view-set. Set ﬂag to 1 if the triangle is
positively oriented, perform parallel reduction to compute the numbers
of 0’s and 1’s, perform parallel exclusive preﬁx sum, and then perform
compaction for index assignment.

triangles of the view-set C + for an armadillo model. In
general, the number of triangles of C + is around half of
the number of triangles of the objects if the objects are
discretized uniformly. There are two advantages by using
the RBVH. First, the construction time of the RBVH is
around half of the construction time of the single BVH
of the objects. Second, the ray traversal time is reduced
as the number of nodes of the RBVH is smaller than the
one of the single BVH.
Consider a single light source L. We can divide the
triangles of the objects into another two view-sets with
respect to L, namely L+ and L− . Recall that the objects
are closed. If a shadow ray hits a triangle of an object, the
shadow ray must hit the closed object in an even number
of times. Furthermore, the shadow ray hits a triangle of
L+ and it also hits a triangle of L− . We can therefore
build the RBVH of L+ or L− and use the RBVH for
computing shadow. We pick the view-set Lmin with the
smallest number of triangles. That is
Lmin

=

argmin | |.

that, we perform parallel exclusive preﬁx sum for the ﬂags
and then perform compaction to group the triangle indices
if the ﬂags of the triangles are 1. Fig. 4 shows the work
ﬂow for collecting the indices of the positively oriented
triangles into an array D. After collecting the triangles,
we perform the approach presented in [13] to construct the
RBVH of C + . Similarly, we perform the same procedure
for building the RBVH of Lmin .

C. Multiple Light Sources
We may have multiple light sources {L1 , L2 , ..., Lm }
for each light
in the scenes. In this case, we compute Lmin
j
source Lj , for j = 1, 2, ..., m. The models are divided into
view-sets with respect to each light source and then the
are constructed. We note that
RBVHs for all the Lmin
j
the procedure of performing model decomposition for the
light sources are independent. Hence, parallel processing
and then
can be adopted for computing all the Lmin
j
constructing the RBVHs.
If there are multiple lights and they are close to each
other, we can group them together so that only one RBVH
is built for them instead of building one RBVH per light.
Let pc be the central position of the light sources. We
have

(3)

∈{L+ ,L− }

We then perform GPU ray tracing for primary rays and
shadow rays by using the RBVHs associated with C + and
Lmin .

B. Construction of RBVHs on GPUs

S + (pc , U ) =

We store all the mesh data, e.g., positions of vertices
and vertex indices of triangles, in global memory on
GPUs. To avoid copying the triangle data, we allocate
additional global memory to store the triangle indices of
C + and the triangle indices of Lmin . The size of memory
for storing C + is proportional to the number of triangles
of C + . Similarly, the size of memory for storing Lmin is
proportional to the number of triangles of Lmin .
To collect the triangle indices of C + , we maintain a
ﬂag array and each ﬂag of the ﬂag array is associated with
a triangle in order. We go over the triangles one by one.
Set the ﬂag associated with a triangle t to 1 if −(p(t) −
p(C)) · n(t) > 0 and the ﬂag is set to 0 otherwise. After

{ti | − (p(ti ) − pc ) · n(ti ) > −R, ti ∈ U },
where R is the longest distance between pc and the
light sources, i.e. R = max{ pc − p(Lj ) }, for j =
1, 2, · · · , m. Hence, we build the RBVH of S + (pc , U )
for the nearby light sources. Fig. 5 shows an example
with nine light sources.

IV. Implementation
To perform ray tracing in parallel, we assign a thread
to handle each ray. We detail the implementation of the
proposed method as follows. There are two important

3

Geforce GTX 480 graphics card with 2.0 compute capability. The timing information of the kernel function was
measured by using the CUDA compute visual proﬁler. We
compared our method to the default method in which we
adopted the method by Lauterbach et al [13]. to construct
the single BVH of the objects. Our method also employed
the technique [13] to build RBVHs. We kept all the other
components of ray tracing the same but the BVHs used
for ray traversal were different.
Table I shows the number of triangles of the viewsets C + , C − , L+ and L− after performing model decomposition. If the triangles of the objects are distributed
uniformly (e.g. Wood Doll, 24 Cell and Armadillo), the
objects are divided into two view-sets and each of the
view-sets contains about half of the total number of
triangles. For the toasters model, the mesh of the board is
not discretized uniformly. Thus, the numbers of triangles
between C + and C − are signiﬁcantly different.
Ray tracing with BVH construction. Table II shows
the timings of the entire process of ray tracing, including
BVHs construction and ray tracing. In general, the overall
performance of our proposed method is faster than the
default approach.
RBVH construction. Table III shows the results of
the timings of the BVH construction. The time spent in
constructing one RBVH is close to one halve of the time
spent in constructing the single BVH of the objects. The
cost of model decomposition is about linear to the number
of the view targets. Table IV shows the breakdown of
the construction of RBVH for different models. The most
time consuming part is to assign the indices of triangles
to the view-sets.
Multiple light sources. Table V shows the timings of
ray tracing with multiple lights sources which are close
to each other. The lights are arranged in a square with
dimension 3x3. We group the light sources as one view
target and build one representative RBVH for them. The
triangle number of the representative RBVH is around
70% of the original model. The result shows that our
method outperforms the default method consistently for
four and nine light sources. For four lights, the speedup
factor of our method is 3.6%; but for nine lights, the
speedup factor of our method increases to 13%.
Table VI show the timings of ray tracing for supersampling. The resolution of the image is 1024×1024. For 4×4
samples per pixel, there are 128 × 128 blocks and 32 × 32
threads per block. For 16 × 16 samples per pixel, there
are 512 × 512 blocks and 32 × 32 threads per block. Each
ray is handled by a thread. The performance of using the
RBVHs is much better than using the single BVH of the
objects. For 4x4 samples per pixel, the speedup factor of
our method ranges from 1.44 to 1.84. For 16x16 samples

Fig. 5.
An example with nine light sources which are uniformly
organized in a square.

issues that should be considered in parallel computation
on GPUs. The ﬁrst issue is about the work load balancing
for the threads, and each thread should access data in
certain order so as to improve the degree of parallelism.
The second issue is that the calculated results of each
thread have to be stored orderly in parallel according to
the related thread id (identiﬁer). In order to handle these
two issues, we employ fundamental parallel functions,
including parallel preﬁx sum, parallel sort, and parallel
reduction [9][14], which are optimized for performance.
TABLE I
T HE NUMBER OF TRIANGLES OF THE VIEW- SETS C + , C − , L+
L− .
Models
Wood Doll
Toasters
24 Cell
Armadillo

Total
#Tri
71,450
105,774
122,882
331,906

AND

C+

C−

L+

L−

35,556
81,794
60,828
166,115

35,894
23,980
62,054
165,791

36,340
81,848
60,860
166,483

35,110
23,926
62,022
165,423

TABLE II
R AY TRACING TIMINGS ( MSEC ) INCLUDING BVH CONSTRUCTION .
T HE PRIMARY AND SHADOW ARE COMPUTED .
Models
Wood Doll
Toasters
24 Cell
Armadillo

Single BVH for Traversal
primary
1 light
rays
28.7
36.1
61.9
77.6
67.8
100.9
107.3
138.5

RBVH for Traversal
primary
1 light
rays
14.2
29.0
38.1
48.3
34.1
68.3
56.4
119.9

V. Experiments and Results
We performed experiments on an Intel(R) Core2 Quad
CPU Q9400 @ 2.66GHz 2.67GHz 4 GB main memory
platform. The GPU techniques were implemented using
the NVIDIA CUDA programming language on NVIDIA

4

TABLE III
M ODEL COMPLEXITY AND TIMING COMPARISONS OF BVH CONSTRUCTION ( IN ms). T HERE IS ONE LIGHT SOURCE L. 2 ND COL .: MODEL
COMPLEXITY; 3 RD COL .: CONSTRUCTION OF THE SINGLE BVH OF ALL OBJECTS ; 4 TH COL .: MODEL DECOMPOSITION WITH RESPECT TO ONE
VIEW TARGET; 5 TH COL . TO 7 TH COL .: CONSTRUCTION TIMES FOR RBVH S OF DIFFERENT VIEW- SETS .
Models

#Tri(K)

Wood Doll
Toasters
24 Cell
Armadillo

71
105
122
331

Single BVH Construction

Model
Division
0.2
0.3
0.4
0.8

18.7
28.7
27.5
74.6

RBVH Construction
−
C+
C−
L+
1 (L1 )
8.9
9
9.1
17.4
5.2
17.4(5.1)
13.2
13.5
13.1
38.3
38.4
40.1

TABLE IV
B REAKDOWN OF M ODEL D ECOMPOSITION (usec).

40.16
72.26

Parallel Sum
Reduction
6.91
7.94

Parallel Exclusive
Preﬁx Sum
23.01
23.93

Indice
Assignment
129.01
335.10

209.09
429.23

65.63

8.35

22.40

93.60

189.98

67.79
128.83

8.32
14.34

21.76
70.46

253.38
548.93

351.25
762.56

Models

Triangle orientation

Wood Doll
Toasters
(C + , L+ )
Toasters
(C − , L− )
24 Cell
Armadillo

Total

TABLE V
R AY TRACING TIMINGS WITH MULTIPLE NEARBY LIGHT SOURCES FOR THE ARMADILLO MODEL . O UR METHOD COMPUTED ONE RBVH FOR THE
LIGHT SOURCES .
# triangle
Approach

# light

Single BVH
Ours
Single BVH
Ours

T IMING COMPARISONS ( IN msec)

4
9

331906
230347
331906
230243

Model
decomposition (camera + lights)
(msec)
0
0.8+0.5
0
0.8+0.5

BVH
construction
(msec)
74.6
38.3+52.9
74.6
38.3+52.6

Primary
rays
(msec)
32.8
17.5
32.8
17.5

Shadow
rays
(msec)
154.3
142.7
368.3
310.1

Total time
(msec)
261.7
252.7
475.7
419.8

TABLE VI
RBVH WITH SUPERSAMPLING COMPARED TO THE SINGLE BVH OF THE OBJECTS , INCLUDING THE COST OF
BVH CONSTRUCTION . P RIMARY RAYS AND SHADOW RAYS ARE HANDLED .

OF

Objects
Wood Doll
Toasters
24 Cell
Armadillo

Using Single BVH for Traversal
1×1
4×4
16 × 16
36.1
172.6
1925.3
77.6
420.2
4407.1
100.9
629.3
6038.6
138.5
611.4
4978.1

Using RBVH for Traversal
1×1
4×4
16 × 16
29
120
1582.2
48.3
227.2
3434.5
68.3
384.5
4442.1
119.9
405.2
3707.9

VI. Conclusion and Future Work

per pixel, the speedup factor of our method ranges from
1.22 to 1.36.

We have presented a method for dividing objects into
view-sets with respect to the camera and the light sources
and then computing the reduced BVHs of the view-sets
for ray traversal on GPUs. The total cost of constructing
the reduced BVHs may be higher than the cost of a single
BVH of the objects. However, we have shown that using
the reduced BVHs for ray traversal is faster than the
single BVH of the objects because there is fewer number
of triangles in the reduced BVH. For handling multiple
nearby light sources, we present a method for grouping
them and treat them as a single view target. The overall
performance of our method improves the process of ray
tracing, especially for supersampling. In the future, we
will extend our approach to the distributed ray tracing,
for instances, motion blur, soft shadow and defocus.

Limitations. Our method has limitations. The objects
should be closed manifold meshes. If the objects are
unclosed, our approach does not work properly (see
Fig. 2). The intersection points may be missed between
the primary rays and the objects. Furthermore, if there
are two or more light sources and they are far way from
each other, our system degrades even though we group
the light sources together. For example, one light source
is in front of the object and another light source is at the
back of the object. In this case, almost all the triangles
of the object are required for building the RBVH of the
light sources.

5

Acknowledgements
This research work was partially supported by the
National Science Council of Taiwan (NSC 100-2221-E009-145).

References
[1] C. Benthin, I. Wald, M. Scherbaum, and H. Friedrich. Ray tracing
on the cell processor. In Proceedings of the 2006 IEEE Symposium
on Interactive Ray Tracing, pages 15–23, 2006.
[2] N.A. Carr, J.D. Hall, and J.C. Hart. The ray engine. In Proceedings
of the ACM SIGGRAPH/EUROGRAPHICS conference on Graphics hardware, pages 37–46, 2002.
[3] N.A. Carr, J. Hoberock, K. Crane, and J.C. Hart. Fast GPU ray
tracing of dynamic meshes using geometry images. In Proceedings
of Graphics Interface 2006, pages 203–209, 2006.
[4] M. Ernst, C. Vogelgsang, and G. Greiner. Stack implementation
on programmable graphics hardware. In Proceedings of Vision,
modeling, and visualization, pages 255–262, 2004.
[5] T. Foley and J. Sugerman.
KD-tree acceleration structures
for a GPU raytracer.
In Proceedings of the ACM SIGGRAPH/EUROGRAPHICS conference on Graphics hardware,
pages 15–22, 2005.
[6] Pantaleoni J. Garanzha, K. and D. Mcallister. Simpler and faster
HLBVH with work queues. HPG ’11, pages 59–64, 2011.
[7] J. G¨unther, S. Popov, H.P. Seidel, and P. Slusallek. Realtime ray
tracing on GPU with BVH-based packet traversal. In Proceedings
of the IEEE/Eurographics Symposium on Interactive Ray Tracing,
pages 113–118, 2007.
[8] S. Guntury and P. J. Narayanan. Ray tracing dynamic scenes
with shadows on the gpu. In Eurographics Symposium on Parallel
Graphics and Visualization, pages 27–34, 2010.
[9] M. Harris, J. Owens, S. Sengupta, Y. Zhang, and A. Davidson.
CUDPP homepage, http://gpgpu.org/developer/cudpp, 2007.
[10] D.R. Horn, J. Sugerman, M. Houston, and P. Hanrahan. Interactive
kd tree GPU raytracing. In Proceedings of the symposium on
Interactive 3D graphics and games, pages 167–174, 2007.
[11] W. Hunt and W.R. Mark. Adaptive acceleration structures in
perspective space. In Proceedings of the IEEE/Eurographics
Symposium on Interactive Ray Tracing, pages 11–17, 2008.
[12] W. Hunt and W.R. Mark. Ray-specialized acceleration structures
for ray tracing. In Proceedings of the IEEE/Eurographics Symposium on Interactive Ray Tracing, pages 3 –10, 2008.
[13] C. Lauterbach, M. Garland, S. Sengupta, D. Luebke, and
D. Manocha. Fast BVH construction on GPUs. In Computer
Graphics Forum, volume 28, pages 375–384, 2009.
[14] NVIDIA
Corporation.
GPU
computing
SDK,
http://developer.nvidia.com/gpu-computing-sdk.
[15] J. Pantaleoni and D. Luebke. HLBVH: hierarchical LBVH construction for real-time ray tracing of dynamic geometry. HPG ’10,
pages 87–95, 2010.
[16] S. Popov, J. G¨unther, H.P. Seidel, and P. Slusallek. Stackless kdtree traversal for high performance GPU ray tracing. In Computer
Graphics Forum, volume 26, pages 415–424, 2007.
[17] T.J. Purcell, I. Buck, W.R. Mark, and P. Hanrahan. Ray tracing on
programmable graphics hardware. In ACM Trans. Graph., pages
703–712, 2002.
[18] K. Zhou, Q. Hou, R. Wang, and B. Guo. Real-time kd-tree
construction on graphics hardware. In ACM SIGGRAPH Asia,
page 126, 2008.

6


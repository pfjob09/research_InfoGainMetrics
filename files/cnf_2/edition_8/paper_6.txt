DOI: 10.1111/j.1467-8659.2007.001097.x

COMPUTER GRAPHICS

forum

Volume 27 (2008), number 1 pp. 73–80

A General Multi-step Algorithm for Voxel Traversing Along
a Line
2
ˇ
Y. K. Liu1 , H. Y. Song1 and B. Zalik

2

1 Computer Science Department, Dalian University for National Minorities, Dalian Development Zone 116600, China
Faculty of Electrical Enginerring and Computer Science, University of Maribor, Smetanova 17, SI-2000 Maribor, Slovenia

ABSTRACT
Traversing voxels along a three dimensional (3D) line is one of the most fundamental algorithms for voxel-based
applications. This paper presents a new 6-connectivity integer algorithm for this task. The proposed algorithm
accepts voxels having different sizes in x, y and z directions. To explain the idea of the proposed approach, a 2D
algorithm is firstly considered and then extended in 3D. This algorithm is a multi-step as up to three voxels may be
added in one iteration. It accepts both integer and floating-point input.
The new algorithm was compared to other popular voxel traversing algorithms. Counting the number of arithmetic operations showed that the proposed algorithm requires the least amount of operations per traversed voxel.
A comparison of spent CPU time using either integer or floating-point arithmetic confirms that the proposed algorithm is the most efficient. This algorithm is simple, and in compact form which also makes it attractive for
hardware implementation.
Keywords: I.3.3 [Computer Graphics] Picture/Image Generation: Line and curve generation
ACM CCS: I.3.3 [Computer Graphics]: Line and Curve Generation

r

1. Introduction

r

Voxel traversing along a line (a ray) is a fundamental algorithm for different voxel-based applications, as for example measurements in microradiology [KR04], object reconstructions [MYA03] and, of course, in computer graphics.
Voxels are usually considered as having the form of cubes,
but in many applications their natural shape is a block. For
example, in the visualization of medical data obtained from
computer tomography (CT) scanners, the distances between
the slides usually differ from the sizes of individual pixels in
a particular slide.

18-connectivity, when the neighbouring voxels touch at
the faces or edges or
26-connectivity, when neighbouring voxels share common faces, edges or vertices (6 face-, 12 edge- and 8
vertex-connectivity).

6-connectivity, when the neighbouring voxels share common faces,

One of the first voxel traversing algorithms was presented
by Fujimoto, Tanaka and Iwata [FTI86]. This algorithm,
named 3DDDA, was used for the ray-tracing of a uniformly
subdivided scene. The most famous voxel traversing algorithm was developed by Cleary and Wyvill [CW88]. The
original version of their solution uses floating-point arithmetic. Simultaneously, Amanatides and Woo [AW87], and
later Snyder and Barr [SB87], proposed similar algorithms. In
1994, Endl and Sommer presented a survey of ray-generators
for ray-tracing algorithms [ES94]. Sakas et al. [SGS95] developed a counting steps algorithm along the ray to improve the numerical stability of the Cleary and Wyvill algorithm. Those algorithms achieved 6-connectivity of traversed

c 2007 The Authors
Journal compilation c 2007 The Eurographics Association and
Blackwell Publishing Ltd. Published by Blackwell Publishing,
9600 Garsington Road, Oxford OX4 2DQ, UK and 350 Main
Street, Malden, MA 02148, USA.

Submitted December 2004
Revised February 2006
Accepted January 2007

The most fundamental algorithm needed when visualization voxel space is voxel traversing along a line (a ray). According to the neighbourhood relationships of pierced voxels,
we distinguish among:

r

73

74

Y. Liu et al. / Multi-step Algorithm for Voxel Traversing

Figure 1: Line traversing and line drawing voxels.

voxels causing, in some cases, more voxels being marked
ˇ
ˇ
than being pierced. In 1997, Zalik
et al. [ZCO97]
presented
a code-based voxel traversing algorithm, which converts between face-, edge- and vertex-connectivity. This algorithm
extends the Bresenham line-drawing algorithm to three dimensional (3D) space by determining so-called Bresenham
voxels. Additional voxels (named non-Bresenham voxels)
are inserted between them to determine all pierced voxels in
one pass. This algorithm applies several conditions according to the two following Bresenham voxels’ positions, which
makes it complicated for implementation. This algorithm is
also slightly slower than Cleary and Wyvill’s algorithm. Another algorithm was later presented by Cohen and Kaufman
[COK97]. This algorithm uses integer arithmetic and can also
convert between vertex- and face-connectivity. Liu et al. preˇ
sented [LZY04]
a multi-step 6-connectivity voxel traversing algorithm, which uses only integer arithmetic. This algorithm is capable of traversing only voxels having the form of
unit cubes, that is having length, width and height equal to
one.
This paper presents a more practical and general 6connectivity multi-step algorithm for traversing voxels having the form of a block. It uses only integer operation, while
the start and end points of the line segments can have any
position in a voxel.
This paper is organized in five Sections, and an Appendix.
In Section 2, the 2D version of the new algorithm is introduced while Section 3 gives details of the 3D algorithm.
Section 4 considers the experimental results and Section 5
concludes the paper. The appendix gives the pseudocode of
the new 3D voxel traversing algorithm.

2. A new 2D voxel traversing algorithm
This section gives the main idea of the new 6-connectivity
voxel traversing algorithm in 2D. In Figure 1, the eight
shadowed cells are the line traversing voxels and the five
dark shadowed cells represent the line drawing voxels or
Bresenham voxels (we will also use the word voxel in the
2D case). One of the directions is considered as the main or
a driving direction, depending on the slope of the line. In the
driving direction, Bresenham voxles are visited sequentially.
In Figure 1, x is the driving axis.
Let us denote the world coordinate by lowercase x, y and
the voxel coordinate by capital x, y. Suppose the start and end
points of the line segment are (x1 , x2 ) and (x2 , y2 ), and the
length and width of the voxel are V x and V y , respectively.
Assume d x = |x 2 − x 1 |, dy = |y 2 − y 1 |. If V y /V x > dy/dx, x
direction is the driving axis, otherwise y is the driving axis.
Without loss of generality, we assume that x is the driving
axis and that x2 > x1 and y2 > y1 . At every step of our algorithm, x increases by V x (the length of the voxel) and then
checks, which directly neighbouring voxel is pierced by the
line segment. Observing Figure 2, we can see that from the
current voxel the line segment can pierce:

r
r

the upper voxel and the upper-right voxel (to be the next
current voxel), if the line segment passes above point T,
or
the right voxel (to be the next current voxel), if the line
segment passes below point T.

Accordingly, we can conclude that there is no other neighbouring voxels that could be selected except the mentioned
three neighboring voxels.

c 2007 The Authors
Journal compilation c 2007 The Eurographics Association and Blackwell Publishing Ltd.

Y. Liu et al. / Multi-step Algorithm for Voxel Traversing

75

Figure 2: 2D voxel traversing.

How do we determine whether the line is above point T?
Clearly, T (with value V y ) should be compared with the height
of the intersection point of the line segment and the right edge
of the current voxel, which can be calculated as (see Figure 2)
px y0 = ys + (Vx − xs )

dy
.
dx

(1)

where
xs = x1 % Vx ,
ys = y1 % Vy ,
and % is the remainder operator.
In the next step, the height of the intersection between the
line segment and the right edge of the next current voxel
increases for the constant value V x dy/dx. We use pxy to accumulate the height, where the subscript ‘xy’ denotes that
the calculation is performed on the XY plane for differentiating the other coordinate planes used by the 3D algorithm
presented in the next section. That is
px y = px y0 + Vx

dy
,
dx

(2)

which is compared with the upper-right vertex of the next
current voxel.
Now, we can sum up the previous descriptions in the following algorithm (function ‘MarkVoxel’ in this pseudocode
indicates the voxel at the position (x, y) is pierced by the ray):

LineTraversal-2D(x1 , y1 , x2 , y2 , Vx , Vy )
begin
X = x1 DIV Vx ;
Y = y1 DIV Vy ; // coordinate of starting voxel
X 2 = x2 DIV Vx ; // x coordinate of ending voxel
dy = |y2 − y1 |;
d x = |x2 − x1 |;
ys = y1 % Vy ;
xs = x1 % Vx ;
px y = ys + (Vx − xs ) ∗ dy/dx;
MarkVoxel(X, Y);
while X < X 2 do
if pxy > Vy then begin
MarkVoxel(X, Y + 1);
MarkVoxel(X + 1, Y + 1);
// position of new current voxel
X = X + 1;
Y = Y + 1;
pxy = pxy + Vx ∗ dy/dx − Vy ;
end else
begin
MarkVoxel(X + 1, Y);
X = X + 1;
// position of new current voxel is (X + 1, Y)
pxy = pxy + Vx ∗ dy/dx;
endif
endwhile
end.
The algorithm is transformed to an integer algorithm in
order to avoid an accumulation of rounding errors and to
increase the execution speed. Firstly, pxy should be compared

c 2007 The Authors
Journal compilation c 2007 The Eurographics Association and Blackwell Publishing Ltd.

76

Y. Liu et al. / Multi-step Algorithm for Voxel Traversing

to 0. For that, V y is subtracted from pxy0 :
px y0 = ys − Vy + (Vx − xs )

dy
.
dx

(3)

Division is avoided by multiplying Eq. 3 by dx in order to
use only integer operations:
px y0 · d x = (ys − Vy )d x + (Vx − xs )dy.

(4)

As dx is positive, the sign of pxy0 is invariant on multiplication by dx. When replacing p xy0 dx with exy0 , we obtain:
ex y0 = (ys − Vy )d x + (Vx − xs )dy.

(5)

To summarize, the new decision variable exy is obatined
from pxy as:
px y = px y − Vy ;

ex y = px y d x.

(6)

If all input parameters are integer, the proposed voxel
traversion algorithm can be realized using only integer arithmetic, as shown in the following pseudocode:
LineTraversalInteger-2D(x1 , y1 , x2 , y2 , Vx , Vy )
begin
Y = y1 DIV Vy ;
X = x1 DIV Vx ;
X 2 = x2 DIV Vx ;
dy = |y2 − y1|;
dx = |x2 − x1 |;
xs = x1 % Vx ;
ys = y1 % Vy ;
exy = (ys − Vy ) ∗ dx + (Vx − xs ) ∗ dy;
d1 = d − Vy ∗ dx;
d = Vx ∗ dy;
while X < X 2 do
if exy > 0 then begin
MarkVoxel(X, Y + 1);
MarkVoxel(X + 1, Y + 1);
X = X + 1;
Y = Y + 1;
exy = exy + d1;
end
else begin
MarkVoxel(X + 1, Y);
X = X + 1;
exy = exy + d;
endif
endwhile
end.
3. Traversing voxels along a 3D line
Let us denote the coordinates of the start and end points of
the 3D line segment by (x1 , y1 , z1 ), (x2 , y2 , z2 ) and the size
of a voxel by V x , V y and V z . Assume dx = |x2 − x1 |, dy =
|y2 − y1 |, and dz = |z2 − z1 |. Similarly as in the 2D case, the
3D traversing voxel algorithm is divided into three parts in

Figure 3: Computing of pzy .
regard to whether x, y or z is the driving axis. As all three parts
are symmetric, only x driving axis algorithm is considered in
the continuation. In this case, we have V y /V x > dy/dx and
V z /V x > dz/dx. Let us suppose the current voxel is (X, Y, Z).
At each step of the algorithm, X always increases by 1, but
whether Y or Z should be increased by 1 or not should be
checked. If Y and Z are not increased by 1 simultaneously,
the previously described algorithm can be trivially extended
in 3D space. Therefore, the most interesting aspect is the case
where both, the y and z directions, are variant. In this case,
we have exy > 0 and exz > 0 (exy is a decision-variable of XY
plane and exz of the XZ plane). It is clear that in this case the
next current voxel is (X + 1, Y + 1, Z + 1), but how do we
move from the current voxel to the next current voxel? By
exy > 0, we know Y should be increased before X, and by
exz > 0, Z should be increased before X. Therefore there are
two possible paths:
(X , Y , Z ), (X , Y + 1, Z ), (X , Y + 1, Z + 1),
(X + 1, Y + 1, Z + 1)
or
(X , Y , Z ), (X , Y , Z + 1), (X , Y + 1, Z + 1),
(X + 1, Y + 1, Z + 1).
Obviously, we have to define which of the two possibilities
should be selected. Actually, we would like to compute ezy
in the ZY plane. Unfortunately, ezy cannot be increased in
the same way as exy and exz , because there does not exist
any drawing axis in the ZY plane. In continuation, we show
how ezy is computed from exy and exz . As in the 2D case, we
also observe the intersection points between the line and the
walls of the voxels (values pxy , pxz and pzy in Figure 3). The

c 2007 The Authors
Journal compilation c 2007 The Eurographics Association and Blackwell Publishing Ltd.

77

Y. Liu et al. / Multi-step Algorithm for Voxel Traversing

Table 1: Number of arithmetic operations at different voxel traversing algorithms (number of operations per traversed voxels is given in
brackets)

CK

Division
Multiplication
Increase/decrease
Comparison

0
0
3
3

CW

ZCO
Traversed voxels in each step

AW

0
0
4
3

0
0
4
3

1

2

3

1

2

3

0
0
3
9

0
1 (0.5)
5 (2.5)
10 (5)

0
2 (0.67)
7 (2.33)
11 (3.67)

0
0
3
3

0
0
3 (1.5)
3 (1.5)

0
2 (0.67)
4 (1.33))
4 (1.33))

meaning of pxy is the same as in the 2D integer algorithm
defined in Eq. 6. pxz and pzy are defined in a similar way but
concerne just different planes. p zy is computed to choose the
path from (X, Y, Z) to (X, Y + 1, Z + 1). If pzy > 0, the y
coordinate should be changed before z and voxel (X, Y + 1,
Z + 1) is then reached through voxel (X, Y + 1, Z), otherwise,
the z coordinate is changed before y and voxel (X, Y + 1,
Z + 1) is accessed through voxel (X, Y, Z + 1). The value pzy
is computed, as previously mentioned, from pxy and pxz . Let
us observe Figure 3. Using the principle of similar triangles,
we obtain:
f
dy
,
=
px z
dz

(7)

therefore
pzy = px y − f = px y − px z

dy
.
dz

(8)

By
px y =

ex y
,
dx

px z =

ex z
dx

(9)

we have
pzy =

ex y
ex z dy
ex y dz − ex z dy
−
=
.
dx
d x dz
d x dz

New algorithm
Traversed voxels in each step

(10)

The denominator in Eq. 10 is positive since both dx and
dz are absolute values. Testing whether pzy is greater than
0 is equal to testing whether the numerator exy dz − exz dy is
greater than 0, or whether exy dz is greater than exz dy.

4. Analyses and comparisons of algorithms
In order to prove the efficiency of the new algorithm, we compared it to four existing voxel traversing algorithms: Cleary–
Wyvill’s algorithm (CW) [CW88], Amanatides-Woo’s (AW)
ˇ
[AW87], Zalik–Clapworthy–Oblonˇ
sek’s algorithm (ZCO)
ˇ
[ZCO97], and Cohen–Kaufman’s algorithm (CK) [COK97].
Firstly, we counted the number of arithmetic operations
within the main loop. The statements outside the loop
execute only once, and therefore their influence on the runtime of the algorithm is minor unless the lattice of the voxels
is extremely small (today, this is usually not the case as we
have enough available memory). The number of numerical
operations executed once in the main loop for each algorithm,
are shown in Table 1. Here, we have omitted these operations
for updating the X, Y and Z coordinates of voxels being
pierced, as they are the same for all algorithms. In Table 1, the
addition and comparison operations in the loop were individually counted, while the comparison between two variables
is considered as a subtraction and a comparison with 0.
During implementations, all algorithms have been
optimized manually to minimize the number of arithmetic
operations. In this way, for example, the number of arithmetic
operations in the Cleary–Wyvill’s algorithm, as published in
their paper, is larger than those given in Table 1. As can
be seen from Table 1, the number of the new algorithm’s
arithmetic operations is evidently smaller than for other
algorithms.

The pseudocode given in the Appendix shows details of
the new voxel traversing algorithm’s implementation for arbitrary rays.

All tested algorithms were implemented in C++ and executed on Pentium 4 Celeron 1.7 GHz. For testing, a sphere
was embedded in the lattice of voxels. The line was generated by connecting two points on the sphere by a line passing
through the centre of the sphere. By changing the diameter of the sphere and the voxel size, different groups of line
segments were generated.

In some applications, the line-coordinates are given by
floating-point numbers. The proposed algorithm is easily
adapted to such cases by declaring some variables as being
floating-points. Clearly, in this case, the algorithm is sensitive to numerical errors caused due to an accumulation of
decision variable rounding errors.

The comparison of spent CPU time for all tested algorithms
is shown in Table 2. It should be mentioned that Cleary–
Wyvill’s and Amanatides–Woo’s algorithms, as described in
the original papers, are floating-point algorithms. We found
that the approach described in Section 2 of this paper can be
adapted to these two algorithms, too. Therefore, integer forms

c 2007 The Authors
Journal compilation c 2007 The Eurographics Association and Blackwell Publishing Ltd.

78

Y. Liu et al. / Multi-step Algorithm for Voxel Traversing

Table 2: Spent CPU times (seconds) of voxels traversing for integer input

Length of line segments

120
600
1200

No. of line segments

CK

CW

AW

ZCO

New algorithm

100,000
1,000,000
100,000
1,000,000
100,000
1,000,000

0.18
1.70
1.02
9.85
1.81
17.70

0.18
1.75
1.12
9.98
1.86
17.89

0.15
1.46
0.83
8.20
1.54
15.06

0.21
1.85
1.08
10.23
1.94
19.00

0.14
1.38
0.72
6.78
1.36
12.99

Table 3: Spent CPU times (seconds) of voxels traversing for floating-point input

Length of line segments

120
600
1200

No. of line segments

CK

CW

AW

ZCO

New algorithm

100,000
1,000,000
100,000
1,000,000
100,000
1,000,000

0.36
3.41
1.93
19.20
3.60
35.72

0.37
3.78
2.08
20.87
3.70
37.85

0.39
3.80
2.16
21.61
3.90
38.93

0.43
4.01
2.22
22.04
4.025
40.32

0.32
3.10
1.70
16.26
3.17
30.79

of all algorithms were used in order to compare algorithms
fairly and impersonally. The times given in Table 2 include
the execution-times in the main loop and the execution-time
needed to set the initial values outside the main loop. All
input/output operations are excluded.

Table 4: Square errors for float-point algorithm regarding different
length of traversed line

In computer graphics, the floating point input for the
line (the ray) is also used. For this reason, we also tested
the floating-point version of the algorithm by declaring all
necessary variables in the algorithms as floating-point. The
results are given in Table 3. As shown in Tables 2 and 3, the
proposed algorithm is the most efficient among algorithms
available at the moment. For this reason it is attractive to be
applied also in graphic operations supported by GPU’s.

500
1000
3000

In the implementation of the algorithm the input
parameters (coordinates of the end-points) can be tested
automatically to see whether they are all integers. In this case,
the variables are declared as integers, otherwise, the variables
are floating-point. For example, in C++, the template function
can be implementing as:

Length of the line

Square error
0.586
0.669
0.839

Table 5: The rules for substitution variables where y or z are driving
axes

Driving axis
Substitute
Substitute
Substitute

x

y

x by y
y by z
z by x

x by z
y by x
z by y

To examine the accumulated error of the float-point algorithm, we did the experiments summarized in Table 4. It is
evident that the accumulation of rounding errors may result
quickly in traversing wrong voxels.

in each step. The algorithm accepts both integer and floatingpoint input. Especially for the case of the integer input the
benefits are higher speed, insensibility on the accumulation
of rounding errors and its suitability for hardware implementation. This algorithm was compared with four of the most
efficient algorithms available today. The analysis showed that
the proposed algorithm requires the smallest number of arithmetic operations per voxel in the main loop, and that it also
achieves the highest speed.

5. Conclusion

Acknowledgment

This paper presents a new multi-step algorithm for voxels
traversing along a 3D line. Up to three voxels can be traversed

This work was supported by the National Natural Science
Foundation of China (60675008), and the Ministry for High

template <class T> void LineTravelsal-3D(T x1, T y1, T z1,
T x2, T y2, T z2, T vx, T vy, T vz),
where T can be int or float.

c 2007 The Authors
Journal compilation c 2007 The Eurographics Association and Blackwell Publishing Ltd.

Y. Liu et al. / Multi-step Algorithm for Voxel Traversing

Education, Science and Technology of Republic Slovenia
(P2-0041).
References
[AW87] AMANATIDES J., WOO A.: Fast voxel traversal algorithm for ray-tracing. In Eurographics’87 Conf. Proceedings (1987),MARECHAL G., (Ed.), North-Holland, pp.
3–10.
[COK97] COHEN-OR D., KAUFMAN A.: 3d line voxelization and connectivity control. IEEE Computer Graphics
& Applications 17, 6 (Nov-Dec 1997), 80–87.
[CW88] CLEARY J. C., WYVILL G.: Analysis of an algorithm for fast ray-tracing using uniform space subdivision.
The Visual Computer 4, 2 (Jul 1988), 65–83.
[ES94] ENDL R., SOMMER M.: Classification of raygenerators in uniform subdivisions and octrees for ray
tracing. Computer Graphics Forum 13, 1 (Jan-Mar 1994),
3–19.
[FTI86] FUJIMOTO A., TANAKA T., IWATA K.: Arts: Accelerated ray-tracing system. IEEE computer graphics &
applications 6, 1 (Apr 1986), 16–26.
[KR04] KETCHAM R. A., RYAN T.: Quantification and visualization of anisotropy in trabecular bone. Journal of
Microscopy 213, 2 (Feb 2004), 158–171.
ˇ
[LZY04]
LIU Y. K., Zˇ ALIK B., YANG H.: An integer onepass algorithm for voxel traversing. Computer Graphics
Forum 23, 2 (Jun 2004), 167–172.
[MYA03] M¨uLAYIM A. Y., YILMAZ U., ATALAY A.:
Silhouette-based 3d nodel reconstruction from multiple
images. IEEE Transactions on Systems, Man and Cybernetics 33, 4 (Aug 2003), 582–591.
[SB87] SNYDER J., BARR A.: Ray-tracing complex models
containing surface tessellations. In Proc. SIGGRAPH ’87
(1987), vol. 21, pp. 119–128.
[SGS95] SAKAS G., GRIMM M., SAVOPULOS A.: Optimized maximum intensity projection (mip). In Rending
Techniques’95 Conf. Proceedings (1995), Hanrahan P.,
Purgathofer W., (Eds.), Springer- Verlag, pp. 51–63.
ˇ
[ZCO97]
Zˇ ALIK B., CLAPWORTHY G., OBLONSˇ EK v.: An
efficient code-based voxel traversing algorithm. Computer
Graphics Forum 16, 2 (Jun 1997), 119–128.
Appendix
This Appendix introduces the pseudocode of the new 3D
voxel traversing algorithm. Only the part when x is the driv-

79

ing axis is given. The rules on how to implement the remaining parts for y and z driving axes are given at the
end.
Linetraversal-3D(x1 , y1 , z 1 , x2 , y2 , z 2 , Vx , Vy , Vz )
begin
d x = |x2 − x1 |;
dy = |y2 − y1 |;
dz = |z 2 − z 1 |;
if x2 ≥ x1 then sx = 1 else sx = −1;
if y2 ≥ y1 then sy = 1 else sy = −1;
if z 2 ≥ z 1 then sz = 1 else sz = −1;
xs = x1 − int(x1 / Vx ) ∗ Vx ;
ys = y1 − int(y1 / Vy ) ∗ Vy ;
z s = z 1 − int(z 1 / Vz ) ∗ Vz ;
if d x ∗ Vy > dy ∗ Vx and d x ∗ Vz > dz ∗ Vx then
begin
// x axis as driving axis
X = int(x1 / Vx );
Y = int(y1 / Vy );
Z = int(z 1 / Vz );
MarkVoxel(X, Y, Z);
X 2 = int(x2 / Vx );
ex y = (ys − Vy ) ∗ d x + (Vx − xs ) ∗ dy;
ex z = (z s − Vz ) ∗ d x + (Vx − xs ) ∗ dz;
dx y = Vx ∗ dy; d1x y = dx y − Vy ∗ d x;
dx z = Vx ∗ dz;
d1x z = dx z − Vz ∗ d x;
whileX < X 2 do
if ex y > 0 then
if ex z > 0 then begin
if ex y ∗ dz > ex z ∗ dy then
MarkVoxel(X,Y+sy,Z);
else
MarkVoxel(X,Y,Z+sz);
MarkVoxel(X,Y+sy,Z+sz);
MarkVoxel(X+sx, Y +sy,Z+sz);
X = X+sx; Y = Y+sy; Z = Z+sz;
ex y = ex y + d1x y ;
ex z = ex z + d1x z ;
end
else begin
MarkVoxel(X,Y+sy,Z);
MarkVoxel(X+sx,Y+sy, Z);
X = X+sx; Y = Y+sy;
ex y = ex y + d1x y ;
ex z = ex z + dx z ;
end
else if ex z > 0 then begin+
MarkVoxel(X,Y,Z+sz);
MarkVoxel(X+sx,Y, Z+sz);
X = X+sx; Z = Z+sz;
ex y = ex y + dx y ;
ex z = ex z + d1x z ;
end
else begin+
MarkVoxel(X+sx, Y, Z);
X = X+sx;
ex y = ex y + dx y ;
ex z = ex z + dx z ;
end;
end while;
else

c 2007 The Authors
Journal compilation c 2007 The Eurographics Association and Blackwell Publishing Ltd.

80

Y. Liu et al. / Multi-step Algorithm for Voxel Traversing

if (dy ∗ Vx > d x ∗ Vy ) and (dy ∗ Vz > dz ∗ Vy ) then
// y axis as driving axis
else
// z axis as driving axis

As the algorithm is symmetrical regarding the coordinate
axes, the algorithm is trivially extended for the cases where y
and z are the driving axes by using the rules for substitution
variables as shown in Table 5.

end.

c 2007 The Authors
Journal compilation c 2007 The Eurographics Association and Blackwell Publishing Ltd.


DOI: 10.1111/j.1467-8659.2010.01715.x

COMPUTER GRAPHICS

forum

Volume 29 (2010), number 8 pp. 2304–2312

A Key-Pose Caching System for Rendering an Animated
Crowd in Real-Time
W. Lister, R.G. Laycock and A.M. Day
School of Computing Sciences, University of East Anglia, UK
{W.Lister, Robert.Laycock, Andy.Day}@uea.ac.uk

Abstract
We present a method to accelerate the visualization of large crowds of animated characters. Linear-blend skinning
remains the dominant approach for animating a crowd but its efficiency can be improved by utilizing the temporal
and intra-crowd coherencies that are inherent within a populated scene. Our work adopts a caching system that
enables a skinned key-pose to be re-used by multi-pass rendering, between multiple agents and across multiple
frames. We investigate two different methods; an intermittent caching scheme (whereby each member of a crowd
is animated using only its nearest key-pose) and an interpolative approach that enables key-pose blending to be
supported. For the latter case, we show that finding the optimal set of key-poses to store is an NP-hard problem and
present a greedy algorithm suitable for real-time applications. Both variants deliver a worthwhile performance
improvement in comparison to using linear-blend skinning alone.
Keywords: crowd rendering and animation, animation caching
ACM CCS: I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism—Animation.

1. Introduction
Virtual crowds lie at the core of many real-time applications and have been employed in the domain of urban simulation [CLM05, DHOO05], cultural heritage [dHCSMT05,
RFD05] and videogames [Ubi07]; to breathe life into otherwise sterile worlds. An effective visualization describes a
large, heterogeneous crowd within which individuals appear
to be visually realistic and are convincingly animated, but this
is difficult to achieve in real-time due to the sheer volume
of geometry required to represent each agent with acceptable fidelity. Moreover, the incorporation of crowd variety
presents a further challenge given that art assets are costly
and time consuming to produce; clearly it is impractical to
author many thousands of characters by hand.
Several early works reduced the complexity of their crowd
visualizations by introducing aggressive level-of-detail techniques. In particular, the impostor representation described
in [ABT00, TLC02] evoked significant research by reducing
the problem of rendering a complex 3D character to that of
c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics
Association and Blackwell Publishing Ltd. Published by
Blackwell Publishing, 9600 Garsington Road, Oxford OX4
2DQ, UK and 350 Main Street, Malden, MA 02148, USA.

displaying a sequence of images. Similarly, in a purely geometric approach, Ulicny et al. [UdHCT04] discuss how animations can be stored on the GPU as sets of pre-transformed
meshes that are played-back during simulation. Hybrid systems are subsequently developed in [CLM05, DHOO05] and
although such methods enable a vast number of characters to
be visualized, the use of pre-deformed meshes can limit the
number of animations available to a crowd.
A fundamental benefit of visualizing crowds in real-time
lies in the ability of a user to interact with the scene. This
enables their actions to affect the behaviour and animation of
a crowd. Whilst pre-computing animations can accelerate the
visualization process [UdHCT04], it reduces the amount of
motion variety that can be depicted. For instance, the inhabitants of a real urban environment navigate their surroundings
with differences in their mode of locomotion, speed and gait.
Furthermore, the rendering and animation module must adapt
to the dynamic nature of a crowd depending on the location,
time of day or circumstance. For example, a populace may
begin with the majority navigating their surroundings to a

2304

W. Lister et al. / A Key-Pose Caching System for Rendering an Animated Crowd in Real-Time

2305

a GPU implementation requires agents to be animated each
time they are rendered and this incurs redundant processing
within multi-pass algorithms such as shadow mapping.
A similar problem does not arise with CPU-based skinning
because crowd members can be animated once and submitted
to the renderer multiple times. As noted in [GB08], a CPUbased implementation is also ideal on multi-core platforms
with a modest graphics processing capability; the typical
hardware configuration in laptop PCs, for example.

Figure 1: Linear-blend skinning animation texture layout.

large percentage becoming stationary when faced by a distraction such as the start of street entertainment. This paper
presents a method to accelerate the rendering of such scenes
by allocating a small geometry cache within which a set of
deformed key-poses can be stored. This serves to augment
linear-blend skinning with baked geometry [UdHCT04] and
enables the cached poses to be re-used by multi-pass rendering, between multiple agents and across multiple frames.

2. Skinning a Crowd
Compelling animation is vital for an effective crowd visualization and following the seminal work of Gosselin et al.
[GSM04], linear-blend skinning (LBS) has emerged to become the prevalent technique by which to animate a crowd
of characters. Although there exist higher-fidelity solutions
such as those based upon dual-quaternions [KCvO08], they
are inherently more complex and LBS remains the favoured
approach due to its low computational cost, modest memory
requirements and ease of implementation.
LBS binds each vertex of a mesh to an animated skeleton
using a set of bone assignments. Vertices are transformed independently by a weighted summation of the corresponding
key-pose matrices and this lends itself to parallel implementation. Consequently, LBS can be mapped efficiently to the
GPU and in [Lee07] seven variants of the basic algorithm are
identified. A typical approach is shown in Figure 1. The bone
transformations for each key-pose of a given animation are
stored as 3 × 4 matrices within a single slice of a texture array
and a vertex constructs its final matrix by blending those of
its assigned bones. Pose interpolation can be achieved using
hardware texture filtering.
In [Dud07, SBOT08], LBS is used to animate many thousands of characters on the GPU using instancing. However,
transforming a large number of crowd members from their
neutral pose still consumes a significant proportion of the
rendering time. Furthermore, although the computational
cost may be reduced using progressive skinning [PSA07],

This fact motivated the work of Gou and Bookout when
they developed a multi-threaded CPU skinning solution in
[GB08]. Incremental updates are used to amortize the cost of
animating a crowd over several frames by dividing the crowd
into subsets; these are updated at a fixed frequency and the
posed characters re-used for a finite period of time. Performance is shown to be competitive with GPU-based implementations but key-poses may only be blended when storing
a character. Consequently, the animation is not smooth and
agents must be suitably distant for this to go unnoticed.

3. Animation Caching
Our work is inspired by that of Gou and Bookout [GB08] in
that we adopt a caching system to accelerate skeletal animation across a crowd of characters. However, whilst they store
an explicit representation of each agent that is updated intermittently, we instead maintain a fixed-sized cache of skinned
key-poses from which crowd members can be reconstructed
by interpolation. This enables the animation of each character to be updated every frame whilst ensuring that the cached
meshes remain generic at all times. Consequently, the poses
can then be shared amongst agents to reduce the number that
must be stored.
We begin by considering the simplified case of intermittent
animation. This works on the premise that distant members
of a crowd can be updated at a reduced frequency if their
screen-space motion is imperceptible from frame-to-frame.
Guo and Bookout exploit this fact by animating each character on the CPU and consolidating the deformed meshes into
a buffer. This is uploaded to the GPU and assumed to remain
a valid representation of the crowd for a number of frames,
k. For each frame in k, the crowd can be visualized by drawing the contents of the buffer but unfortunately, each agent
is described explicitly and memory requirements therefore
scale linearly with crowd size. Furthermore, parameterizing
members of the crowd (to pick from a set of textures, for
example) becomes difficult without storing additional data
per-vertex or issuing multiple draw calls.
An alternative method is to maintain a cache of deformed
meshes that is shared by all members of a crowd. Whereas
Guo and Bookout permit an agent to interpolate neighbouring
key-poses before being skinned, we instead animate agents
using only the nearest key-pose. This enables a cached mesh

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

2306

W. Lister et al. / A Key-Pose Caching System for Rendering an Animated Crowd in Real-Time

Figure 4: A set of per-instance attributes are used to parameterize each member of the crowd.
Figure 2: The intermittent caching scheme clamps the animation of each agent (blue) to its nearest key-pose (green).

Figure 3: Key-pose cache texture with sample entries.

to remain generic and it is therefore unnecessary to store an
explicit representation of each agent, just the set of unique
key-poses. Of course, by clamping an animation in this way
the motion proceeds at discreet intervals but this is already
the case for an intermittent animation scheme. The interval
size for our approach is l × 0.5, where l is the time between
successive key-poses, as shown in Figure 2. The value of l
can be controlled by employing lossy LOD techniques such
as that described in [LT01] to reduce the number of poses
defined by an animation.
The cache size can be defined by the developer given the
usual trade-off between rendering performance and memory
overhead. For instance, we expect that console applications
will be constrained by a smaller cache size whereas PCs offer
the potential for it to be far larger. In either case, the ‘best’
set of key-poses should be stored and given the constrained
case whereby agents require only their nearest key-pose, the
optimal set is simple to determine. After culling against the
view frustum, we clamp the animation of each character to
the nearest key-pose and then build a mapping between each
key-pose and the number of characters that use it. The map
is sorted by descending order of size and the corresponding
poses skinned into the cache until it is full.
We implement the key-pose cache as a vertex-texture because this enables disparate locations to be updated by the
GPU using a single draw-call. An alternative approach could

adopt a vertex buffer as the data-store but this would require
multiple invocations of stream-out to render non-consecutive
updates. The vertices of a deformed pose can be stored using
a single row of texels and the cache is updated by rendering
animated positions, normals and tangents to the desired rows
using skinned instancing [Dud07]. This layout is depicted in
Figure 3. Vertices are packed into a 128-bit format using the
algorithms and compression schema discussed by Shopf et
al. [SBOT08] to lessen the memory footprint of the cache,
reduce bandwidth and enable a single texture fetch to load
all of the attributes belonging to a vertex. If the data was to
be stored in its original form then the cache would require
nine floating-point values per-vertex (three each for the position, normal and tangent). When multiple base models are
used (to introduce crowd variety and incorporate LOD, for
example), each is provided with a dedicated texture. This is
because a shared cache would incur a significant amount of
wasted space due to lesser detailed models occupying only a
small proportion of their allocated rows.
To draw a crowd using the cached key-poses we first note
that all members share a consistent texture parameterization
and this enables rendering to be initiated by instancing a set
of UV coordinates. A constant buffer on the GPU stores the
set of per-instance attributes used to parameterize the crowd;
specifically, the attributes depicted in Figure 4 are given for
each agent. Each instance queries its key pose row attribute
then loads and decompresses the corresponding vertex data
from the cache. Skinned instancing [Dud07] is used to obtain
the equivalent result for agents that cannot exploit the cache.

4. Pose Interpolation
The intermittent animation scheme is a legitimate acceleration technique for distant members of a crowd but the lack of
smooth pose interpolation can become noticeable for those in
close proximity to the camera. Consequently, nearby agents
must load and interpolate two key-poses but this doubles
the memory bandwidth required by the technique. For this
case, does a caching scheme continue to deliver a worthwhile
performance gain over using skeletal animation directly?
A further complication stems from the fact that members of the crowd can only exploit the cache if both of their

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

W. Lister et al. / A Key-Pose Caching System for Rendering an Animated Crowd in Real-Time

key-poses are present at a given moment in time. As the cache
is shared by potentially thousands of agents, finding the subset of poses that maximizes the number of supported characters becomes a difficult problem to solve. In the case of a
populated urban environment, the distribution of animations
required by the crowd is far from uniform and each key-pose
is unequally likely to be requested as a consequence. Although many modes of walking will dominate the populace,
a few of the characters will be sat reading, eating or talking
on mobile phones. A caching strategy must account for this
and selecting animations in a na¨ıve or random fashion will
fall short of the optimum given their non-uniform distribution within a scene. In this section we shown that finding the
optimal set of poses can be cast in the form of an NP-hard
optimization problem and present a heuristic algorithm to
approximate the solution in real-time.

4.1. Problem definition
For each frame, a set of n characters, C = {c1 , c2 , . . . , cn },
will be rendered whereby each interpolates a set of two keyposes, ki = {ks , kd }. The key-poses associated with a character remain valid for a period of time, temporal coherency,
and can be shared with those of another character in C, intraframe coherency. Consequently, to maximise the rendering
performance at a given time, it is desirable to populate a
cache of L locations with skinned key-poses such that the
number of characters that can be rendered by interpolation is
also maximized. This can be expressed in the form of the setunion knapsack problem [GNY94], which is a generalisation
of the classical knapsack problem.
The set-union knapsack problem (SUKP) considers a set,
N, of n items, each with an associated profit, pj , and a set,
P, of m elements each with an associated weight, wi . An
item, j, is composed of a set Pj ⊆ P and has a weight, wj ,
that is equal to the sum of the weights of the elements in
Pj . The objective is to find a set Q ⊆ N that fits within a
knapsack of capacity c and maximises the total profit. An
item, j, contributes towards the profit if all of the elements in
Pj are in the knapsack. The solution is expressed as a linear
programming problem in Equation (1).
pj

maximize
j ∈Q

wi ≤ c.

subject to

(1)

i∈PQ

The key-pose caching problem can be mapped to SUKP
by letting the set of elements, P, be equal to the set of all keyposes required by the crowd in a given frame. Each key-pose
requires a single location within the cache, is equally costly
to compute and is therefore assigned the weight wi = 1. Each
item, j, refers to a crowd member that requires a unique pair
of key-poses, leading to a total set of items C ⊆ C. The profit

2307

Figure 5: Crowd simulation state at time t.
for each item, pj , is equal to the number of occurrences of the
key-pose pair in the original set of characters, C. Therefore,
pairs of key-poses that are required by many characters in C
form items in C with a more significant profit.
Solving the optimization problem in Equation (1) results
in a set of key-poses that maximizes the number of characters
that can be rendered from the cache. Unfortunately, even for
this constrained case where wi = 1 and |Pj | = 2, the computational complexity of SUKP is strongly NP-hard [GNY94].
A greedy algorithm is therefore proposed to obtain a solution
at a sufficient rate to enhance the rendering performance.
4.2. Heuristic algorithm
We describe our method by way of an example, which uses
a crowd of 14 characters instanced from the same mesh, a
single animation of seven key-poses and an available cache
size of 4 meshes. The simulation begins at time t and its
current state is illustrated in Figure 5. The white numbers
denote how many characters are currently interpolating the
enclosing key-poses; we denote the regions between successive key-poses as temporal bins.
To ensure maximum utility of baked key-poses, the cache
is populated by first sorting temporal bins by size and then
adding their enclosing key-poses in descending order until
the cache is full. Thus, the set of key-poses used by bins 0
and 2 {0.0, 0.2, 0.4, 0.6} are rendered to the cache.
Crowd members are subsequently filtered dependent upon
whether they can be rendered from the cache. Clearly, those
agents from bins 0 and 2 qualify as it was their key-poses,
which were used in its construction. The characters in bin
1 also note the presence of their key-poses. However, the
character in bin 3 has only one baked key-pose available and
those in bin 4 have neither. Thus, for this frame, a total of
11 characters can be rendered by interpolating cached keyposes and the remaining 3 use skinning. The frame has a total
cost of 7 skinning operations (4 cache updates and 3 skinned
characters) and 11 blending operations.
At time t + dt, the simulation state is as shown in
Figure 6 and at this timestep, the set of key-poses belonging to bins 1 and 3 {0.2, 0.4, 0.6, 0.8} are required to exist
within the cache. Of these, {0.2, 0.4, 0.6} are already present;
only key-pose {0.8} needs to be cached and replaces the

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

2308

W. Lister et al. / A Key-Pose Caching System for Rendering an Animated Crowd in Real-Time

Figure 6: Crowd simulation state at time t + dt.

sizes of {7, 15, 22, 30} were tested and the algorithm was
found to consistently support more characters than the na¨ıve
alternatives and achieved near optimal results. Further tests
involving character sets equal in size to {10, 20, 40} were
able to confirm the trend across differently sized sets of characters. Larger tests cases could not be investigated because
the underlying complexity of the optimization problem leads
to prohibitive computation times.

5. Performance Analysis

Figure 7: A comparison of the proposed caching algorithm
against an exact solution. Given a crowd of 30 characters,
each agent selects two elements from a set of 22 key-poses. We
measure how many characters can be supported by various
cache sizes.
least-recently used key-pose {0.0}. As before, 11 characters can be rendered from the cache and 3 use skinning.
However, due to the exploitation of temporal coherency, the
total cost of this frame is reduced to 4 skinning operations
(1 cache update and 3 skinned characters) and 11 blending
operations.
A formal description of the caching algorithm is presented
in Appendix and to evaluate its accuracy, a series of tests
were performed with the results compared to exact solutions
calculated using an exhaustive approach. Given a crowd of 30
characters, each agent was permitted to select its source and
destination key-poses, at random with normal distribution,
from a set, P, of 22 key-poses shared by all crowd members.
The key-poses were selected with normal distribution to approximate the non-uniform distribution of animations in an
urban scene. Both the proposed and exhaustive algorithms
were then used to populate various cache sizes and we measured the number of characters that could be supported by
each cache for each technique. The results of this test are
given in Figure 7. In addition, the graph illustrates the results of naively selecting the first n key-poses and selecting
n key-poses at random for comparison.
Experiments were conducted by varying the size of P to
measure the affect of key-pose re-use amongst a crowd. Set

To evaluate the key-pose caching system, a crowd of 10 000
virtual humans is drawn whereby each character can choose
either a male or female template model and select from one
of four diffuse textures. Both models are provided at three
LODs and these consist of approximately 500, 1000 and
5000 faces and 250, 500 and 2500 vertices. A separate cache
is used for each LOD of each model type and their entries
consume 4, 8 and 39 kB of memory, respectively, using the
128-bit compressed format of [SBOT08]. Vertex attributes
for the render-to-cache passes and skinning-only implementation are submitted uncompressed. There are five animations (clapping, jumping, cheering, shouting and idle) for
a total of 200 key-poses. All tests were undertaken on a
2.4 GHz Intel Core 2 Duo with 2 GB of memory and a
Nvidia GeForce 8800 GTX. Experiments were undertaken
using a fixed camera path of 25 s in duration that started with
a view of the entire crowd, moved to a location where far
fewer agents were visible and finished with an overview of
the entire crowd again (Figure 8).
Our initial objective is to evaluate the overall performance
gain that results from using the caching system. To address
this point, the test scene was rendered using skinning, intermittent caching and interpolative caching at three different
cache sizes. Each test was repeated three times and the results
are presented in Figure 9. The intermittent scheme was implemented as described in Section 3. The interpolative approach
is very similar but requires the per-instance attributes shown
in Figure 10 to enable each agent to load and interpolate two
key-poses.
Figure 9 shows that a caching system can indeed accelerate the rendering of an animated crowd scene. As expected,
performance can be improved by increasing the cache size
and for those test cases using a size of 200 poses, the time
required to render each frame could be reduced by up to 40%
in comparison to drawing the crowd using linear-blend skinning alone. For all cases, we find the interpolative scheme to
be slightly slower than intermittent caching owing to the fact
that an additional key-pose must be loaded and processed in
a shader.
It is interesting to consider the shapes of the data-series
in relation to the state of the test scene. As was mentioned
previously, the scene begins and ends with an overview of

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

W. Lister et al. / A Key-Pose Caching System for Rendering an Animated Crowd in Real-Time

2309

Figure 8: The caching system is tested on a recreation of the crowd scene from Nvidia’s Direct3D SDK 10.5 [NVI08].
the crowd and many thousands of agents are visible. Each
agent occupies only a small area in screen-space and the
caching system is able to offer a worthwhile performance
improvement. By contrast, between 10 and 15 s into the
test, the camera zooms in on a subset of the crowd such
that only a few agents are visible. Here, frustum culling ensures that the majority of the crowd is not drawn but we
find that key-pose caching is unable to offer any real bene-

fit because character animation is not the bottleneck in this
situation.
Figure 11 illustrates the percentage of visible agents that
are able to make use of cached poses at each point in the
test. Again, increasing the cache size enables more agents
to be supported but we find that the interpolative scheme
B consistently supports less characters that the intermittent

Figure 10: Each instance stores the vertical texture coordinate of its source and destination key-poses. The associated
vertex data is blended in accordance with the blend ratio.

Figure 9: A comparison of the time taken to render each
frame of the test scene using skinning, intermittent caching
and interpolative caching with various cache sizes.

Figure 11: A comparison of the percentage of agents that are
able to exsploit the cache each frame using the intermittent
(A) and interpolative (B) schemes with different cache sizes.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

2310

W. Lister et al. / A Key-Pose Caching System for Rendering an Animated Crowd in Real-Time

are in use) the key-pose cache is large enough to store the
animations in their entirety and the crowd can be drawn using
cached meshes alone. Each animation introduced thereafter
coincides with a new ‘step’ on the graph. Here, a combination of cached and skinned meshes are used to render the
crowd because the set of required key-poses is larger than
can be stored in the cache at a given time. As the number
of animations is increased, additional cache updates are performed to maintain the ‘best’ set of poses but for a given
number of animations, the number of cache updates is relatively constant. To this end, the trendline produced by the
interpolative approach can be seen as the more stable and
the likely reason for this can be seen by considering the
sequence of keyframes {a, b, c, d, e}. If at given point in
time there are a large number of characters interpolating the
keyframes {b, c} then the heuristic selects these as a profitable pair and inserts them into the cache. As time progresses
the same set of characters gradually shift their dependency
on keyframes {b, c} to {c, d}. Here we expect that once the
second pair becomes the more profitable then keyframe {b}
is simply swapped out of the cache in favour of {d} although
we are yet to verify this experimentally.
Figure 12: A graph to show the number of characters supported by the cache (left axis) and the number of updates
made to the cache (right axis) is affected by the number of
animations available for selection.
scheme A for a given cache size. This is due to the constraint
that an agent can only exploit the cache if both its source
and destination poses are present at given moment in time.
When the size of the cache is increased to 200 key-poses it
becomes sufficiently large to contain all of the animations
required by the crowd and the technique emulates a baked
renderer [UdHCT04] because cache updates and skinning
become unnecessary. Consequently, 100% of the crowd can
be rendered from the cache and we commit this result from
the graph for clarity.
To assess the frame-to-frame coherency of the key-poses
stored in the cache, a second test scenario is used whereby
the camera is placed at a fixed position and approximately
2500 agents are in view. The male and female base models
are both allocated a cache of 100 key-poses. At t = 0 s, we
permit each agent to select from one of the five animations at
random and use a random time offset within that animation
to avoid the crowd being animated in lock-step. At t = 5 s,
the choice of animation is reduced to just one (cheering) and
every 5 s thereafter an additional animation is made available
for selection. Consequently, at t = 25 s, all five are again
available. Each frame we record the number of agents that
can/cannot exploit the cache and how many cache updates
are made.
Figure 12 presents the results of this test and it can be seen
that from t = 5 to 15s (where only one, then two animations

6. Conclusions and Future Work
We have described a caching system that accelerates the rendering of real-time crowds by exploiting the temporal and
intra-crowd coherencies that are inherent within a populated
scene. By storing a ‘best’ set of skinned key-poses that can
be shared amongst crowd members, the technique retains the
fidelity of skeletal animation whilst approaching the performance of rendering static geometry. Moreover, the system
adapts to the current state of a crowd simulation and the
allocated cache size can be chosen to balance memory consumption against computational cost.
Both the intermittent and interpolative key-pose caching
schemes were able to reduce the computational cost of drawing a crowd in comparison to using skinned geometry in isolation. The intermittent scheme performed particularly well
and could almost double the rendering performance because
it incurs far less work on the GPU. Only one mesh needs to
be loaded (thereby halving the memory bandwidth required),
only one set of vertices must be decompressed and the vertex
data does not need to be interpolated.
Given the improved performance of intermittent caching,
the quality/performance trade-off is best addressed by using
intermittent caching to draw the majority of a crowd and
traditional skinning for agents that cannot be supported by
the technique (such as those subject to motion blending). It
is inevitable for this to limit the richness of animations that
can be applied and suggests that our method is best suited
to drawing a large number of ‘second-tier’ characters. The
decision of which caching scheme to employ is highly dependent on the frequency of the underlying animation data. For

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

W. Lister et al. / A Key-Pose Caching System for Rendering an Animated Crowd in Real-Time

example, the animations described in Section 5 were sampled
at 15 key-poses per second and this proved to be sufficient for
the appearance of smooth motion, except for those agents in
close proximity to the camera. Consequently, little benefit is
derived from pose interpolation whereas low frequency data
would deem the interpolative scheme necessary for a greater
number of agents.

2311

[aXY08] AXYZ DESIGN: aXYZ Design 3D Animated People Human Characters Models, 2008. http://www.axyzdesign.com/.
[CLM05] COIC J.-M., LOSCOS C., MEYER A.: Three lod for
the realistic and real-time rendering of crowds with dynamic lighting. Research Report, LIRIS, Lyon University,
France, 2005.

Appendix
This appendix provides a formal description of the interpolative caching algorithm outlined in Section 4.2.
Algorithm 1: Interpolative character caching
Input: A set of characters, C, and a set of key-poses, K
Define a map of characters, CK, to key-pose pairs
CK = {c → {ks , kd } | c ∈ C ∧ ks ∈ K ∧ kd ∈ K ∧ ks = kd }
Let CK ⊆ CK with unique key-pose pairs
CK = {{f → k} | k ∈ range(CK)∧
f = {{c → k1 } ∈ CK | k1 = k} }
CA = {}
while CK = {→} ∧ CA < n do
Select the most profitable key-pose pair
{f → {ks , kd }} ∈ CK such that
∀{f1 → {ks1 , kd1 }} ∈ CK ,
{f1 → {ks1 , kd1 }} = {f → {ks , kd }}∧
f ≥ f1 ∧ ks <= ks1 ∧ kd <= kd1
Update the cache to include the new key-poses
CA = CA ∪ {ks }
CA = CA ∪ {kd }
Remove the key-pose pair from CK
CK = CK − {f → {ks , kd }}
end
Update the cache from the previous frame, PC
PC = PC − {PC − CA}
CA = PC ∪ CA
Compute the number of supported characters, NSC
N SC = {{c → {ks , kd }} ∈ CK|ks ∈ CA ∧ kd ∈ CA}
Output: A cache, CA, of at most n key-poses, which enables
NSC characters to be rendered by interpolation

Acknowledgements
This programme of research is supported by EPSRC grant
EP/E035639/1. The character models can be purchased from
[aXY08]. The authors thank all the reviewers for their feedback and in particular for those commenting on the stability
of the interpolative heuristic and providing the example discussed in Section 5.

[dHCSMT05] DE HERAS CIECHOMSKI P., SCHERTENLEIB S.,
MAIM J., THALMANN D.: Reviving the roman odeon of
aphrodisias: Dynamic animation and variety control of
crowds in virtual heritage. In Proceedings of the 11th
International Conference on Virtual Systems and Multimedia (2005).
[DHOO05] DOBBYN S., HAMILL J., O’CONOR K., O’SULLIVAN
C.: Geopostors: A real-time geometry/impostor crowd
rendering system. In I3D ’05: Proceedings of the 2005
Symposium on Interactive 3D Graphics and Games (New
York, NY, USA, 2005), ACM, pp. 95–102.
[Dud07] DUDASH B.: Animated crowd rendering. In GPU
Gems 3 (2007), Addison-Wesley, pp. 39–52.
[GB08] GUO S., BOOKOUT D.: Multithreading the Rendering Pipeline for 3D Model Animation, 2008.
http://software.intel.com/en-us/articles/multithreadingthe-rendering-pipeline-for-3d-model-animation.
[GNY94] GOLDSCHMIDT O., NEHME D., YU G.: Note: on the
set-union knapsack problem. Naval Research Logistics 41,
6 (1994), 833–842.
[GSM04] GOSSELIN D., SANDER P., MITCHELL J.: Drawing
a crowd. In ShaderX 3: Advanced Rendering with DirectX and OpenGL (2004). Charles River Media, 2004,
pp. 505–517.
ˇ ARA J., O’SULLIVAN C.: Ge[KCvO08] KAVAN L., COLLINS S., Z´
ometric skinning with approximate dual quaternion blending. ACM Transaction on Graph. 27, 4 (2008), 1–23.
[Lee07] LEE M.: Seven ways to skin a mesh: character skinning revisited for modern gpus. Gamefest Unplugged (Europe) (2007).
[LT01] LIM I. S., THALMANN D.: Key-posture extraction out
of human motion data by curve simplification. In 23rd
Annual International Conference of the IEEE Engineering
in Medicine and Biology Society (2001), pp. 1167–1169.
[NVI08] NVIDIA CORPORATION: Direct3d sdk 10.5, 2008.
http://developer.nvidia.com/object/sdk_home.html.

References
[ABT00] AUBEL A., BOULIC R., THALMANN D.: Real-time
display of virtual humans: Levels of detail and impostors. IEEE Transactions on Circuits and Systems for Video
Technology 10, 2 (2000), 207–217.

[PSA07] PILGRIM S., STEED A., AGUADO A.: Progressive skinning for character animation. Computer Animation and
Virtual Worlds 18, 4–5 (2007), 473–481.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.

2312

W. Lister et al. / A Key-Pose Caching System for Rendering an Animated Crowd in Real-Time

[RFD05] RYDER G., FLACK P., DAY A. M.: A framework
for real-time virtual crowds in cultural heritage environments. In VAST ’05: Short Papers Proceedings (2005),
pp. 108–113.
[SBOT08] SHOPF J., BARCZAK J., OAT C., TATARCHUK N.:
March of the froblins: Simulation and rendering massive
crowds of intelligent and detailed creatures on gpu. In
SIGGRAPH ’08: ACM SIGGRAPH 2008 Classes (2008),
pp. 52–101.

[TLC02] TECCHIA F., LOSCOS C., CHRYSANTHOU Y.: Imagebased crowd rendering. IEEE Computer Graphics and
Applications 22, 2 (2002), 36–43.
[Ubi07] UBISOFT: Assassin’s creed (2007).
[UdHCT04] ULICNY B., DE HERAS CIECHOMSKI P., THALMANN
D.: Crowdbrush: Interactive authoring of real-time
crowd scenes. In Proceedings of the ACM SIGGRAPH/
Eurographics Symposium on Computer Animation (2004),
pp. 243–252.

c 2010 The Authors
Computer Graphics Forum c 2010 The Eurographics Association and Blackwell Publishing Ltd.


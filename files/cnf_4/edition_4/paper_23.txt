WhatsOnWeb+ : An Enhanced Visual Search Clustering Engine ∗
Emilio Di Giacomo†

Walter Didimo‡

Luca Grilli§

Giuseppe Liotta¶

Pietro Palladino

Dipartimento di Ingegneria Elettronica e dell’Informazione
Universita` degli Studi di Perugia
Italy

A BSTRACT
The paper describes WhatsOnWeb+, a search clustering engine that allows users to browse and analyze the results of
a query by means of enhanced graph visualization techniques.
WhatsOnWeb+ integrates a wide array of visual interfaces, animation and interaction functionalities, and clustering technologies.
The effectiveness of the different visual interfaces and of the different clustering algorithms implemented in the system has been
measured by means of an extensive experimental analysis. The described system represents a significant evolution of a previous clustering engine for the Web.
Keywords: Information Visualization, Graph Drawing, Search
Clustering Engine.
1 I NTRODUCTION
Classical search engines for the Web (like Google or Yahoo!)
have a weak point in the presentation of the results to the user. They
often return a very long list of (ranked) documents and never provide an overview of them. Since the user can only go through this
list (displaying a few documents per page), she typically limits the
analysis to the five top most documents and misses the rest. If the
query is rather generic or ambiguous and it involves a wide range
of meanings, relevant results may be listed after many others, and
the user will never see them.
To cope with this problem, a new generation of search engines for the Web has been designed and made available over the
Internet in the last five years. These systems, which are often
called Web clustering engines (see, e.g., Viv´
ısimo, iBoogie,
SnakeT [13]), perform a complementary work to the one of classical search engines, focused on the presentation of the results. More
precisely, once the user passes a query string to a clustering engine, the system forwards this string to one or more classical search
engines, takes back their results, selects a limited number of them
(typically the first two or three hundreds), and then displays the selected results grouped and organized into a hierarchy of thematic
categories, also called clusters. Each category contains documents
that are semantically related with each other and it is labeled with
a string that describes its content. A category may be recursively
subdivided into sub-categories.
This approach has the advantage of providing the user with an
overview of the different arguments related with her query, and allows her to find the desired information by recursively exploring
∗ Research partially supported by MIUR under Project “MAINSTREAM: Algorithms for massive information structures and data
streams.”
† e-mail:digiacomo@diei.unipg.it
‡ e-mail:didimo@diei.unipg.it
§ e-mail:grilli@diei.unipg.it
¶ e-mail:liotta@diei.unipg.it
e-mail:palladino@diei.unipg.it

IEEE Pacific Visualisation Symposium 2008
4 - 7 March, Kyoto, Japan
978-1-4244-1966-1/08/$25.00 ©2008 IEEE

the hierarchy while keeping a certain guarantee that no relevant information is missed. However, while there is a general consensus
that clustering is a valuable approach for mining web data, only a
limited research effort has been devoted so far to the design of visual interfaces to effectively browse and analyze the hierarchy of
the categories. The majority of existing clustering engines just offers a directory-tree paradigm to navigate the clusters and no other
visual tools are given to the user to support the analysis.
In [11] a search clustering engine, called WhatsOnWeb, is presented, which allows users to explore the results by means of advanced visual analysis techniques. It represents and displays the
results as a clustered graph, and makes it possible to expand or
collapse clusters at any time, so getting the preferred level of details in the visualization. The authors experimentally showed that
in many practical situations users can more efficiently browse categories and retrieve the wanted information if they are provided with
such a graph-based interface instead of a tree-based one.
1.1 Our Contribution
This paper continues the study initiated in [11]. Our main contribution is twofold:
1. We present a system that is a significant evolution of
WhatsOnWeb. This system, which we call WhatsOnWeb+,
provides a new efficient clustering algorithm (inspired by the
algorithm of Aslam et al. [3]), integrates new graph visualization algorithms that are engineered versions of existing graph
drawing algorithms, and introduces a novel visual strategy for
exploring clustered graphs.
2. In order to evaluate the effectiveness of WhatsOnWeb+ as
a search engine for the end-users and to compare its performances vs. those of WhatsOnWeb, we performed an extensive experimental analysis. We both performed experiments
about the layout interfaces and measured the effectiveness and
the efficiency of the clustering technique.
More in details, WhatsOnWeb+ consists of the following features and ingredients:
• It integrates a platform of pluggable visual paradigms for
showing and browsing the results. Besides the orthogonal
drawing convention already presented in WhatsOnWeb, an
array of new diagrammatic interfaces adopting radial, layered, and treemap conventions have been implemented and
mounted on top of this platform. These interfaces use the following novel visual strategy for exploring clustered graphs:
When a cluster is expanded, only its children and their
parental links are added to the drawing; the non-parental
links among categories are shown on demand, by means of
a mouse-over operation. This makes it possible to control the
visual complexity of the layout and at the same time it offers to the user the possibility of displaying local details when
desired. A recent work that uses an incremental tree layout
strategy to explore large graphs, where non-parental links can
be displayed on demand, is described in [16]; in that paper

167

however, the explored graphs do not have a clustered structure.
• It provides several interaction facilities to analyze the map of
the results, such as zooming, filtering, search by rank, undo
and redo operations. In order to maintain the user’s mental
map, possible changes in the visualization are animated with
a morphing function. The layout interfaces are designed so to
guarantee stability. This means that the same view of the clustered graph will be always represented with the same drawing
during the browsing (see, e.g., [16]).
• An essential requirement for a clustering engine is the efficiency in computing the clusters. WhatsOnWeb+ features
a new clustering algorithm that can cluster several hundreds
of documents in a few seconds and that remains feasible also
when the set of documents grows to some thousands. The algorithm is a variant of a graph clustering algorithm proposed
by Aslam et al. [3], which is based on finding stars with center of high degree. While the algorithm of Aslam et al. only
produces flat clusters, our algorithm is extended to compute
hierarchies of clusters.
1.2

Related Work

In the general field of search results, there is a wide range of papers
that use visual paradigms to describe and navigate the results.
In [25] Web search results are visualized by using a graph such
that each node represents a single Web page and two nodes are connected by an edge if the corresponding documents have a certain
text similarity; however, no clustering approaches are used to support users. In the specific field of Web clustering engines, which
is the topic of interest of this paper, two well-recognized systems
that make it possible for the user to navigate the results by means
of graph visualization techniques are Kartoo1 and TouchGraph
Google Browser2 . Both these systems compute flat structures
of categories and present a lack of effective overview and filtering
tools. Namely, Kartoo only allows the visualization of a small
number of nodes in each map, where each node of a map represents a distinct Web page, and therefore it does not provide the
user with a high-level overview of the whole graph. TouchGraph
Google Browser directly displays the entire set of documents
in a unique view, which usually causes a high visual complexity for
the user; the map can be iteratively increased by refining the query
with mouse-click operations on single nodes, but there is no way to
collapse clusters so to hide information. Notice that overview and
filter represent two important aspects of an effective information
visualization interface, as stated in a paper by Shneiderman [23]
and witnessed by the many implementations, methods, evaluations,
and taxonomies based on the principles contained in the work of
Shneiderman (see [6] for a recent survey on the subject).
In the Information Retrieval field, an interesting tool is
NIRVE [21], which makes it possible to visually analyze a certain
set of search results according to a set of keywords and related concepts, which are defined by the user, and not automatically computed by means of a text analysis of the results [7]. This system
computes a concept profile of each search result and determines
clusters of concepts and their similarities. It offers to the user a 2D
or a 3D graph visualization interface to navigate these clusters. An
experimental evaluation of the usability of NIRVE is presented in.
Other research papers focus on the presentation of Web search
results by computing clusters and by using some geographic or reallife metaphors, instead of graphs, to visualize and navigate these
clusters (see, e.g., [1, 2, 4, 18]).
1 http://www.kartoo.com/
2 http://www.touchgraph.com/

168

Besides the papers and systems cited above, there are also many
results that introduce several paradigms for the visualization of data
associated with search results (not necessarily in the Web space),
like predefined attributes, user-defined attributes, and term distribution. A very limited list of such results includes: [14, 17, 20, 24]).
1.3 Structure of the Paper
The remainder of the paper is structured as follow. The basic design
principles of the system are recalled in Section 2. The new visual interfaces and interactions tools are illustrated in Section 3, while the
new clustering and labeling algorithm is described in Section 4. The
results of our experimental analysis are presented in Section 5. Section 6 briefly discusses the architecture of WhatsOnWeb+. Conclusions and future work can be found in 7.
2 T HE TOPOLOGY - DRIVEN A PPROACH
In order to better illustrate the improvements and the new features
of WhatsOnWeb+, we briefly recall here some of the main design
principles of the system WhatsOnWeb (refer to [10, 11] for more
details). It relies on a methodology for the design of Web clustering
engines, called the topology-driven approach. This methodology
aims at computing and visualizing a clustered graph representing
not only the hierarchy of thematic categories (given by the inclusion
relationships among clusters), but also additional non-parental links
among the categories to give some more hints on their contents.
The user can take advantage from these additional links to relate
categories with non meaningful labels to categories whose labels
clearly reflect their contents. The topology-driven approach works
in three distinct phases:
1. A base weighted graph, called snippet graph, is computed that
summarizes the semantic relationships of the snippets3 returned by the classical search engines. Each edge of the snippet graph is labeled with the sentences shared by the snippets
associated with their end-vertices; each label has a relevance
score, which contributes to the weight of its corresponding
edge.
2. A clustering algorithm is applied on the snippet graph to compute a hierarchy of thematic categories, each category grouping a certain subset of snippets. Non-parental links among
categories are automatically induced by the edges of the snippet graph, by applying some simplification rules. The resulting clustered graph is called the graph of categories.
3. The graph of categories is visualized to the user, who can expand or collapse the categories and perform some analysis to
simplify the information or to get more details.
WhatSonWeb visualizes the categories adopting the orthogonal
layout convention. This is based on a variant of the well-known
topology-shape-metrics approach, capable to deal with rectangular
nodes of prescribed dimensions [8]. It guarantees a limited number of edge crossings, good compaction, and a certain mental map
preservation during the navigation, because the shape of the drawing never changes. The categories are colored with different intensity to convey their relevance (the relevance of a category is automatically computed by the system, based on the number of pages
stored in the category, on the search engine rank of these pages,
and on an estimation of the reliability of the label assigned to the
category). The thickness of a link is proportional to the strength of
the corresponding relation (i.e., to the weight of the link). A map
computed by the system in the orthogonal drawing convention is
depicted in Figure 1. In the map, some categories are expanded and
some others are collapsed.
3A

snippet is a brief summary of the content of a Web page returned by
a Web search engine in response to a user’s query.

Focusing: Which makes it possible for the user to get local details
on specific nodes or edges of the drawing.
Fast interaction: The user can quickly perform basic actions on
the drawing like translations, zooming, and filtering.
Stability: Chosen a layout interface, the same view of the clustered graph will be always represented with the same drawing
during the browsing. This is fundamental for the user’s mental
map preservation.

Figure 1: A map for the query “Visualization” in the orthogonal layout interface. The two categories “Computer Graphics” and “Journal Visualization”
have been expanded by the user: The first contains five new subcategories,
while the second contains two pages.

In addition to exploring or collapsing categories, the user has
some other visual analysis tools. To simplify the amount of visual information, she can hide or prune links with “low” weight
or categories with “low” relevance. To get more information about
non-parental links, she can explore them to display the snippets that
originated the link and their shared words.
While the topology-driven approach has been shown to be effective in practice, the system WhatsOnWeb also showed some clear
drawbacks:
• Regarding the orthogonal layout interface, users pointed out
that: (i) The positions of the categories is neither representative of their relevance nor of their level in the cluster hierarchy; (ii) The presence of all non-parental links in the drawing is sometimes confusing (i.e., the visual complexity was
sometimes too high); (iii) The absence of fast zooming and
filtering operations makes the interaction slow in many cases
(to apply these operations it was required to interact with a
window menu bar).
• The clustering algorithm is based on a minimum cut strategy,
which implies a high computational complexity. As a consequence, it can take several minutes for clustering just a few
hundreds of documents, which is a strong limitation in practice.
Motivated by the above remarks, WhatsOnWeb+ adopts the
topology-driven approach but it is equipped with a new array of diagrammatic interfaces using different graph drawing conventions.
It provides several tools for visual analysis that can be activated
quickly by means of mouse and keyboard operations, and a novel
exploration strategy in introduced. Also, in order to speed-up the
clustering phase, we designed a new algorithm that can efficiently
handle some thousands of results.
3

L AYOUTS AND I NTERACTION IN WhatsOnWeb+

WhatsOnWeb+ features three new diagrammatic interfaces, based
on radial, layered, and treemap conventions, respectively. These
interfaces adopt some common visualization principles and are
equipped with a set of interaction functionalities, which have been
designed having in mind the following important requirements:
Limited visual complexity: To facilitate the user in dealing with
the information.

The interfaces of WhatsOnWeb+ start with a map that displays
only the first-level categories. When the user performs a single click
on a category using the left button of the mouse, the category is expanded if it was collapsed or it is collapsed if it was expanded. Expanding a category causes the display of all its children. Collapsing
a category hides its subtree of categories. A node representing a
Web page has a shape different from the one used for the categories
and contains the icon of the Web page, when available. A single
click on a Web page node opens a new window in which the page
is displayed.
To keep the visual complexity low during the navigation in the
cluster hierarchy, only parental relationships among the categories
are directly displayed by the system. If the user performs a mouseover operation on a node, the additional non-parental relations between that node and the others are highlighted in some way, depending on the layout standard chosen (see the next subsections).
This implies that, at each step of the browsing, the user sees the
drawing of a tree plus, possibly, some additional relations.
If the user performs a single click on a category using the right
button of the mouse, a local menu of filtering actions for that node is
shown. Among the most useful actions, it is possible to hide/prune
all the nodes that do not have any relationship with the selected
node. This makes it possible to rapidly simplify the information
by keeping visible only a subset of categories that are thematically
related.
Other common interaction operations can be quickly executed
on the drawing: Right drag of the mouse on the canvas is used
to translate the view; mouse wheel combined with the CTRL key
is used for zoom-in and zoom-out. Furthermore, undo and redo
actions can be performed at any time and it is also possible to automatically recognize a Web page by rank (i.e., the score that the
search engine assigned to it); in this case the category containing
the page is automatically expanded by the system and the page is
highlighted. Finally, smooth interpolated animation techniques are
used for drawing when an action causes it to change.
The next subsections describe the peculiarities of these layout
interfaces. Each interface has its own implementation of the above
described general principles and facilities; also, it sometimes provides additional interaction and analysis tools.
3.1

Radial Layout Interface

This interface displays the maps by placing the nodes (categories
and Web pages) on concentric circles. The dummy category representing the user’s query is placed at the center of the circles. The
first-level categories are placed on the innermost circle, their children on the next one, and so on. In this way, circular levels are
used to directly convey the category levels. Categories are drawn as
rectangles with a label inside; Web pages are drawn as small circle
with a short label outside. Passing over a Web page node causes the
display of its title and snippet.
On each circular level, the categories are sorted clockwise according to their relevance. In the first map, only a subset of the firstlevel categories is shown (the size of this subset can be customized),
and the user can display new categories by means of clockwise or
counterclockwise shifting, performed with the mouse wheel. Each

169

single shifting causes the entrance of a new category and the hiding of another, so that the total number of categories displayed at
each time remains constant. This is useful to reduce the overlap
among categories in case they are too many to stay all together on
the perimeter of the circle .
The tree consisting of the visible categories and of their parental
links is drawn by using a variant of a classical divide and conquer
technique [9]. The non-parental links displayed when the user performs a mouse-over operation on a node are drawn as circular arcs,
whose thickness is proportional to the strength of the relationships
they represent. Each circular arc always connect two nodes lying
on the same circular level and passes inside the circle on which the
two nodes are placed; the curvature of the arc is computed so that
arcs connecting close nodes are clearly visible and nested arcs cross
as less as possible. It is also allowed to temporarily fix the display
of non-parental links of a node, and then moving on a link to see its
detailed label, i.e., the list of words shared by the pages that caused
that link.
The radial layout interface also allows additional zoom-in/zoomout operations. It is possible to increase or decrease the radius of
the circles, without zooming the rest of the drawing. This is quickly
done by using the mouse wheel combined with the ALT key.

Figure 3: A map for the query “Visualization” in the layered layout interface.

3.3

Figure 2: A map for the query “Visualization” in the radial layout interface.
Two categories have been expanded by the user. Non-parental links for the
node “Computer Graphics” are displayed, due to a mouse-over operation on
this node.

An example of a map computed with the radial layout interface
is depicted in Figure 2.
3.2 Layered Layout Interface
The layered interface adopts conventions and functionalities that
are pretty similar to those of the radial layout interface. The main
difference is that the geometric levels are not concentric circles but
parallel lines (either vertical or horizontal lines). On vertical levels,
the categories appear from top to bottom according to decreasing
values or relevance; on horizontal levels, they are ordered from left
to right.
The tree consisting of the visible categories and of their parental
links is drawn by using the Reingold and Tilford strategy [19], but
the links are represented with orthogonal shape, i.e., they are chains
of horizontal and vertical segments. As in the radial layout interface, non-parental links are drawn as circular arcs, whose thickness
is proportional to the strength of the relationships they represent.
Figure 3 depicts a map computed by the layered layout interface,
where the layers are vertical lines.

170

Treemap Layout Interface

Treemap is a popular convention for representing trees with
weighted nodes in a compact and effective way. It was introduced
by Shneiderman in [22], to visualize the file system organization.
In a treemap representation, the whole tree is drawn by totally
filling a given rectangular area; this area is subdivided into rectangular subregions, each subregion representing a different child of
the root. The subregion associated with a node v is then recursively
subdivided into other subregions to represent the subtree rooted at
v. Each subregion should have an area proportional to the weight
of the corresponding node.
Hence, in a treemap the parental relationship between two nodes
is not represented by a geometric link, but just as an inclusion relation among the subregions associated with the nodes. In this sense,
the treemap drawing convention is similar to the orthogonal layout
interface. However, while the orthogonal layout interface always
displays the totality of the non-parental links among the visible categories, in the treemap layout interface the non-parental relations
are only displayed on demand with a mouse-over operation on a
node (as in the radial and layered layout interfaces) and they are
conveyed to the user by highlighting all nodes connected to the one
selected (not by drawing curves). Different color intensities are
used to represent the strength of the relations.
Concerning the layout algorithms and the actions performed
when a category is expanded or collapsed, our treemap layout interface works as follows.
• An initial rectangular area is partitioned into rectangular subregions corresponding to the first-level categories; the dimensions of this area can be chosen by the user, so that it can
fit well in the computer’s screen (see Figure 4(a)). Different
weights can be chosen for the categories and different algorithms can be used to compute the partitioning according to
the weights of the categories. Namely, the weight of a category can be chosen either equal to its size (i.e., the number
of contained pages) or equal to its relevance score. The subregions can be computed applying two different algorithms:

(i) An algorithm called Squarified [5], which applies a greedy
heuristic with the main objective of producing squarified regions, i.e., regions with aspect ratio close to 1; this algorithm
takes O(n2 ) time in the worst case, where n is the number of
nodes in the tree. (ii) An algorithm called Split [12], which
recursively splits a region into two subregions (by means of
a horizontal or a vertical segment), while keeping for the two
subregions a good aspect ratio and areas as much balanced
as possible. The Split algorithm also preserves a desired embedding for the input tree, i.e., consecutive children of a node
will correspond to adjacent subregions. We use this feature
to keep the subregions partially ordered according to the relevance of the corresponding nodes. The time complexity of
the Split algorithm is O(n log n) in the worst case and O(n) in
the average case.
• When the user expands a first-level category v, a new rectangular panel is opened in which the subcategories of v are
displayed in a treemap fashion. Successive expansions of
these subcategories will cause recursive subdivisions of their
regions, without opening new panels (see Figure 4(b)). In order to limit the visual complexity, the system does not allow
users to open other first-level categories until v is collapsed.
4

C LUSTERING IN WhatsOnWeb+

The clustering algorithm implemented in [11] is based on a recursive graph clustering approach using min-cut; in the remainder, we
call this algorithm WMinCut. Although the quality of the clusters
computed by WMinCut is rather satisfactory, its time complexity in
the worst case is O(n2 m + n3 log n), where n and m are the number
of vertices and the number of edges of the snippet graph, respectively. As shown by the experiments, WMinCut can be reasonably
applied in practice for just a few hundreds of documents.
To cope with this limitation, we designed a new clustering algorithm for the snippet graph, which runs pretty fast for some hundreds of documents and which takes a few minutes for some thousands of documents (see Section 5.2). It is a variant of an algorithm
proposed by Aslam et al. [3], which is based on finding stars with
center of high degree; in particular, while the algorithm of Aslam et
al. only produces flat clusters, our algorithm is extended to compute
hierarchies of clusters.
Denote by G the snippet graph of a set of documents and call
weighted degree of a vertex of G the sum of the weights of its incident edges. Our new clustering algorithm, which we call WStar,
computes the first-level categories of the hierarchy as follows:

To create deeper categories of the hierarchy, the algorithm recursively applies Step 1, Step 2, and Step 3 to the graph induced by
the documents contained in each cluster Cv , excluding the centroid
of Cv . The level of recursion can be set as a parameter of the algorithm. At the end of the computation, if a cluster Cv contains some
subcategories then the centroid of Cv will be moved in the largest
of them. The theoretical time complexity of WStar in the worst
case is O(n2 ), assuming that the depth of the hierarchy is a constant
number fixed in advance (it is at most equal to the level of recursion). Indeed, the cycle of Step 2 can require O(n) iterations, and
the cost of each step in a single iteration takes linear time in the size
of L, i.e., O(n).
5 E XPERIMENTAL S TUDY
We performed two kinds of experimental studies. The first experiment, illustrated in Subsection 5.1, compared the effectiveness of
the four layout interfaces of our system, from the user point of view.
The second experiment, described in Subsection 5.2, compared the
efficiency of the different clustering algorithms and their effectiveness against ground truths of clusters defined by humans.
5.1 Comparison of the Layout Interfaces
To compare the effectiveness of the four different layout interfaces,
we performed the following experimental study. We recruited 13
volunteers, which are students of our engineering school, aged from
20 to 26 and we assigned a certain number of experimental tasks to
each of them. The generic experimental task was the following:
Given a query string q, a topic tq pertinent to q, and a layout interface l, find as much pages as possible related with tq using the
interface l, within a given time.
5.1.1 Experimental Set-up
The pairs pq = (q,tq ) were taken from a predefined set Q, and for
each query string q we gave to the user a cluster hierarchy precomputed by the system. The number of total pages for each query
ranged from 150 to 200. We assigned the tasks (pq , l) to the users,
according to the following rules: (i) Each user performed the same
number of tasks, exactly one for each pair pq ; (ii) The layout interfaces were distributed among the tasks as much uniformly as possible; (iii) The total order of pairs pq and the one of the layout
interfaces were counterbalanced.
Set Q consisted of 9 pairs (q,tq ), which are reported in Table 1
in alphabetic order. We chosen an equal number of “ambiguous”,
“generic”, and “specific” queries, according to the definitions given
in [11].
Query

Step 1: Store in a list L all vertices of G.
Step 2: While L has at least three vertices, one of which adjacent
to the other two, iteratively execute the following steps:
• Pick the vertex v of L that has the highest weighted degree, and create a new cluster Cv . Vertex v is called the
centroid of Cv .
• Insert in Cv all vertices of L that are adjacent to v in G.
• Compute a label lv for cluster Cv ; label lv is chosen as
the most relevant label among those of the edges connecting v to the other vertices of Cv .
• Remove from Cv all vertices whose snippets do not contain lv .
• Remove from L all vertices contained in Cv .
Step 3: Insert the remaining vertices in a category labeled Other
Topics.

q

Apple
Clinton
Games
Graph Clustering
Jaguar
Jokes
Music
Olympic Games
Salsa

Topic tq

Type of query

Intel
Hillary
Kids, Toys, and Education
Spectral and Cuts
Animal
Science
Education and Schools
History
Recipes and Food

Ambiguous
Specific
Generic
Specific
Ambiguous
Generic
Generic
Specific
Ambiguous

Table 1: Queries and topics used for the tasks.

Concerning the layout interfaces, we decided to use the Split algorithm for computing treemaps (according to our perception, it
appears more effective than the Squarified algorithm in our application context), and we use vertical layers for the layered layout
interface (as typically done in all tree-based interfaces of classical
clustering engines).

171

(a)

(b)

Figure 4: (a) The first map computed by the treemap layout interface for the query “Visualization”. With a mouse-over operation on node “Data” all the related
categories are highlighted with different color intensity in the red scale. (b) Expanding node “Data” a new panel is opened to display its subcategories; the subcategory
“Visualization System” is further expanded and all its Web pages are listed inside; the snippet of the AT&T Labs is visualized by means of a mouse-over operation.

Before performing the experiment, we provided the users with a
brief tutorial about the system and its interfaces, and we also asked
them to experiment the different layout interfaces on a small set of
practice tasks. Such a training activity required about 30 minutes
for each user.
To perform the experiments, the layout interfaces were slightly
modified as follows: For each task, the remaining time was displayed on the assigned interface and the user could add a page to
her “experimental basket” by using the right button of the mouse.
She could not switch to another layout interface. We logged in a
file the pages inserted in the experimental basket and their insertion
times, and we assigned a 3-minute time limit to perform each task.
Once a user completed all her tasks, she was asked to fill a subjective satisfaction questionnaire about the different layout interfaces. The questionnaire consisted of the following questions: (i)
In your opinion, what is the best interface and why? (ii) In your
opinion, what is the worst interface and why?. (iii) Assign to each
interface a score in the range [0, 5].

(a)

(b)

Figure 5: (a) Distribution of the scores for the best layout interface. (b) Distribution of the scores for the worst layout interface. T=TreeMap, L=Layered,
R=Radial, O=Orthogonal.

layout interface grows with the time; the percentage values are averaged over all tasks performed with the same interface.

5.1.2 Results and Analysis
From the subjective satisfaction questionnaires we collected the following results: (refer to Figure 5):
• 56% of the users judged the treemap layout interface the best
one, with the main motivations that it allows a compact and
effective overview of all categories, and that the highlight of
the connected categories using color intensities is more intuitive than using geometric links. No user avoided to express a
preference about the best interface.
• 62% of the users judged the layered layout interface the worst
one, with the main motivations that the aspect ratio is very
poor and there is a big waste of space; the non-parental links
often generate too many crossings and are confusing. It is remarkable to observe that the treemap is the only layout interface never judged the worst, and that 13% of the users avoided
to specify the worst interface.
• The average scores given to each interface, in decreasing order, are the following: treemap (3.91), orthogonal (3.56), radial (3.31), layered (2.8).
From the data collected from the performances of the users, we
tried to evaluate the effectiveness of the different layout interfaces
in practice. To this aim, for each task we counted the correct pages
inserted by the users in their experimental baskets over time. Figure 6 shows how the percentage of correct pages found with each

172

Figure 6: Growth of the average percentage of correct pages found with each
layout interface over time.

The results confirmed the judgements expressed by the users in
the satisfaction questionnaire. Namely, the treemap interface outperformed the others, and allows users to find in the average almost
50% of the relevant results for the assigned topics in the given 3
minutes (with the other interfaces this percentage is between 33%
and 37%). The statistical relevance of the better results of the
treemap interface against the others was confirmed by performing
a balanced one-way ANOVA test (with Fisher’s PLSD) on the row
data. The dependent variable was the average percentage of correct pages found with each layout interface, and we obtained that
the null hypothesis was always rejected, with α = 0.01, for each
instant time t reported in Figure 6. Successively, we performed

a Tukey’s pairwise analysis to find which pairs of interfaces were
significantly different. We obtained that the treemap was always
significantly better of the radial interface with p < 0.01. Also, for
t = 120 and t = 180 the differences between the treemap and the
orthogonal and layered interfaces were statistically significant with
p < 0.05. There were no other significant pairwise differences.
5.2

Comparison of the Clustering Algorithms

We compared the performances of the two clustering algorithms
WMinCut and WStar. From the efficiency point of view we were
interested in evaluating the computational time spent by the two algorithms when the set of snippets to cluster grows. To this aim,
we run the algorithms on increasing subsets of results returned by a
classical search engine in response to the queries of Table 14 . The
subsets of results ranged from 50 to 1000 snippets. The computation was executed under the Linux OS, on a machine having a
Pentium IV - 3GHz processor and 2GB of RAM.
As shown in Figure 7, WStar outperforms WMinCut. In particular, if the number of snippets ranges from 100 to 200, WStar
takes from 1 to 4 seconds, and it requires about 70 seconds for 1000
snippets. Conversely, WMinCut can take around 30 seconds for
200 snippets and it requires more than one hour for 1000 snippets.

For each query three values of similarity are shown: (i) The similarity between the clusters computed by WStar and those of the
ground truth (leftmost bars), (ii) the similarity between the clusters
computed by WMinCut and those of the ground truth (bars in the
middle), and (iii) the similarity between the clusters computed by
WStar and those of WMinCut (rightmost bars). The values of similarity between the clusters of the two algorithms against the ground
truth are between 26% and 51% (the average is 39% for WMinCut
and 36% for WStar). These values can be judged rather good if
we consider the knowledge expertise of a human and the fact that
in the manual clustering we looked at the web pages and not only
at their snippets. For almost all the queries the values of similarity
for WMinCut are higher than those for WStar, but the difference
between the two algorithms is never larger than 8%. The values
of similarity between WStar and WMinCut are between 62% and
69% with an average value of 66%. This means that the clusters
computed by the two algorithms are rather similar and therefore,
WStar represents a significant better trade-off between efficiency
and effectiveness.
Cluster similarity
Wstar vs Ground Truth

WMinCut vs Ground Truth

Wstar vs WMinCut

80
70

Running time

60

WStar

%F-measure

WMinCut
900
800
700
seconds

600

50
40
30
20

500

10

400

0

300

Apple

200

Clinton

Games

Jaguar

Music

Olympic
Games

100
0
50

100

150

200

300

400

500

1000

number of snippets

Figure 8: Cluster similarity results for the two algorithms WStar and
WMinCut. For each query it is shown the value of similarity between: (i) WStar
and the Ground Truth (leftmost bar), (ii) WMinCut and the Ground Truth (middle
bar), and (iii) WStar and WMinCut (rightmost bar).

Figure 7: Running times of algorithms WMinCut (dashed line) and WStar
(solid line) for increasing number of snippets. The time is in seconds and the
values are averaged over all queries of Table 1. For 1000 snippets WMinCut
takes more than one hour and therefore we do not report data.

We performed a second experiment to evaluate the quality of the
clusters computed by the two algorithms. To this aim we measured
the similarity between the first-level categories computed by each
of the two algorithms against those computed by a human. Since
a manual computation of the clusters can take a significant amount
of time, in order to speed-up this experiment, we randomly selected
six of the nine queries of Table 1, namely: Apple, Clinton,
Games, Jaguar, Music and Olympic Games. For each query
we manually classified the pages whose snippets were returned by
the search engine and that form the input to the clustering algorithms. When defining such a classification we looked not only at
the snippets, but also at the corresponding Web pages. The function
used to evaluate the similarity between clusters is the well-known
F-measure function (see [15] for a formal definition of this function). The results of this experiment are illustrated in Figure 8.

6 A RCHITECTURE OF WhatsOnWeb+
The architecture of WhatsOnWeb+ has been designed such that it
can be easily extended with new layout interfaces, new clustering
algorithms, and new drivers for different data sources (i.e., different
search engines). Since WhatsOnWeb+ must be accessed over the
Internet, it has a client/server architecture, mainly implemented in
Java. The client side architecture adopts the well-known ModelView-Controller design pattern.
From the application context point of view, we remark that the
new system can be used not only for searching the whole World
Wide Web, but also for searching documents in more restricted
environments. Namely, there is a growing range of customizable search engines like, for example, GoogleDesktop5 , IBM Omnifind6 , and Oracle Secure Search7 , that are specifically developed
for indexing and retrieving data within single computers, intranets,
or small portions of the Web (i.e., selected Web sites). These engines are typically easy to install and set-up in home or company environments, and provide the programmer with an API (Application
5 http://desktop.google.com/

4 For

this experiment, we retrieved data from the MSN search engine,
because it always returned 1000 results on our queries, while other popular
search engines, like Google, returned no more than 900 results.

6 http://www-306.ibm.com/software/data/enterprise-search/omnifindenterprise/
7 http://www.oracle.com/technology/products/oses/index.html

173

Programming Interface) to pass query string and retrieve results.
Thanks to the WhatsOnWeb+ plug-in architecture, it is possible
to quickly implement specific data source drivers to integrate in our
system. In this way the visual analysis tools of WhatsOnWeb+ can
be rapidly used to support the information retrieval on unstructured
collections of documents that are stored in a single file system, or
in the file systems of organization or collaboration networks.
As a proof of feasibility, we implemented and integrated
in WhatsOnWeb+ drivers for accessing the following search
engines: Google, MSN, and IBM Omnifind.
A publicly available prototype of WhatsOnWeb+, which allows to
retrieve data from Google and MSN can be accessed at
http://whatsonweb.diei.unipg.it/.
7

C ONCLUSIONS AND F UTURE W ORK

In this paper we presented an enhanced visual search clustering engine, called WhatsOnWeb+; with respect to a previous prototype,
this new system introduces a more efficient clustering algorithm,
and presents several graph visualization interfaces and a novel visual strategy for exploring clustered graphs. We also presented the
results of an experimental study that compared the effectiveness of
the different visual interfaces of WhatsOnWeb+ and that showed
how the new clustering algorithm represents a good trade-off between quality and efficiency.
There are many research directions that we plan to investigate
in the near future. For example, new visual paradigms can be explored and the use of real-life metaphors can be combined with
graph based approaches to represent the map of categories and documents. New experiments should be performed in order to understand the validity of our technology for presenting search results in
various contexts other than the World Wide Web.
R EFERENCES
[1] M. S. Akhavi, M. Rahmati, and N. N. Amini. 3d visualization of
hierarchical clustered web search results. In CGIV ’07: Proc. of the
Computer Graphics, Imaging and Visualisation, pages 441–446. IEEE
Computer Society, 2007.
[2] K. Andrews, C. G¨utl, J. Moser, V. Sabol, and W. Lackner. Search
result visualisation with xfind. In UIDIS ’01: Proc. of the second
International Workshop on User Interfaces to Data Intensive Systems,
pages 50–58. IEEE Computer Society, 2001.
[3] J. A. Aslam, E. Pelekhov, and D. Rus. The star clustering algorithm
for static and dynamic information organization. Journal of Graph
Algorithms and Applications, 8(1):95–129, 2004.
[4] N. Bonnel, A. Cotarmanac’h, and A. Morin. Meaning metaphor for
visualizing search results. In IV ’05: Proc. of the Ninth International Conference on Information Visualisation (IV’05), pages 467–
472. IEEE Computer Society, 2005.
[5] M. Bruls, K. Huizing, and J. J. van Wijk. Squarified treemaps. Proc.
of Joint Eurographics and IEEE TCVG Symposium on Visualization,
pages 33–42, 2000.
[6] B. Craft and P. Cairns. Beyond guidelines: What can we learn from
the visual information seeking mantra? In Proc. Ninth International
Conference on Information Visualization, pages 110–118, 2005.
[7] J. Cugini, C. Piatko, and S. Laskowski. Interactive 3d visualization for document retrieval. In CIKM’96: Proc. of the Workshop
on New Paradigms in Information Visualization and Manipulation.
ACM, 1996.
[8] G. Di Battista, W. Didimo, M. Patrignani, and M. Pizzonia. Orthogonal and quasi-upward drawings with vertices of prescribed sizes. In
GD ’99: Proc. of the International Symposium on Graph Drawing,
volume 1731 of LNCS, pages 297–310. Springer Verlag, 1999.
[9] G. Di Battista, P. Eades, R. Tamassia, and I. G. Tollis. Graph Drawing.
Prentice Hall, 1999.
[10] E. Di Giacomo, W. Didimo, L. Grilli, and G. Liotta. A topologydriven approach to the design of web meta-search clustering engines.
In SOFSEM’05, volume 3381 of LNCS, pages 106–116. Springer Verlag, 2005.

174

[11] E. Di Giacomo, W. Didimo, L. Grilli, and G. Liotta. Graph visualization techniques for web clustering engines. IEEE Transactions on
Visualization and Computer Graphics, 13(2):294–304, 2007.
[12] B. Engdahl. Ordered and unordered treemap algorithms and their applications on handheld devices. Master’s thesis, Royal Institute of
Technology, Stockholm, Sweden, 2005.
[13] P. Ferragina and A. Gulli. The anatomy of a clustering engine for webpage snippet. In ICDM’04: Proc. of the Fourth IEEE International
Conference on Data Mining, 2004.
[14] M. A. Hearst. Tilebars: visualization of term distribution information
in full text information access. In CHI ’95: Proc. of the SIGCHI conference on Human factors in computing systems, pages 59–66. ACM
Press/Addison-Wesley Publishing Co., 1995.
[15] B. Larsen and C. Aone. Fast and effective text mining using lineartime document clustering. In Conference on Knowledge Discovery in
Data, pages 16–22, 1999.
[16] B. Lee, C. S. Parr, C. Plaisant, B. B. Bederson, V. Veksler, W. D.
Gray, and C. Kotfila. Treeplus: Interactive exploration of networks
with enhanced tree layouts. IEEE Transactions on Visualization and
Computer Graphics, 12(6):1414–1426, 2006.
[17] L. T. Nowell, R. K. France, and D. Hix. Exploring search results
with envision. In CHI ’97: extended abstracts on Human factors in
computing systems, pages 14–15. ACM, 1997.
[18] A. Rahman and A. E. Saddik. Eye & why: A prototype for learning
objects visualization in virtual environment. In ISM’06: Proc. of the
eighth IEEE International Symposium on Multimedia, pages 787–789.
IEEE Computer Society, 2006.
[19] E. Reingold and J. Tilford. Tidier drawing of trees. IEEE Trans. Softw.
Eng., SE-7(2):223–228, 2007.
[20] J. Roberts, N. Boukhelifa, and P. Rodgers. Multiform glyph based web
search result visualization. In Proc. of the sixth international conference on Information Visualisation, pages 549–554. IEEE Computer
Society, 2002.
[21] M. M. Sebrechts, J. V. Cugini, S. J. Laskowski, J. Vasilakis, and M. S.
Miller. Visualization of search results: a comparative evaluation of
text, 2d, and 3d interfaces. In SIGIR ’99: Proc. of the 22nd annual
international ACM SIGIR conference on Research and development in
information retrieval, pages 3–10. ACM, 1999.
[22] B. Shneiderman. Tree visualization with treemaps: A 2-D spacefilling approach. ACM Transactions on Graphics, 11(1):92–99, 1992.
[23] B. Shneiderman. The eyes have it: A task by data type taxonomy for
information visualizations. In Proc. Visual Languages Conference,
pages 336–343, 1996.
[24] B. Shneiderman, D. Feldman, A. Rose, and X. F. Grau. Visualizing
digital library search results with categorical and hierarchical axes. In
DL ’00: Proc. of the fifth ACM conference on Digital libraries, pages
57–66. ACM, 2000.
[25] C. M. Zaina and M. C. C. Baranauskas. Revealing relationships
in search engine results. In CLIHC ’05: Proc. of the 2005 Latin
American conference on Human-computer interaction, pages 120–
127. ACM, 2005.


Placing Connected Components
of Disconnected Graphs
Dennis Goehlsdorf∗

Michael Kaufmann†

Martin Siebenhaller‡

Universität Tübingen, WSI für Informatik, Sand 13,
72076 Tübingen, Germany

Abstract
A problem arising when drawing disconnected graphs, is the
placement of the connected components. The problem corresponds to finding an appropriate two-dimensional, nonoverlapping placement of given objects. Most layout algorithms assume a connected graph and do not deal with connected components. Thus, each component is layed out separately which requires an additional step to arrange these
components. There are only few approaches in literature
which address this task. We review some of them and present
new methods that improve existing results. Our approach is
based on a classical greedy approach described by Freivalds
et al. which uses a polyomino representation of the objects. We introduce new quality measures to evaluate a twodimensional placement which yield more compact layouts.
Our approach particularly eliminates most cases in which
previous approaches returned poor results.
Keywords:
two-dimensional packing, graph drawing,
placing connected components.
Index Terms: F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems—
Geometrical problems and computations.
1

Introduction and Motivation

Graphs model complex information by describing the relationships between discrete objects. There are several automatic layout approaches that construct readable drawings of graphs such that users can easily interpret the contained information. An overview of those approaches is given
in [20, 18]. Most of them assume a connected graph and do
not deal with connected components. Thus, each component
is layed out separately which requires an additional step to
arrange these components. This is often done naively resulting in poor results.
The drawing of a graph is usually displayed on a device of
fixed size (e.g. a screen or paper). No matter how effectively
connected components are layed out, a significant amount of
space on the output device might be unused if disconnected
components are placed naively, without taking the desired
aspect ratio into account.
A related problem arises in manufacturing industries like
wood-cutting or textile processing industry, where the object is to cut pieces of given shape and size out of rectangular shaped sheets of base material. Consequently, there
are many commercial solutions that aim at optimizing the
∗ e-mail:

goelsdor@informatik.uni-tuebingen.de
mk@informatik.uni-tuebingen.de
‡ e-mail: siebenha@informatik.uni-tuebingen.de
† e-mail:

Asia-Pacific Symposium on Visualisation 2007
5 - 7 February, Sydney, NSW, Australia
1-4244-0809-1/07/$20.00 © 2007 IEEE

Figure 1: Ad-hoc placement (adjusted fullness for an aspect ratio of
1:1: 32%), advanced placement as being described in [14] (43%), and
our solution (60%). Using our approach results in an improvement
of 40% for this example.

placement of pieces in order to improve material usage and
decrease excess parts [19, 5, 16]. Unfortunately, there are
only few algorithms for this problem available to public and
these algorithms have high computational costs [10]. Furthermore, the addressed problem is more simple, since the
size of the rectangular sheet is fixed. Leaving the final scale
of objects flexible makes it impossible to employ the same
algorithms as for fixed scaling.
In this paper, we review existing approaches for twodimensional packing of objects. We focus on the greedy
approach described by Freivalds et al. [14] which uses a polyomino representation to approximate the shape of objects.
We introduce an extended greedy approach which incorporates some fundamental changes and new quality measures.
The improvement over existing techniques is shown in several experiments.
In the following section, we will give basic definitions and
review some of the previous approaches in more detail. Then
we present our new approach and its concepts. Section 4 describes some implementation issues and Section 5 the results
of our experiments.
2 Definitions and Previous Approaches
2.1 Definitions
In the following, we consider a set of n discrete objects O =
{o1 , ..., on }, each having a defined two-dimensional shape.
These objects have to be placed on a plane such that no
two objects overlap each other. An assignment of objects to
relative positions on a plane defines a placement to which
we will also refer to as configuration.
The bounding rectangle of a placement is defined as the
tightest rectangle R = (W, H) enclosing all objects of the
given set O. This bounding rectangle defines the bounding area BA = W ∗ H of a placement and an aspect ratio
AR = W/H. In case the placement should fulfill a desired
aspect ratio DAR, the effective area of a placement is defined as the area of the tightest rectangle with aspect ratio
DAR that encloses R. Given the bounding area BA of a

101

a)

b)

c)

Figure 2: A set of rectangles packed two-dimensionally by StripPacking (a), Tiling (b) and Alternate Bisection (c).

placement, its aspect ratio AR and a desired aspect ratio
DAR, the effective area EA of the placement can be calculated as follows: If AR > DAR, then EA = BA ∗ AR/DAR
and otherwise EA = BA ∗ DAR/AR.
The input of an algorithm that places connected components is the set of objects (components) and a desired aspect
ratio. The algorithm’s task is to calculate a placement such
that no objects overlap with each other and that the effective
area is minimized.
If Ai denotes the area occupied by object oi ∈ O,
the fullness F U of a placement is defined as F U =
P
n
i=1 Ai /BA.
Pn Accordingly, the adjusted fullness AF U is
AF U =
i=1 Ai /EA. Furthermore, the adjusted wasted
space is defined as AW S = 1 − AF U .
2.2

Approximating the Used Area by Rectangles

Most algorithms for two-dimensional packing that are described in literature work with objects of rectangular shape
only. If a placement for a set of non-rectangular objects
is searched, their shapes need to be approximated by their
bounding rectangles. In this subsection, we summarize three
of the most popular algorithms using rectangular objects.
More details about two-dimensional packing algorithms can
be found in [1, 3, 8, 9, 11, 15].
2.2.1

Strip-Packing:

Strip-Packing is based on packing a set of rectangular objects into a semi-infinite strip of unit width. The most popular variant is the level algorithm, i.e. First-Fit Decreasing
Height (FFDH) where the set of rectangles (Wi , Hi ) is first
sorted by height in decreasing order. Then these objects are
placed successively into levels. In each placing step, the algorithm searches the lowest level with enough space to place
the current object. The rectangle is then placed left-justified
into this level. If no such level can be found, a new level is
opened. Another implementation of Strip-Packing is called
Best-Fit Decreasing Height, where rectangles are placed into
those levels where they fit best. Given a desired aspect ratio, a two-dimensional packing problem can be solved using Strip-Packing by estimating an appropriate strip width
before applying the algorithm. This estimate P
can be calculated by dividing the total area of all objects n
i=1 Ai with
the average adjusted fullness of the algorithm. Clearly, this
estimate is one of the main disadvantages of the algorithm.
The runtime complexity of the algorithm is O(n log n).
2.2.2

Tiling:

The Tiling methods works similar to the Strip-Packing
method but eliminates the need for an estimate of the strip
width. Instead of delimiting the strip width in advance, it
increases dynamically as rectangles are placed.

102

Figure 3: The generation of a polyomino from a graph object and
the filling of bounded grid cells.

Similar to Strip-Packing, objects are first sorted by height
in decreasing order. The first object is then placed into
an initial level. Each following object is either placed leftjustified into an existing level with minimal width or into a
new level. This decision is made depending on the adjusted
fullness of the placement that would result: The object is
placed onto the position where the effective area of the placement of all objects placed so far is minimal. The algorithm
has runtime O(n log n).
2.2.3

Alternate Bisection:

This method is a divide-and-conquer approach that works
by bisecting the set of rectangles to be placed into two sets
that have the same size in a given metric, i.e. the total area
of rectangles in a set. These two sets are processed recursively. The recursion stops when a set consists only of a
single rectangle. Two embedded sets are combined by placing them horizontally or vertically aligned. The orientation
is alternated after each recursion step. The algorithm has
runtime O(n log2 n).
2.3

Polyominoes

All methods described so far assume that all objects that
need to be placed are of rectangular shape. Therefore, objects with different shapes need to be approximated by their
bounding rectangles, which significantly decreases the adjusted fullness of the final output. Approximating triangles
for example would result in a fullness of less than 50% which
is of course unsatisfying.
Hence, Freivalds et al. proposed another approach for
two-dimensional packing problems with objects of arbitrary
shape [14]: Instead of using rectangular objects, they used
polyominoes to approximate an object’s shape. Following
their definition, a polyomino is a finite set of δ ≥ 1 cells
of the infinite planar square grid Γ where each cell is intersected by some part of the drawing. In other words, a
polyomino represents a low-resolution picture of the object’s
shape. Grid cells that are covered by the objects drawing
will also be referred to as filled, the remaining grid cells as
empty. In case it is not desired that objects may lie inside
of other objects, grid cells that are completely bounded by
covered grid cells are filled, too (see Figure 3).
In the polyomino approach [14], a polyomino is generated
for each object in the set. The resulting list of polyominoes
is sorted by the size of the bounding rectangle of each polyomino. Now, a grid structure is initialized, which we will
refer to as base grid. The base grid is used to place polyominoes by copying filled grid cells of the polyomino relative to
a specified position onto the base grid. A polyomino only fits
at a position, if no grid cells of the polyomino would overlap
with filled grid cells of the base grid when the polyomino is
placed at that position.

a)

a)

b)

b)
4

3
2

1

3

4

2

1

Figure 5: (a) the layout returned by a greedy algorithm (DAR 1:1)
and (b) the optimal solution returned by our algorithm.
Figure 4: Applying Polyomino-based algorithms to polygonal objects
(desired aspect ratio: 3:2). Our algorithm (b) generates results that
are more compact and better sorted than the results of the greedy
algorithm by Freivalds et al. (a).

+
The algorithm of Freivalds et al. then performs a greedy
search for a good placement of all polyominoes: The first
polyomino in the list is placed at any position onto the
base grid. The following polyominoes in the list are then
placed consecutively as follows: Positions on the base grid
are sorted in decreasing order by the adjusted fullness of the
partial configuration that would result if the current polyomino would be placed at that position. The current polyomino is placed at the first position in this order where it
fits. If the average polyomino size is limited by a constant
c, the runtime of the algorithm is O(n2 ) [14].
A clear advantage of this algorithm is the better approximation of an object’s shape in the placing process, which
leads to much higher levels of adjusted fullness than in the
other approaches.
A similar approach was presented by Chen et al. [6]. They
use a greedy algorithm to calculate an initial placement and
apply heuristics like a genetic algorithm [2] or tabu search [4]
to improve this placement. Unlike Freivalds et al., they
solely try to improve the fullness of placements and do not
consider the aspect ratio of these placements. In their publication, they also present an approach to place vectorized objects of any shape onto a two-dimensional area of fixed size
and shape. While offering a more exact approximation of
the object’s contour than methods that allow rectilinearizd
shapes only, this approach makes it much more complicated
to find and evaluate placements.
3 The New Approach
Our approach is designed to place connected components
of disconnected graphs. Connected components are already
layed out by any layout algorithm, e.g. the layered approach of Sugiyama or the topology-shape-metrics (TSM)
approach [20]. Both approaches often produce drawings
with irregular contours, especially when applying additional
drawing constraints like a prescribed direction of flow or
clusters, and thus demand an advanced strategy to yield
a satisfying fullness. A popular application using such constraints are layout approaches for UML-diagrams [12, 13].
The TSM-approach sometimes tend to produce large empty
areas inside a connected component such that it is favorable
to allow smaller components to be placed inside those areas.
Such a nesting of connected components is especially suitable for applications where connected components do not
imply a semantic membership.
Although initially designed to lay out graph components,
our algorithm can also be applied to any polygonal shapes,
as shown in Figure 4.
3.1 Basic Idea
The approach described by Freivalds et al. represents a traditional greedy approach. In each placing step, the best configuration is chosen. Finding an optimal solution for packing

+

Figure 6: Importance of variability: Three polyominoes are placed
successively to fulfill an aspect ratio of 1:1. After the first placing
step, two similar configurations are selected which both lead to a
similar suboptimal result after the second placing step. The third
configuration selected after the first placing step, which has a lower
similarity with the other two, leads to an optimal solution.

n polyominoes into a minimal area is NP-hard, since it would
be necessary to test every possible place for every single polyomino. Even the problem of finding an optimal solution for
a set of n rectangles has been shown to be NP-hard [17].
Like any greedy algorithm for a NP-hard problem, the described algorithm is very likely to end up in a local minimum
of the target cost function. Figure 5 shows a simple example for a set of four graph objects each consisting of a single
node, where the greedy approach chooses a sub-optimal solution. Hence, we decrease the probability of bad results by
generating alternative configurations: For each polyomino
that is placed on the base grid, the algorithm should store
a number of k different placements. Consequently, since a
constant number of configurations is stored after each placing step, the following polyomino is placed onto each of the
k resulting base grids. This placing process again results in
a number of different configurations, from which the best
k are chosen for the following placing step and so on. The
effect of the choice of k is investigated in Section 5.
If we would omit the bounding of choosing only k configurations after each placing step, the algorithm would perform
a complete search for the optimal solution, resulting in an
exponential runtime complexity. Using at most k configurations leads to an increase of the runtime by a constant factor
k, which still leaves us with a O(n2 ) time complexity.
3.2 Refinements
The main problem arising when more than one configuration
is stored after each placing step is to find a good criteria
for selecting the best configurations. Simply selecting the k
configurations with the highest adjusted fullness results in
a higher runtime but in most cases no improvement of the

103

a)

b)

Figure 7: Adjusted fullness AF U vs. fullness F U : The adjusted
fullness for a desired aspect ratio of 1:1 of the configuration shown
in (a) is higher (0.64) than in (b) (0.44), whereas the fullness in
(b) (0.89) is higher than in (a) (0.64). Obviously, the configuration
shown in (b) is suited better if further components will be placed.

placement’s quality. Therefore, improved quality measures
are necessary to evaluate configurations of polyominoes.
3.2.1

Fullness:

The algorithm described in [14] selects the best configuration after each placing step, where the adjusted fullness of a
placement is used as quality measure. It is reasonable to use
the adjusted fullness as a criteria to select a configuration,
since it represents the target cost function of the finally obtained placement. Nevertheless, the fullness of a placement
sometimes represents the better criterion. The adjusted fullness after the first few placing steps has little influence on
the adjusted fullness after placing all objects if the number of grid cells covered by the already placed polyominoes
is small compared to that of the non-placed polyominoes.
The fullness gives a better measure for the packing rate of
a configuration and is therefore better suited as a quality
measure, if a high number of polyominoes is still left to be
placed. Figure 7 shows an example to point up this coherence.
3.2.3

Surface:

As described above, the fullness of a polyomino configuration
can be a better quality measure than the adjusted fullness
if a considerable part of the set of polyominoes is still to
be placed. The main reason for this is the fact that the
fullness is a more exact measure for the compactness of a
placement. One can obtain an even more accurate measure
of compactness by computing the surface of a configuration.
The surface of a configuration is the length of the border
between filled and empty grid cells. Examples for the surface
of polyominoes can be found in Figure 8.
Using the surface as a quality measure yields good results
but experiments revealed that the quality may be further improved by using a refined surface measure: Since the target
shape to which the placement is optimized is a rectangle, it
is preferable if partial configurations have flat sides. Therefore, we introduce a more appropriate quality measure which
we will refer to as effective surface. The effective surface is
defined as the surface minus the number of filled grid cells

104

b)

c)

d)

Figure 8: Surface as a quality measure: All shown polyominoes have
the same fullness (0.64). The polyomino shown in (a) has a surface
of 20, the one in (b) 34. It is striking that it is more likely that
empty spaces in configuration (a) will be filled by other polyominoes
than in (b). Both examples in (c) and (d) have the same surface
(20). Nevertheless, the example in (c) seems to be the better choice
over (d) since non-filled grid cells form a larger connected area that
can be used to place other components. Using the effective surface
(highlighted in light grey), example (c) retrieves a better score (6)
than (d) (13).

Variability:

A striking observation is that in order to improve a placement returned by the greedy strategy, the k different configurations selected after one placing step need to be significantly different >from each other. If so, it becomes unlikely
that the heuristics will be trapped in a bad local minimum
of the cost function. In Figure 6, a simple example with 3
polyominoes and k = 3 is shown in which the selection of
two similar configurations after the first placing step lead to
suboptimal solutions after the second placing step, whereas
a very different configuration after the first placing step leads
to an optimal solution.
3.2.2

a)

that lie at one of the horizontal or vertical borders of the
placement. Figure 8 (c,d) shows an example for the effective
surface.
The surface of a polyomino configuration offers an efficient way to evaluate placements, but it may significantly
increase the runtime of an algorithm: In each step of placing one polyomino onto a base grid, each possible resulting
configuration needs to be evaluated. Hence, if xb and yb denote the maximal x-distance and y-distance of two filled grid
cells on the base grid, the evaluation has to be performed
O(xb · yb ) times. To calculate the surface, each position of a
filled grid cell of the current polyomino has to be examined
for neighboring filled grid cells, which results in a runtime
complexity of O(xp · yp ) with xp and yp being the width and
the height of the polyomino, respectively.
Chen et. al [6] introduced a related quality measure to
evaluate placements of two-dimensional objects: They calculated the number of edges that is needed to draw the
outer shape of a placement and combined it into one formula with the area wasted by a drawing, being equivalent
to BA − BA ∗ F U . We chose the described effective surface
instead since this measure better accounts for inclusions of
empty grid cells. Furthermore, many small inclusions will
give a higher penalty than a single large inclusion.
3.2.4 Profile Homogeneity:
In order to obtain a quality measure with similar properties
as the effective surface but with a lower runtime complexity,
we developed another scoring system that we will refer to
as profile homogeneity. Each configuration has four profiles
that determine its vertical and horizontal boundaries. The
homogeneity of the upper profile is the sum of y-differences
of neighboring cells that form this profile. The homogeneity of the lower, the left and the right profiles are defined
accordingly. The sum of these four values is the profile homogeneity of a configuration. Figure 9 shows an example on
how to calculate this measure.
The profile homogeneity accounts for all irregularities that
can be found on the outer surface of a placement. Inclusions
of empty grid cells do not influence this value. This is disadvantageous, because it is unlikely that these empty grid cells
will be filled during placement of the remaining polyominoes. Experiments underlined that it is of high importance
to penalize such inclusions.
Calculation of all empty grid cells bounded by others
would be too time consuming. Therefore, we use a measure
that we call the pseudo inclusion count P IC, which can be
obtained by the formula P IC = Avertical + Ahorizontal −
2 ∗ Atotal , where Avertical denotes the area that is included

2

1

Algorithm 1: calcPlacement
Input: The set of objects O,
the desired aspect ratio DAR.
Output: The final placement φ.

2
1

1
1
2 2

Figure 9: The calculation of the profile homogeneity of a configuration (here: 12).

Avertical:

1
16

2

4

19

Ahorizontal:

19

4
Figure 10: The calculation of the refined profile homogeneity:
Avertical and Ahorizontal represent the area that is included by
the vertical and horizontal borders. In this example, the pseudo inclusion count adds up to 19 + 19 − 2 ∗ 16 = 6, resulting in a refined
profile homogeneity of 17.

between the upper and the lower profile of the placement,
Ahorizontal the area between the left and the right profile
and Atotal the number of filled grid cells. Avertical can easily be calculated by iterating over all columns of a placement
and summing up the distances between the highest and the
lowest filled grid cell in each column. Ahorizontal can be
calculated analogously. Adding the pseudo inclusion count
to the profile homogeneity results in a quality measure that
performs almost as good as the effective surface and that we
will call the refined profile homogeneity.
If the profile of a base grid and of a polyomino that should
be placed are known and saved in an appropriate data structure, the refined profile homogeneity can be calculated in
O(xp + yp ), since the profile of the base grid only needs to
be updated in those areas that overlap with the polyomino
that is being placed. Note that in the worst case this term
might be equal to the runtime complexity of calculating the
effective surface (xp = 1 or yp = 1).
4 Implementation
Algorithm 1 gives an outline of our approach. Refinements
are provided in subsequent subsections.
4.1 Processing Order
We sort the polyominoes with respect to their bounding
rectangles. More precisely, they are sorted by the value
s2min + smax , where smin is the length (in grid cells) of the
shorter side of the bounding rectangle and smax is the length
of the longer side. Using this value, polyominoes that are
smaller and of prolate shape are placed later. We obtained
slightly better results using this strategy instead of sorting
by BA.
4.2 Quality of a Placement
As described in Section 3.2, several quality measures can be
found to assign a score to a placement. In an implementation, these measures need to be combined to allocate a single
score to a configuration.

PList ← list of polyominoes generated from O;
sort PList (see Section 4.1);
ConfigList ← first polyomino of PList placed on an
empty base grid;
foreach polyomino p ∈ PList do
foreach configuration c ∈ ConfigList do
foreach possible placement x of p onto c (see
Section 4.4) do
calculate score of x (see Section 4.2);
end
end
ConfigList ← select the k best configurations for p
(see Section 4.3);
end
φ ← first configuration of ConfigList;

We present two implementations, one of them using the
effective surface of a placement (called MinimalSurface) and
the other using the refined profile homogeneity (called ProfileHomogeneity). Using the effective surface, our algorithm
calculates a score of a placement as follows:
score = max(0, EA − Atotal − Anotplaced /2) + ES
Here, Atotal denotes the number of filled grid cells in the
base grid, Anotplaced the number of filled grid cells in polyominoes that are not yet placed and ES the effective surface of the placement. We use the same formula for the
ProfileHomogeneity-algorithm but substitute the effective
surface with the refined profile homogeneity.
This formula combines quality measures like the effective
surface or the refined profile homogeneity with the adjusted
fullness of a placement. The desired aspect ratio for the
placement is also included in this formula, since it is part
of the effective area. When placing the first few polyominoes, the unused area described by the term EA − Atotal is
practically ignored since the size of non-placed polyominoes
is subtracted. Consequently, placements are only compared
using the effective surface at this stage of the algorithm.
Later, when only few polyominoes are still to be placed, the
importance of the effective surface lessens since the first term
in the formula will result in values of increasing size.
The fullness of a placement is not considered in this formula. As mentioned above, the surface or the profile homogeneity of a placement are better suited to measure the
compactness of a placement. A decreasing fullness will normally result in an increasing surface or profile homogeneity.
4.3 Selection of Placements
As we mentioned in Section 3.2, maintaining variability in
the set of configurations that will be stored after one placing step is an important task in order to improve the result
obtained by the greedy approach. When simply selecting
the k configurations with respect to the score as described
in Section 4.2, stored configurations would be too similar to
each other.
We define two placements A and B as different from each
other, if their bounding rectangles have a different size in
one dimension or if their scores differ at least by SD. Experimental results showed that good results can be obtained
using a difference factor of 5%.

105

a)
b)

A B CDE F GH I J K L

c)

Figure 11: Finding possible positions for polyomino (a) on the base
shown in (b) and (c). Hatched grid cells indicate positions that are
checked by different placing strategies, placing the upper left grid
cell of the polyomino onto that cell. (a): basic placing strategy, (b):
fast placing strategy.

4.4
4.4.1

Basic Strategy:

Fast Strategy:

The above strategy is obviously not optimal since it is senseless to place the current polyomino at positions such that no
filled grid cells of the polyomino touches any filled grid cell of
the base grid. Such configurations would receive low scores
and would not be stored anyway. Therefore, these positions
need not to be tested. Instead, only those positions need to
be tested which guarantee that at least one filled grid cell
of the polyomino will have contact to a filled grid cell of the
base grid or that the current polyomino will lie inside the
base, being bounded by filled grid cells of the base.
The outer positions can be calculated easily provided that
the horizontal and vertical profiles of the polyomino and the
base grid are given. In Figure 11, hatched positions indicate
outer positions to which the polyomino should be placed to.
Using these outer positions exclusively to place the polyomino leads to good results and decreases the runtime complexity for finding suitable positions from O(xb yb · xp yp ) to
O(xb · xp + yb · yp ).
The strategy of placing a polyomino only at outer positions of the base grid obviously does not allow to find positions that are horizontally and vertically bounded by filled
base grid cells. However, the disadvantage arising from this

106

A B CDE F GH I J K L
1
2
3
4
5
6
7
8
9
10
11

Figure 12: Example for the advanced placing strategy: The left grid
shows a base grid with filled (grey/dark grey) and empty (white)
cells, onto which a polyomino (black/dark grey) should be placed. If
the polyomino is placed at B3, it will give an overlap at D5. Consequently, we know that the polyomino cannot be placed at this
position. Furthermore, it cannot be placed at the positions indicated
in black on the right grid, because some part of the polyomino will lie
on position D5. If the polyomino is placed at I4, another overlap is
found at I6. The polyomino is turned by 180 degree and the position
that caused the overlap is drawn at I4.

Finding Valid Placements

In order to select the best valid positions of a polyomino on
a base grid, all valid positions for that polyomino need to
be found and evaluated. Finding valid positions for a polyomino is a critical process regarding the runtime of the algorithm. As a basic approach, the placement of the current
polyomino onto the base grid can be tested at every position that does not yield a configuration with empty columns
between non-empty columns or empty rows between nonempty rows. This results in a rectangular area in which
every position is tested. In Figure 11(b), this area is indicated in an example base grid. In case a greedy strategy is
used to find a good placement for a set of objects, this basic
strategy can be refined by searching the indicated positions
on the base grid >from inside to outside. The first position
at which the current polyomino can be placed will then be
the one that results in the highest adjusted space. A similar
strategy is used by Freivalds et al. [14]. Note that this greedy
strategy cannot be applied if alternative configurations are
searched or if a more sophisticated quality measure than the
adjusted fullness is used.
4.4.2

1
2
3
4
5
6
7
8
9
10
11

restriction is small since the placing algorithm tries to minimize the number of empty base grid cells bounded by filled
grid cells.
4.4.3 Advanced Strategy:
In order to abandon the disadvantages of the fast strategy,
we extended this strategy as follows: Outer positions are
calculated in the same way as in the fast strategy. In addition to these outer positions, all positions bounded by them
are tested, too. This results in the same theoretical runtime as for the basic strategy, but the practical runtime can
be reduced significantly, if non-successful position tests are
evaluated carefully: every time a testing for a specific placing position fails, at least one specific filled base grid cell
interferes with a filled polyomino grid cell. Since every position test will fail if any other filled polyomino grid cell will
overlap with the same base grid cell, all such positions need
not to be tested. Hence, our algorithm uses an additional
two-dimensional array to remember positions to which the
polyomino will not fit. Every time a position test fails, the
pattern of the polyomino is rotated by 180 degree and then
drawn onto that array (see Figure 12). All filled grid cells of
the array denote invalid positions.
5 Experimental Results
We implemented our approach in Java using the yFiles library [21]. All experiments have been performed on a AMD
Athlon XP 1600 System with 768 MB main memory running
MS Windows XP.
We compared the two implementations of our algorithms
with an implementation of the greedy approach described
by Freivalds et al. [14]. Algorithms were tested using random graph objects each containing 30 to 100 nodes. They
were constructed by first building a tree of n nodes and then
adding n to 2n additional edges. The graphs were layed
out using an orthogonal layout algorithm [20]. A desired
aspect ratio of 1:1 was used when executing the algorithms.
We obtained similar results when applying different aspect
ratios.
Figure 13 shows the adjusted wasted space obtained when
using an average polyomino size of 100 grid cells and different numbers of disconnected objects. In order to measure
the improvement obtained by our algorithms, we compared
the adjusted wasted space returned by them with that of

adjusted wasted space

ProfileHomogeneity

MinimalSurface

Greedy

5 objects

0,35

20 objects

0,25

100 objects

0,16
0,14

0,3
0,2

0,12

0,25

0,1

0,15

0,2

0,08
0,15

0,1

0,06

0,1

0,04

0,05

0,05

0,02

0

0

0
0

20

40

60

80

0

20

No. of configurations

40

60

0

80

20

40

60

80

No. of configurations

No. of configurations

Figure 13: The space wasted in results that were returned by the three algorithms, averaged over 30 random samples. The new algorithms were
run with increasing numbers of configurations (k) stored in each placing step.

ProfileHomogeneity

MinimalSurface

5 objects

improvement [%]

25

20 objects

35

40

30

20

100 objects

45
35

25

30

15

20

25

10

15

20
15

10

10

5

5

0

5

0
0

20

40

60

80

0
0

20

No. of configurations

40

60

80

0

20

No. of configurations

40

60

80

No. of configurations

Figure 14: Percentage reduction of adjusted wasted space in results obtained by our algorithms compared to those of the greedy algorithm.
The results are averaged over 30 random samples.

Basic
4500
4000
3500

time [ms]

Greedy

Fast

Advanced

10000
9000
8000
7000
6000
5000
4000
3000
2000
1000
0

3000
2500
2000
1500
1000
500
0
0

50

100

150

200

No. of objects

250

300

0

2000

4000

6000

8000

10000

Average polyomino size

Figure 15: Runtimes observed when applying different placing strategies, averaged over 5 random sets of objects. The left part shows the
runtime as a function of the object count. All four placing strategies show consistent runtimes with the theoretical runtime of O(n 2 ) and only
varying by factor 2 from each other. The right picture shows the dependence of the average polyomino size. Using the basic strategy, the
runtime increases rapidly with increasing polyomino size. Meanwhile, possible positions were found much faster using one of the other three
strategies.

107

the greedy algorithm. These improvements are shown in
Figure 14.
As shown in the figures above, it was possible to improve
results obtained by the greedy algorithm by up to 40% when
applying the MinimalSurface-algorithm and by up to 34%
with the ProfileHomogeneity-algorithm. Improvements increased with increasing number of disconnected components
and as well with increasing numbers of configurations (k)
stored after each placing step.
We further tested our algorithms with different types of
graph objects, using for instance graphs with 1 to 10 or 1
to 50 nodes. Results returned by the greedy algorithm were
still improved, but less significantly, probably because objects that are small compared to others can easily be placed
into areas of wasted space, even without the optimizations
introduced in this paper. Similarly, improvements were less
significant (up to 21%) when applying a spring embedder
layout [20] to graph objects instead of orthogonal layout.
We attribute this to the average shape of such objects which
is more circular and thereby makes it more difficult to reduce
the surface of configurations.
In Section 4.4, we described several alternative strategies
to search for possible positions of a polyomino on a base
grid. We analyzed the performance of these strategies by applying a greedy algorithm and a MinimalSurface-algorithm
(one configuration per placing step) to random samples, the
former using a greedy placing strategy and the latter using
either the basic, the fast or the advanced placing strategy.
Runtimes were measured in dependence of number of disconnected objects and of average polyomino size. Figure 15
shows the results of these experiments.
6

Conclusion and Future Research

In this paper, we reviewed existing techniques for the layout of two-dimensional objects on a plane and introduced
refinements of an existing approach. Our algorithm uses
polyominoes to approximate the shape of objects. These are
placed successively using an greedy strategy that stores several different alternatives at a time. We were able to show in
experiments, that the quality of results of a classical greedy
approach can be significantly improved by using additional
quality measures like the surface or the profile homogeneity
of a configuration.
There are several improvements of the described approach
that could be subject to future research: First, a second processing step could be added to improve results returned by
our algorithm. As Chen et al. showed for a related algorithm, a genetic algorithm or tabu search can be applied to
increase the fullness of placements [6]. Second, a preprocessing step could be added, in which objects that are smaller
than one grid cell, could be combined to fill out one grid
cell as efficiently as possible. Such a processing step could
eliminate the problem that small objects often occupy much
more space than needed.
References
[1] M. Adamowicz and A. Albano, “Nesting Two-Dimensional
Shapes in Rectangular Modules”, Computer Aided Design,
vol. 8, pp. 27-33, 1976.
[2] T. Back, “Evolutionary Algorithms in Theory and Practice: Evolution Strategies, Evolutionary Programming,
Genetic Algorithms”, Oxford University Press, New York,
1996.
[3] B. S. Baker, E. G. Coffman, and R. L. Rivest, “Orthogonal
Packings in Two Dimensions”, SIAM Journal on Computing, vol. 9(4), pp. 846-855, 1980.

108

[4] H. P. Blazewicz, J. Walkowiak, and R. Walkowiak, “Using
a Tabu Search Approach for Solving the Two-Dimensional
Irregular Cutting Problem”, Annals of Operations Research, vol. 41, pp. 313-325, 1993.
[5] Boeing, “2NA Nesting Software” (WWW document),
http://www.boeing.com/phantom/2NA/ (accessed September 2006).
[6] P. Chen, Z. Fu, A. Lim, and B. Rodrigues, “TwoDimensional Packing for Irregular Shaped Objects”, in
Proceedings of the 36th Hawaii International Conference
on System Sciences (HICSS’03), pp. 86-95, 2002.
[7] E. G. Coffman, M. R. Garey, and D. S. Johnson, “Approximation Algorithms for Bin Packing: An Updated Survey”,
in: G. Ausiello, M. Lucertini, and P. Serafini (editors), Algorithm Design for Computer Systems Design, Springer,
Vienna, pp. 49-106, 1984.
[8] E. G. Coffman, M. R. Garey, D. S. Johnson, and
R. E. Tarjan, “Performance Bounds for Level-Oriented
Two-Dimensional Packing Algorithms”, SIAM Journal on
Computing, vol. 9(4), pp. 808-826, 1990.
[9] E. G. Coffman and P. W. Shor, “Packings in Two Dimensions: Asymptotic Average-Case Analysis of Algorithms”,
Algorithmica, vol. 9, pp. 253-277, 1993.
[10] K. Daniels and V. J. Milenkovic, “Multiple Translational
Containment. Part I: An Approximation Algorithm”, Algorithmica, vol. 19, pp. 148-182, 1997
[11] U. Dogrusoz, “Two-Dimensional Packing Algorithms for
Layout of Disconnected Graphs”, Information Sciences,
vol. 143, pp. 147-158, 2002.
[12] H. Eichelberger, “Aesthetics and Automatic Layout of
UML Class Diagrams”, Ph.D. Thesis, Fakultät für Mathematik und Informatik, University of Würzburg, Germany,
2005.
[13] M. Eiglsperger, C. Gutwenger, M. Kaufmann, J. Kupke,
M. Jünger, S. Leipert K. Klein, P. Mutzel, and M. Siebenhaller, “Automatic Layout of UML Class Diagrams in Orthogonal Style”, Information Visualization, vol. 3(3), pp.
189-208, 2004.
[14] K. Freivalds, U. Dogrusoz, and P. Kikusts, “Disconnected
Graph Layout and the Polyomino Packing Approach”, in
Proceedings of the 9th International Symposium on Graph
Drawing (GD’01), LNCS 2265, Springer, pp. 378-391,
2002.
[15] H. Freeman and R. Shapira, “Determining the MinimumArea Encasing Rectangle for an Arbitrary Closed Curve”,
Communications of the ACM, vol. 18(7), pp. 409-413,
1975.
[16] Geometric Software Solutions, “NestLib - Fully Automatic,
True Shape Nesting Technology from Geometric” (WWW
document), http://nestlib.geometricsoftware.com (accessed September 2006).
[17] T. Kamada and S. Kawai, “An Algorithm for Drawing
General Undirected Graphs”, Information Processing Letters, vol. 31, pp. 7-15, 1989.
[18] M. Kaufmann and D. Wagner, “Drawing Graphs: Methods
and Models”, LNCS 2025, Springer, Berlin, 2001.
[19] Nester
Software
Technologies,
“Production
Optimization Software for Upholstery and Other
Wood Products Manufacturing” (WWW document),
http://www.nestersoftware.com/Engineered_wood.asp
(accessed September 2006).
[20] I. G. Tollis, G. Di Battista, P. Eades, and R. Tamassia, “Graph Drawing: Algorithms for the Visualization of
Graphs”, Prentice Hall, New Jersey, 1999.
[21] R. Wiese and M. Eiglsperger, and M. Kaufmann, “yFiles:
Visualization and Automatic Layout of Graphs”, in Proceedings of the 9th International Symposium on Graph
Drawing (GD’01), LNCS 2265, Springer, pp. 453-454,
2002.


Multi-Scale Morphological Volume Segmentation and Visualization
Runzhen Huang∗

Eric Lum

Kwan-Liu Ma†

University of California at Davis

A BSTRACT
This paper presents a multi-scale morphology approach to the volume segmentation and visualization problem. The basis of the approach is applying morphological operations with spherical structuring elements at various sizes to create a representation of the
volume data that encodes structural information at multiple scales.
Through an interactive user interface, the user can effectively segment and visualize a specific feature of interest using a fast, region
growing method with this multi-scale data representation. A graph
representing the segmented feature is created to facilitate interactive
visual inspection and refinement of the feature. We have introduced
a new volume data visualization technique based on interactive segmentation rather than the traditional transfer-function based classification approach. This new technique offers the user greater power
in isolating and examining volumetric features of interest.
1

I NTRODUCTION

Volume visualization techniques have gone from being batch-mode
with rendering times that take minutes to being highly interactive.
Although data can be rendered at interactive rates, an important remaining question is how one takes advantage of this performance
for novel methods of user interaction. That is, going beyond simple changes in camera view or transfer function, we would like to
develop methods that allow for the creation of user driven visualizations that provide greater clarity and insight into the 3D structure
of a complex data set.
Perhaps the best known example of the method of user interaction that allows for data exploration and does not involve a change
in viewpoint is the real-time specification of a transfer function.
The very act of specifying a transfer function to map scalar values to colors and opacity promotes data understanding. As the
user changes the transfer function, he or she can explore a data
set not only spatially, but also in terms of data space, thus providing insights into the spatial/data relationships found within a data
set although transfer functions offer a powerful framework for user
interaction, they are typically very primitive in their ability to classify different materials in a volume. This can be contrasted with
segmentation methods which can better separate materials, but are
often less suited for data space exploration.
One of the defining characteristics of segmentation methods that
differentiates them from simpler classification techniques is the reliance on structure in separating different materials. Morphology
does non-linear filtering and makes use of neighboring structure in
separating features but at times is not robust because of the need to
specify parameters related to the size of the neighborhood. Region
growing techniques take advantage of a material’s connectivity to
neighboring voxels in separating regions of a volume but requires
specifying thresholds that control to what extent growing occurs. In
this paper we present a new approach to volume data visualization
which couples hierarchically applied morphology, region growing,
∗ e-mail:

rzhuang@ucdavis.edu

† e-mail:ma@cs.ucdavis.edu

Asia-Pacific Symposium on Visualisation 2007
5 - 7 February, Sydney, NSW, Australia
1-4244-0809-1/07/$20.00 © 2007 IEEE

new user interfaces for performing interaction, and optimized algorithms for performance. This new visualization technique can be
used to not only effectively segment materials in a volume, but also
interact with those materials for examining their spatial relationships.
2

R ELATED W ORK

Volume segmentation techniques separate and visualize the feature
of interest by grouping the voxels which share similar characteristics. Region growing is a classic segmentation technology, which
merges connected voxels or subregions into larger regions based on
some criteria [19]. It has been broadly used in image segmentation [20] [11]. Graph theory and data structure have also been employed in segmentation [3] [4] [23] [10]. Huang et al. [10] utilizes
a hierarchical graph to organize the subregions with different resolutions and to help segment features in large data sets. Although we
also use graph to organize subregions in this technique, our novelty
is in discovering the properties of the graph and applying them to
data exploration. A more detailed review of segmentation can be
found in [18].
Mathematical morphology is based on set theory and is used to
analyze region shapes. It has been used to extract image components such as boundaries, skeletons, and the convex hull, which
can facilitate shape analysis. It has also been employed for preprocessing and post-processing such as morphological filtering,
thinning and pruning. Advanced applications have been explored
with this technology, such as watershed transformation [1]. Gauch
et al. [6] presented an approach to image segmentation and analysis by using multi-scale gradient watershed hierarchies. Nedzved
et al. [17] developed fast gray-scale thinning algorithm to segment
histology cell images. A more detailed review of segmentation of
range images using morphological operations can be found in [7].
Unlike existing methods explicitly using morphological operations
to decompose images, our method utilizes multi-scale morphological data to collect local shape information and use it with the original data to facilitate volume visualization in cases where transfer
function fails.
The local shape information of a feature can be used in classification [12]. The first-order gradient and second-order derivatives
encode local value variations and together with the data values form
a 3D histogram volume, which can support semi-automatic transfer function generation. Hadjidemetriou et al. [8] use multiresolution histograms to capture important information about shapes for
textures in images for recognition and retrieval of images from visual databases. Our method is different because it directly uses
derived data instead of using global statistical information such as
histograms. Lum et al. [16] also take advantage of multi-scale data
obtained from filtering operations to classify the feature of interest
using graphics hardware. Unlike their method, which operates on
voxel data values, our method employs region growing to segment
the feature of interest and uses a graph representation of the feature
to enable feature refinement.
Modern programmable graphics hardware enables interactive
data visualization. Tzeng et al. [22] classify volume data with a
hardware-accelerated neural network and a novel interface. Sherbondy et al. [20] make use of graphics hardware to achieve interactive region growing. Lefohn et al. [15] move deformable boundary

121

M orp hol og i c a l
O p era t i on s

O ri g i n a l D a t a

M u l t i - S c a l e M orp hol og i c a l
D a ta

S i n g l e R eg i on M a s k

M u l t i - R eg i on M a s k

F ea t u re M a n i p u l a t i on

U s er

F a s t R eg i on G row i n g

R ef i n ed R eg i on M a s k

(a)
H a rd w a re I s os u rf a c i n g / S l i c i n g / V ol u me R en d eri n g

Figure 1: The process of multi-scale morphological data exploration
involving multiple steps from data preparation, rendering, interactive
editing, to feature refinement.

finding with level sets to GPU to gain interactivity. Our work also
employs graphics hardware extensively for both volume segmentation and rendering.
3 A N EW VOLUME V ISUALIZATION P ROCESS
The new approach to volume data visualization we have developed
requires multiple steps, as shown in Figure 1. First, multiple morphological operations with different structuring elements are applied to the original volume data to generate what we call multiscale morphological data. These encode useful local feature shape
information. The user navigates the volume data through an interactive interface to locate a feature of interest, and then marks a
few points on the feature using a mouse. To segment the feature,
the multi-scale morphological data set is then used in region growing starting from those points. Region growing generates a singleregion mask which is a binary mask of the whole segmented region,
and a multi-region mask which records the contribution of morphological data at each scale to the segmented region. The whole region
can be partitioned to one or more subregions based on the contributions. These subregions reflect the local shape and decomposition
of the feature of interest. With the assistance of a graph that organizes the subregions, the feature can be manipulated and refined
in order to obtain desired results. The extracted volumetric feature
can be rendered directly for displaying boundary surface or the volumetric content of the feature using region masks. This process
enables the user to interactively select one or more morphological
data of different scales to segment, refine, and visualize features
embedded in the volume data. In the rest of the paper we describe
each of the key steps and demonstrate this multi-scale morphological approach.
4 M ATHEMATICAL M ORPHOLOGY
Mathematical Morphology has been broadly used in image processing and shape analysis of features of interest [19]. The fundamental morphological set operations consist of union, intersection and
complement. The operands of the set operations are the original
data and data translated from the original with a reference shape
called a structuring element. Given an object A which contains
voxels a that share some common property:
A = {a|property(a) = true}
and a vector x, the translation A + x is defined as:
A + x = {a + x|a ∈ A}.
A structuring element B can be formed by a set of vectors. Then
the fundamental mathematical morphological operations called dilation and erosion can be defined with the basic Minkowski set operations called addition and subtraction:
Dilation: D(A, B) = A ⊕ B = ∪β ∈B (A + β )
Erosion: E(A, B) = A ⊖ (−B) = ∩β ∈B (A − β )

122

(b)

(c)

Figure 2: A 2D example of the opening and closing operations. (a)
the original region; (b) the region after an opening (c) the region after
a closing.

where −B = {−β |β ∈ B}. Two high-order operations called opening and closing can be defined by combining dilation and erosion:
Opening: O(A, B) = A ◦ B = D(E(A, B), B)
Closing: C(A, B) = A • B = E(D(A, −B), −B)
Figure 2 gives an example of opening and closing. The opening tends to remove thin connections, while the closing fills small
gaps and holes. In image processing community, these two operations with various structuring elements have built up broad applications, such as segmentation, smoothing, skeletonization and propagation [19].
Mathematical morphology has also been extended to gray-scale
images. In this context, a structuring element B also has gray values. The gray-scale dilation and erosion are defined as following:
Gray-scale dilation: DG (A, B) = max[ j,k]∈B {a[m − j, n − k] +
b[ j, k]}
Gray-scale erosion: EG (A, B) = min[ j,k]∈B {a[m + j, n + k] − b[ j, k]}
where [ j, k] and [m, n] are any element of B and A respectively. Then
the definition of gray-scale opening and closing are:
Gray-scale opening: OG (A, B) = DG (EG (A, B), B)
Gray-scale closing: CG (A, B) = −OG (−A, −B)
If B is convex, bounded, and symmetric, the complexity of the
gray-scale morphological processing can be significantly reduced.
Further, if the most common case, B = constant = 0, is used, the
definitions above become much simpler:
DG (A, B) = max[ j,k]∈B {a[m − j, n − k]} = maxB (A)
EG (A, B) = min[ j,k]∈B {a[m − j, n − k]} = minB (A)
OG (A, B) = maxB (minB (A))
(1)
CG (A, B) = minB (maxB (A))
(2)
We can see that dilation and erosion actually are the maximum
filter and minimum filter, respectively. With these operations, some
morphological algorithms can be produced, such as morphological smoothing, morphological gradient and morphological Laplacian [19].
Mathematical morphology has been extended to 3D images. Our
method employs gray-scale morphological operations to process
volume data and generate a multi-scale morphological representation that is useful for volume segmentation tasks.
5

M ULTI -S CALE M ORPHOLOGICAL DATA

We call the data multi-scale because it is generated using spherical
structuring elements with different radius values. A radius value = 1
is one voxel distance. By default, a pool of multi-scale volume data
generated using radius values between 1 and 2.5 is sufficient. The
user first examines each scale of the volume data using direct volume rendering and simple region growing. The knowledge gained
in this examination is then used to choose the best combination of
different scales of the data for conducting the subsequent volume
segmentation tasks. Note that this data preparation step is computationally intensive, depending on the radius value used, taking

from tens of seconds to near 2 minutes to generate each scale of
a 2563 volume on a PC. However, this process need only be performed once.
With each structuring element, two morphological data sets are
generated by the opening operation and closing operation, respectively. The multi-scale morphological data can be very large if
many different scales of the data sets are used. In practice, however, only a few scales are needed. For a specific segmentation task,
the ideal subset of the morphological data is selected according to
the characteristics of the feature of interest. For example, a data set
generated using the closing operation with a spherical structuring
element that is too small would fail to provide necessary connections between feature components, while one produced using the
opening operation with a structuring element that is too large would
remove some feature components. In our work, we select particular scales of a morphological data set according to our knowledge
on data and the objective of visualization. The selection usually
can be done quickly. To improve performance, the volume data can
be partitioned into blocks for fast transmission between disk, main
memory, and video memory to facilitate local operations.
After a multi-scale morphological data set is generated, the user
segments the feature of interest with a fast region growing algorithm. The output result is previewed with hardware accelerated
ray-casting isosurface rendering [13] [21] [24]. We have accelerated the region growing step to support interactive visualization.
6

F EATURE S EGMENTATION

A simple implementation of region growing performs a breadth first
search (BFS) or depth first search by regarding the image as a graph
where each node represents one voxel and each edge implies an
adjacency relationship. However, since we process 26-connectivity
in region growing, the memory access pattern is arbitrary and the
implementation has poor data locality. This fact makes memory
latency the dominant cost due to the increasing performance gap
between CPU and memory [9]. This implementation would be too
slow to achieve interactive visualization.
We have developed a fast region growing (FRG) algorithm which
re-organizes the growing order to optimize data locality. Assume
the data set is stored in the order of X, Y and Z dimensions. The
algorithm grows from a seed point first along X direction, then Y,
and Z direction. In addition to re-ordering the growing process,
we optimize the code according to the PHiPAC coding guidelines
reported by Bilmes et al. [2] to gain further performance improvement. Among the set of coding guidelines, loop unrolling and register caching result in the biggest performance benefit.
While growing a multi-scale morphological data set, all variables
stored at the visited voxel are compared to the threshold. When any
one of the variables is within the threshold, the voxel is included. A
byte-formated volumetric mask, called multi-region mask, is used
to store the comparison results by encoding which variables fall
within the threshold. One bit is used for access control in the algorithm, and the remaining seven bits available for seven variables.
This means there is a limit that at most seven morphological data
sets can be used at the same time.
Table 1 compares the performance between our implementation
and the implementation of BFS. For the brain data set, we can see
that the dominant factor in performance is not the number of morphological data sets used, but the number of voxels that are grown.
This is because the prefetch mechanism of caching can greatly reduce the cost of accessing continuous memory. The timing numbers
were obtained on a 3.2GHz Pentium 4 PC which has 8KB Level 1
data cache and 512 level 2 cache. Note that our implementation
does not change the complexity of the algorithm, O(n). The performance improvement comes from the optimization of memory
access pattern.

Table 1: Performance of region growing implementations

Feature
Aneurysm
Brain
Brain
Virus

# of Scales
1
1
3
7

# of Voxels
50342
252351
252322
886920

BFS
0.101
0.404
0.400
1.753

FRG
0.053
0.082
0.101
0.382

7 F EATURE R EFINEMENT
The multi-region mask records the contributions of multi-scale
morphological data as voxel values. If we define a subregion as
a group of connected voxels which have the identical value, the
mask can be partitioned into one or more subregions, and none of
two adjacent subregions have the same value. These subregions can
be organized as a graph (which we call a region graph) to support
interactive operations for refining feature segmentation and visualization.
7.1 Region Graph Construction
The region graph consists of graph nodes, each of which represents
a subregion of the multi-region mask, and graph edges which indicate adjacency between the subregions. A simple method to construct the region graph is to first separate each subregion and then
detect their adjacent relationships. However, this method must keep
a volumetric mask to avoid repeated voxel processing when separating subregions. Further, it must store connectivity information to
assist in the adjacency detection calculations. In addition, the memory access pattern is not optimal due to the arbitrary shape of each
subregion. Thus, this simple method is expensive in both memory
consumption and access latency.
We developed a fast algorithm to construct the region graph. The
algorithm starts from the seed S and partitions the voxels along the
X direction into linear subregions based on the non-zero voxel values. For each linear subregion, a graph node is created and its
neighboring nodes are recorded. Then, the adjacent voxels along
the positive Y direction are partitioned. If a new subregion has the
same voxel value as an adjacent subregion, all the involved subregions belonging to the same graph node are merged. Otherwise, a
new graph node is generated for the new subregion. This procedure
is performed continuously (first in the Y direction and then in the Z
direction) until the whole region has been processed.
A dramatic performance enhancement is obtained from such optimization of memory access. As an example, we used three-scale
morphological data to generate a multi-region mask which contains
301 subregions. The simple method takes 3.71 seconds to build all
301 graph nodes, while our method takes 0.274 seconds, a more
than 13 fold speedup. Figure 3 shows an example of the region
graph.
7.2 Region Graph Operations
The region graph organizes the subregions which reflect the decomposition by morphological operations. Four operations are available
for manipulating or editing the graph:
•
•
•
•

connection retaining
connection removal
direct region removal
non-seed region removal

7.2.1 Connection Retaining
The morphological closing operator is used to fill holes and gaps,
which makes some near, but separate, regions to become connected.
However, some of the connections are desirable to keep while some

123

Figure 3: An example of the region graph: (a) the regions obtained
through a set of morphological operations. R, C and O represent the
contributions from the original data, morphological data generated
by closing, and opening, respectively; for example, graph node 9 is
marked ROC which means it receives the contributions from all three
data sets. (b) the graph of the regions in (a). The shaded nodes form
the definite part of the feature.

are not. For example, assume subregion 6 in Figure 3 should be
connected to subregion 4 in ground truth, but it does not due to
image noise. On the other hand, subregion 1, 7 and 10 should not
exist.
The region graph can effectively help remove unwanted connections while retaining the desired ones. Because multi-scale morphological data are derived from the original data, we give the highest confidence to the sub-regions receiving contributions from the
original data, and keep these sub-regions in the segmentation. We
call the graph nodes representing these subregions primary graph
nodes, and the graph formed by these primary graph nodes a primary graph. The primary graph may or may not be fully connected,
and therefore can have several subgraphs. Each subgraph contains
only connected primary graph nodes and has no direct connection
to other subgraphs. To derive a complete feature, we need to identify those nodes that connect several primary subgraphs into one.
In Figure 3, graph nodes 2, 3, 4, 8 and 9 form a primary subgraph,
while graph node 6 is another primary subgraph. Graph node 5 is
the node that can connect these two primary subgraphs.
Figure 4 illustrates the algorithm for retaining the connecting
graph nodes. Given a graph G(V, E) where V is the set of graph
nodes and E is the set of edges, the primary subgraphs, denoted as
Gi (Vi , Ei ), i = 1, 2 . . . n where n is their id, are found by performing breadth first search from each unvisited primary graph node.
Then we construct a new graph G′ (V ′ , E ′ ) called a condensed region graph by collapsing each subgraph to one graph node (condensed node). Since the connecting graph nodes are usually introduced by noise or an imperfect sampling process, they are typically
small. The problem of finding connecting graph nodes is reduced to
the problem of finding a set of non-primary graph nodes v′′i , which
make G′ connected and the total volume of these nodes
′′
′′
′′
M = ∑m
i=1 t(vi ), where t(vi ) is the volume of vi , minimum.
The solution is a tree within G′ and contains all the condensed
nodes. We call such a tree a minimum condensed tree of G′ .
The minimum condensed tree of G′ is built as follows. First, G′
is converted to a directed graph G′D by replacing each edge with
two edges having opposite directions. For each directed edge, the
weight equals to the volume or the number of voxels of the subregion represented by the graph node it incidents from. For the edges
away from condensed nodes, the weight equals infinity. Second,
the shortest paths of each pair of the condensed nodes are calculated with Dijkstra’s algorithm [5] under this configuration. Third,
a complete graph G′S (VS′ , ES′ ) is constructed by regarding the condensed nodes as graph nodes and each shortest path as an edge,

124

Figure 4: Finding the connecting graph nodes: (a) the region graph
G; the shaded graph nodes are the primary graph nodes which form
three subgraphs G1 , G2 and G3 . (b) the condensed region graph
G′ ; Gi ,i = 1..3 are the condensed graph nodes, and the thick edges
are the shortest paths between G1, G2 and G3; ei ,i = 1..7 are their
edge weights. (c) the minimum condensed tree of G1, G2 and G3;
Ei ,i = 1..3 are the edge weights. E3 is not included. (d) the desired
consequent graph; the white nodes are the connecting graph nodes.

with a weight equal to its length. Finally, the minimum spanning
tree of G′S is computed with Prim’s algorithm [5]. Replacing the
edges in the minimum spanning tree with the shortest paths results
in a minimum condensed tree.
The complexity of the algorithm includes O(|V |) for breadth
first search in subgraph identification, O(|E ′ |) for graph conversion, nO((|V ′ | + |E ′ |)log|V ′ |) for pairs’ shortest path evaluation,
and O(|ES′ | + |VS′ |log|VS′ |) = O(n2 + nlogn) for minimum spanning tree selection. The total complexity is O(n2 + |V | + n(|V ′ | +
|E ′ |)log|V ′ |). This algorithm is universally applicable to all cases
but for graphs with large |V | and |V ′ |, the processing would become
too slow to deliver interactive performance.
In the presence of image noise and an imperfect sampling process, the closing operation is used more than the closing operation.
Consequently, we use at most one data set generated by the closing
operation. We call the resulting region graph in such case a simple
region graph, call a condensed graph derived from a simple region
graph a simple condensed region graph, and denote the minimum
condensed tree obtained from the simple condensed region graph
as a simple minimum condensed tree. Figure 3(b) is a simple region
graph. In this case, we can use a simple and fast algorithm instead.
This algorithm is based on the theorem described as follows:
Theorem 1. Each simple minimum condensed tree has two properties:
1 Each shortest path retained in the tree passes through only
one connecting graph node;
2 All leaf nodes are condensed nodes.
Proof.
1. From the definition of the shortest path, there are at least two
edges on the path because any two condensed graph nodes have no

The region graph and its associated operations are affected by
noise present in the data. For example, the closing operations can
reach a noise voxel which happens to receive contribution from the
original data as well. During connection retaining, this noise will
become a subgraph and is kept in the region graph. In addition,
other undesired subregions will be retained to connect this noise.
We handle this case by imposing the rule that the subgraph should
contain a bigger volume than the weight of the path connecting to
the tree. The experiments show that noise is removed effectively
this way.
7.2.2 Connection Removal and Region Removal

Figure 5: A simple region graph. (a) the simple region graph G;
the shaded graph nodes are the primary graph nodes which form
two subgraphs G1 and G2 . (b) the simple condensed region graph
G′ ; Gi ,i = 1..2 are the condensed graph nodes, and the bold edges
are the shortest paths between G1 and G2. (c) the simple minimum
condensed tree of G′ ; graph node 5 is the connecting graph node.

direct connection. Since the shortest path is a simple path, there are
at least one graph node on the path. Since these one or more graph
nodes are not contributed by the original data, their corresponding
region W have voxel values within the range of S which is out of
the threshold T : S ∩ T = 0.
/ A property of gray-scale opening is:
A′ = OG (A, B) ⊆ A and A′ (v) ≤ A(v) where A is the data, B is
a structuring element, and A′ (v) and A(v) are the voxel values at
position v of A′ and A, respectively [19]. So the new range of W is
still out of the threshold T . That means, opening operations do not
introduce new voxels into the region but remove some parts. So W
must be brought in by closing operations. Since there is no more
than one closed morphological data used, W only receives contribution from this data. Thus W is one subregion and only represented
by one graph node.
2. A minimum spanning tree of a complete graph of only condensed
nodes always has such nodes as leaves. Since the simple minimum
condensed tree is derived from such a minimum spanning tree by
replacing its edges with shortest paths, the leaf nodes are intact and
are still condensed nodes.
Figure 5 shows an example of a simple region graph derived from
Figure 3. Figure 5(c) gives the simple minimum condensed tree.
The shortest path between leaf nodes G1 and G2 only has graph
node 5.
Based on the above theorem, the connection retaining operation
becomes simple:
1. Initialize the distances between each pair of condensed graph
nodes to infinity.
2. For each non-condensed graph node in the simple condensed
region graph, check if it connects two different condensed
graph nodes and is less than their current distance. If it is,
assign the volume of the node as the new distance.
3. Construct a minimum spanning tree from the complete graph
G′S of all condensed nodes.
This process simplifies the evaluation of shortest paths, and the result is still a minimum spanning tree of G′S . That means the algorithm generates valid results. We can see that this algorithm has a
complexity O(n2 + |V ′ |) which is much simpler than the universal
algorithm.
Illustrated with the example in Figure 5, graph node 1, 5, 7 and
10 are checked and only node 5 connects to G1 and G2 . Graph node
5 is the only node in the shortest path and its volume becomes the
distance.

The morphological opening operator tends to remove fine subregions and break thin connections, which causes some connected
regions to be separated (see Figure 2 (b)). The strategy to remove
undesired connections and keep usable fine features is to take advantage of the structure of the region graph obtained from connection retaining. The small sub-regions removed by opening operations are either leaf nodes (e.g., graph nodes 2 and 3 in Figure 3(a))
or internal nodes (e.g., graph node 8 in Figure 3(a)) of the graph.
Leaf nodes represent the surface properties while internal nodes often suggest connections between different sub-regions. The user
can delete the leaf nodes that receive no contribution from opening
operations to smooth the surface, or delete similar internal nodes to
create sub-regions.
Based on the graph, the feature can also be edited by directly
removing some sub-regions selected with mouse. The erased graph
nodes can disconnect some other nodes, which can benefit further
region removal based on connectivity. For example, assume the
graph node 9 in Figure 3(a) is the only feature of interest and other
subregions should be removed. The procedure for isolating graph
node 9 can start with connection retaining which removes graph
nodes 1, 7 and 10. Then graph nodes 2, 3 and 6 can be erased by
filtering the non-opening leaf nodes, Graph node 5 is also deleted
because it is introduced to connect graph node 6. Third, graph node
4 is selected to delete by user. It is big enough to be selected; otherwise, it would become a RC node. At last, graph node 8 is filtered
away as an non-opening leaf node. Another way to isolate graph
node 9 is to remove graph node 4 first, and then remove graph nodes
1, 2, 3, 5, and 6 because they do not connect to graph node 9. Graph
node 7 and 8 can then be removed via filtering.
Figure 6 illustrates a typical segmentation procedure using a CT
kidney tumor data set. Figure 6 (a) shows direct volume rendering
of the CT volume data using a 1-d transfer function. This picture
shows that the kidneys, tumor, and several other parts of the body
share a similar range of values. As a result, when we placed a seed
point in the large tumor region for segmentation, region growing
gave us a much larger region consisting partially of unwanted parts,
as shown in Figure 6 (b) and (c). Further refinement is thus needed.
By coloring different regions according to the contributions of particular morphological data, as displayed in Figure 6 (d), the user
can identify and specify an unwanted region with ease and verify
the consequence of removing it. This operation often generates disconnected regions which can be processed further with the ”nonseeded region removal” operation. Figure 6(e) displays the result
of removing sub-regions from the kidney tumor data by directly
selecting with a mouse on a slice of the volume.
Applying some of the first three operations may result in multiple disconnected subgraphs. An operation that can automatically
detect disconnected subregions is useful, enabling the removal of
such regions without explicitly selecting each by hand. Using the
kidney data as an example, connection removal modifies the region
graph into multiple subgraphs. The subgraph for the kidney with
the large tumor contains the seed point, and we call it a ”seeded
region”. Other regions, which we call ”non-seeded regions”, can
be removed directly without further user intervention. Figure 6(f)

125

shows the result of removing disconnected regions from the kidney
data.
8

(a)

(b)

(c)

(d)

(e)

(f)

(g)

(h)

Figure 6: Segmenting a kidney tumor from a CT volume
(512×512×180). (a) Volume rendering of the CT volume using a 1-d
transfer function. (b) A slice of the volume outlining the segmented
area in red. The objective is to segment the kidney on the right side
but region growing picked up a much larger region. (c) Boundary
surface rendering of the segmented result. (d) Boundary surface colored according to the contributions from different morphological data.
(e) After direct region removal. (f) After non-seeded region removal.
(g) Boundary surface rendering of the segmented kidney. (h) volume
rendering of the segmented kidney.

126

F EATURE V ISUALIZATION

After a volumetric feature is segmented, the corresponding multiregion mask is loaded into the video memory as a 3D texture for
interactive viewing. The user can see the segmented feature in
three different ways with a hardware-accelerated ray-casting volume renderer. The simplest way is to render a boundary surface
of the feature as an isosurface of the bounding region, as shown in
Figure 6 (g). The mask voxel values are between 0 and 1. The user
picks the isovalue depending on if a tighter and looser bounding
surface is desired. The second way, as already described, is to color
the bounding surface according to the contributions from different
morphological data. A distinct color is assigned to each particular
scale of the morphological data and for the subregion contributed
by multiple scales, a blending of contributing colors is used. This
color encoding essentially conveys the local shape information of
the segmented feature and helps the user to choose the best combination of morphological data, as shown in Figure 6 (d). Finally, the
user can also visualize the feature using direct volume rendering of
the enclosed voxels from the raw volume data, as shown in Figure 6
(h). In summary, through an interactive interface, the user can select a feature of interest by mouse clicking on the slice and refine
the segmented feature by looking at these different views and applying the editing operations described in Section 7.2. In the overall
visualization process, in addition to adjusting the typical rendering
parameters and switching between different views of the data, the
user can choose a particular combination of morphological data,
seeds and threshold values for region growing, and color mapping
to regions to derive desired visualization results.
9

R ESULTS

We further demonstrate this multi-scale morphological approach
using three MRI data sets. The aneurysm data set has 256 × 256 ×
256 voxels and exhibits a vessel-like structure. The head data set
has 128×128×128 voxels. The tumor data set has 256×256×128
voxels. In the rest of this section, we denote the morphological data
as follows: R refers to the original data; C and O refers to the data
generated by closing and opening operations, respectively; the subscripts of C and O are the radius of the spherical structuring elements used in the morphological operations.
Figure 7 shows results of using connection retaining on the the
aneurysm data set. The upper left image shows the segmented vessels generated from region growing on the R volume, while the upper right image is a visualization of the multi-region mask generated from the RC2 volume. Then connection retaining was applied
to the multi-region mask data to remove undesired subregions, and
the result is shown in the bottom left image. Comparing the upper
left image with the bottom left image, we can see a large branch
in the area circled with the blue ellipse has been included. Note
that the green region is only contributed by the C2 data. It is not a
region of the aneurysm and can be removed easily. The whole process is interactive and connection retaining takes only sub-seconds
to complete.
Figure 8 shows the results of segmenting the brain from the MRI
head data using different multi-scale morphological data from R,
O1 , O2 to O2.5 . Note that we found that none of these data by itself
were sufficient to isolate the complete brain region. For example,
using RO2 alone, the resulting regions still include an unwanted
part which can be removed by using RO2 O2.5 instead. The initial
output of RO2 and RO2 O2.5 before feature refinement is identical to
the one of R, but the former two generate multi-region masks which
contain many subregions. We apply the connection removal operation to obtain a cleaner brain visualization. We manually selected
and removed undesired subregions of the skull.

Left: region grown from R; the skull is included but unwanted.
Right: region grown from O1 ; some part of the skull is removed
because of the opening operation.

Figure 7: The regions of the aneurysm obtained with connection retaining. Top Left: Region growing of features from the R data. Top
Right: Region growing of features from the RC2 data; the green regions are the ones only receiving contributions from the C2 data. Bottom Left: After applying connection retaining. Bottom Right: Closeup view of the area marked with blue line in the bottom left image.

The results shown in Figure 7 and Figure 8 are generated with
hardware accelerated ray-casting isosurface rendering. With the assistance of multi-scale morphological data, the feature of interest is
decomposed to subregions based on their local shape. This decomposition provides a finer control of feature segmentation and visualization, as well as the analysis of the spatial relationship among
different materials.
Figure 9 compares a brain classified using a transfer function
with the same brain segmented using our method. The segmented
brain is clearly better as a result of the interactive feature refinement
operations offered by our approach. Even though our approach is
computationally more demanding, needs more storage space, and
requires more user intervention than the conventional methods, the
user is given more precise and intuitive control of the volume visualization and feature segmentation.
Figure 10 shows the visualization of the brain, tumor, vessels and
skull of the MRI tumor data. The brain and skull are segmented
with the multi-scale data RO3 O4 and the tumor and vessels are obtained directly with the fast region growing. After they are individually extracted, they are merged back into a volume data set to
generate the image in Figure 10
10

Left: region grown result from O2 ; most of the skull disappears but
some part of the brain is removed as well; Right: region grown
from O2.5 ; the skull totally disappears but the brain is not
complete.

Left: region grown from RO2 ; only one small part of the skull
remains. Right: a cleaner brain obtained from RO2 O2.5 .

C ONCLUSIONS

We present a new interactive volume data visualization technique
based on segmentation using multi-scale, morphological information of the volume data. Interactivity is ensured with a fast region
growing method based on a region-graph representation of the segmented regions, and hardware-accelerated rendering.
The contributions of our work are as follows. 1) We introduce a method to explore the local shape information of features
with multi-scale morphological data, which enables better visualization of the features. 2) We introduce a set of operations allowing
the user to effectively refine the region graph in order to generate
the desired feature visualization. 3) We achieve highly interactive
segmentation-based visualization by devising an optimized region
growing approach and a region graph construction algorithm. The
result is a new volume data visualization technology giving the user

Left: multi-region from RO2 ; Right: multi-region from RO2 O2.5 .

Figure 8: The regions of MRI head data generated using region removal operations. The red color in the bottom two images highlights
those regions which receive the contribution of O2 data, while the
green color in the bottom right image shows the contribution of O2.5
data. This coloring guides the user in the segmentation process.

127

Figure 9: The brain rendered with volume rendering. The left image are produced with the original data using a 2D transfer function,
while the right one is generated with anti-aliased feature volume segmented with our approach.

Figure 10: The brain, tumor, vessels and skull rendered with volume rendering. The four features are segmented individually, and
rendered together for making this visualization.

greater power than conventional, transfer-function based methods.
For further work, we plan to use structuring elements other than
spheres to generate multi-scale morphological data, and study their
relationship to feature characteristics. The storage and computational overhead for using our multi-scale morphological method
could become unacceptable for visualizing very large data sets.
Blocking techniques [14] and incremental growing can potentially
alleviate this problem. Finally, we will evaluate and improve our
current interactive interface to make it even easier to operate on the
multi-scale morphological data.
ACKNOWLEDGMENTS
This work was sponsored in part by the National Science Foundation under contracts ACI 9983641, CCF 0222991, OCI 0325934,
IIS 0552334, and CCF 0634913. The test datasets were obtained
through Professor Akio Doi, the Volume Dataset Repository at the
University of Tbigen, and the Cancer Research Center at the University of California at Davis.
R EFERENCES
[1] S. Beucher. The watershed transformation applied to image segmentation. In Proceedings of the Conference on Signal and Image Processing in Microscopy and Microanalysis, pages 299–314, 1991.
[2] J. Bilmes, K. Asanovic, J. Demmel, D. Lam, and C. Chin.
The PHiPAC v1.0 matrix-multiply distribution. Technical Report
UCB/CSD-98-1020, University of California at Berkeley, 1998.

128

[3] Y. Y. Boykov and M.-P. Jolly. Interactive graph cuts for optimal
boundary and region segmentation of objects in n-d images. In Proceedings of International Conference on Computer Vision, volume 1,
pages 105–112, 2001.
[4] A. Y. S. Chia and V. Zagorodnov. Graph cut segmentation on convoluted objects. IEEE International Conference on Image Processing,
pages 848–851, 2005.
[5] T. H. Cormen, C. Stein, R. L. Rivest, and C. E. Leiserson. Introduction
to Algorithms. McGraw-Hill Higher Education, 2001.
[6] J. Gauch. Image segmentation and analysis via multiscale gradient
watersheds. IEEE Trans. on Image Processing, 8(1), 1999.
[7] L. A. Gee and M. A. Abidi. Segmentation of range images using
morphological operations: Review and examples, 1995.
[8] E. Hadjidemetriou, M. D. Grossberg, and S. K. Nayar. Multiresolution histograms and their use for recognition. IEEE Transactions on
Pattern Analysis and Machine Intelligence, 26(7):831–847, 2004.
[9] J. L. Hennessy and D. A. Patterson. Computer Architecture: A Quantitative Approach. Morgan Kaufmann Publishers, third edition, 2003.
[10] R. Huang and K.-L. Ma. A three-level graph based interactive volume
segmentation system. In Proceedings of ISVC’05, 2005.
[11] R. Huang, K.-L. Ma, P. McCormick, and W. Ward. Visualizing industrial CT volume data for nondestructive testing applications. In
Proceedings of IEEE Visualization 2003 Conference, pages 547–554,
2003.
[12] G. Kindlmann and J. Durkin. Semi-automatic generation of transfer
functions for direct volume rendering. In Proceedings of 1998 Symposium on Volume Visualization, pages 79–86, 1998.
[13] J. Kr¨uger and R. Westermann. Acceleration Techniques for GPUbased Volume Rendering. In Proceedings IEEE Visualization 2003,
2003.
[14] M. Lam, E. Rothberg, and M. Wolf. The cache performance and optimizations of blocked algorithms. In Proceedings of the 4th International Conference on Architectural Support for Programming Languages and Operating Systems, April 1991.
[15] A. Lefohn, J. Cates, and R. Whitaker. Interactive, gpu-based level
sets for 3d brain tumor segmentation. In Proceedings of Medical Image Computing and Computer Assisted Intervention (MICCAI) 2003,
pages 564–572, 2003.
[16] E. Lum, J. Shearer, and K.-L. Ma. Interactive multi-scale exploration
for volume classification. In Proceedings of Pacific Graphics 2006
Conference (to appear), 2006.
[17] A. Nedzved, S. Ablameyko, and I. Pitas. Morphological segmentation
of histology cell images. In 15th International Conference on Pattern
Recognition (ICPR’00), volume 1, pages 1500–1504, 2000.
[18] D. L. Pham, C. Xu, and J. L. Prince. A survey of current methods in
medical image segmentation. Technical report, Johns Hopkins University, Baltimore, 1998.
[19] A. Rosenfeld and A. Kak. Digital Picture Processing, Volume 2. Academic Press, second edition, 1982.
[20] A. Sherbondy, M. Houston, and S. Napel. Fast volume segmentation
with simultaneous visualization using programmable graphics hardware. In Proceedings of the IEEE Visualization 20003 Conference,
pages 171–176, 2003.
[21] S. Stegmaier, M. Strengert, T. Klein, and T. Ertl. A simple and flexible
volume rendering framework for graphics-hardware-based raycasting.
In Volume Graphics, pages 187–195, 2005.
[22] F.-Y. Tzeng, E. Lum, and K.-L. Ma. A novel interface for higherdimensional classification functions. In Proceedings of the IEEE Visualization 20003 Conference, pages 505–512, 2003.
[23] A. V. Vezhnevets. Growcut-interactive multi-label n-d image segmentation by cellular.
[24] R. Westermann and B. Sevenich. Accelerated volume ray-casting
using texture mapping. In Proceedings of the IEEE Visualization
2001 Conference, pages 271–278, Washington, DC, USA, 2001. IEEE
Computer Society.

